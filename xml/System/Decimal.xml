<Type Name="Decimal" FullName="System.Decimal">
  <TypeSignature Language="C#" Value="public struct Decimal : IComparable, IComparable&lt;decimal&gt;, IConvertible, IEquatable&lt;decimal&gt;, IFormattable, System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Decimal extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Decimal&gt;, class System.IConvertible, class System.IEquatable`1&lt;valuetype System.Decimal&gt;, class System.IFormattable, class System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="DocId" Value="T:System.Decimal" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Decimal&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um número decimal.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal> tipo de valor representa números decimais que vão do 79.228.162.514.264.337.593.543.950.335 positivo ao 79.228.162.514.264.337.593.543.950.335 negativo. O <xref:System.Decimal> tipo de valor é adequado para cálculos financeiros que exigem um grande número de dígitos integral e fracionário significativos e sem erros de arredondamento. O <xref:System.Decimal> tipo não elimina a necessidade de arredondamento. Em vez disso, ele minimiza os erros devido a um arredondamento. Por exemplo, o código a seguir produz um resultado de 0.9999999999999999999999999999 em vez de 1.  
  
 [!code-cpp[System.Decimal.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal1.cpp#1)]
 [!code-csharp[System.Decimal.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#1)]
 [!code-vb[System.Decimal.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#1)]  
  
 Quando o resultado da divisão e multiplicação é passado para o <xref:System.Math.Round%2A> método, o resultado será prejudicado sem perda de precisão, como mostra o código a seguir.  
  
 [!code-cpp[System.Decimal.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Class/cpp/decimal2.cpp#2)]
 [!code-csharp[System.Decimal.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Class/cs/DecimalDivision_46630_1.cs#2)]
 [!code-vb[System.Decimal.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Class/vb/DecimalDivision_46630_1.vb#2)]  
  
 Um número decimal é um valor de ponto flutuante que consiste em um sinal, um valor numérico em que cada dígito no valor varia de 0 a 9 e um fator de escala que indica a posição de um ponto decimal flutuante que separa as partes integrais e fracionárias do valor numérico.  
  
 A representação binária de um <xref:System.Decimal> valor consiste em um sinal de 1 bit, um número inteiro de 96 bits e um fator de escala usada para dividir o inteiro de 96 bits e especificar qual parte dele é uma fração decimal. O fator de escala é implicitamente o número 10, elevado a um expoente variando de 0 a 28. Portanto, a representação binária de um <xref:System.Decimal> o formulário, valor ((-2<sup>96</sup> 2<sup>96</sup>) / 10<sup>(de 0 a 28)</sup>), onde-(2<sup>96</sup>-1) é igual a <xref:System.Decimal.MinValue>e 2<sup>96</sup>-1 é igual a <xref:System.Decimal.MaxValue>. Para obter mais informações sobre a representação binária do <xref:System.Decimal> valores e um exemplo, consulte o <xref:System.Decimal.%23ctor%28System.Int32%5B%5D%29> construtor e o <xref:System.Decimal.GetBits%2A> método.  
  
 O fator de dimensionamento também preserva qualquer à direita zeros em uma <xref:System.Decimal> número. Zeros à direita não afetam o valor de um <xref:System.Decimal> número em operações de comparação ou aritmética. No entanto, zeros à direita podem ser exibida a <xref:System.Decimal.ToString%2A> método se uma cadeia de caracteres de formato apropriado é aplicada.  
  
## <a name="conversion-considerations"></a>Considerações de conversão  
 Esse tipo fornece métodos que convertem <xref:System.Decimal> valores do <xref:System.SByte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.Byte>, <xref:System.UInt16>, <xref:System.UInt32>, e <xref:System.UInt64> valores. Conversões desses tipos integrais para <xref:System.Decimal> são conversões que nunca percam informações ou lançam exceções de ampliação.  
  
 Conversões de <xref:System.Decimal> para qualquer um dos tipos integrais são conversões que de ida e volta entre o <xref:System.Decimal> valor para o valor inteiro mais próximo em direção a zero. Algumas linguagens, como c#, também suportam a conversão de <xref:System.Decimal> valores <xref:System.Char> valores. Se o resultado dessas conversões não pode ser representado no tipo de destino, um <xref:System.OverflowException> exceção será lançada.  
  
 O <xref:System.Decimal> tipo também fornece métodos que convertem <xref:System.Decimal> valores do <xref:System.Single> e <xref:System.Double> valores. Conversões de <xref:System.Decimal> para <xref:System.Single> ou <xref:System.Double> são conversões que podem perder precisão, mas não as informações sobre a magnitude do valor convertido reduzidas. A conversão não lançará uma exceção.  
  
 Conversões de <xref:System.Single> ou <xref:System.Double> para <xref:System.Decimal> lançar um <xref:System.OverflowException> exceção se o resultado da conversão não pode ser representado como um <xref:System.Decimal>.  
  
## <a name="performing-operations-on-decimal-values"></a>Realizando operações em valores decimais  
 O <xref:System.Decimal> tipo oferece suporte a operações matemáticas padrão, como adição, subtração, divisão, multiplicação e unário de negação. Você também pode trabalhar diretamente com a representação binária de um <xref:System.Decimal> valor chamando o <xref:System.Decimal.GetBits%2A> método.  
  
 Para comparar dois <xref:System.Decimal> valores, você pode usar os operadores de comparação numérica padrão, ou você pode chamar o <xref:System.Decimal.CompareTo%2A> ou <xref:System.Decimal.Equals%2A> método.  
  
 Você também pode chamar os membros de <xref:System.Math> classe para realizar uma ampla gama de operações numéricas, incluindo o valor absoluto de um número, determinando o valor máximo ou mínimo de dois <xref:System.Decimal> valores, obtendo o sinal de um número e um número de arredondamento.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Decimal>.  
  
 [!code-cpp[Decimal Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#1)]
 [!code-csharp[Decimal Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#1)]
 [!code-vb[Decimal Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros desse tipo são thread-safe. Os membros que aparentam modificar efetivamente o estado retornam uma nova instância inicializada com o novo valor. Assim como acontece com qualquer outro tipo, a leitura e a gravação em uma variável compartilhada que contém uma instância desse tipo devem ser protegidas por um bloqueio para garantir thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor do número de ponto flutuante especificado de precisão dupla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor Arredonda `value` em 15 dígitos significativos usando arredondamento mais próximo. Isso é feito mesmo se o número tiver mais de 15 dígitos e os menos dígitos significativos são zero.  
  
   
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.Double> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctordo.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Reals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctordo.cs#2)]
 [!code-vb[System.Decimal.Ctor.Reals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctordo.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor inteiro com sinal de 32 bits especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.Int32> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctori.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Ints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctori.cs#1)]
 [!code-vb[System.Decimal.Ctor.Ints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctori.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int[] bits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32[] bits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bits" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="bits">Uma matriz de inteiros com sinal de 32 bits que contém uma representação de um valor decimal.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para um valor decimal representado no binário e contido em uma matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação binária de um <xref:System.Decimal> número consiste em um sinal de 1 bit, um número inteiro de 96 bits e um fator de escala usada para dividir o número inteiro e especificar qual parte dele é uma fração decimal. O fator de escala é implicitamente o número 10, elevado a um expoente variando de 0 a 28.  
  
 `bits`é uma matriz de quatro elementos longo de inteiros com sinal de 32 bits.  
  
 `bits`[0], `bits` [1], e `bits` [2] contém os baixos, médio e alto 32 bits do número inteiro de 96 bits.  
  
 `bits`[3] contém o fator de escala e o sinal e consiste nas seguintes partes:  
  
 Bits de 0 a 15, a palavra inferior, são utilizadas e devem ser zero.  
  
 Bits de 16 a 23 devem conter um expoente entre 0 e 28, que indica a potência de 10 para dividir o número inteiro.  
  
 Bits de 24 a 30 são utilizadas e devem ser zero.  
  
 Bit 31 contém do sinal. positivo de significado 0 e 1 significado negativo.  
  
 Um valor numérico pode ter vários possíveis representações binárias; todos são igualmente válidos e numericamente equivalente. Observe que a representação de bit diferencia entre zero positiva e negativa. Esses valores são tratados como iguais em todas as operações.  
  
   
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com uma matriz de quatro <xref:System.Int32> valores.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriarr.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Arrays#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriarr.cs#1)]
 [!code-vb[System.Decimal.Ctor.Arrays#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriarr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bits" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="bits" /> não é 4.  
  
 -ou-  
  
 A representação do valor decimal em <paramref name="bits" /> não é válida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor do especificado inteiro assinado de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.Int64> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorl.cpp#3)]
 [!code-csharp[System.Decimal.Ctor.Ints#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorl.cs#3)]
 [!code-vb[System.Decimal.Ctor.Ints#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorl.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Single)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor do que o número de ponto flutuante de precisão simples especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor Arredonda `value` 7 dígitos significativos usando arredondamento mais próximo. Isso é feito mesmo se o número tiver mais de 7 dígitos e os menos dígitos significativos são zero.  
  
   
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.Single> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Reals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CPP/ctors.cpp#1)]
 [!code-csharp[System.Decimal.Ctor.Reals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/CS/ctors.cs#1)]
 [!code-vb[System.Decimal.Ctor.Reals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Reals/VB/ctors.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor do inteiro não assinado 32 bits especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.UInt32> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorui.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Ints#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorui.cs#2)]
 [!code-vb[System.Decimal.Ctor.Ints#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorui.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.UInt64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser representado como um <see cref="T:System.Decimal" />.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> para o valor do inteiro sem sinal de 64 bits especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com um <xref:System.UInt64> valor.  
  
 [!code-cpp[System.Decimal.Ctor.Ints#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CPP/ctorul.cpp#4)]
 [!code-csharp[System.Decimal.Ctor.Ints#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/CS/ctorul.cs#4)]
 [!code-vb[System.Decimal.Ctor.Ints#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Ints/VB/ctorul.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Decimal (int lo, int mid, int hi, bool isNegative, byte scale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 lo, int32 mid, int32 hi, bool isNegative, unsigned int8 scale) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Byte)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="lo" Type="System.Int32" />
        <Parameter Name="mid" Type="System.Int32" />
        <Parameter Name="hi" Type="System.Int32" />
        <Parameter Name="isNegative" Type="System.Boolean" />
        <Parameter Name="scale" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="lo">Os 32 bits inferiores de um inteiro de 96 bits.</param>
        <param name="mid">Os 32 bits intermediários de um inteiro de 96 bits.</param>
        <param name="hi">Os 32 bits superiores de um inteiro de 96 bits.</param>
        <param name="isNegative">
          <see langword="true" /> para indicar um número negativo; <see langword="false" /> para indicar um número positivo.</param>
        <param name="scale">Uma potência de 10, variando de 0 a 28.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.Decimal" /> de parâmetros que especificam as partes constituintes da instância.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação binária de um <xref:System.Decimal> número consiste em um sinal de 1 bit, um número inteiro de 96 bits e um fator de escala usada para dividir o número inteiro e especificar qual parte dele é uma fração decimal. O fator de escala é implicitamente o número 10 elevado a um expoente variando de 0 a 28.  
  
   
  
## Examples  
 O exemplo de código a seguir cria várias `Decimal` números usando a sobrecarga de construtor que inicializa um `Decimal` estrutura com três <xref:System.Int32> valor palavras, uma <xref:System.Boolean> sinal e um <xref:System.Byte> fator de escala.  
  
 [!code-cpp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CPP/ctoriiibby.cpp#2)]
 [!code-csharp[System.Decimal.Ctor.Arrays#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/CS/ctoriiibby.cs#2)]
 [!code-vb[System.Decimal.Ctor.Arrays#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ctor.Arrays/VB/ctoriiibby.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.Decimal.GetBits%2A> método para recuperar as partes do componente de uma matriz. Ele então usa essa matriz na chamada para o <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> construtor para instanciar um novo <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="scale" /> é maior que 28.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static decimal Add (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Add(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Add(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser adicionado.</param>
        <param name="d2">O segundo valor a ser adicionado.</param>
        <summary>Soma dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>A soma de <paramref name="d1" /> e <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O exemplo de código a seguir ilustra o uso de `Add` :  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">A soma de <paramref name="d1" /> e <paramref name="d2" /> é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Ceiling(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal.</param>
        <summary>Retorna o menor valor integral maior ou igual ao número decimal especificado.</summary>
        <returns>O menor valor integral maior ou igual ao parâmetro <paramref name="d" />. Observe que esse método retorna um <see cref="T:System.Decimal" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para positivo infinito. Em outras palavras, se `d` for positivo, a presença de qualquer componente fracionários causa `d` a ser arredondado para o inteiro mais próximo. Se `d` é negativo, a operação de arredondamento faz com que qualquer componente frações de `d` sejam descartadas. A operação desse método difere de <xref:System.Decimal.Floor%2A> método, que oferece suporte para o infinito negativo de arredondamento.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o <xref:System.Decimal.Ceiling%2A> método e contrasta com o <xref:System.Decimal.Floor%2A> método.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Compare(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Compara dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>Um número assinado que indica os valores relativos de <paramref name="d1" /> e <paramref name="d2" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Significado  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="d1" />é menor que <paramref name="d2" />.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="d1" />e <paramref name="d2" /> são iguais.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="d1" />é maior do que <paramref name="d2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir compara vários <xref:System.Decimal> valores. Observe que a primeira comparação indica que os dois valores são iguais apesar da operação de subtração executada no `value2` variável. Isso ocorre porque o <xref:System.Decimal> tipo tem 29 dígitos de precisão, enquanto uma diferença entre esses dois valores pode ser detectada somente com 30 dígitos de precisão.  
  
 [!code-csharp[System.Decimal.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Decimal.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser comparado com essa instância.</param>
        <summary>Compara essa instância com um objeto <see cref="T:System.Decimal" /> especificado e retorna uma comparação dos valores relativos.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Significado  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementa esse método de <xref:System.IComparable%601?displayProperty=nameWithType> interface e executa um pouco melhor do que o <xref:System.Decimal.CompareTo%2A?displayProperty=nameWithType> método porque ele não tem que converter a `value` parâmetro para um objeto.  
  
 Dependendo da linguagem de programação, talvez seja possível código um <xref:System.Decimal.CompareTo%2A> método em que o tipo de parâmetro tem bits menos (é mais estreita) que o tipo de instância. Isso é possível porque algumas linguagens de programação executam uma conversão de ampliação implícita que representa o parâmetro como um tipo com tantos bit quanto a instância.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Int32> e o tipo de parâmetro seja <xref:System.Byte>. O compilador Microsoft c# gera instruções para representar o parâmetro como um <xref:System.Int32> do objeto e, em seguida, gera um <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> método para comparar os valores da <xref:System.Int32> instância e o <xref:System.Int32> representação de parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador realiza conversões de ampliação implícitas em tipos numéricos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra genéricas e versões dos <xref:System.Decimal.CompareTo%2A> método para vários tipos de valor e referência.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Compara essa instância com um objeto especificado e retorna uma comparação dos valores relativos.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Significado  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer instância do <xref:System.Decimal>, independentemente de seu valor é considerado maior `null`.  
  
 Parâmetro `value` devem ser `null` ou uma instância de <xref:System.Decimal>; caso contrário, uma exceção será lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir compara vários `Decimal` e outros objetos para uma referência `Decimal` valor usando o `CompareTo` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é um <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static decimal Divide (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Divide(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Divide(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O dividendo.</param>
        <param name="d2">O divisor.</param>
        <summary>Divide dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado da divisão de <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 A exemplo a seguir chama o <xref:System.Decimal.Divide%2A> método pelo qual dividir um intervalo de valores 22.1.  
  
 [!code-csharp[System.Decimal.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Decimal.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> é zero.</exception>
        <exception cref="T:System.OverflowException">O valor retornado (isso é, o quociente) é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto a ser comparado com essa instância.</param>
        <summary>Retorna um valor que indica se essa instância e um objeto <see cref="T:System.Decimal" /> especificado representam o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for igual a essa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementa esse método de <xref:System.IEquatable%601?displayProperty=nameWithType> de interface e executa um pouco melhor do que <xref:System.Decimal.Equals%2A> porque ele não tem que converter a `value` parâmetro para um objeto.  
  
 Se `value` tem menos bits (é mais estreita) que o tipo de instância, algumas linguagens de programação executam uma conversão implícita de ampliação que transforma o valor do parâmetro em um valor com mais bits.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Int32> e o tipo de parâmetro seja <xref:System.Byte>. O compilador Microsoft c# gera instruções para representar o valor do parâmetro como um <xref:System.Int32> do objeto e, em seguida, gera um <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> método para comparar o <xref:System.Int32> representação de instância e o parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador realiza conversões de ampliação implícitas em tipos numéricos.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Decimal.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Decimal" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Decimal.Equals(System.Decimal)" /> método. Caso contrário, eles chamam o <see cref="M:System.Decimal.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Decimal" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos primitivos integrais, inclusive assinados e tipos, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chama o <see cref="M:System.Decimal.Equals(System.Decimal)" /> método, enquanto o segundo comparação retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Decimal.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser comparado com essa instância.</param>
        <summary>Retorna um valor que indica se esta instância e um especificado <see cref="T:System.Object" /> representar o mesmo tipo e valor.</summary>
        <returns>
          <see langword="true" />Se <paramref name="value" /> é um <see cref="T:System.Decimal" /> e igual a esta instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir compara vários `Decimal` e outros objetos para uma referência `Decimal` valor usando o `Equals` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/cto_eq_obj.cpp#1)]
 [!code-csharp[System.Decimal.Compare_Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/cto_eq_obj.cs#1)]
 [!code-vb[System.Decimal.Compare_Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/cto_eq_obj.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Decimal.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Decimal" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Decimal.Equals(System.Decimal)" /> método. Caso contrário, eles chamam o <see cref="M:System.Decimal.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Decimal" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos primitivos integrais, inclusive assinados e tipos, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chama o <see cref="M:System.Decimal.Equals(System.Decimal)" /> método, enquanto o segundo comparação retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Decimal.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Decimal.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Decimal.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Equals(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se duas instâncias especificadas de <see cref="T:System.Decimal" /> representam o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> e <paramref name="d2" /> forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir compara vários `Decimal` valores para uma referência `Decimal` valor usando o estático `Equals` método.  
  
 [!code-cpp[System.Decimal.Compare_Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CPP/comp_equal.cpp#2)]
 [!code-csharp[System.Decimal.Compare_Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/CS/comp_equal.cs#2)]
 [!code-vb[System.Decimal.Compare_Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Compare_Equals/VB/comp_equal.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Floor(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser arredondado.</param>
        <summary>Arredonda um número <see cref="T:System.Decimal" /> especificado para o inteiro mais próximo do infinito negativo.</summary>
        <returns>Se o <paramref name="d" /> tiver uma parte fracionária, o próximo número <see cref="T:System.Decimal" /> inteiro do infinito negativo menor que <paramref name="d" />.  
  
 -ou-  
  
 Se o <paramref name="d" /> não tiver uma parte fracionária, o <paramref name="d" /> será retornado inalterado. Observe que o método retorna um valor integral do tipo <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento desse método segue IEEE 754 padrão, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para negativo infinito. Em outras palavras, se `d` for positivo, qualquer componente fracionário é truncado. Se `d` for negativo, a presença de qualquer componente fracionário faz com que ele deve ser arredondada para o menor inteiro. A operação desse método difere de <xref:System.Decimal.Ceiling%2A> método, que oferece suporte para o infinito positivo de arredondamento.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o <xref:System.Decimal.Floor%2A> método e contrasta com o <xref:System.Decimal.Ceiling%2A> método.  
  
 [!code-csharp[System.Decimal.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Ceiling/cs/ceiling1.cs#1)]
 [!code-vb[System.Decimal.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromOACurrency">
      <MemberSignature Language="C#" Value="public static decimal FromOACurrency (long cy);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal FromOACurrency(int64 cy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.FromOACurrency(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cy" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="cy">Um valor de moeda de automação OLE.</param>
        <summary>Converte o 64 bits assinado inteiros especificados, que contém um valor de moeda de automação OLE, equivalente a <see cref="T:System.Decimal" /> valor.</summary>
        <returns>Um <see cref="T:System.Decimal" /> que contém o equivalente de <paramref name="cy" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código usa o `FromOACurrency` método para converter <xref:System.Int64> campos que contêm valores de moeda de automação OLE para o equivalente `Decimal` números.  
  
 [!code-cpp[System.Decimal.OACurrency#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/fromoacurrency.cpp#2)]
 [!code-csharp[System.Decimal.OACurrency#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/fromoacurrency.cs#2)]
 [!code-vb[System.Decimal.OACurrency#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/fromoacurrency.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBits">
      <MemberSignature Language="C#" Value="public static int[] GetBits (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32[] GetBits(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetBits(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser convertido.</param>
        <summary>Converte o valor da instância especificada de <see cref="T:System.Decimal" /> para sua representação de cadeia de caracteres equivalente.</summary>
        <returns>Uma matriz de número inteiro com sinal de 32 bits com quatro elementos que contêm a representação binária de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação binária de um <xref:System.Decimal> número consiste em um sinal de 1 bit, um número inteiro de 96 bits e um fator de escala usada para dividir o número inteiro e especificar qual parte dele é uma fração decimal. O fator de escala é implicitamente o número 10, elevado a um expoente variando de 0 a 28.  
  
 O valor de retorno é uma matriz de quatro elementos de inteiros com sinal de 32 bits.  
  
 O primeiro, segundo e terceiros elementos da matriz retornada contém os baixos, médio e alto 32 bits do número inteiro de 96 bits.  
  
 O quarto elemento da matriz retornada contém o fator de escala e o sinal. Ele consiste das seguintes partes:  
  
 Bits de 0 a 15, a palavra inferior, são utilizadas e devem ser zero.  
  
 Bits de 16 a 23 devem conter um expoente entre 0 e 28, que indica a potência de 10 para dividir o número inteiro.  
  
 Bits de 24 a 30 são utilizadas e devem ser zero.  
  
 Bit 31 contém o sinal: 0 significa positivo e negativo significa que 1.  
  
 Observe que a representação de bit diferencia entre zero positiva e negativa. Esses valores são tratados como iguais em todas as operações.  
  
   
  
## Examples  
 O exemplo a seguir usa o `GetBits` método para converter vários `Decimal` valores em suas representações binárias equivalentes. Em seguida, exibe os valores decimais e o valor hexadecimal dos elementos na matriz retornada pelo <xref:System.Decimal.GetBits%2A> método.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/getbits.cpp#2)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/getbits.cs#2)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/getbits.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.Decimal.GetBits%2A> método para recuperar as partes do componente de uma matriz. Ele então usa essa matriz na chamada para o <xref:System.Decimal.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%2CSystem.Byte%29> construtor para instanciar um novo <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Decimal.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.ctor/cs/ctor2a.cs#1)]
 [!code-vb[System.Decimal.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.ctor/vb/ctor2a.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para tipo de valor <see cref="T:System.Decimal" />.</summary>
        <returns>A constante enumerada <see cref="F:System.TypeCode.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código usa o `GetTypeCode` método para retornar o código de tipo de `Decimal` tipo de valor.  
  
 [!code-cpp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CPP/gettypecode.cpp#3)]
 [!code-csharp[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/CS/gettypecode.cs#3)]
 [!code-vb[System.Decimal.Get_Bits_Hash_Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Get_Bits_Hash_Type/VB/gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MaxValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MaxValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o maior valor possível de <see cref="T:System.Decimal" />. Este campo é constante e somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é 79.228.162.514.264.337.593.543.950.335 positivo.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de `MaxValue` :  
  
 [!code-cpp[Decimal Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#2)]
 [!code-csharp[Decimal Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#2)]
 [!code-vb[Decimal Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static readonly decimal MinusOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinusOne" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinusOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o número um negativo (-1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `MinusOne` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public static readonly decimal MinValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal MinValue" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o menor valor possível de <see cref="T:System.Decimal" />. Este campo é constante e somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é 79.228.162.514.264.337.593.543.950.335 negativo.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `MinValue` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static decimal Multiply (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Multiply(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O multiplicando.</param>
        <param name="d2">O multiplicador.</param>
        <summary>Multiplica dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado da multiplicação de <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria vários pares de `Decimal` valores e calcula seus produtos com o `Multiply` método.  
  
 [!code-cpp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CPP/mul_div_rem.cpp#1)]
 [!code-csharp[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/CS/mul_div_rem.cs#1)]
 [!code-vb[System.Decimal.Mul_Div_Rem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Mul_Div_Rem/VB/mul_div_rem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static decimal Negate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Negate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Negate(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser negado.</param>
        <summary>Retorna o resultado da multiplicação do valor <see cref="T:System.Decimal" /> especificado pelo negativo.</summary>
        <returns>Um número decimal com o valor de <paramref name="d" />, mas com o sinal oposto.  
  
 -ou-  
  
 Zero, se <paramref name="d" /> for zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código usa o `Negate` método para alterar o sinal de várias `Decimal` valores.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly decimal One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal One" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o número um (1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `One` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Addition(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Addition(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser adicionado.</param>
        <param name="d2">O segundo valor a ser adicionado.</param>
        <summary>Soma dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado da adição de <paramref name="d1" /> e <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Addition%2A> método define a operação do operador de adição para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/addition1.cs#3)]
 [!code-vb[System.Decimal.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/addition1.vb#3)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Add%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Add%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static decimal operator -- (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Decrement(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Decrement(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser diminuído.</param>
        <summary>Diminui o operando <see cref="T:System.Decimal" /> em um.</summary>
        <returns>O valor de <paramref name="d" /> diminuído em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Decrement%2A> método define a operação do operador de decremento <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement1.cs#4)]  
  
 Alguns idiomas (como o Visual Basic) que não têm um operador de incremento podem chamar o <xref:System.Decimal.op_Decrement%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement1.vb#5)]  
  
 Se o idioma não oferece suporte a operadores personalizados, chame o <xref:System.Decimal.Subtract%2A> método em vez disso, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Decimal.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/decrement2.cs#6)]
 [!code-vb[System.Decimal.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/decrement2.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static decimal operator / (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Division(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Division(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O dividendo.</param>
        <param name="d2">O divisor.</param>
        <summary>Divide dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado da divisão de <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Division%2A> método define a operação do operador de divisão para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/division1.cs#7)]
 [!code-vb[System.Decimal.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/division1.vb#7)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Divide%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Divide%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> é zero.</exception>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Equality(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois valores <see cref="T:System.Decimal" /> são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> e <paramref name="d2" /> forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Equality%2A> método define a operação do operador de igualdade para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/equality1.cs#1)]
 [!code-vb[System.Decimal.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/equality1.vb#1)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Equals%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Byte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um inteiro sem sinal de 8 bits.</summary>
        <returns>Um inteiro sem sinal de 8 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Byte>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Byte> valor usando c#, C++ e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToByte%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToByte%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples 
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Byte> valores usando explícita <xref:System.Decimal> para <xref:System.Byte> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctos_byte.cpp#4)] 
 [!code-csharp[System.Decimal.ConvTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctos_byte.cs#4)] 
 [!code-vb[System.Decimal.ConvTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctos_byte.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator char (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname char op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Char" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um caractere Unicode.</summary>
        <returns>Um caractere Unicode que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Char>. A sintaxe para tais conversões explícitas é dependente de idioma, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes, ou pode não oferecer suporte a conversão em todos os. Por exemplo, os compiladores do Visual Basic e C++ não oferecem suporte explícito <xref:System.Decimal> para um <xref:System.Char> conversão.
 

## Examples 
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Char> valores (caracteres Unicode) usando o explícita <xref:System.Decimal> para <xref:System.Char> operador de conversão.

 [!code-csharp[System.Decimal.ConvTo#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctochar.cs#6)]
 [!code-vb[System.Decimal.ConvTo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctochar.vb#6)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" /> ou maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa operação pode resultar em perda de precisão, como um número de ponto flutuante de precisão dupla tem menos dígitos significativos que uma <xref:System.Decimal>.
 
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Double>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Double> valor usando c#, C++ e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToDouble%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToDouble%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Double> valores usando explícita <xref:System.Decimal> para <xref:System.Double> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctosgl_dbl.cpp#5)] 
 [!code-csharp[System.Decimal.ConvTo#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ConvTo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctosgl_dbl.vb#5)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> em um inteiro com sinal de 16 bits.</summary>
        <returns>Um inteiro com sinal de 16 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Int16>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Int16> valor usando c#, Visual Basic e C++. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToInt16%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToInt16%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Int16> valores usando explícita <xref:System.Decimal> para <xref:System.Int16> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)] 
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um inteiro com sinal de 32 bits.</summary>
        <returns>Um inteiro com sinal de 32 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Int32>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Int32> valor usando c#, C++ e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToInt32%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToInt32%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Int32> valores usando explícita <xref:System.Decimal> para <xref:System.Int32> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)] 
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Int64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> em um inteiro com sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Int64>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Int64> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToInt64%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToInt64%28System.Decimal%29?displayProperty=nameWithType> método.
 
## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Int64> valores usando explícita <xref:System.Decimal> para <xref:System.Int64> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)] 
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.SByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um inteiro com sinal de 8 bits.  
  
 Esta API não compatível com CLS.</summary>
        <returns>Um inteiro com sinal de 8 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.SByte>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Byte> e um <xref:System.SByte> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToSByte%28System.Decimal%29?displayProperty=nameWithType> método ou o <xref:System.Convert.ToSByte%28System.Decimal%29?displayProperty=nameWithType> método.   


## Examples 
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.SByte> valores usando explícita <xref:System.Decimal> para <xref:System.SByte> operador de conversão.

 [!code-cpp[System.Decimal.Operators.Explicit#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosbyte.cpp#1)] 
 [!code-csharp[System.Decimal.Operators.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosbyte.cs#1)]
 [!code-vb[System.Decimal.Operators.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosbyte.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> em um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número de ponto flutuante de precisão simples que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa operação pode resultar em perda de precisão, como um número de ponto flutuante de precisão simples tem menos dígitos significativos que uma <xref:System.Decimal>.

 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.Single>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.Single> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToSingle%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToSingle%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.Single> valores usando explícita <xref:System.Decimal> para <xref:System.Single> operador de conversão.

 [!code-cpp[System.Decimal.Operators.Explicit#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cpp/tosingle1.cpp#2)] 
 [!code-csharp[System.Decimal.Operators.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators.explicit/cs/tosingle1.cs#2)]
 [!code-vb[System.Decimal.Operators.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators.explicit/vb/tosingle1.vb#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> para um inteiro não assinado de 16 bits.  
  
 Esta API não compatível com CLS.</summary>
        <returns>Um inteiro sem sinal de 16 bits que representa o objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.UInt16>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.UInt16> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToUInt16%28System.Decimal%29?displayProperty=nameWithType> método.
 

## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.UInt16> valores usando explícita <xref:System.Decimal> para <xref:System.UInt16> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int16.cpp#3)] 
 [!code-csharp[System.Decimal.ConvTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int16.cs#3)]
 [!code-vb[System.Decimal.ConvTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int16.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> em um inteiro sem sinal de 32 bits.  
  
 Esta API não compatível com CLS.</summary>
        <returns>Um inteiro sem sinal de 32 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.UInt32>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.UInt32> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToUInt32%28System.Decimal%29?displayProperty=nameWithType> método.


## Examples
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.UInt32> valores usando explícita <xref:System.Decimal> para <xref:System.UInt32> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int32.cs#2)]
 [!code-vb[System.Decimal.ConvTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int32.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Decimal)~System.UInt64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Decimal" /> em um inteiro sem sinal de 64 bits.  
  
 Esta API não compatível com CLS.</summary>
        <returns>Um inteiro sem sinal de 64 bits que representa o <see cref="T:System.Decimal" /> convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este operador suporta a conversão explícita de um <xref:System.Decimal> para um <xref:System.UInt64>. A sintaxe dessas conversões explícitas depende da linguagem, e os compiladores de linguagem individuais podem fornecer implementações diferentes e retornar resultados diferentes. O exemplo ilustra os diferentes valores de retorno quando você converter explicitamente um <xref:System.Decimal> valor para um <xref:System.UInt64> valor usando o c# e Visual Basic. Para executar uma conversão que é independente do idioma, você pode chamar o <xref:System.Decimal.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> ou <xref:System.Convert.ToUInt64%28System.Decimal%29?displayProperty=nameWithType> método.


## Examples 
 O exemplo a seguir converte <xref:System.Decimal> números para <xref:System.UInt64> valores usando explícita <xref:System.Decimal> para <xref:System.UInt64> operador de conversão.

 [!code-cpp[System.Decimal.ConvTo#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CPP/ctou_int64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvTo/CS/ctou_int64.cs#1)]
 [!code-vb[System.Decimal.ConvTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvTo/VB/ctou_int64.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é negativo ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Double)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Define uma conversão explícita de um número de ponto flutuante de precisão dupla como um <see cref="T:System.Decimal" />.</summary>
        <returns>O número de ponto flutuante de precisão dupla convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  

 O exemplo a seguir converte <xref:System.Double> valores <xref:System.Decimal> números usando o <xref:System.Double> para <xref:System.Decimal> operador de conversão. Essa conversão requer o operador op_Explicit no Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromdouble.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.Others#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromdouble.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.Others#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromdouble.vb#2)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Explicit(System.Single)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Define uma conversão explícita de um número de ponto flutuante de precisão simples para um <see cref="T:System.Decimal" />.</summary>
        <returns>O número de ponto flutuante de precisão simples convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte <xref:System.Single> valores <xref:System.Decimal> números usando o <xref:System.Single> para <xref:System.Decimal> operador de conversão. Essa conversão requer o operador op_Explicit no Visual Basic.

 [!code-cpp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromsingle.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.Others#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromsingle.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.Others#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromsingle.vb#3)]

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThan(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Decimal" /> especificado é maior que outro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="d1" /> seja maior que <paramref name="d2" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthan1.cs#8)]
 [!code-vb[System.Decimal.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan1.vb#8)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Decimal.Compare%2A> em vez disso. Eles também é possível chamar o <xref:System.Decimal.op_GreaterThan%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthan2.vb#9)]  
  
 O método equivalente para esse operador é<xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_GreaterThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Decimal" /> especificado é maior ou igual a outro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> for maior ou igual a <paramref name="d2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_GreaterThanOrEqual%2A> método define a operação do operador maior que ou igual para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/greaterthanorequal1.cs#10)]
 [!code-vb[System.Decimal.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal1.vb#10)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Decimal.Compare%2A> em vez disso. Eles também é possível chamar o <xref:System.Decimal.op_GreaterThanOrEqual%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/greaterthanorequal2.vb#11)]  
  
 O método equivalente para esse operador é<xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define uma conversão implícita do valor de um tipo para um <see cref="T:System.Decimal" /> valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Byte)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro sem sinal de 8 bits em um <see cref="T:System.Decimal" />.</summary>
        <returns>O inteiro sem sinal de 8 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.Byte> valores <xref:System.Decimal> números.

 [!code-cpp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfrombyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfrombyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.UInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfrombyte.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Char)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Define uma conversão implícita de um caractere Unicode para um <see cref="T:System.Decimal" />.</summary>
        <returns>O caractere Unicode convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.Char> valores (caracteres Unicode) para <xref:System.Decimal> números. Essa conversão requer o operador op_Implicit no Visual Basic, mas não em c# e C++. 

 [!code-cpp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CPP/cfromchar.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.Others#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/CS/cfromchar.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.Others#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.Others/VB/cfromchar.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int16)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 16 bits em um <see cref="T:System.Decimal" />.</summary>
        <returns>O inteiro com sinal de 16 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.Int16> valores <xref:System.Decimal> números. Essa conversão requer o operador op_Implicit no Visual Basic, mas não em c# e C++. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.SInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint16.vb#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int32)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 32 bits em um <see cref="T:System.Decimal" />.</summary>
        <returns>O inteiro com sinal de 32 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.Int32> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint32.cpp#2)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint32.cs#2)]
 [!code-vb[System.Decimal.ConvFrom.SInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint32.vb#2)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.Int64)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 64 bits em um <see cref="T:System.Decimal" />.</summary>
        <returns>O inteiro com sinal de 64 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.Int64> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromint64.cpp#1)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromint64.cs#1)]
 [!code-vb[System.Decimal.ConvFrom.SInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromint64.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.SByte)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro assinado de 8 bits para um <see cref="T:System.Decimal" />.  
  
 Esta API não compatível com CLS.</summary>
        <returns>O inteiro de assinado de 8 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.SByte> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CPP/cfromsbyte.cpp#4)]
 [!code-csharp[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/CS/cfromsbyte.cs#4)]
 [!code-vb[System.Decimal.ConvFrom.SInts#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.SInts/VB/cfromsbyte.vb#4)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt16)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro não assinado de 16 bits em um <see cref="T:System.Decimal" />.  
  
 Esta API não compatível com CLS.</summary>
        <returns>O inteiro de não assinado de 16 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.UInt16> valores <xref:System.Decimal> números. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint16.cpp#3)]
 [!code-csharp[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint16.cs#3)]
 [!code-vb[System.Decimal.ConvFrom.UInts#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint16.vb#3)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt32)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro sem sinal de 32 bits em um <see cref="T:System.Decimal" />.  
  
 Esta API não compatível com CLS.</summary>
        <returns>O inteiro sem sinal de 32 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.UInt32> valores <xref:System.Decimal> números.

 [!code-cpp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint32.cpp#2)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint32.cs#2)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint32.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator decimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Implicit(System.UInt64)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Define uma conversão implícita de um inteiro não assinado de 64 bits em um <see cref="T:System.Decimal" />.  
  
 Esta API não compatível com CLS.</summary>
        <returns>O inteiro de não assinado de 64 bits convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do método <xref:System.Decimal.op_Implicit%2A> definem os tipos a partir dos quais o compilador pode converter automaticamente um valor <xref:System.Decimal> sem um operador de conversão explícita (no C#) ou uma chamada para uma função de conversão (no Visual Basic). Elas são conversões de ampliação que não envolvem perda de dados e não lançam uma exceção de <xref:System.OverflowException>.  


## Examples
 O exemplo a seguir converte <xref:System.UInt64> valores <xref:System.Decimal> números usando o <xref:System.UInt64> para <xref:System.Decimal> operador de conversão. 

 [!code-cpp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CPP/cfromuint64.cpp#1)] 
 [!code-csharp[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/CS/cfromuint64.cs#1)] 
 [!code-vb[System.Decimal.ConvFrom.UInts#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.ConvFrom.UInts/VB/cfromuint64.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static decimal operator ++ (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Increment(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Increment(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser incrementado.</param>
        <summary>Incrementa o operando <see cref="T:System.Decimal" /> em 1.</summary>
        <returns>O valor de <paramref name="d" /> incrementado em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Increment%2A> método define a operação do operador de incremento para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment1.cs#12)]  
  
 Alguns idiomas (como o Visual Basic) que não têm um operador de incremento podem chamar o <xref:System.Decimal.op_Increment%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment1.vb#13)]  
  
 Se o idioma não oferece suporte a operadores personalizados, chame o <xref:System.Decimal.Add%2A> método em vez disso, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Decimal.Operators#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/increment2.cs#14)]
 [!code-vb[System.Decimal.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/increment2.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Inequality(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois <see cref="T:System.Decimal" /> objetos têm valores diferentes.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="d1" /> e <paramref name="d2" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/inequality1.cs#2)]
 [!code-vb[System.Decimal.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/inequality1.vb#2)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, você pode testar a desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Decimal.Compare%2A> método, que indica a relação entre duas <xref:System.Decimal> valores.  
  
-   Chamar o <xref:System.Decimal.Equals%2A> método e a reversão de seu valor.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThan(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Decimal" /> especificado é menor que outro <see cref="T:System.Decimal" /> especificado.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="d1" /> seja menor que <paramref name="d2" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthan1.cs#15)]
 [!code-vb[System.Decimal.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan1.vb#15)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Decimal.Compare%2A> em vez disso. Eles também é possível chamar o <xref:System.Decimal.op_LessThan%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthan2.vb#16)]  
  
 O método equivalente para esse operador é<xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_LessThanOrEqual(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser comparado.</param>
        <param name="d2">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um especificado <see cref="T:System.Decimal" /> é menor ou igual a outro especificado <see cref="T:System.Decimal" />.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="d1" /> seja menor ou igual a <paramref name="d2" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_LessThanOrEqual%2A> método define a operação de menor que ou operador de igualdade para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/lessthanorequal1.cs#17)]
 [!code-vb[System.Decimal.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal1.vb#17)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Decimal.Compare%2A> em vez disso. Eles também é possível chamar o <xref:System.Decimal.op_LessThanOrEqual%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Decimal.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/lessthanorequal2.vb#18)]  
  
 O método equivalente para esse operador é<xref:System.Decimal.Compare%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static decimal operator % (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Modulus(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Modulus(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O dividendo.</param>
        <param name="d2">O divisor.</param>
        <summary>Retorna o resto da divisão de dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resto da divisão de <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Modulus%2A> método define a operação do operador de módulo para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/modulus1.cs#19)]
 [!code-vb[System.Decimal.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/modulus1.vb#19)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Remainder%2A> método em vez disso.  
  
 O sinal do valor retorno pela operação de módulo depende do sinal de dividendo. Se o dividendo é positivo, a operação de módulo retorna um resultado positivo; Se ele for negativo, a operação de módulo retorna um resultado negativo.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Remainder%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> é <see langword="zero" />.</exception>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static decimal operator * (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Multiply(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Multiply(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro valor a ser multiplicado.</param>
        <param name="d2">O segundo valor a ser multiplicado.</param>
        <summary>Multiplica dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado de multiplicar <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Multiply%2A> método define a operação do operador de multiplicação para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/multiply1.cs#20)]
 [!code-vb[System.Decimal.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/multiply1.vb#20)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Multiply%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Multiply%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Subtraction(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_Subtraction(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O minuendo.</param>
        <param name="d2">O subtraendo.</param>
        <summary>Subtrai dois valores <see cref="T:System.Decimal" /> especificados.</summary>
        <returns>O resultado da subtração de <paramref name="d2" /> de <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_Subtraction%2A> método define a operação do operador de subtração para <xref:System.Decimal> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Decimal.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.operators/cs/subtraction1.cs#21)]
 [!code-vb[System.Decimal.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.operators/vb/subtraction1.vb#21)]  
  
 Se o idioma que você está usando não dá suporte a operadores personalizados, chame o <xref:System.Decimal.Subtract%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Subtract%28System.Decimal%2CSystem.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static decimal operator - (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryNegation(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryNegation(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O valor a ser negado.</param>
        <summary>Nega o valor de especificado <see cref="T:System.Decimal" /> operando.</summary>
        <returns>O resultado de <paramref name="d" /> multiplicado por negativo um (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_UnaryPlus%2A> método define a operação de operador unário de negação (ou o operador aditivo inverso) para <xref:System.Decimal> valores. A operação produz um valor que resulta em 0 (zero) quando ele é adicionado ao número original. Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Decimal.Negate%2A> em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Decimal.Negate%28System.Decimal%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static decimal operator + (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_UnaryPlus(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.op_UnaryPlus(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O operando para retornar.</param>
        <summary>Retorna o valor da <see cref="T:System.Decimal" /> operando (o sinal do operando é alterado).</summary>
        <returns>O valor do operando, <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.op_UnaryPlus%2A> método define a operação do operador unário positivo para <xref:System.Decimal> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no <see cref="T:System.Decimal" /> equivalente.</summary>
        <returns>O equivalente ao número contido em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `s` contém um número no formato:  
  
 [ws] [entrada] [dígitos] dígitos [fracionários dígitos] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*,*|Um símbolo de separador de milhares específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9.|  
  
 Parâmetro `s` é interpretado usando o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> estilo. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> ou <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 Parâmetro `s` é analisada usando as informações de formatação em um <xref:System.Globalization.NumberFormatInfo> inicializado para a cultura atual do sistema. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analisar uma cadeia de caracteres usando as informações de formatação de alguns outros cultura, use o <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> ou <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 Se necessário, o valor de `s` é arredondado usando arredondamento mais próximo.  
  
 Um <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Se durante uma operação de análise um separador é encontrado na `s` parâmetro, a moeda aplicável ou número decimal e separadores de grupo são os mesmos, a operação de análise assumirá que o separador é um separador decimal em vez de um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Decimal.Parse%28System.String%29> método analisar representações de cadeia de caracteres de <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Decimal.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#1)]
 [!code-vb[System.Decimal.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não está no formato correto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit de <see cref="T:System.Globalization.NumberStyles" /> valores que indicam os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico a ser especificado é <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo especificado em seu <see cref="T:System.Decimal" /> equivalente.</summary>
        <returns>O número <see cref="T:System.Decimal" /> equivalente ao número contido em <paramref name="s" />, conforme especificado por <paramref name="style" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `style` parâmetro define os elementos de estilo (como milhares separadores, espaço em branco e símbolos de moeda) que são permitidos no `s` parâmetro para o êxito da operação de análise. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Dependendo do valor de `style`, o parâmetro `s` pode incluir os seguintes elementos:  
  
 [ws] [$] [entrada] [dígitos] dígitos [fracionários dígitos] [dígitos e [logon]] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*,*|Um símbolo de separador de milhares específico da cultura. Milhares da cultura atual separador pode aparecer em `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9. Os dígitos fracionários só podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*e*|O caractere 'e' ou 'E', que indica se o valor é representado na notação exponencial. O parâmetro `s` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles.None> ) sempre é analisada com êxito. O restante <xref:System.Globalization.NumberStyles> elementos que podem ser, mas não precisa estar presente na cadeia de entrada de controle de membros. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em s além de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O elemento de linguagem *.* e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O parâmetro `s` também pode usar notação exponencial. Esse sinalizador dá suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos, como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os. O parâmetro `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o *.* símbolo. O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, *,*, e *.* elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os estilos, exceto caso `s` não possa representar um número hexadecimal.|  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Um <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Se um separador é encontrado na `s` parâmetro durante uma operação de análise, `styles` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> valores e a moeda aplicável ou número decimal e separadores de grupo são os mesmos, a operação de análise assumirá que o separador é um separador decimal em vez de um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analisar as representações de cadeia de caracteres de <xref:System.Decimal> valores usando a cultura en-US.  
  
 [!code-csharp[System.Decimal.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#2)]
 [!code-vb[System.Decimal.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não está no formato correto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <param name="provider">Um <see cref="T:System.IFormatProvider" /> que fornece informações de análise específicas de cultura sobre <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número no equivalente de <see cref="T:System.Decimal" /> usando as informações de formato específicas da cultura especificadas.</summary>
        <returns>O número <see cref="T:System.Decimal" /> equivalente ao número contido em <paramref name="s" />, conforme especificado por <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> método normalmente é usado para converter um texto que pode ser formatado de várias maneiras de um <xref:System.Decimal> valor. Por exemplo, ele pode ser usado para converter o texto inserido por usuário em uma caixa de texto HTML em um valor numérico.  
  
 O parâmetro `s` contém um número da forma:  
  
 [ws] [entrada] [dígitos] dígitos [fracionários dígitos] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*,*|Um símbolo de separador de milhares específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9.|  
  
 O parâmetro `s` é interpretado usando-se o estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>, como um objeto <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na análise. Caso `provider` seja `null`, a cultura atual do thread é usada.  
  
 Um objeto <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir é o manipulador de eventos de clique do botão de um formulário da Web. Ele usa a matriz retornada pela propriedade <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> para determinar a localidade do usuário. Em seguida, ele instancia um objeto <xref:System.Globalization.CultureInfo> que corresponde à localidade. O <xref:System.Globalization.NumberFormatInfo> que pertence ao objeto <xref:System.Globalization.CultureInfo> objeto é transmitido para o <xref:System.Decimal.Parse%28System.String%2CSystem.IFormatProvider%29> método para converter o usuário de entrada para um <xref:System.Decimal> valor.  
  
 [!code-csharp[ParseMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#3)]
 [!code-vb[ParseMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não está no formato correto</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static decimal Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit de <see cref="T:System.Globalization.NumberStyles" /> valores que indicam os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico a ser especificado é <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Um <see cref="T:System.IFormatProvider" /> objeto que fornece informações específicas de cultura sobre o formato de <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em seu <see cref="T:System.Decimal" /> equivalente usando o formato específico da cultura e estilo especificados.</summary>
        <returns>O número <see cref="T:System.Decimal" /> equivalente ao número contido em <paramref name="s" />, conforme especificado por <paramref name="style" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `style` define o formato permitido do parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Dependendo do valor de `style`, o parâmetro `s` pode incluir os seguintes elementos:  
  
 [ws] [$] [entrada] [dígitos] dígitos [fracionários dígitos] [dígitos e [logon]] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*$*|Um símbolo de moeda específico de cultura. Sua posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> propriedades do <xref:System.Globalization.NumberFormatInfo> objeto retornado pelo <xref:System.IFormatProvider.GetFormat%2A> método do `provider` parâmetro. O símbolo de moeda pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*ws*|Espaço em branco opcional. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*,*|Um símbolo de separador de milhares específico da cultura. Milhares separador da cultura definida pelo `provider` pode aparecer em `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo de ponto decimal da cultura definido pelo `provider` pode aparecer em `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9. Os dígitos fracionários só podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*e*|O caractere 'e' ou 'E', que indica se o valor é representado na notação exponencial. O parâmetro `s` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles.None> ) sempre é analisada com êxito. O restante <xref:System.Globalization.NumberStyles> elementos que podem ser, mas não precisa estar presente na cadeia de entrada de controle de membros. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em s além de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O elemento de linguagem *.* e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O parâmetro `s` também pode usar notação exponencial.  Esse sinalizador dá suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos, como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os. O parâmetro `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o *.* símbolo. O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, *,*, e *.* elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os estilos, exceto caso `s` não possa representar um número hexadecimal.|  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>, como um objeto <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na análise. Caso `provider` seja `null`, a cultura atual do thread é usada.  
  
 Um objeto <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa uma variedade de `style` e `provider` parâmetros para analisar as representações de cadeia de caracteres de <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Decimal.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Parse/CS/parse.cs#3)]
 [!code-vb[System.Decimal.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Parse/VB/parse.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não está no formato correto.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static decimal Remainder (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Remainder(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Remainder(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O dividendo.</param>
        <param name="d2">O divisor.</param>
        <summary>Calcula o resto após dividir dois valores <see cref="T:System.Decimal" />.</summary>
        <returns>O resto após dividir <paramref name="d1" /> por <paramref name="d2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.Remainder%2A> método para calcular o restante em uma série de operações de divisão.  
  
 [!code-csharp[System.Decimal.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.remainder/cs/remainder.cs#1)]
 [!code-vb[System.Decimal.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.remainder/vb/remainder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="d2" /> é zero.</exception>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <summary>Arredonda um valor decimal para o inteiro mais próximo.</summary>
        <returns>O inteiro mais próximo ao parâmetro <paramref name="d" />. Se <paramref name="d" /> estiver entre dois inteiros, sendo um deles par e outro ímpar, o número par será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Esse tipo de arredondamento às vezes é chamado *arredondar metade mesmo* ou *do arredondamento bancário*. Minimiza os erros de arredondamento que resultam de arredondamento consistentemente um valor de ponto médio em uma única direção. É equivalente a chamar o <xref:System.Decimal.Round%28System.Decimal%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir Arredonda um intervalo de <xref:System.Decimal> valores entre 100 e 102 para o inteiro mais próximo. Como o método usa arredondamento bancário, observe que 100.5 arredondado para 100 e 101.5 é arredondado para 102.  
  
 [!code-csharp[System.Decimal.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round1.cs#1)]
 [!code-vb[System.Decimal.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O resultado está fora do intervalo de um valor <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="decimals">Um valor de 0 a 28 que especifica o número de casas decimais para o qual arredondar.</param>
        <summary>Arredonda um valor <see cref="T:System.Decimal" /> para um número especificado de casas decimais.</summary>
        <returns>O número decimal equivalente ao <paramref name="d" /> arredondado para o número <paramref name="decimals" /> de casas decimais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a chamar o <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding?displayProperty=nameWithType>. Quando `d` é exatamente a meio caminho entre dois valores arredondados, o resultado é o valor arredondado que tem um mesmo dígito na posição decimal à direita. Por exemplo, quando arredondado para duas casas decimais, o valor 2.345 torna-se 2.34 e 2.355 torna-se o valor 2.36. Esse processo é conhecido como *arredondamento em direção mesmo*, ou *do arredondamento bancário*. Minimiza os erros de arredondamento que resultam de arredondamento consistentemente um valor de ponto médio em uma única direção.  
  
   
  
## Examples  
 O exemplo a seguir Arredonda várias `Decimal` valores para um número especificado de casas decimais usando o `Round` método.  
  
 [!code-csharp[System.Decimal.Round#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Decimal.Round/cs/Round12.cs#12)]
 [!code-vb[System.Decimal.Round#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Decimal.Round/vb/Round12.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> não é um valor de 0 a 28.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="mode">Um valor que especifica como arredondar <c>d</c> se ele estiver entre dois outros números.</param>
        <summary>Arredonda um valor decimal para o inteiro mais próximo. Um parâmetro especifica como arredondar o valor caso esteja entre dois outros números.</summary>
        <returns>O inteiro mais próximo ao parâmetro <paramref name="d" />. Se <paramref name="d" /> estiver entre dois números, sendo um deles par e o outro ímpar, o parâmetro <paramref name="mode" /> determinará qual dos dois será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de ponto médio, o valor após os dígitos menos significativos no resultado é precisamente metade do caminho entre dois números. Por exemplo, 7.5 é um valor de ponto médio, se for a ser arredondado para um número inteiro. Para obter valores de ponto médio, o valor mais próximo não pode ser identificado facilmente sem uma convenção de arredondamento, que é especificada pelo `mode` argumento. O <xref:System.Decimal.Round%2A> método dá suporte a duas convenções de arredondamento para lidar com valores de ponto médio.  
  
 Arredondamento para cima.  
 Valores de ponto médio são arredondados para o próximo número diferente de zero. Por exemplo, 3.5 arredonda para 4, 4,5 arredonda para 5,-3.5 arredonda para -4, e-4.5 arredonda para -5. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento diferente de zero é a forma mais amplamente conhecida de arredondamento.  
  
 Até mesmo o arredondamento ou arredondamento bancário  
 Valores de ponto médio são arredondados para o número par mais próximo. Por exemplo, 3.5 e 4.5 arredondados para 4 e-3.5 e-4.5 arredondam -4. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento mais próximo é a forma padrão de arredondamento usados em operações financeiras e estatísticas. Ele está em conformidade com IEEE 754 padrão, a seção 4. Quando usado em várias operações de arredondamento, ele reduz o erro de arredondamento é causado por valores de ponto médio em uma única direção de arredondamento consistentemente. Em alguns casos, esse erro de arredondamento pode ser significativo.  
  
   
  
## Examples  
 O exemplo a seguir exibe valores retornados pelo <xref:System.Math.Round%28System.Decimal%29> método, o <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding.ToEven>e o <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">O resultado está fora do intervalo de um objeto <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="decimals">O número de casas decimais significativas (precisão) no valor retornado.</param>
        <param name="mode">Um valor que especifica como arredondar <c>d</c> se ele estiver entre dois outros números.</param>
        <summary>Arredonda um valor decimal para uma precisão especificada. Um parâmetro especifica como arredondar o valor caso esteja entre dois outros números.</summary>
        <returns>O número mais próximo do parâmetro <paramref name="d" /> com uma precisão igual ao parâmetro <paramref name="decimals" />. Se <paramref name="d" /> estiver entre dois números, sendo um deles par e o outro ímpar, o parâmetro <paramref name="mode" /> determinará qual dos dois será retornado. Se a precisão de <paramref name="d" /> for menor que <paramref name="decimals" />, <paramref name="d" /> será retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `decimals` parâmetro especifica o número de casas decimais a significativas no valor de retorno e varia de 0 a 28. Se `decimals` for zero, um número inteiro será retornado.  
  
 Um valor de ponto médio, o valor após os dígitos menos significativos no resultado é precisamente metade do caminho entre dois números. Por exemplo, 3.47500 é um valor de ponto médio se ele deve ser arredondado para duas casas decimais e 7.500 é um valor de ponto médio, se for a ser arredondado para um número inteiro. Nesses casos, o valor mais próximo não pode ser identificado facilmente sem uma convenção de arredondamento, que é especificada pelo `mode` argumento. O <xref:System.Decimal.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método dá suporte a duas convenções de arredondamento para lidar com valores de ponto médio.  
  
 Arredondamento para cima.  
 Valores de ponto médio são arredondados para o próximo número diferente de zero. Por exemplo, 3,75 Arredonda para 3.8, 3.85 Arredonda para 3.9,-3.75 Arredonda para-3.8, e-3.85 Arredonda para-3.9. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento diferente de zero é a forma mais amplamente conhecida de arredondamento.  
  
 Até mesmo o arredondamento ou arredondamento bancário  
 Valores de ponto médio são arredondados para o número par mais próximo. Por exemplo, 3,75 e 3,85 arredondar para 3.8 e-3.75 e-3.85 arredondam para-3.8. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento mais próximo é a forma padrão de arredondamento usados em operações financeiras e estatísticas. Ele está em conformidade com IEEE 754 padrão, a seção 4. Quando usado em várias operações de arredondamento, ele reduz o erro de arredondamento é causado por valores de ponto médio em uma única direção de arredondamento consistentemente. Em alguns casos, esse erro de arredondamento pode ser significativo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29> método com o <xref:System.MidpointRounding> enumeração.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> é menor que 0 ou maior que 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">O resultado está fora do intervalo de um objeto <see cref="T:System.Decimal" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static decimal Subtract (decimal d1, decimal d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Subtract(valuetype System.Decimal d1, valuetype System.Decimal d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Subtract(System.Decimal,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Decimal" />
        <Parameter Name="d2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d1">O minuendo.</param>
        <param name="d2">O subtraendo.</param>
        <summary>Subtrai um valor <see cref="T:System.Decimal" /> especificado de outro.</summary>
        <returns>O resultado da subtração de <paramref name="d2" /> de <paramref name="d1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir ilustra o uso de `Subtract`.  
  
 [!code-cpp[Decimal Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#4)]
 [!code-csharp[Decimal Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#4)]
 [!code-vb[Decimal Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de retorno é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> caso o valor da instância atual não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.Decimal%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToByte%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToByte%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. A tentativa de usar esse método lança um <see cref="T:System.InvalidCastException" />.</summary>
        <returns>nenhuma. Esta conversão não é suportada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. A tentativa de usar esse método lança um <see cref="T:System.InvalidCastException" />.</summary>
        <returns>nenhuma. Esta conversão não é suportada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToDouble%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToDouble%2A?displayProperty=nameWithType> método.  
  
 Porque um <xref:System.Double> tem menos dígitos significativos que uma <xref:System.Decimal>, essa operação pode gerar erros de arredondamento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToInt16%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToInt16%2A?displayProperty=nameWithType> método.  
  
 O valor <xref:System.Decimal> é arredondado para zero até o valor inteiro mais próximo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">O parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToInt32%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToInt32%2A?displayProperty=nameWithType> método.  
  
 O valor <xref:System.Decimal> é arredondado para zero até o valor inteiro mais próximo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToInt64%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToInt64%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToSByte%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToSByte%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToSingle%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToSingle%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual converter o valor deste <see cref="T:System.Decimal" /> instância.</param>
        <param name="provider">Uma implementação de <see cref="T:System.IFormatProvider" /> que fornece informações específicas da cultura sobre o formato do valor retornado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o `static` (`Shared` no Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método em vez disso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Não há suporte para a conversão do tipo solicitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToUInt16%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToUInt16%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToUInt32%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToUInt32%2A?displayProperty=nameWithType> método.  
  
 O valor <xref:System.Decimal> é arredondado para zero até o valor inteiro mais próximo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Decimal> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Decimal.ToUInt64%2A?displayProperty=nameWithType> método ou o <xref:System.Convert.ToUInt64%2A?displayProperty=nameWithType> método.  
  
 O valor <xref:System.Decimal> é arredondado para zero até o valor inteiro mais próximo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor inteiro resultante é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">O objeto que iniciou o retorno de chamada. A funcionalidade desse parâmetro não está implementada no momento.</param>
        <summary>Executado quando a desserialização de um objeto foi concluída.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">O <see cref="T:System.Decimal" /> objeto contém dados inválidos ou corrompidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToByte(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro sem sinal de 8 bits.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `value` é arredondado para o valor inteiro mais próximo em direção a zero, e que o resultado é retornado.  
  
 Você também pode converter um <xref:System.Decimal> valor para um inteiro não assinado de 8 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToByte%2A> método para converter números decimais para <xref:System.Byte> valores.  
  
 [!code-csharp[System.Decimal.ToByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tobyte/cs/tobyte_1.cs#1)]
 [!code-vb[System.Decimal.ToByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tobyte/vb/tobyte_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToDouble(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor do <see cref="T:System.Decimal" /> especificado no número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa operação pode gerar erros de arredondamento como um número de ponto flutuante de precisão dupla tem menos dígitos significativos que uma <xref:System.Decimal>.  
  
 Você também pode converter um <xref:System.Decimal> para um <xref:System.Double> valor usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Porque a conversão pode envolver uma perda de precisão, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O código a seguir converte exemplo `Decimal` números para <xref:System.Double> valores usando `ToDouble` método.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt16(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro assinado de 16 bits.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você também pode converter um <xref:System.Decimal> valor como um inteiro de 16 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToInt16%2A> método para converter números decimais para <xref:System.Int16> valores.  
  
 [!code-csharp[System.Decimal.ToInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint16/cs/toint16_1.cs#1)]
 [!code-vb[System.Decimal.ToInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint16/vb/toint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt32(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor do <see cref="T:System.Decimal" /> especificado para o inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente ao valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é a parte integral do valor decimal; os dígitos fracionários são truncados.  
  
 Você também pode converter um <xref:System.Decimal> valor como um inteiro de 32 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToInt32%2A> método para converter números decimais para <xref:System.Int32> valores.  
  
 [!code-csharp[System.Decimal.ToInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint32/cs/toint32_1.cs#1)]
 [!code-vb[System.Decimal.ToInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint32/vb/toint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToInt64(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>Um inteiro assinado de 64 bits equivalente ao valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é a parte integral do valor decimal; os dígitos fracionários são truncados.  
  
 Você também pode converter um <xref:System.Decimal> valor como um inteiro de 64 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToInt64%2A> método para converter números decimais para <xref:System.Int64> valores.  
  
 [!code-csharp[System.Decimal.ToInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.toint64/cs/toint64_1.cs#1)]
 [!code-vb[System.Decimal.ToInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.toint64/vb/toint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToOACurrency">
      <MemberSignature Language="C#" Value="public static long ToOACurrency (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToOACurrency(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToOACurrency(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor <see cref="T:System.Decimal" /> especificado no valor de moeda de Automação OLE equivalente, que é contido em um inteiro com sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits que contém o equivalente à Automação OLE de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código usa o `ToOACurrency` método para converter `Decimal` números para os valores de moeda de automação OLE equivalentes que estão contidos em <xref:System.Int64> campos.  
  
 [!code-cpp[System.Decimal.OACurrency#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CPP/tooacurrency.cpp#1)]
 [!code-csharp[System.Decimal.OACurrency#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.OACurrency/CS/tooacurrency.cs#1)]
 [!code-vb[System.Decimal.OACurrency#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.OACurrency/VB/tooacurrency.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSByte(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro assinado de 8 bits.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você também pode converter um <xref:System.Decimal> valor em um inteiro assinado de 8 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToSByte%2A> método para converter números decimais para <xref:System.SByte> valores.  
  
 [!code-csharp[System.Decimal.ToSByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.tosbyte/cs/tosbyte1.cs#1)]
 [!code-vb[System.Decimal.ToSByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.tosbyte/vb/tosbyte1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt16(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToSingle(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor do <see cref="T:System.Decimal" /> especificado no número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente ao valor do <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa operação pode gerar erros de arredondamento como um número de ponto flutuante de precisão simples tem menos dígitos significativos que uma <xref:System.Decimal>.  
  
 Você também pode converter um <xref:System.Decimal> para um <xref:System.Single> valor usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Porque a conversão pode envolver uma perda de precisão, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O código a seguir converte exemplo `Decimal` números para <xref:System.Single> valores usando o `ToSingle` método.  
  
 [!code-cpp[System.Decimal.ToXXX#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CPP/tosgl_dbl.cpp#5)]
 [!code-csharp[System.Decimal.ToXXX#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToXXX/CS/tosgl_dbl.cs#5)]
 [!code-vb[System.Decimal.ToXXX#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToXXX/VB/tosgl_dbl.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente.</summary>
        <returns>Uma cadeia de caracteres que representa o valor dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.ToString> formatos do método um <xref:System.Decimal> valor padrão ("G" ou geral), formato da cultura atual. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Decimal.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Decimal.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Decimal> valor usando o padrão <xref:System.Decimal.ToString> método. Ele também exibe as representações de cadeia de caracteres da <xref:System.Decimal> valor resultantes do uso de um número de especificadores de formato padrão.  
  
 [!code-csharp[System.Decimal.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#2)]
 [!code-vb[System.Decimal.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#2)]  
  
 O exemplo a seguir exibe a quantidade de dinheiro em uma conta.  
  
 [!code-cpp[Decimal Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Decimal Example/CPP/source.cpp#5)]
 [!code-csharp[Decimal Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Decimal Example/CS/source.cs#5)]
 [!code-vb[Decimal Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Decimal Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.ToString%28System.IFormatProvider%29> formatos do método um <xref:System.Decimal> valor padrão ("G" ou geral) formato de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura atual, use as outras sobrecargas do <xref:System.Decimal.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Decimal.ToString>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Decimal.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um objeto <xref:System.Globalization.NumberFormatInfo> ou um objeto <xref:System.Globalization.CultureInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Caso `provider` seja `null`, a cultura atual do thread é usada.  
  
 Para converter um <xref:System.Decimal> valor em sua representação de cadeia de caracteres usando uma cultura especificada e uma cadeia de caracteres de formato específico, chamada de <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir exibe a representação de cadeia de caracteres de um <xref:System.Decimal> valor usando <xref:System.Globalization.CultureInfo> objetos que representam várias culturas diferentes.  
  
 [!code-csharp[System.Decimal.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#3)]
 [!code-vb[System.Decimal.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal.ToString%28System.String%29> formatos do método um <xref:System.Decimal> valor em um formato especificado usando as convenções da cultura atual. Se você quiser usar o padrão ("G" ou geral) formatar ou especificar uma cultura diferente, use as outras sobrecargas do <xref:System.Decimal.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Decimal.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Decimal.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O <xref:System.Decimal.ToString%2A> método usa a cadeia de caracteres de formato numérico personalizado ou padrão especificada pelo `format` parâmetro para converter o valor da instância atual em sua representação de cadeia de caracteres. O `format` parâmetro pode ser qualquer [especificador de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) , exceto D, R e X, bem como qualquer combinação de [especificadores de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` é `null` ou uma cadeia de caracteres vazia, o valor de retorno desta instância é formatada com o especificador de formato numérico geral (G).  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O valor de retorno é formatado usando o <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual. Para aplicar as convenções de formatação de uma cultura específica, chame o <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29> método.  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Decimal> valor usando cada um dos especificadores de formato numérico padrão com suporte, juntamente com duas cadeias de caracteres de formato numérico personalizado. Na conversão dos valores numéricos em cadeias de caracteres, o exemplo usa as convenções de formatação da cultura en-US.  
  
 [!code-csharp[System.Decimal.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#4)]
 [!code-vb[System.Decimal.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato numérico.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> formatos do método um <xref:System.Double> valor em um formato especificado de uma cultura específica. Se você quiser usar as configurações padrão de formato ou a cultura, use as outras sobrecargas do <xref:System.Double.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Double.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Double.ToString%28System.String%29>|  
  
 O `format` parâmetro pode ser qualquer especificador de formato numérico padrão válido, exceto D, R e X, bem como qualquer combinação de especificadores de formato numérico personalizado. Se `format` é `null` ou uma cadeia de caracteres vazia, o valor de retorno para esta instância é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objeto. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Caso `provider` seja `null`, a cultura atual do thread é usada.  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Decimal> valor usando cada um dos especificadores de formato numérico padrão com suporte para várias culturas diferentes.  
  
 [!code-csharp[System.Decimal.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.ToString/CS/ToString2.cs#5)]
 [!code-vb[System.Decimal.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.ToString/VB/ToString2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt16(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro sem sinal de 16 bits.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente ao valor de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é a parte integral do valor decimal; os dígitos fracionários são truncados.  
  
 Você também pode converter um <xref:System.Decimal> valor para um inteiro não assinado de 16 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToUInt16%2A> método para converter números decimais para <xref:System.UInt16> valores.  
  
 [!code-csharp[System.Decimal.ToUInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint16/cs/touint16_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint16/vb/touint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt32(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.UInt16.MaxValue" /> ou menor que <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt32(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 32 bits equivalente ao valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é a parte integral do valor decimal; os dígitos fracionários são truncados.  
  
 Você também pode converter um <xref:System.Decimal> valor para um inteiro não assinado de 32 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToUInt32%2A> método para converter números decimais para <xref:System.UInt32> valores.  
  
 [!code-csharp[System.Decimal.ToUInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint32/cs/touint32_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint32/vb/touint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Decimal.ToInt64(System.Decimal)" />
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> é negativo ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.ToUInt64(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser convertido.</param>
        <summary>Converte o valor especificado <see cref="T:System.Decimal" /> para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro não assinado de 64 bits equivalente ao valor de <paramref name="d" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é a parte integral do valor decimal; os dígitos fracionários são truncados.  
  
 Você também pode converter um <xref:System.Decimal> valor para um inteiro não assinado de 64 bits usando o <xref:System.Decimal.op_Explicit%2A> operador de atribuição. Como o operador executa uma conversão de restrição, você deve usar um operador de conversão em c# ou uma função de conversão no Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.ToUInt64%2A> método para converter números decimais para <xref:System.UInt64> valores.  
  
 [!code-csharp[System.Decimal.ToUInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.decimal.touint64/cs/touint64_1.cs#1)]
 [!code-vb[System.Decimal.ToUInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.decimal.touint64/vb/touint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="d" /> é negativo ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.Truncate(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">O número decimal a ser truncado.</param>
        <summary>Retorna os dígitos integrais do <see cref="T:System.Decimal" /> especificado; todos os dígitos fracionários são descartados.</summary>
        <returns>O resultado de <paramref name="d" /> arredondado para zero, até o número inteiro mais próximo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método Arredonda `d` em direção a zero, para o próximo número inteiro, que corresponde ao descartar os dígitos após o ponto decimal.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o `Truncate` método para descartar os dígitos fracionários de várias `Decimal` valores.  
  
 [!code-cpp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CPP/floor_neg_trunc.cpp#1)]
 [!code-csharp[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/CS/floor_neg_trunc.cs#1)]
 [!code-vb[System.Decimal.Flr_Neg_Rnd_Trnc#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Flr_Neg_Rnd_Trnc/VB/floor_neg_trunc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Decimal@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <param name="result">To be added.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no <see cref="T:System.Decimal" /> equivalente. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga difere de <xref:System.Decimal.Parse%28System.String%29?displayProperty=nameWithType> método retornando um valor booliano que indica se a operação de análise foi bem-sucedida em vez de retornar o valor numérico analisado. Ele elimina a necessidade de usar a identificação de exceções para testar um <xref:System.FormatException> caso esse `s` seja inválido e não possa ser analisado com êxito.  
  
 Parâmetro `s` contém um número no formato:  
  
 [ws] [entrada] [dígitos] dígitos [fracionários dígitos] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*,*|Um símbolo de separador de milhares específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9.|  
  
 Parâmetro `s` é interpretado usando o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> estilo. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> sobrecarga do método.  
  
 Parâmetro `s` é analisada usando as informações de formatação em um <xref:System.Globalization.NumberFormatInfo> objeto inicializado para a cultura atual do sistema. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analisar uma cadeia de caracteres usar as informações de formatação de alguma outra especificado cultura, use o <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29?displayProperty=nameWithType> sobrecarga do método.  
  
 Se necessário, o valor de `s` é arredondado usando arredondamento mais próximo.  
  
 Um objeto <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Se durante uma operação de análise um separador é encontrado na `s` parâmetro, a moeda aplicável ou número decimal e separadores de grupo são os mesmos, a operação de análise assumirá que o separador é um separador decimal em vez de um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Decimal.TryParse%28System.String%2CSystem.Decimal%40%29?displayProperty=nameWithType> método para converter as representações de cadeia de caracteres de valores numéricos para <xref:System.Decimal> valores. Ele pressupõe que en-US é a cultura atual.  
  
 [!code-csharp[System.Decimal.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#1)]
 [!code-vb[System.Decimal.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out decimal result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Decimal&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Decimal.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Decimal@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Decimal&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">A representação da cadeia de caracteres do número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indica o formato permitido de <c>s</c>. Um valor típico a ser especificado é <see cref="F:System.Globalization.NumberStyles.Number" />.</param>
        <param name="provider">Um objeto que fornece informações de análise específicas de cultura sobre <c>s</c>.</param>
        <param name="result">To be added.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em seu <see cref="T:System.Decimal" /> equivalente usando o formato específico da cultura e estilo especificados. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga difere de <xref:System.Decimal.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método retornando um valor booliano que indica se a operação de análise foi bem-sucedida em vez de retornar o valor numérico analisado. Ele elimina a necessidade de usar a identificação de exceções para testar um <xref:System.FormatException> caso esse `s` seja inválido e não possa ser analisado com êxito.  
  
 O parâmetro `style` define o formato permitido do parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 Dependendo do valor de estilo, a `s` parâmetro pode incluir os seguintes elementos:  
  
 [ws] [$] [entrada] [dígitos] dígitos [fracionários dígitos] [dígitos e [logon]] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início do `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador. Ele pode aparecer no final da `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. Sua posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> ou <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriedades do <xref:System.Globalization.NumberFormatInfo> objeto retornado pelo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método do `provider` parâmetro. O símbolo de moeda pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma sequência de dígitos que varia de 0 a 9.|  
  
 O `style` parâmetro especifica o formato permitido do `s` parâmetro e pode ser um ou mais <xref:System.Globalization.NumberStyles> combinados usando uma operação OR bit a bit de constantes enumeradas. Se `style` for nulo, `s` é interpretado usando o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> estilo.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação, como um <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objeto. O parâmetro `provider` fornece informações específicas da cultura usadas na análise. Caso `provider` seja `null`, a cultura atual do thread é usada.  
  
 Um objeto <xref:System.Decimal> tem 29 dígitos de precisão. Caso `s` represente um número com mais de 29 dígitos, mas com uma parte fracionária e dentro do intervalo de <xref:System.Decimal.MaxValue> e <xref:System.Decimal.MinValue>, o número é arredondado, não truncado, para 29 dígitos usando-se o arredondamento mais próximo.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Decimal.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Decimal%40%29> método ao analisar a representação de cadeia de caracteres de um número que tem um estilo específico e é formatado usando as convenções de uma determinada cultura.  
  
 [!code-csharp[System.Decimal.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.TryParse/cs/TryParse.cs#2)]
 [!code-vb[System.Decimal.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.TryParse/vb/TryParse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly decimal Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Decimal Zero" />
      <MemberSignature Language="DocId" Value="F:System.Decimal.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o número zero (0).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `Zero` campo.  
  
 [!code-cpp[System.Decimal.Fields#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Decimal.Fields/CPP/fields.cpp#1)]
 [!code-csharp[System.Decimal.Fields#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Decimal.Fields/CS/fields.cs#1)]
 [!code-vb[System.Decimal.Fields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Decimal.Fields/VB/fields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
