<Type Name="Uri" FullName="System.Uri">
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma representação de objeto de um URI (Uniform Resource Identifier) e fácil acesso às partes do URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um URI é uma representação compacta de um recurso disponível para seu aplicativo na intranet ou na Internet. O <xref:System.Uri> classe define as propriedades e métodos para lidar com URIs, incluindo análise, comparar e combinar. O <xref:System.Uri> propriedades de classe são somente leitura; para criar um objeto pode ser modificado, use o <xref:System.UriBuilder> classe.  
  
 URIs relativos (por exemplo, "/ new/index.htm") deve ser expandido em relação a um URI de base para que eles sejam absolutos. O <xref:System.Uri.MakeRelative%2A> método é fornecido para converter URIs absolutos para URIs relativos quando necessário.  
  
 O <xref:System.Uri> construtores não escapar cadeias de caracteres do URI se a cadeia de caracteres é um URI bem formado, incluindo um identificador do esquema.  
  
 O <xref:System.Uri> propriedades retornam uma representação de dados canônica em codificação com caracteres de escape, todos os caracteres com valores Unicode maiores que 127 substituído por seus equivalentes hexadecimais. Para colocar o URI em forma canônica, o <xref:System.Uri> construtor executa as seguintes etapas:  
  
-   Converte o esquema de URI em minúsculas.  
  
-   Converte o nome do host em minúsculas.  
  
-   Se o nome do host é um endereço IPv6, o endereço IPv6 canônico é usado. ScopeId e outros dados IPv6 opcionais são removidos.  
  
-   Remove o padrão e números de porta vazio.

-   Caracteres de escape (também conhecida como octetos codificados por percentual) que não têm uma finalidade reservada são decodificadas (também conhecido como sendo sem escape). Esses caracteres não reservadas incluem letras maiusculas e minúsculas (% % 41 5A e % 61% 7A), dígitos decimais (30-% 39), hífen (% 2D), o período (% 2E), sublinhado (% 5F) e til (% 7E).

-   Padroniza o caminho para URIs hierárquica pelas sequências de compactação como /., /... e / / (ou não a sequência é liberada). Observe que há alguns esquemas para o qual essas sequências não são compactadas.
  
-   Para URIs hierárquica, se o host não termina com uma barra invertida (/), um será adicionado.  
  
-   Por padrão, nenhum dos caracteres reservados no URI é escapados de acordo com RFC 2396. Este alterações de comportamento se identificadores de recurso ou o nome de domínio internacional análise está habilitada no qual casos caracteres reservados no URI são ignoradas acordo com RFC 3986 e RFC 3987.

 Como parte da conversão em formato canônico no construtor para alguns esquemas, segmentos de ponto e vazio (/., /... e / /) são compactadas (em outras palavras, eles serão removidos). Os esquemas para o qual o URI compactará essas sequências incluem http, https, tcp, NET. pipe e NET. TCP. Para alguns esquemas, essas sequências não são compactadas. Aqui está como essa compactação aparece na prática.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("tcp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("tcp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, unescaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Quando esse código é executado, ele retorna a saída a seguir, com as sequências de escape sem escape se necessário e, em seguida, compactado.

```  
http://myUrl/  
/  
```  
  
 Você pode transformar o conteúdo a <xref:System.Uri> classe a partir de uma referência URI de escape codificado como uma referência URI legível usando o <xref:System.Uri.ToString%2A> método. Observe que alguns caracteres reservados podem ainda ser substituídas na saída do <xref:System.Uri.ToString%2A> método. Isso é para dar suporte a ambígua reconstrução de um URI do valor retornado por <xref:System.Uri.ToString%2A>.  
  
 Alguns URIs incluem um identificador de fragmento ou uma consulta ou ambos. Um identificador do fragmento é qualquer texto que segue um sinal numérico (#), não incluindo o sinal de número; o texto do fragmento é armazenado no <xref:System.Uri.Fragment%2A> propriedade. Informações de consulta são qualquer texto que segue a um ponto de interrogação (?) no URI. o texto da consulta é armazenado no <xref:System.Uri.Query%2A> propriedade.  
  
 No .NET Framework versão 1.1, se a cadeia de caracteres especificada para um construtor contém um esquema desconhecido e "c:\\", as inserções de classe de Uri "/ /" após os dois-pontos. Por exemplo, o URI `xyz:c:\abc` é convertido em `xyz://c:/abc`. No .NET Framework versão 2.0, esse comportamento foi removido e a cadeia de caracteres de exemplo é convertida em `xyz:c:/abc`.  
  
> [!NOTE]
>  A classe URI oferece suporte ao uso de endereços IP em ambos os quad-notação protocolo IPv4 e hexadecimal com dois-pontos para o protocolo IPv6. Lembre-se de incluir o endereço IPv6 entre colchetes, como em http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Suporte ao identificador do recurso internacional  
 Endereços da Web geralmente são expressos usando identificadores de recursos uniformes que consistem em um conjunto muito restrito de caracteres:  
  
-   Letras maiúsculas e minúsculas ASCII do alfabeto inglês.  
  
-   Dígitos de 0 a 9.  
  
-   Um pequeno número de outros símbolos ASCII.  
  
 As especificações de URIs estão documentadas na RFC 2396, RFC 2732, RFC 3986 e RFC 3987 publicados pelo Internet engenharia Task Force (IETF).  
  
 Com o crescimento da Internet, há uma necessidade crescente de identificar recursos com idiomas diferentes do inglês. Identificadores que facilitam a essa necessidade e permitem que os caracteres não ASCII (caracteres no conjunto de caracteres Unicode/ISO 10646) são conhecidos como IRIs (International Resource Identifiers). As especificações de IRIs estão documentadas na RFC 3987, publicado pela IETF. O uso de IRIs permite que uma URL contenha caracteres Unicode.  
  
 Existente <xref:System.Uri> classe foi estendida no .NET Framework v 3.5, 3.0 SP1, e 2.0 SP1 para oferecer suporte a IRI com base na RFC 3987. Os usuários de versões anteriores à versão 4.5 do .NET Framework não verão qualquer alteração no comportamento do .NET Framework 2.0, a menos que eles permitem especificamente IRI. Isso garante a compatibilidade do aplicativo com versões anteriores do .NET Framework.  
  
 Para habilitar o suporte para IRI, é necessária a seguinte alteração:  
  
-   Especifique se deseja que a análise de nome de domínio internacionalizado (IDN) aplicado ao nome de domínio e se as regras de análise de IRI deve ser aplicada. Isso pode ser feito *Machine. config* ou o *App. config* arquivo. Por exemplo, adicione o seguinte:  
  
    ```  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Os usuários do .NET Framework 4.5 e mais recente sempre ter IRI habilitado. A análise de IRI não pode ser alterada usando um *. config* arquivo.  
  
 Habilitar o IDN converterá todos os rótulos Unicode de um nome de domínio para seus equivalentes em Punycode. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--. A razão para isso é dar suporte a servidores DNS existentes na Internet, pois a maioria dos servidores DNS dá suporte somente a caracteres ASCII (consulte RFC 3940).  
  
 Habilitar IRI e IDN afeta o valor da propriedade <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Habilitar IRI e IDN também pode alterar o comportamento dos métodos <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> e <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Há três valores possíveis para IDN dependendo os servidores DNS que são usados:  
  
-   IDN habilitado = All  
  
     Esse valor converterá todos os nomes de domínio Unicode em seus equivalentes do Punycode (nomes IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Esse valor serão convertidos em todos os nomes de domínio de Unicode não na Intranet local para usar os equivalentes de Punycode (nomes IDN). Nesse caso para lidar com nomes internacionais da intranet local, os servidores DNS que são usados para a Intranet devem dar suporte a resolução de nomes de Unicode.  
  
-   IDN habilitado = nenhum  
  
     Esse valor não converterá nenhum nome de domínio Unicode para usar o Punycode. Este é o valor padrão que é consistente com o comportamento do .NET Framework 2.0.  
  
 Quando a análise de IRI está habilitada (iriParsing habilitado = `true`) normalização e a verificação de caractere são feitas de acordo com as regras IRI mais recentes em RFC 3986 e RFC 3987. Quando a análise de IRI estiver desabilitada, normalização e a verificação de caractere são executadas de acordo com RFC 2396 e RFC 2732 (para literais IPv6).  Nas versões do .NET Framework antes da versão 4.5, o valor padrão é `false`. No .NET Framework versão 4.5 e mais recente, o valor padrão é `true`, e o estado habilitado da análise de IRI não pode ser modificado por configurações em um *. config* arquivo.  
  
 IRI e IDN processamento o <xref:System.Uri> classe também pode ser controlada usando o <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, e <xref:System.Configuration.UriSection?displayProperty=nameWithType> classes de configuração. A configuração <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> habilita ou desabilita o processamento de IRI na classe <xref:System.Uri>. A configuração <xref:System.Configuration.IdnElement?displayProperty=nameWithType> habilita ou desabilita o processamento de IDN na classe <xref:System.Uri>. A configuração <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> também controla indiretamente o IDN. O processamento de IRI deve estar habilitado para que o processamento de IDN seja possível. Se o processamento de IRI estiver desabilitado, o processamento de IDN será definido para a configuração padrão, na qual o comportamento do .NET Framework 2.0 será usado para fins de compatibilidade e nomes IDN não serão usados.  
  
 O parâmetro de configuração para o <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> e <xref:System.Configuration.IdnElement?displayProperty=nameWithType> serão lidos uma vez quando o primeiro <xref:System.Uri?displayProperty=nameWithType> classe é criada. Alterações nas configurações depois desse tempo serão ignoradas.  
  
 A classe <xref:System.GenericUriParser?displayProperty=nameWithType> também foi estendida para permitir a criação de um analisador personalizável que dá suporte a IRI e IDN. O comportamento de um objeto <xref:System.GenericUriParser?displayProperty=nameWithType> é especificado passando-se uma combinação bit a bit dos valores disponíveis na enumeração <xref:System.GenericUriParserOptions?displayProperty=nameWithType> para o construtor <xref:System.GenericUriParser?displayProperty=nameWithType>. O tipo <xref:System.GenericUriParserOptions?displayProperty=nameWithType> que indica que o analisador dá suporte às regras de análise especificadas na RFC 3987 para IRI (Identificadores de Recurso Internacional). Se IRI é usada é determinada pelos valores de configuração abordados anteriormente.  
  
 O tipo <xref:System.GenericUriParserOptions?displayProperty=nameWithType> indica que o analisador dá suporte à análise de IDN (Nome de Domínio Internacionalizado) dos nomes de host. Se IDN é usada é determinada pelos valores de configuração abordados anteriormente.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Se você usar um *Web.config * arquivo que contém URIs para inicializar o tempo de aplicativo, adicional é necessária para processar os URIs se seus identificadores de esquema não são padrão. Nesse caso, inicialize as partes afetadas do seu aplicativo quando os URIs são necessárias, não na hora de início.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do <xref:System.Uri> classe e o usa para criar um <xref:System.Net.WebRequest> instância.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Devido a questões de segurança, seu aplicativo deve ter cuidado ao aceitar <see cref="T:System.Uri" /> instâncias de fontes não confiáveis e com <paramref name="dontEscape" /> definido como <see langword="true" />. Você pode verificar uma cadeia de caracteres URI para validade chamando o <see cref="M:System.Uri.IsWellFormedOriginalString" /> método.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com URI especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância de uma cadeia de caracteres do URI. Ele analisa o URI, coloca-o em formato canônico e faz qualquer codificações de escape exigido.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
 Este construtor supõe que o `string` parâmetro faz referência a um URI absoluto e é equivalente a chamar o <xref:System.Uri.%23ctor%2A> construtor com <xref:System.UriKind> definido como <xref:System.UriKind.Absolute>. Se o `string` parâmetro passado para o construtor é um URI relativo, este construtor lançará um <xref:System.UriFormatException>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância com o URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>
          <paramref name="uriString" />está vazio.  
  
 -ou-  
  
 O esquema especificado em <paramref name="uriString" /> não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 -ou-  
  
 <paramref name="uriString" />contém um número excessivo de barras.  
  
 -ou-  
  
 A senha especificada em <paramref name="uriString" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de arquivo especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no <paramref name="uriString" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado em <paramref name="uriString" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O comprimento de <paramref name="uriString" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O comprimento do esquema especificado no <paramref name="uriString" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida em <paramref name="uriString" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Uma instância da classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar a nova instância de <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Uma instância da classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem do fluxo serializado associado à nova instância de <see cref="T:System.Uri" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> das instâncias especificadas das classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor implementa o <xref:System.Runtime.Serialization.ISerializable> a interface para o <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="serializationInfo" /> contém um URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">O parâmetro <paramref name="serializationInfo" /> contém um URI vazio.  
  
 -ou-  
  
 O esquema especificado não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 -ou-  
  
 O URI contém um número excessivo de barras.  
  
 -ou-  
  
 A senha especificada no URI não é válida.  
  
 -ou-  
  
 O nome do host especificado no URI não é válido.  
  
 -ou-  
  
 O nome de arquivo especificado no URI não é válido.  
  
 -ou-  
  
 O nome de usuário especificado no URI não é válido.  
  
 -ou-  
  
 O nome de host ou autoridade especificado no URI não pode ser terminado por barras invertidas.  
  
 -ou-  
  
 O número da porta especificado no URI não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O comprimento do URI excede 65519 caracteres.  
  
 -ou-  
  
 O comprimento do esquema especificado no URI de excede 1023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caractere inválido no URI.  
  
 -ou-  
  
 O caminho do MS-DOS especificado no URI deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" />Se <c>uriString</c> totalmente escape; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com o URI especificado, com controle explícito de escape de caractere.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância de uma cadeia de caracteres do URI. Ele analisa o URI e o coloca em formato canônico.  
  
 O `dontEscape` parâmetro controla se os caracteres reservados são convertidos em sequências de escape. Esse parâmetro deve ser definido como `true` somente se você tiver certeza de que todos os caracteres reservados no URI foi substituídos. Definir o valor como `true` para um URI que não foi totalmente escape pode causar um comportamento inesperado. É altamente recomendável que você sempre defina esse parâmetro para `false`.  
  
 Se `dontEscape` é definido como `false`, o construtor ignora os caracteres reservados, verificando se todas as ocorrências de porcentagem (%)) são seguidas por uma sequência de escape válida. Se a sequência de caracteres a seguir uma porcentagem não for válida, o percentual é substituído por % 25.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância para o URI http://www.contoso.com/Hello%20World.htm. Porque o URI independente completamente é ignorado e está no formato canônico, o `dontEscape` parâmetro pode ser definido como `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="uriString" />está vazio ou contém apenas espaços.  
  
 -ou-  
  
 O esquema especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 <paramref name="uriString" />contém um número excessivo de barras.  
  
 -ou-  
  
 A senha especificada em <paramref name="uriString" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de arquivo especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no <paramref name="uriString" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado em <paramref name="uriString" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O comprimento de <paramref name="uriString" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O comprimento do esquema especificado no <paramref name="uriString" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida em <paramref name="uriString" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Especifica se a cadeia de caracteres do URI é um URI relativo, o URI absoluto, ou é indeterminada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com URI especificado. Este construtor permite que você especifique se a cadeia de caracteres do URI é um URI relativo, um URI absoluto ou indeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URIs relativas e absolutas têm diferentes restrições em seu formato. Por exemplo, um URI relativo não requer um esquema ou uma autoridade. O valor especificado em `uriKind` deve corresponder ao tipo de URI passada `uriString`. No entanto, se <xref:System.UriKind.RelativeOrAbsolute> for especificado, a cadeia de caracteres do URI pode ser relativo ou absoluto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> é inválido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>
          <paramref name="uriString" />contém um URI relativo e <paramref name="uriKind" /> é <see cref="F:System.UriKind.Absolute" />.  
  
 ou  
  
 <paramref name="uriString" />contém um URI absoluto e <paramref name="uriKind" /> é <see cref="F:System.UriKind.Relative" />.  
  
 ou  
  
 <paramref name="uriString" /> está vazio.  
  
 -ou-  
  
 O esquema especificado em <paramref name="uriString" /> não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  
  
 -ou-  
  
 <paramref name="uriString" />contém um número excessivo de barras.  
  
 -ou-  
  
 A senha especificada em <paramref name="uriString" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de arquivo especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado em <paramref name="uriString" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no <paramref name="uriString" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado em <paramref name="uriString" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O comprimento de <paramref name="uriString" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O comprimento do esquema especificado no <paramref name="uriString" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida em <paramref name="uriString" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">O URI de base.</param>
        <param name="relativeUri">O URI relativo a ser adicionado ao URI de base.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com base no URI base especificado e na cadeia de caracteres do URI relativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância combinando o `baseUri` e `relativeUri`. Se `relativeUri` é um URI absoluto (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria uma nova instância do <xref:System.Uri> classe combinando o catalog/showew.htm para formar o http://www.contoso.com/catalog/shownew.htm URI absoluta e relativa URIs http://www.contoso.com.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  
  
 -ou-  
  
 O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras.  
  
 -ou-  
  
 A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Um <see cref="T:System.Uri" /> absoluto que é a base da nova instância de <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Relativo <see cref="T:System.Uri" /> instância combinada com <c>baseUri</c>.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com base na combinação de uma instância base de <see cref="T:System.Uri" /> especificada e uma instância de <see cref="T:System.Uri" /> relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um novo <xref:System.Uri> instância combinando um absoluto <xref:System.Uri> instância, `baseUri`, com relativa <xref:System.Uri> instância, `relativeUri`. Se `relativeUri` é um absoluto <xref:System.Uri> instância (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 Este exemplo cria um absoluto <xref:System.Uri> instância, `absoluteUri`e relativo <xref:System.Uri> instância, `relativeUri`. Um novo <xref:System.Uri> instância, `combinedUri`, em seguida, é criada a partir dessas duas instâncias.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  
  
 -ou-  
  
 O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras.  
  
 -ou-  
  
 A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">O URI de base.</param>
        <param name="relativeUri">O URI relativo a ser adicionado ao URI de base.</param>
        <param name="dontEscape">
          <see langword="true" />Se <c>uriString</c> totalmente escape; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> baseada nos URIs de base e relativos especificados, com controle explícito de escape de caracteres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância combinando `baseUri` e `relativeUri`. Se o URI passado `relativeUri` é um URI absoluto (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
  
 O `dontEscape` parâmetro controla se os caracteres reservados são convertidos em sequências de escape. Esse parâmetro deve ser definido como `true` somente se você tiver certeza de que todos os caracteres reservados no URI foi substituídos. Definir o valor como `true` para um URI que não foi totalmente escape pode causar um comportamento inesperado. É altamente recomendável que você sempre defina esse parâmetro para `false`. Se `dontEscape` é definido como `false`, o construtor ignora os caracteres reservados, verificando se todas as ocorrências de porcentagem (%)) são seguidas por uma sequência de escape válida. Se a sequência de caracteres a seguir uma porcentagem não for válida, o percentual é substituído por % 25.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria uma nova instância do <xref:System.Uri> classe combinando o relativo URIs http://www.contoso.com e Hello%20World.htm para formar um URI absoluto.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  
  
 -ou-  
  
 O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras.  
  
 -ou-  
  
 A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válida.  
  
 -ou-  
  
 O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido.  
  
 -ou-  
  
 O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar em barras invertidas.  
  
 -ou-  
  
 O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não é válido ou não pode ser analisado.  
  
 -ou-  
  
 O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  
  
 -ou-  
  
 O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  
  
 -ou-  
  
 Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  
  
 -ou-  
  
 O caminho do MS-DOS especificado em <paramref name="uriString" /> deve começar com c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>Devido a questões de segurança, seu aplicativo não deve o chamar este construtor com cadeias de caracteres do URI de fontes não confiáveis e com <paramref name="dontEscape" /> definido como <see langword="true" />. Como alternativa, você pode verificar uma cadeia de caracteres URI para validade chamando o <see cref="M:System.Uri.IsWellFormedOriginalString" /> método antes de chamar este construtor.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho absoluto do URI.</summary>
        <value>Um <see cref="T:System.String" /> que contém o caminho absoluto para o recurso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.AbsolutePath%2A> propriedade contém as informações de caminho que o servidor usa para resolver solicitações de informações. Geralmente é o caminho para as informações desejadas no sistema de arquivos do servidor, embora ele também pode indicar o aplicativo ou o servidor deve executar para fornecer as informações do script.  
  
 As informações de caminho não incluem o esquema, o nome de host ou a parte de consulta do URI.  
  
   
  
## Examples  
 O exemplo a seguir grava /catalog/shownew.htm o caminho para o console.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI absoluto.</summary>
        <value>Um <see cref="T:System.String" /> que contém o URI inteiro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.AbsoluteUri%2A> propriedade inclui o URI todo armazenado na <xref:System.Uri> instância, incluindo todos os fragmentos e cadeias de caracteres de consulta.  
  
   
  
## Examples  
 O exemplo a seguir grava todo o conteúdo do <xref:System.Uri> instância para o console. No exemplo mostrado, http://www.contoso.com/catalog/shownew.htm?date=today é gravada no console.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do host do DNS (Sistema de Nomes de Domínio) ou o endereço IP e o número da porta para um servidor.</summary>
        <value>Um <see cref="T:System.String" /> que contém o componente de autoridade do URI representado por essa instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Authority%2A> propriedade normalmente é um nome de host do servidor DNS ou endereço IP. Essa propriedade pode incluir o número da porta de serviço se for diferente da porta padrão para o URI. Se o <xref:System.Uri.Authority%2A> componente contém caracteres reservados, elas são ignoradas no valor de cadeia de caracteres retornado por esta propriedade.  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do host (www.contoso.com) e o número de porta (8080) do servidor para o console.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o URI armazenado internamente em forma canônica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Armazena a versão canônica do URI internamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Essa instância representa um URI relativo e esse método é válido apenas para URIs absolutos.</exception>
        <exception cref="T:System.UriFormatException">O URI está formado incorretamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome de host a ser validado. Isso pode ser um endereço IPv4 ou IPv6 ou um nome de host da Internet.</param>
        <summary>Determina se o nome de host especificado é um nome DNS válido.</summary>
        <returns>Um <see cref="T:System.UriHostNameType" /> que indica o tipo do nome do host. Se o tipo do nome do host não puder ser determinado ou se o nome do host for <see langword="null" /> ou uma cadeia de caracteres de tamanho zero, este método retornará <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.CheckHostName%2A> método verifica se o nome do host fornecido atende aos requisitos de um nome de host da Internet. No entanto, ele não executa uma pesquisa de nome de host para verificar a existência do host.  
  
   
  
## Examples  
 O exemplo a seguir verifica se o nome do host é válido.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">O nome do esquema a ser validado.</param>
        <summary>Determina se o nome do esquema especificado é válido.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o nome do esquema for válido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método verifica o nome do esquema de validade de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, esse método verifica o nome do esquema de validade de acordo com RFC 3986. O nome do esquema deve começar com uma letra e deve conter apenas letras, dígitos e os caracteres ".", "+" ou "-".  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e verifica se o nome do esquema é válido.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamar esse método não tem nenhum efeito.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">O primeiro <see cref="T:System.Uri" />.</param>
        <param name="uri2">O segundo <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Uma combinação bit a bit do <see cref="T:System.UriComponents" /> valores que especifica as partes de <c>uri1</c> e <c>uri2</c> para comparar.</param>
        <param name="compareFormat">Um dos valores <see cref="T:System.UriFormat" /> que especificam o escape de caracteres utilizado quando os componentes do URI são comparados.</param>
        <param name="comparisonType">Um dos valores de <see cref="T:System.StringComparison" />.</param>
        <summary>Compara as partes especificadas de dois URIs usando as regras de comparação especificadas.</summary>
        <returns>Um <see cref="T:System.Int32" /> valor que indica a relação lexical entre o comparados <see cref="T:System.Uri" /> componentes.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Significado  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="uri1" />é menor que <paramref name="uri2" />.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="uri1" />é igual a <paramref name="uri2" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="uri1" />é maior do que <paramref name="uri2" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ambos os `uri1` e `uri2` são `null`, esse método retornará 0. Ao comparar valores URI, um URI relativo é sempre menor que um URI absoluto e um URI não nulo é sempre maior do que uma URI nula. Para casos onde ambos `uri1` e `uri2` não `null` e URIs relativos ou ambos os URIs absolutos, o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método executa a comparação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um nome de host que, após sendo sem escape se necessário, é seguro usar resolução de DNS.</summary>
        <value>Um <see cref="T:System.String" /> que contém a parte de host do URI em um formato adequado para resolução de DNS, ou a cadeia de caracteres original do host, se ele já é adequado para resolução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para endereços IPv6, os colchetes ([]) são removidos e o <xref:System.Net.IPAddress.ScopeId%2A> propriedade for definida, se tiver sido especificado quando esta instância foi construída.

Se você usou uma cadeia de caracteres de escape para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), DnsSafeHost, em seguida, retorna uma cadeia de caracteres de escape. Unescape qualquer cadeia de caracteres de escape retornada de `DnsSafeHost` antes de usar essa cadeia de caracteres para a resolução DNS (veja o exemplo). Se você usou uma cadeia de caracteres de escape inválida para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), DnsSafeHost, em seguida, retorna uma cadeia de caracteres de escape.
  
 O <xref:System.Uri.DnsSafeHost%2A> propriedade é dependente de definições de configuração, conforme discutido posteriormente neste tópico. As definições de configuração não podem ser alteradas por aplicativos da Windows Store, que podem levar a resultados inconsistentes quando usando <xref:System.Uri.DnsSafeHost%2A>. O <xref:System.Uri.IdnHost%2A> é fornecida como uma alternativa ao uso preferencial <xref:System.Uri.DnsSafeHost%2A>, pois <xref:System.Uri.IdnHost%2A> é garantido para ser sempre DNS seguro, não importa qual atual *App. config* configurações podem ser.  
  
 O <xref:System.Uri.DnsSafeHost%2A> propriedade tiver sido estendida no .NET Framework v 3.5, 3.0 SP1, e 2.0 SP1 para fornecer o identificador de recurso internacional (IRI) suporte com base na RFC 3987. Os usuários atuais não verão qualquer mudança do comportamento do .NET Framework 2.0, a menos que habilitem o IRI especificamente. Isso garante a compatibilidade do aplicativo com versões anteriores do .NET Framework.  
  
 Para habilitar o suporte para IRI, as alterações a seguir são necessárias:  
  
1.  Adicione a seguinte linha para o *Machine. config* arquivo no diretório do .NET Framework 2.0  
  
     \<nome da seção = "uri" type="System.Configuration.UriSection, sistema, versão = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089" / >  
  
2.  Especifique se deseja que a análise de nome de domínio internacionalizado (IDN) aplicado ao nome de domínio e se as regras de análise de IRI deve ser aplicada. Isso pode ser feito *Machine. config* ou o *App. config* arquivo. Por exemplo, adicione o seguinte:  
  
    ```  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Habilitar o IDN converterá todos os rótulos Unicode de um nome de domínio para seus equivalentes em Punycode. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--. A razão para isso é dar suporte a servidores DNS existentes na Internet, pois a maioria dos servidores DNS dá suporte somente a caracteres ASCII (consulte RFC 3940).  
  
 A habilitação de IDN só afeta o valor da <xref:System.Uri.DnsSafeHost%2A> propriedade.  
  
 Há três valores possíveis para IDN dependendo os servidores DNS que são usados:  
  
-   IDN habilitado = All  
  
     Esse valor converterá todos os nomes de domínio Unicode em seus equivalentes do Punycode (nomes IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Esse valor converterá todos os nomes de domínio Unicode externos para usar os equivalentes do Punycode (nomes IDN). Nesse caso, para manipular nomes internacionais na Intranet local, os servidores DNS usados para a Intranet devem dar suporte a nomes Unicode.  
  
-   IDN habilitado = nenhum  
  
     Esse valor não converterá nenhum nome de domínio Unicode para usar o Punycode. Este é o valor padrão que é consistente com o comportamento do .NET Framework 2.0.  
  
 Habilitar a análise de IRI (iriParsing habilitado = `true`) fará a normalização e regras de verificação de acordo com a IRI mais recente de caractere em RFC 3987. O valor padrão é `false` e normalização e verificação de acordo com RFC 2396 e RFC 2732 de caracteres (para literais IPv6).  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.Host%2A>, que retorna o nome do host ou endereço especificado no URI e o valor retornado de <xref:System.Uri.DnsSafeHost%2A>, que retorna um endereço que é seguro usar na resolução de DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Conforme explicado em comentários, unescape o nome do host antes de resolvê-lo. Você pode usar o <xref:System.Uri.UnescapeDataString%2A> método unescape o nome do host e você pode resolvê-lo ao chamar o <xref:System.Net.Dns.GetHostEntry%2A> método.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">A instância de <see cref="T:System.Uri" /> ou um identificador de URI a ser comparado à instância atual.</param>
        <summary>Compara duas instâncias de <see cref="T:System.Uri" /> quanto à igualdade.</summary>
        <returns>Um valor de <see cref="T:System.Boolean" /> que é <see langword="true" /> se as duas instâncias representarem o mesmo URI. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Equals%2A> método compara as duas instâncias sem considerar as informações do usuário (<xref:System.Uri.UserInfo%2A>) e o fragmento (<xref:System.Uri.Fragment%2A>) partes que podem conter. Por exemplo, considerando os URIs http://www.contoso.com/index.htm#search e http://user:password@www.contoso.com/index.htm, o <xref:System.Uri.Equals%2A> método retornaria `true`.  
  
 Se um <xref:System.Uri> instância é formada com um nome de host de Unicode e `comparand` parâmetro contiver um <xref:System.Uri> instância ou um identificador que é formado com um nome de host que tem o nome de host Punycode equivalente, em seguida, <xref:System.Uri.Equals%2A> retorna `true` somente se o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) está habilitado. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, o <xref:System.Uri.Query%2A> também será ignorado.  
  
> [!NOTE]
>  O <xref:System.Uri.Equals%2A> método pode ser substituído em uma classe derivada; cuidado como uma entidade mal-intencionado poderia modificar o método. Você não deve usar esse método para executar verificações de segurança, a menos que você sabe que essa instância provenientes de uma fonte confiável.  
  
   
  
## Examples  
 Este exemplo cria dois <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `address1`e `address2` são os mesmos, pois o <xref:System.Uri.Fragment%2A> parte é ignorada para essa comparação. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para impedir que o código parcialmente confiável derivando de <see cref="T:System.Uri" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte caracteres reservados não seguros no componente de caminho para suas representações de caractere hexadecimal.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">O URI passado a partir do construtor é inválido. Essa exceção poderá ocorrer se um URI tiver muitos caracteres ou for relativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">A cadeia de caracteres a ser escapada.</param>
        <summary>Converte uma cadeia de caracteres em sua representação de escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Uri.EscapeDataString%2A> método converte todos os caracteres, exceto caracteres de não reservados 2396 RFC em sua representação hexadecimal. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.EscapeDataString%2A> método converte todos os caracteres, exceto pelo RFC 3986 caracteres não reservados, em sua representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Este método assume que `stringToEscape` não exibe nenhuma sequência de escape.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987. Consulte esses RFCs para uma definição dos caracteres reservado e não reservado.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O tamanho de <paramref name="stringToEscape" /> excede 32766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres a ser transformada em sua representação de escape.</param>
        <summary>Converte uma cadeia de caracteres em sua representação de escape.</summary>
        <returns>A representação de escape da cadeia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.EscapeString%2A> método RFC 2396 reservados e todos os caracteres com um valor de caractere maior que 127 converte a representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">A cadeia de caracteres a ser escapada.</param>
        <summary>Converte uma cadeia de caracteres de URI para sua representação de escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Uri.EscapeUriString%2A> método para preparar uma cadeia de caracteres URI sem escape seja um parâmetro para o <xref:System.Uri.%23ctor%2A> construtor.  
  
 Por padrão, o <xref:System.Uri.EscapeUriString%2A> método converte todos os caracteres, exceto RFC 2396 não reservados caracteres em sua representação hexadecimal. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.EscapeUriString%2A> método converte todos os caracteres, exceto pelo RFC 3986 caracteres não reservados, em sua representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Este método assume que `stringToEscape` não exibe nenhuma sequência de escape.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987. Consulte esses RFCs para uma definição dos caracteres reservado e não reservado.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O tamanho de <paramref name="stringToEscape" /> excede 32766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o fragmento de URI de escape.</summary>
        <value>Um <see cref="T:System.String" /> que contém informações de fragmento do URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Fragment%2A> propriedade obtém qualquer texto após um marcador de fragmento (#) no URI, incluindo o marcador de fragmento em si. Considerando http://www.contoso.com/index.htm#main URI, o <xref:System.Uri.Fragment%2A> propriedade retornaria #main.  
  
 O <xref:System.Uri.Fragment%2A> propriedade não é considerada em qualquer <xref:System.Uri.Equals%2A> comparação.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava as informações de fragmento no console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Os dígitos hexadecimais (0-9, a-f, A-F) a serem convertidos.</param>
        <summary>Obtém o valor decimal de um dígito hexadecimal.</summary>
        <returns>Um <see cref="T:System.Int32" /> valor que contém um número de 0 a 15 correspondente para o dígito hexadecimal especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.FromHex%2A> método converte um caractere que representa um dígito hexadecimal (0-9, a-f, A-F) para seu valor decimal (0 a 15). Se `digit` não é um dígito hexadecimal válido, um <xref:System.ArgumentException> exceção será lançada.  
  
   
  
## Examples  
 O exemplo a seguir determina se um caractere é um caractere hexadecimal e, se for, grava o valor decimal correspondente para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> não é um dígito hexadecimal válido (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Uma combinação bit a bit dos valores <see cref="T:System.UriComponents" /> que especificam quais partes da instância atual a se retornar para o chamador.</param>
        <param name="format">Um dos valores <see cref="T:System.UriFormat" /> que controlam como escapar caracteres especiais.</param>
        <summary>Obtém os componentes especificados da instância atual usando o escape especificado para caracteres especiais.</summary>
        <returns>Um <see cref="T:System.String" /> que contém os componentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, e <xref:System.UriComponents.Path> componentes não incluem o delimitador. Você pode combinar o <xref:System.UriComponents.KeepDelimiter> sinalizador (usando o operador OR bit a bit) com qualquer um desses valores para obter o valor com o delimitador. Para todos os outros <xref:System.UriComponents> valores e combinações de valores, os delimitadores são incluídos no valor retornado.  
  
 Os componentes são retornados na ordem em que aparecem no URI. Por exemplo, se <xref:System.UriComponents.Scheme> for especificado, ele aparece primeiro.  
  
 Quando o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) estiverem habilitadas, o número de caracteres retornados no <xref:System.String> aumenta. Nomes de Punycode usados para dar suporte a IRI contenham apenas caracteres ASCII e sempre começam com o prefixo xn-. Quando IRI e IDN estiverem habilitadas, os caracteres substitutos de Unicode são tratados corretamente pelo <xref:System.Uri.GetComponents%2A> método.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
> [!NOTE]
>  Se o <xref:System.Uri.GetComponents%2A> método for chamado com `format` definida como <xref:System.UriFormat.Unescaped> , você não pode usar o valor de retorno como um argumento para um <xref:System.Uri.%23ctor%2A> construtor para criar um equivalente <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> não é uma combinação de valores <see cref="T:System.UriComponents" /> válidos.</exception>
        <exception cref="T:System.InvalidOperationException">Atual <see cref="T:System.Uri" /> não é um URI absoluto. Não é possível usar os URIs relativos com este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o código hash para o URI.</summary>
        <returns>Um <see cref="T:System.Int32" /> que contém o valor de hash gerado para este URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o código hash para o console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Um dos valores de <see cref="T:System.UriPartial" /> que especifica o fim da parte do URI a ser retornada.</param>
        <summary>Obtém a parte especificada de uma instância de <see cref="T:System.Uri" />.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a parte especificada da <see cref="T:System.Uri" /> instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.GetLeftPart%2A> método retorna uma cadeia de caracteres que contém a parte mais à esquerda da cadeia de caracteres URI, terminando com a parte especificada pelo `part`.  
  
 <xref:System.Uri.GetLeftPart%2A>inclui delimitadores nos seguintes casos:  
  
-   <xref:System.UriPartial.Scheme>inclui o delimitador de esquema.  
  
-   <xref:System.UriPartial.Authority>não inclui o delimitador de caminho.  
  
-   <xref:System.UriPartial.Path>inclui qualquer delimitadores no URI original até o delimitador de consulta ou fragmento.  
  
-   <xref:System.UriPartial.Query>inclui o <xref:System.UriPartial.Path>, a consulta e o delimitador.  
  
 Os exemplos a seguir mostram um URI e os resultados da chamada <xref:System.Uri.GetLeftPart%2A> com <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, ou <xref:System.UriPartial.Query>.  
  
|URI|Esquema|Autoridade|Caminho|Consulta|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?Date=Today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?Date=Today|  
|http://www.contoso.com/index.htm#Main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com? subject = uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com? subject = uri|\<Nenhum >|  
|nntp://news.contoso.com/123456@contoso.com|NNTP: / /|NNTP://News.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|notícias:|news:123456@contoso.com|news:123456@contoso.com|\<Nenhum >|  
|file://Server/filename.ext|file://|file://Server|file://Server/filename.ext|file://Server/filename.ext|  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o caminho para o console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A atual instância de <see cref="T:System.Uri" /> não é uma instância absoluta.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="part" /> especificado não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Uri" />.</param>
        <summary>Retorna os dados necessários para serializar a instância atual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar os métodos de serialização. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O caractere para converter a representação hexadecimal.</param>
        <summary>Converte um caractere especificado em seu equivalente hexadecimal.</summary>
        <returns>A representação hexadecimal do caractere especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um caractere para seu equivalente hexadecimal e grava-o para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> é maior que 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">A representação hexadecimal de um caractere.</param>
        <param name="index">O local na <c>padrão</c> onde começa a representação hexadecimal de um caractere.</param>
        <summary>Converte uma representação hexadecimal especificada de um caractere no caractere.</summary>
        <returns>O caractere representado pela codificação hexadecimal na posição <paramref name="index" />. Se o caractere no <paramref name="index" /> não for codificado em hexadecimal, o caractere no <paramref name="index" /> será retornado. O valor de <paramref name="index" /> é incrementado para apontar para o caractere seguinte ao retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O exemplo de código a seguir determina se é um caractere hexadecimal codificado e, nesse caso, grava o caractere equivalente para o console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0 ou maior ou igual ao número de caracteres em <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o componente de host desta instância.</summary>
        <value>Um <see cref="T:System.String" /> que contém o nome do host. Isso geralmente é o nome de host DNS ou endereço IP do servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao contrário do <xref:System.Uri.Authority%2A> propriedade, o valor da propriedade não inclui o número da porta.  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do host (www.contoso.com) do servidor no console.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do nome de host especificado no URI.</summary>
        <value>Membro de <see cref="T:System.UriHostNameType" /> enumeração.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e grava o <xref:System.Uri.HostNameType%2A> para o console.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>O Nome de Domínio Internacional do host em conformidade com RFC 3490 usando Punycode conforme apropriado. Essa cadeia de caracteres depois sendo sem escape se necessário, é segura usar resolução de DNS.</summary>
        <value>Retorna o nome do host, formatado com Punycode de acordo com o padrão IDN<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida para o uso de protocolos de rede de nível inferior que exigem o nome de domínio no formato Punycode. Se seu código não precisar desse formato específico, use <xref:System.Uri.Host%2A> para o nome do host.  
  
 Preterido <xref:System.Uri.DnsSafeHost%2A> propriedade é dependente de *App. config* configurações, que não podem ser alteradas por aplicativos da Windows Store. IdnHost é fornecido como uma alternativa ao uso preferencial <xref:System.Uri.DnsSafeHost%2A>, pois <xref:System.Uri.IdnHost%2A> é garantido para ser sempre DNS seguro, não importa qual atual *App. config* configurações podem ser.  

 Se você usou uma cadeia de caracteres de escape para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), IdnHost, em seguida, retorna uma cadeia de caracteres de escape. Você deve unescape qualquer cadeia de caracteres de escape retornada de IdnHost antes de usar essa cadeia de caracteres para a resolução DNS. Lembre-se que, se você usou uma cadeia de caracteres de escape inválida para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm") e, em seguida, IdnHost retorna uma cadeia de caracteres de escape.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se o <see cref="T:System.Uri" /> instância é absoluta.</summary>
        <value>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o <see cref="T:System.Uri" /> instância é absoluto; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é `true` se a cadeia de caracteres ou <xref:System.Uri> instância que foi passada para o construtor pode ser analisada como um absoluto <xref:System.Uri> instância, que contém um esquema, uma autoridade e um caminho. Caso contrário, o <xref:System.Uri> instância é tratada como relativa e pode omitir o esquema ou outros componentes do URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Determina se um caractere é inválido em um nome de sistema de arquivos.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o caractere especificado é inválido; caso contrário <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caractere é analisado de acordo com as regras para o sistema de arquivos NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">A instância <see cref="T:System.Uri" /> especificada a ser testada.</param>
        <summary>Determina se a instância <see cref="T:System.Uri" /> atual é uma base da instância <see cref="T:System.Uri" /> especificada.</summary>
        <returns>
          <see langword="true" /> se a instância <see cref="T:System.Uri" /> atual é uma base da <paramref name="uri" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A>é usado para comparar atual <xref:System.Uri> instância especificada <xref:System.Uri> para determinar se esse URI é uma base especificado <xref:System.Uri>. Ao comparar dois <xref:System.Uri> objetos para determinar uma relação de base, as informações do usuário (<xref:System.Uri.UserInfo%2A>) não será avaliada. Ao comparar dois URIs (uri1 e uri2), uri1 é a base de uri2 se, quando você ignorar tudo no uri2 após a última barra (/), os dois URIs são idênticos. Usando http://host/path/path/file?query como o URI de base, a tabela a seguir mostra se ele é uma base para outros URIs.  
  
|URI|http://host/Path/Path/File?Query é a base de|  
|---------|------------------------------------------------------|  
|http://host/Path/Path/File/|sim|  
|http://host/Path/Path/#Fragment|sim|  
|http://host/Path/Path/MoreDir/"|sim|  
|http://host/Path/Path/OtherFile?Query|sim|  
|http://host/Path/Path/|sim|  
|http://host/Path/Path/File|sim|  
|http://host/Path/Path|no|  
|http://host/Path/Path?Query|no|  
|http://host/Path/Path#Fragment|no|  
|http://host/Path/path2/|no|  
: //host/path/path2/MoreDir|no|  
|http://host/Path/File|no|  
  
   
  
## Examples  
 Este exemplo cria um <xref:System.Uri> instância que representa uma base <xref:System.Uri> instância. Em seguida, cria um segundo <xref:System.Uri> instância de uma cadeia de caracteres. Ele chama <xref:System.Uri.IsBaseOf%2A> para determinar se a instância de base é a base da segunda instância. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o valor da porta do URI é o padrão para este esquema.</summary>
        <value>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o valor de <see cref="P:System.Uri.Port" /> propriedade é o padrão porta para este esquema; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e verifica se ele usa a porta padrão.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Obtém se o caractere especificado deve ser substituído.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o caractere especificado deve ser de escape; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Uri" /> especificado é um URI de arquivo.</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se o <see cref="T:System.Uri" /> é um URI de arquivo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsFile%2A> é de propriedade `true` quando o <xref:System.Uri.Scheme%2A> propriedade é igual a <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele é um URI de arquivo.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O caractere a ser validado.</param>
        <summary>Determina se um caractere especificado é um dígito hexadecimal válido.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" />, se o caractere for um dígito hexadecimal válido, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dígitos hexadecimais são os dígitos 0 a 9 e as letras A-F ou a-f.  
  
   
  
## Examples  
 O exemplo a seguir determina se um caractere é um caractere hexadecimal e, se for, grava o valor decimal correspondente para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">A cadeia de caracteres a ser verificada.</param>
        <param name="index">O local na <c>padrão</c> para verificar a codificação hexadecimal.</param>
        <summary>Determina se um caractere em uma cadeia de caracteres é hexadecimal codificado.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se <paramref name="pattern" /> é hexadecimal codificada no local especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsHexEncoding%2A> método verifica para codificação hexadecimal que segue o padrão "% hexhex" em uma cadeia de caracteres, onde "hexadecimal" é um dígito de 0 a 9 ou uma letra de A-F (diferencia maiusculas de minúsculas).  
  
   
  
## Examples  
 O exemplo de código a seguir determina se é um caractere hexadecimal codificado e, nesse caso, grava o caractere equivalente para o console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se o <see cref="T:System.Uri" /> especificado faz referência ao host local.</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" />, se esse <see cref="T:System.Uri" /> fizer referência ao host local; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A>Retorna `true` se o URI especificado quando esta instância foi criada foi loopback, 127.0.0.1 ou localhost, ou se o URI não especificou hospeda informações (por exemplo, file:///c:Dir/file.txt). Todos os outros retorno URIs `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele faz referência a um host local.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Determina se o caractere especificado é um caractere reservado.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o caractere especificado é um caractere reservado caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica se o <see cref="T:System.Uri" /> especificado é um caminho UNC (Convenção de Nomenclatura Universal).</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se <see cref="T:System.Uri" /> for um caminho UNC; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsUnc%2A> é de propriedade `true` se especificado <xref:System.Uri> instância é um caminho UNC (como \\\server\folder ou file://server/folder). Essa propriedade sempre retorna `true` se o URI com o esquema file:// e especifica um componente do host.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele é um caminho UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se a cadeia de caracteres usada para construir essa <see cref="T:System.Uri" /> foi bem formada e não é necessário realizar o escape adicional.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se a cadeia de caracteres foi bem formada, caso contrário <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres é considerada bem formado de acordo com RFC 2396 e RFC 2732 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é considerada bem formado de acordo com RFC 3986 e RFC 3987  
  
 A cadeia de caracteres é considerada mal formada, fazendo com que o método retornar falso, se ocorrer qualquer uma das condições a seguir.  
  
|Erro|Exemplo|  
|-----------|-------------|  
|A cadeia de caracteres não tem escape definida corretamente.|[http://www.contoso.com/Path???/File](http://www.contoso.com/path???/file) nome|  
|A cadeia de caracteres é um absoluto <xref:System.Uri> que representa um arquivo implícita <xref:System.Uri>.|c:\\\directory\filename|  
|A cadeia de caracteres é um URI absoluto que não tem uma barra antes do caminho.|file://c:/Directory/filename|  
|A cadeia de caracteres contém barras invertidas de escape, mesmo se eles são tratados como barras.|http:\\\host/path/file|  
|A cadeia de caracteres representa um absoluto hierárquico <xref:System.Uri> e não contêm "://".|www.contoso.com/Path/File|  
|O analisador para o <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indica que a cadeia de caracteres original não foi bem formada.|O exemplo depende do esquema do URI.|  
  
 Por padrão, a cadeia de caracteres usado para construir esse <xref:System.Uri> são considerados bem formados no acordo com RFC 2396 e RFC 2732.  
  
 Quando o identificador de recurso internacional (IRI) e suporte de nome de domínio internacionalizado (IDN) estão habilitadas, a cadeia de caracteres usado para construir esse <xref:System.Uri> são considerados bem formados no acordo com RFC 3986 e RFC 3987. Nomes de Punycode usados para dar suporte a IRI contenham apenas caracteres ASCII e sempre começam com o prefixo xn-.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">A cadeia de caracteres usada na tentativa de construir um <see cref="T:System.Uri" />.</param>
        <param name="uriKind">O tipo do <see cref="T:System.Uri" /> na <c>uriString</c>.</param>
        <summary>Indica se a cadeia de caracteres é bem formada pela tentativa de construir um URI com a cadeia de caracteres e garante que a cadeia de caracteres não requer mais de escape.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se a cadeia de caracteres foi bem formada, caso contrário <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nas versões do .NET anteriores à versão 4.5, por padrão a cadeia de caracteres é considerada válido de acordo com RFC 2396 e RFC 2732. Se os identificadores de recurso (íris) ou o nome de domínio internacionalizado (IDN) de análise é habilitado, a cadeia de caracteres é considerada válido de acordo com RFC 3986 e RFC 3987.  
  
 A partir do .NET 4.5, cadeias de caracteres são sempre consideradas bem formados no acordo com RFC 3986 e RFC 3987, ou não IRI ou IDN estão habilitados. No entanto, observe que isso só é verdadeiro para aplicativos de destino .NET 4.5 ou posterior. Aplicativos que se destinam a .NET 4.0 invocar código de compatibilidade e o antigo comportamento de (pre-4.5).  
  
 A cadeia de caracteres é considerada mal formada, fazendo com que o método retornar falso, se ocorrer qualquer uma das condições a seguir  
  
|Erro|Exemplo|  
|-----------|-------------|  
|A cadeia de caracteres não tem escape definida corretamente.|[http://www.contoso.com/Path???/File](http://www.contoso.com/path???/file) nome|  
|A cadeia de caracteres é um absoluto <xref:System.Uri> que representa um arquivo implícita <xref:System.Uri>.|c:\\\directory\filename|  
|A cadeia de caracteres é um URI absoluto que não tem uma barra antes do caminho.|file://c:/Directory/filename|  
|A cadeia de caracteres contém barras invertidas de escape, mesmo se eles serão tratados como barras|http:\\\host/path/file|  
|A cadeia de caracteres representa um absoluto hierárquico <xref:System.Uri> e não contêm "://"|www.contoso.com/Path/File|  
|O analisador para o <xref:System.Uri.Scheme%2A> indica que a cadeia de caracteres original não foi bem formada.|O exemplo depende do esquema do URI.|  
|Começando com o .NET 4.5, relativo a URIs com dois-pontos (': ') no seu primeiro segmento não são considerados bem formado.|2013.05.29_14:33:41|  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma representação local do sistema operacional de um nome de arquivo.</summary>
        <value>Uma <see cref="T:System.String" /> que contém uma representação do sistema operacional de um nome de arquivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade é sem escape. Se o caminho é reconhecido como um caminho de arquivo do Windows, todas as barras (/) são substituídas por invertidas (\\).  
  
 Para o URI `file://computer/file.ext`, o caminho absoluto é `/file.ext` e o caminho local é `\\computer\file.ext`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o caminho local para o console.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">O URI a ser comparado com o URI atual.</param>
        <summary>Determina a diferença entre duas instâncias <see cref="T:System.Uri" />.</summary>
        <returns>Se o nome de host e o esquema dessa instância do URI e <paramref name="toUri" /> forem os mesmos, esse método retornará um <see cref="T:System.String" /> representando um URI relativo que, quando for anexado à instância atual do URI, gerará o parâmetro <paramref name="toUri" />.  
  
 Se o nome do host ou o esquema for diferente, esse método retornará um <see cref="T:System.String" /> que representa o parâmetro <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra a instância do URI, `toUri`e os resultados da chamada <xref:System.Uri.MakeRelative%2A>.  
  
|Instância atual do URI|`toUri`|Valor retornado|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/Test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000 /|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/Test1/Test1.txt|Test1/test1.txt|  
  
 Informações do usuário, se presente no URI, serão ignoradas.  
  
   
  
## Examples  
 O exemplo a seguir cria 2 <xref:System.Uri> instâncias. A diferença nas informações de caminho é gravada no console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Essa instância representa um URI relativo e esse método é válido apenas para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">O URI a ser comparado com o URI atual.</param>
        <summary>Determina a diferença entre duas instâncias <see cref="T:System.Uri" />.</summary>
        <returns>Se o nome de host e o esquema dessa instância do URI e <paramref name="uri" /> forem os mesmos, esse método retornará um <see cref="T:System.Uri" /> relativo que, quando for anexado à instância atual do URI, gerará <paramref name="uri" />.  
  
 Se o nome do host ou o esquema for diferente, esse método retornará um <see cref="T:System.Uri" /> que representa o parâmetro <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra a instância do URI, `toUri`e os resultados da chamada <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Instância atual do URI|`toUri`|Valor retornado|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/Test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000 /|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/Test1/Test1.txt|Test1/test1.txt|  
  
 Informações do usuário, se presente no URI, serão ignoradas.  
  
   
  
## Examples  
 O exemplo a seguir cria 2 <xref:System.Uri> instâncias. A diferença nas informações de caminho é gravada no console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Um <see cref="T:System.Uri" /> instância a ser comparado com <c>uri2</c>.</param>
        <param name="uri2">Um <see cref="T:System.Uri" /> instância a ser comparado com <c>uri1</c>.</param>
        <summary>Determina se duas instâncias <see cref="T:System.Uri" /> têm o mesmo valor.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se as instâncias <see cref="T:System.Uri" /> forem equivalentes; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga usa o <xref:System.Uri.Equals%2A> método para determinar se os dois <xref:System.Uri> instâncias forem equivalentes. <xref:System.Uri.UserInfo%2A>e <xref:System.Uri.Fragment%2A> conteúdo será ignorado ao fazer essa comparação.  
  
   
  
## Examples  
 Este exemplo cria três <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `Address1`e `Address2` são os mesmos, pois o <xref:System.Uri.Fragment%2A> parte é ignorada para essa comparação. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Um <see cref="T:System.Uri" /> instância a ser comparado com <c>uri2</c>.</param>
        <param name="uri2">Um <see cref="T:System.Uri" /> instância a ser comparado com <c>uri1</c>.</param>
        <summary>Determina se dois <see cref="T:System.Uri" /> instâncias não tiverem o mesmo valor.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se os dois <see cref="T:System.Uri" /> instâncias não forem iguais; caso contrário, <see langword="false" />. Se o parâmetro for <see langword="null" />, esse método retornará <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga usa o <xref:System.Uri.Equals%2A> método para determinar se os dois <xref:System.Uri> instâncias não são equivalentes. <xref:System.Uri.UserInfo%2A>e <xref:System.Uri.Fragment%2A> conteúdo será ignorado ao fazer essa comparação.  
  
   
  
## Examples  
 Este exemplo cria três <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `Address2`e `Address3` não são iguais porque `Address3` contém um <xref:System.Uri.Query%2A> que não foi encontrado no `Address2`. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a cadeia de caracteres do URI original que foi passada para o construtor <see cref="T:System.Uri" />.</summary>
        <value>Um <see cref="T:System.String" /> que contém o URI exato especificado quando esta instância foi construída; caso contrário, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o URI especificado para o construtor contiver espaços à direita ou, esses espaços são preservados.  
  
 O valor retornado por essa propriedade é diferente do <xref:System.Uri.ToString%2A> e <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A>Retorna o formulário canonicamente sem escape do URI. <xref:System.Uri.AbsoluteUri%2A>Retorna o formulário canonicamente com caracteres de escape do URI.  
  
 Quando o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) estiverem habilitadas, <xref:System.Uri.OriginalString%2A> retorna a cadeia de caracteres não normalizada original com o nome de host Punycode se estava sendo usado para inicializar o <xref:System.Uri> instância. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 Quando um <xref:System.Uri> o objeto é serializado, o <xref:System.Uri.OriginalString%2A> não é preservada. O processo de serialização usa o totalmente com caracteres de escape e a conversão em formato canônico <xref:System.Uri.AbsoluteUri%2A> propriedade ao serializar. Para uma <xref:System.Uri> que contém um endereço IPv6, o endereço IPv6 e a identificação de escopo são incluídos na serializada <xref:System.Uri> objeto.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.OriginalString%2A>, que retorna a cadeia de caracteres que foi passada para o construtor e de uma chamada para <xref:System.Uri.ToString%2A>, que retorna a forma canônica da cadeia de caracteres.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analisa o URI da instância atual para garantir que contenha todas as partes necessárias para um URI válido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">O URI passado do construtor é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as propriedades <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separadas por um ponto de interrogação (?).</summary>
        <value>Um <see cref="T:System.String" /> que contém as propriedades <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separadas por um ponto de interrogação (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.PathAndQuery%2A> propriedade contém o caminho absoluto no servidor e as informações de consulta enviada com a solicitação. Ele é idêntico ao concatenar a <xref:System.Uri.AbsolutePath%2A> e <xref:System.Uri.Query%2A> propriedades.  
  
 O <xref:System.Uri.PathAndQuery%2A> propriedade é escapada de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.PathAndQuery%2A> propriedade é escapada de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir grava o caminho URI (/ catalog/shownew.htm) e a consulta (Data = hoje) informações para o console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número da porta desse URI.</summary>
        <value>Um valor <see cref="T:System.Int32" /> que contém o número da porta para esse URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número da porta define a porta do protocolo usada para contatar o servidor referenciado no URI. Se uma porta não for especificada como parte do URI de <xref:System.Uri.Port%2A> propriedade retorna o valor padrão para o protocolo. Se não houver nenhum número de porta padrão, essa propriedade retornará -1.  
  
   
  
## Examples  
 O exemplo a seguir grava o número de porta URI para o console. Nesse caso, o valor é o número de porta padrão para HTTP, a porta 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações de consulta incluídas no URI especificado.</summary>
        <value>Um <see cref="T:System.String" /> que contém quaisquer informações de consulta incluídas no URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Query%2A> propriedade contém informações de consulta incluídas no URI. Informações de consulta são separadas das informações de caminho por um ponto de interrogação (?) e continua até o final do URI. As informações de consulta retornadas incluem o principal ponto de interrogação.  
  
 As informações de consulta são escapadas de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, as informações de consulta são escapadas de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir grava a consulta? data = hoje no console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do esquema para esse URI.</summary>
        <value>Um <see cref="T:System.String" /> que contém o esquema para este URI, convertido em minúsculas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Scheme%2A> propriedade retorna o esquema usado para inicializar o <xref:System.Uri> instância. Essa propriedade não indica que o esquema usado para inicializar o <xref:System.Uri> instância foi reconhecida.  
  
 A tabela a seguir mostra exemplos de algumas possíveis valores retornados pelo <xref:System.Uri.Scheme%2A> propriedade.  
  
|Esquema|Descrição|  
|------------|-----------------|  
|Arquivo |O recurso é um arquivo no computador local.|  
|FTP|O recurso é acessado por meio de FTP.|  
|gopher|O recurso é acessado por meio do protocolo de Gopher.|  
|HTTP|O recurso é acessado por meio de HTTP.|  
|HTTPS|O recurso é acessado por meio de HTTP criptografada por SSL.|  
|LDAP|O recurso é acessado por meio do protocolo LDAP.|  
|mailto|O recurso é um endereço de email e acessados por meio do protocolo SMTP.|  
|net.pipe|O recurso é acessado por meio de um pipe nomeado.|  
|net.tcp|O recurso é acessado de ponto de extremidade TCP.|  
|notícias|O recurso é acessado por meio do protocolo NNTP.|  
|NNTP|O recurso é acessado por meio do protocolo NNTP.|  
|telnet|O recurso é acessado por meio do protocolo TELNET.|  
|uuid|O recurso é acessado por meio de um nome de ponto de extremidade UUID exclusivo para se comunicar com um serviço.|  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do esquema (http) para o console para o URI http://www.contoso.com/.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica os caracteres que separam o esquema de protocolo de comunicação da parte do endereço do URI. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma cadeia de caracteres de <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>e um endereço. Um <xref:System.Uri> instância é então criada usando a cadeia de caracteres.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma matriz contendo os segmentos de caminho que compõem o URI especificado.</summary>
        <value>Uma matriz de <see cref="T:System.String" /> contendo os segmentos de caminho que compõem o URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Segments%2A> propriedade retorna uma matriz de cadeias de caracteres que contém os "segmentos" (subcadeias de caracteres) que formam o caminho absoluto do URI. O primeiro segmento é obtido ao analisar o caminho absoluto do seu primeiro caractere até alcançar uma barra (/) ou no final do caminho. Cada segmento adicional começa no primeiro caractere após o segmento anterior e termina com a próxima barra ou o final do caminho. (Caminho absoluto do URI contém tudo após o host e a porta e antes da consulta e o fragmento).  
  
 O exemplo a seguir mostra o caminho absoluto e segmentos para dois URIs. O segundo exemplo ilustra que o fragmento e a consulta não fazem parte do caminho absoluto e, portanto, não são segmentos.  
  
 URI absoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Caminho absoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 URI absoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#Page1?Answer=no  
  
 Caminho absoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Observe que, como o caminho absoluto inicia com um '/', o primeiro segmento contém e nada mais.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância com 3 segmentos e exibe os segmentos na tela.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Uri" />.</param>
        <summary>Retorna os dados necessários para serializar a instância atual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar os métodos de serialização. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma representação de cadeia de caracteres canônica para a instância <see cref="T:System.Uri" /> especificada.</summary>
        <returns>Uma instância <see cref="T:System.String" /> que contém a representação canônica sem escape da instância <see cref="T:System.Uri" />. Todos os caracteres são sem escape exceto #,? e %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres retornada por este método não contém informações de porta quando a porta é a porta padrão para o esquema.  
  
> [!NOTE]
>  A cadeia de caracteres retornada pelo <xref:System.Uri.ToString%2A> método pode conter caracteres de controle, que podem corromper o estado de um aplicativo de console. Você pode usar o <xref:System.Uri.GetComponents%2A> método com o <xref:System.UriFormat?displayProperty=nameWithType> formato remover caracteres de controle de cadeia de caracteres retornada.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.OriginalString%2A>, que retorna a cadeia de caracteres que foi passada para o construtor e de uma chamada para <xref:System.Uri.ToString%2A>, que retorna a forma canônica da cadeia de caracteres.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para impedir que o código parcialmente confiável derivando de <see cref="T:System.Uri" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">O <see cref="T:System.String" /> que representa o <see cref="T:System.Uri" />.</param>
        <param name="uriKind">O tipo do Uri.</param>
        <param name="result">Quando este método retorna, contém o construído <see cref="T:System.Uri" />.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a instância <see cref="T:System.String" /> especificada e um <see cref="T:System.UriKind" />.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">O <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">O <see cref="T:System.Uri" /> relativo, representado como um <see cref="T:System.String" />, a ser adicionado ao <see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Uri" /> construído a partir de <c>baseUri</c> e <c>Uri_relativo</c>. Este parâmetro é passado não inicializado.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a base especificada e as instâncias de <see cref="T:System.String" /> relativas.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">O <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">O <see cref="T:System.Uri" /> relativo a ser adicionado ao <see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Uri" /> construído a partir de <c>baseUri</c> e <c>Uri_relativo</c>. Este parâmetro é passado não inicializado.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a base especificada e as instâncias de <see cref="T:System.Uri" /> relativas.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 Esse método constrói o URI, coloca na forma canônica e valida. Se ocorrer uma exceção sem tratamento, esse método captura a ele. Se você quiser criar um <xref:System.Uri> e get exceções usam uma da <xref:System.Uri.%23ctor%2A> construtores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O <see cref="T:System.String" /> a ser convertido.</param>
        <summary>Converte a cadeia de caracteres especificada substituindo as sequências de escape por sua representação sem escape.</summary>
        <returns>A <see cref="T:System.String" /> que contém o valor sem escape do parâmetro <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">A cadeia de caracteres para desfazer o escape.</param>
        <summary>Converte uma cadeia de caracteres em sua representação sem escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação sem escape de <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve usar esse método com cuidado. Unescaping uma cadeia de caracteres que tenha sido anteriormente sem escape pode resultar em ambiguidades e erros.  
  
 Muitos navegadores da Web de escape espaços dentro de URIs em adição caracteres ("+"); No entanto, o método UnescapeDataString não converte mais caracteres em espaços porque esse comportamento não seja padrão entre todos os esquemas URI.  
  
   
  
## Examples  
 O exemplo de código a seguir unescapes um URI e, em seguida, converte qualquer além de caracteres ("+") em espaços.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um ponteiro para um arquivo. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No .NET Framework versão 1.1, um "`file:///path`"URI foi convertido em"`file:/path`". Isso foi corrigido para a versão 2.0.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo FTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo de Gopher. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo HTTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio de HTTPS (Secure Hypertext Transfer Protocol). Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um endereço de email e é acessado por meio do protocolo SMTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do esquema de NetPipe usado pelo Windows Communication Foundation (WCF). Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do esquema de NetTcp usado pelo Windows Communication Foundation (WCF). Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um grupo de notícias da Internet e é acessado por meio do transporte de protocolo NNTP (Network News). Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um grupo de notícias da Internet e é acessado por meio do transporte de protocolo NNTP (Network News). Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NNTP <xref:System.Uri> analisar erros no .NET Framework versão 1.1 foram corrigidos.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que a cadeia de caracteres do URI sofreu escape completo antes que a instância de <see cref="T:System.Uri" /> fosse criada.</summary>
        <value>Um valor de <see cref="T:System.Boolean" /> que é <see langword="true" /> se o parâmetro <paramref name="dontEscape" /> tiver sido definido como <see langword="true" /> quando a instância de <see cref="T:System.Uri" /> foi criada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.UserEscaped%2A> está definida como `true` para indicar que a cadeia de caracteres usada para criar o <xref:System.Uri> instância foi totalmente escape antes que foi transmitido ao construtor, ou seja, o `dontEscape` parâmetro da chamada de construtor foi definido como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele foi totalmente escape quando ele foi criado.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de usuário, a senha ou outras informações específicas do usuário associado com o URI especificado.</summary>
        <value>Um <see cref="T:System.String" /> que contém as informações de usuário associadas ao URI. O valor retornado não inclui o ' @' caractere reservado para a parte de informações de usuário do URI de delimitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade é geralmente no formato "nome_de_usuário".  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava as informações do usuário do console.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
