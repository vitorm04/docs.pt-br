<Type Name="Console" FullName="System.Console">
  <TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa os fluxos de entrada, saída e erro padrão para aplicativos de console. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/console.cs#f907d79481da6ba4). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 O console é uma janela do sistema operacional em que os usuários interagem com o sistema operacional ou com um aplicativo de console com base em texto, texto de entrada do teclado do computador e lendo a saída de texto de terminal do computador. Por exemplo, no sistema operacional Windows, o console é chamado de janela de Prompt de comando e aceita comandos do MS-DOS. O <xref:System.Console> classe fornece suporte básico para aplicativos que ler caracteres de e escrever caracteres para o console.  
  
 Para obter informações sobre o desenvolvimento com o <xref:System.Console> de classe, consulte as seções a seguir:  
  
-   [Fluxos de e/s do console](#Streams)  
  
-   [Buffer da tela e a janela do Console](#Buffer)  
  
-   [Suporte a Unicode para o Console do](#Unicode)  
  
-   [Operações comuns](#Operations)  
  
-   [Notas de núcleo do .NET](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Fluxos de E/S de console  
 Quando um aplicativo de console é iniciado, o sistema operacional associa automaticamente três fluxos de e/s com o console: fluxo, o fluxo de saída padrão e o fluxo de saída de erro padrão de entrada padrão. Seu aplicativo pode ler a entrada do usuário do fluxo de entrada padrão; grava dados normais para o fluxo de saída padrão; e gravar dados de erro para o fluxo de saída de erro padrão. Esses fluxos são apresentados ao seu aplicativo, como os valores de <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, e <xref:System.Console.Error%2A?displayProperty=nameWithType> propriedades.  
  
 Por padrão, o valor da <xref:System.Console.In%2A> propriedade é um <xref:System.IO.TextReader?displayProperty=nameWithType> objeto que representa o teclado e os valores da <xref:System.Console.Out%2A> e <xref:System.Console.Error%2A> propriedades são <xref:System.IO.TextWriter?displayProperty=nameWithType> objetos que representam uma janela do console. No entanto, você pode definir essas propriedades em fluxos que não representam a janela de console ou o teclado; Por exemplo, você pode definir essas propriedades em fluxos que representam arquivos. Para redirecionar a entrada padrão, a saída padrão ou o fluxo de erro padrão, chame o <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, ou <xref:System.Console.SetError%2A?displayProperty=nameWithType> método, respectivamente. Operações de e/s que usam esses fluxos são sincronizadas, o que significa que vários threads podem ler ou gravar os fluxos. Isso significa que os métodos que são normalmente assíncronos, como <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, execute sincronia se o objeto que representa um fluxo de console.  
  
> [!NOTE]
>  Não use o <xref:System.Console> classe para exibir a saída em aplicativos autônomos, como aplicativos de servidor. Chamadas para métodos como <xref:System.Console.Write%2A?displayProperty=nameWithType> e <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> não têm nenhum efeito em aplicativos de interface gráfica do usuário.  
  
 <xref:System.Console>membros de classe que funcionam normalmente quando o fluxo subjacente é direcionado a um console podem lançar uma exceção se o fluxo é redirecionado, por exemplo, para um arquivo. Programa seu aplicativo para capturar <xref:System.IO.IOException?displayProperty=nameWithType> exceções se você redirecionar um fluxo padrão. Você também pode usar o <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, e <xref:System.Console.IsErrorRedirected%2A> propriedades para determinar se um fluxo padrão é redirecionado antes de executar uma operação que gera um <xref:System.IO.IOException?displayProperty=nameWithType> exceção.  
  
 Às vezes é útil chamar explicitamente os membros dos objetos de fluxo representados pelo <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, e <xref:System.Console.Error%2A> propriedades. Por exemplo, por padrão, o <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método lê a entrada do fluxo de entrada padrão. Da mesma forma, o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> método grava dados no fluxo de saída padrão e os dados são seguidos a sequência de terminação de linha padrão, que é um retorno de carro e alimentação de linha ("\r\n"). No entanto, a <xref:System.Console> classe não fornece um método correspondente para gravar dados no fluxo de saída de erro padrão ou uma propriedade para alterar a cadeia de caracteres de terminação de linha para os dados gravados nesse fluxo.  
  
 Você pode resolver esse problema definindo o <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriedade do <xref:System.Console.Out%2A> ou <xref:System.Console.Error%2A> propriedade para outra cadeia de caracteres de terminação de linha. Por exemplo, a instrução c# a seguir define a cadeia de caracteres de terminação de linha para o fluxo de saída de erro padrão para dois retorno de carro e alimentação de sequências de linha:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Você pode chamar explicitamente o <xref:System.IO.TextWriter.WriteLine%2A> método do objeto de fluxo de saída de erro, como a instrução c# a seguir:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Buffer de tela e janela do console  
 Dois recursos relacionados do console são buffer da tela e a janela do console. Texto é realmente ler ou gravado em fluxos de propriedade do console, mas parece ser lido ou gravado para uma área de console chamado buffer da tela. Buffer da tela é um atributo do console e é organizado como uma grade retangular de linhas e colunas em que cada interseção de grade ou célula de caracteres pode conter um caractere. Cada caractere tem sua própria cor de primeiro plano, e cada célula de caractere tem sua própria cor de plano de fundo.  
  
 Buffer da tela é exibido por meio de uma região retangular chamada a janela do console. A janela do console é outro atributo do console; não é o console em si, que é uma janela do sistema operacional. A janela do console é organizada em linhas e colunas, é menor ou igual ao tamanho do buffer da tela e pode ser movida para exibir diferentes áreas do buffer da tela subjacente. Se o buffer da tela é maior que a janela de console, o console exibe automaticamente as barras de rolagem para a janela do console pode ser reposicionada sobre a área de buffer da tela.  
  
 Um cursor indica a posição do buffer da tela em que o texto no momento é lida ou gravado. O cursor pode ser ocultado ou visíveis, e sua altura pode ser alterada. Se o cursor estiver visível, a posição da janela de console será movida automaticamente para que o cursor está sempre no modo de exibição.  
  
 A origem das coordenadas de célula do caractere no buffer da tela é o canto superior esquerdo e as posições do cursor e a janela do console são medidas em relação a essa origem. Use índices com base em zero para especificar as posições; ou seja, especifique a primeira linha como linha 0 e a coluna mais à esquerda como a coluna 0. O valor máximo para os índices de linha e coluna é <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Suporte Unicode para o console  
 Em geral, o console lê a entrada e grava a saída usando a página de código atual do console, que define a localidade do sistema por padrão. Uma página de código pode manipular apenas um subconjunto de caracteres Unicode disponíveis, portanto, se você tentar exibir caracteres que não são mapeados por uma página de código em particular, o console não poderá exibir todos os caracteres ou representá-los com precisão. O exemplo a seguir ilustra esse problema. Ele tenta exibir os caracteres do alfabeto cirílico de U + 0410 a U + 044F para o console. Se você executar o exemplo em um sistema que usa a página de código 437 do console, cada caractere é substituído por um ponto de interrogação (?) como caracteres cirílicos não são mapeados para os caracteres na página de código 437.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Além de oferecer suporte a páginas de código, o <xref:System.Console> classe dá suporte à codificação UTF-8 o <xref:System.Text.UTF8Encoding> classe. Começando com o .NET Framework 4.5, o <xref:System.Console> classe também dá suporte à codificação UTF-16 a <xref:System.Text.UnicodeEncoding> classe. Para exibir os caracteres Unicode no console. definir o <xref:System.Console.OutputEncoding%2A> propriedade como <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>.  
  
 Suporte para caracteres Unicode requer o codificador reconhecer um determinado caractere Unicode e também requer uma fonte que tenha os glifos necessários para processar esse caractere. Para exibir os caracteres Unicode com êxito para o console, a fonte do console deve ser definida para uma varredura não ou uma fonte TrueType como Consolas ou Lucida Console. O exemplo a seguir mostra como você pode programaticamente alterar a fonte de uma fonte de varredura Lucida Console.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 No entanto, as fontes TrueType podem exibir apenas um subconjunto de glifos. Por exemplo, a fonte Lucida Console exibe somente 643 dos aproximadamente 64.000 disponíveis caracteres de U + 0021 a U + FB02. Para ver quais caracteres uma determinada fonte suporta, abra o **fontes** miniaplicativo Painel de controle, escolha o **localizar um caractere** opção e escolha a fonte do conjunto de cujos caracteres você deseja examinar no **fonte** lista da **mapa de caracteres** janela.  
  
 O Windows usa a vinculação de fontes para exibir glifos que não estão disponíveis em uma determinada fonte. Para obter informações sobre a fonte de vinculação para exibir conjuntos de caracteres adicionais, consulte [globalização passo a passo: fontes](http://go.microsoft.com/fwlink/?LinkId=229111). Fontes vinculadas são definidas na subchave do Registro HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink. Cada entrada associada a essa subchave corresponde ao nome de uma fonte de base, e seu valor é uma matriz de cadeia de caracteres que define os arquivos de fonte e as fontes que são vinculadas para a fonte de base. Cada membro da matriz define uma fonte vinculada e assume a forma *nome do arquivo de fonte*,*nome da fonte*. O exemplo a seguir ilustra como você pode definir programaticamente uma fonte vinculada chamada SimSun encontrado em um arquivo de fonte chamado simsun.ttc que exibe caracteres Han simplificado.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Suporte a Unicode para o console tem as seguintes limitações:  
  
-   Não há suporte para a codificação UTF-32. A única com suporte a Unicode codificações são UTF-8 e UTF-16, que são representados pelo <xref:System.Text.UTF8Encoding> e <xref:System.Text.UnicodeEncoding> classes, respectivamente.  
  
-   Não há suporte para a saída bidirecional.  
  
-   Exibição de caracteres fora do plano multilíngue básico (isto é, de pares substitutos) não é suportada, mesmo se elas são definidas em um arquivo de fonte vinculado.  
  
-   Não há suporte para a exibição de caracteres de scripts complexos.  
  
-   Sequências de caracteres de combinação (isto é, caracteres que consistem em um caractere base e um ou mais caracteres combinando) são exibidas como caracteres distintos. Para contornar essa limitação, você poderá normalizar a cadeia de caracteres a ser exibida ao chamar o <xref:System.String.Normalize%2A?displayProperty=nameWithType> método antes de enviar a saída para o console. No exemplo a seguir, uma cadeia de caracteres que contém o caractere de combinação sequência 0061 U + U + 0308 é exibido no console como dois caracteres antes da cadeia de caracteres de saída é normalizada e como um único caractere após o <xref:System.String.Normalize%2A?displayProperty=nameWithType> método é chamado.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Observe que a normalização é uma solução viável somente se a sequência de caracteres padrão para o caractere inclui um formulário previamente composto que corresponde a um determinado combining Unicode.  
  
-   Se uma fonte fornece um glifo para um ponto de código na área de uso particular, que glifo será exibido. No entanto, como os caracteres na área de uso particular são específicas do aplicativo, isso não pode ser o símbolo esperado.  
  
 O exemplo a seguir exibe um conjunto de caracteres Unicode no console. O exemplo aceita três parâmetros de linha de comando: o início do intervalo para exibir o final do intervalo de exibição, e se deseja usar a codificação atual para o console (`false`) ou codificação UTF-16 (`true`). Ele pressupõe que o console está usando uma fonte TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Operações comuns  
 O <xref:System.Console> classe contém os seguintes métodos para ler a entrada do console e gravar saída de console:  
  
-   As sobrecargas do <xref:System.Console.ReadKey%2A> método ler um caractere individual.  
  
-   O <xref:System.Console.ReadLine%2A> método lê uma linha inteira de entrada.  
  
-   O <xref:System.Console.Write%2A> sobrecargas do método converter uma instância de um tipo de valor, uma matriz de caracteres ou um conjunto de objetos em uma cadeia de caracteres formatada ou não formatada e, em seguida, gravar essa cadeia de caracteres no console.  
  
-   Definir um paralelo do <xref:System.Console.WriteLine%2A> sobrecargas de método de saída a mesma cadeia de caracteres como o <xref:System.Console.Write%2A> sobrecargas, mas também adicionar uma cadeia de caracteres de terminação de linha.  
  
 O <xref:System.Console> classe também contém métodos e propriedades para executar as seguintes operações:  
  
-   Obtém ou define o tamanho do buffer da tela. O <xref:System.Console.BufferHeight%2A> e <xref:System.Console.BufferWidth%2A> propriedades permitem que você obtenha ou defina o buffer altura e largura, respectivamente e o <xref:System.Console.SetBufferSize%2A> método permite que você defina o tamanho do buffer em uma única chamada de método.  
  
-   Obtém ou define o tamanho da janela do console. O <xref:System.Console.WindowHeight%2A> e <xref:System.Console.WindowWidth%2A> propriedades permitem que você obtenha ou defina a altura da janela e a largura, respectivamente e o <xref:System.Console.SetWindowSize%2A> método permite que você defina o tamanho da janela em uma única chamada de método.  
  
-   Obtém ou define o tamanho do cursor. O <xref:System.Console.CursorSize%2A> propriedade especifica a altura do cursor em uma célula de caractere.  
  
-   Obtém ou define a posição da janela do console em relação ao buffer da tela. O <xref:System.Console.WindowTop%2A> e <xref:System.Console.WindowLeft%2A> propriedades permitem que você obtenha ou defina a linha superior e a coluna mais à esquerda do buffer da tela que aparece na janela do console, e o <xref:System.Console.SetWindowPosition%2A> método permite que você defina esses valores em uma única chamada de método.  
  
-   Obtenha ou defina a posição do cursor, obter ou definir o <xref:System.Console.CursorTop%2A> e <xref:System.Console.CursorLeft%2A> propriedades ou definir a posição do cursor chamando o <xref:System.Console.SetCursorPosition%2A> método.  
  
-   Mover ou limpe os dados no buffer da tela chamando o <xref:System.Console.MoveBufferArea%2A> ou <xref:System.Console.Clear%2A> método.  
  
-   Obtenha ou defina as cores de primeiro plano e em segundo plano usando o <xref:System.Console.ForegroundColor%2A> e <xref:System.Console.BackgroundColor%2A> propriedades, ou redefina-o primeiro e segundo plano para as cores padrão chamando o <xref:System.Console.ResetColor%2A> método.  
  
-   Executar o som de um aviso sonoro por meio do apresentador console chamando o <xref:System.Console.Beep%2A> método.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]Anotações  
 No .NET Framework na área de trabalho, o <xref:System.Console> classe usa a codificação retornado por `GetConsoleCP` e `GetConsoleOutputCP`, que normalmente é uma página de código codificação. Por exemplo, código, em sistemas cuja é cultura é inglês (Estados Unidos), página de código 437 é a codificação é usado por padrão. No entanto, [!INCLUDE[net_core](~/includes/net-core-md.md)] podem criar somente um subconjunto limitado dessas codificações disponível. Quando esse for o caso, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> é usado como a codificação padrão para o console.  
  
 Se seu aplicativo depende de codificações de página de código específico, você pode ainda disponibilizá-los usando o seguinte procedimento *antes de* você chamar qualquer <xref:System.Console> métodos:  
  
1.  Adicione uma referência ao assembly System.Text.Encoding.CodePages.dll ao seu projeto.  
  
2.  Recuperar o <xref:System.Text.EncodingProvider> de objeto do <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriedade.  
  
3.  Passar o <xref:System.Text.EncodingProvider> o objeto para o <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para fazer as codificações adicionais com suporte pelo provedor de codificação disponível.  
  
 O <xref:System.Console> classe automaticamente usará a codificação padrão do sistema em vez de UTF8, desde que você registrou o provedor de codificação antes de chamar qualquer <xref:System.Console> métodos de saída.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar dados, o padrão fluxos de entrada e saída. Observe que esses fluxos podem ser redirecionados usando o <xref:System.Console.SetIn%2A> e <xref:System.Console.SetOut%2A> métodos.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor da tela de fundo do console.</summary>
        <value>Um valor que especifica a cor da tela de fundo do console; ou seja, a cor exibida atrás de cada caractere. O padrão é preto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma alteração de <xref:System.Console.BackgroundColor%2A> propriedade afeta apenas a saída é gravada para células individuais de caracteres depois que a cor do plano de fundo é alterada. Para alterar a cor de plano de fundo da janela do console como um todo, defina o <xref:System.Console.BackgroundColor%2A> propriedade e chame o <xref:System.Console.Clear%2A> método. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Uma operação get para um aplicativo baseado no Windows, no qual um console não existir, retorna <xref:System.ConsoleColor?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir salva os valores da <xref:System.ConsoleColor> enumeração para uma matriz e armazena os valores atuais do <xref:System.Console.BackgroundColor%2A> e <xref:System.Console.ForegroundColor%2A> propriedades para variáveis. Ele altera a cor de primeiro plano para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que coincida com o plano de fundo atual, e ele altera a cor de plano de fundo para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que corresponde a em primeiro plano atual. (Se a cor de primeiro plano é o mesmo que a cor do plano de fundo, o texto não será visível.) Finalmente, ele chama o <xref:System.Console.ResetColor%2A> método para restaurar as cores originais do console.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A cor especificada em uma operação de conjuntos não é um membro válido de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reproduz o som de um aviso sonoro por meio do alto-falante do console.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o aviso sonoro desempenha em uma frequência de 800 hertz por um período de 200 milissegundos.  
  
> [!NOTE]
>  O <xref:System.Console.Beep%2A> método não tem suporte nas edições de 64 bits do Windows Vista e Windows XP.  
  
 <xref:System.Console.Beep%2A>encapsula uma chamada para o Windows [bipe função](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Se <xref:System.Console.Beep%2A> produz um som em versões do Windows para Windows 7 depende da presença de um chip do temporizador de intervalo programável 8254. Começando com o Windows 7, depende do dispositivo de som padrão.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.Beep%2A> método. O exemplo aceita um número de 1 a 9, como um argumento de linha de comando e desempenha o aviso sonoro do número de vezes.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Esse método foi executado em um servidor, como o SQL Server, que não permite acesso a uma interface do usuário.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">A frequência do aviso sonoro, variando de 37 a 32.767 hertz.</param>
        <param name="duration">A duração do aviso sonoro medida em milissegundos.</param>
        <summary>Reproduz o som de um aviso sonoro de frequência e duração especificadas por meio do alto-falante do console.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A>encapsula uma chamada para o Windows [bipe função](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Se <xref:System.Console.Beep%2A> produz um som em versões do Windows para Windows 7 depende da presença de um chip do temporizador de intervalo programável 8254. Começando com o Windows 7, depende do dispositivo de som padrão.  
  
> [!NOTE]
>  O <xref:System.Console.Beep%2A> método não tem suporte nas edições de 64 bits do Windows Vista e Windows XP.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.Beep%2A> método reproduzindo as primeiro algumas observações de uma música por meio de alto-falantes do console.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="frequency" /> é menor que 37 ou maior que 32.767.  
  
 -ou-  
  
 <paramref name="duration" /> é menor que ou igual a zero.</exception>
        <exception cref="T:System.Security.HostProtectionException">Esse método foi executado em um servidor, como SQL Server, que não permite acesso ao console.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura da área de buffer.</summary>
        <value>A altura atual, em linhas, da área de buffer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade define o número de linhas (ou linhas) armazenados no buffer que é acessado por uma janela do modo de console. Em contraste, o <xref:System.Console.WindowHeight%2A> propriedade define o número de linhas que realmente são exibidos na janela do console a qualquer momento determinado. Se o número de linhas que realmente gravado no buffer excede o número de linhas definido pelo <xref:System.Console.WindowHeight%2A> propriedade, a janela pode ser rolada verticalmente para que ele exiba um número de contíguo de linhas que são iguais para o <xref:System.Console.WindowHeight%2A> propriedade e estão localizados em qualquer lugar no buffer.  
  
 Se uma operação definida diminui o valor da <xref:System.Console.BufferHeight%2A> propriedade, as linhas mais alta são removidas. Por exemplo, se o número de linhas é reduzido de 300 para 250, linhas de 0 a 49 são removidas e existente linhas 50 e 299 que se tornam linhas 249 a 0.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.BufferHeight%2A> e <xref:System.Console.BufferWidth%2A> propriedades. O exemplo informa as dimensões de uma janela de sistema operacional definido com um tamanho de buffer de 300 linhas e colunas de 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor ou igual a zero.  
  
 -ou-  
  
 O valor em uma operação de conjuntos é maior ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 O valor em uma operação de definição é menor que <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a largura da área de buffer.</summary>
        <value>A largura atual, em colunas, da área de buffer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma operação definida diminui o valor de <xref:System.Console.BufferWidth%2A> propriedade, as colunas mais à direita são removidas. Por exemplo, se o número de colunas é reduzido de 80 a 60, 60 a 79 de cada linha de colunas são removidas.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.BufferHeight%2A> e <xref:System.Console.BufferWidth%2A> propriedades. O exemplo informa as dimensões de uma janela de sistema operacional definido com um tamanho de buffer de 300 linhas e colunas de 85.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor ou igual a zero.  
  
 -ou-  
  
 O valor em uma operação de conjuntos é maior ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 O valor em uma operação de definição é menor que <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a tecla modificadora <see cref="F:System.ConsoleModifiers.Control" /> (Ctrl) e a tecla do console <see cref="F:System.ConsoleKey.C" /> (C) ou a tecla Break são pressionadas simultaneamente (Ctrl + C ou Ctrl + Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é usado em conjunto com <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> e <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. O <xref:System.Console.CancelKeyPress> evento permite que um aplicativo de console interceptar o sinal Ctrl + C para o manipulador de eventos pode decidir se deseja continuar a executar ou encerrar. Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 Quando o usuário pressiona Ctrl + C ou Ctrl + Break o <xref:System.Console.CancelKeyPress> evento é acionado e o aplicativo <xref:System.ConsoleCancelEventHandler> manipulador de eventos é executado. O manipulador de eventos é passado um <xref:System.ConsoleCancelEventArgs> objeto que tem duas propriedades úteis:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, que permite que você determine se o manipulador foi invocado como resultado o usuário pressionar Ctrl + C (o valor da propriedade é <xref:System.ConsoleSpecialKey?displayProperty=nameWithType>) ou Ctrl + Break (o valor da propriedade é <xref:System.ConsoleSpecialKey?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, que permite que você determine como seu aplicativo deve responder para o usuário pressionar Ctrl + C ou Ctrl + Break. Por padrão, o <xref:System.ConsoleCancelEventArgs.Cancel%2A> é de propriedade `false`, que faz com que programa execução encerrada quando o manipulador de eventos será encerrado. Alterando sua propriedade para `true` Especifica que o aplicativo deve continuar a ser executada.  
  
> [!TIP]
>  Se seu aplicativo tiver requisitos simples, você pode usar o <xref:System.Console.TreatControlCAsInput%2A> propriedade em vez desse evento. Definindo essa propriedade como `false`, você pode garantir que seu aplicativo sempre será encerrado se o usuário pressionar Ctrl + C. Definindo-a como `true`, você pode garantir que pressionar Ctrl + C não para encerrar o aplicativo.  
  
 O manipulador de eventos para esse evento é executado em um pool de threads.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como o <xref:System.Console.CancelKeyPress> de eventos é usado. Quando você pressionar Ctrl + C, a operação de leitura é interrompida e o `myHandler` manipulador de eventos é chamado. Na entrada para o manipulador de eventos, o <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> é de propriedade `false`, que significa que o processo atual terminará quando o manipulador de eventos é encerrado. No entanto, o manipulador de eventos define o <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> propriedade `true`, que significa que o processo não será encerrado e continuará a operação de leitura.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a alternância de teclado CAPS LOCK está ativada ou desativada.</summary>
        <value>
          <see langword="true" /> se a tecla CAPS LOCK está ativada; <see langword="false" /> se CAPS LOCK está desativada.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o buffer do console e a janela do console correspondente de informações de exibição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Console.Clear%2A> método é equivalente a chamar o MS-DOS `cls` comando na janela do prompt de comando. Quando o <xref:System.Console.Clear%2A> método é chamado, o cursor passa automaticamente para o canto superior esquerdo da janela e o conteúdo do buffer da tela é definido como espaços em branco usando as cores de plano de fundo de primeiro plano atual.  
  
> [!NOTE]
>  Tentativa de chamar o <xref:System.Console.Clear%2A> quando a saída de um aplicativo console é redirecionada para um arquivo de método lançará um <xref:System.IO.IOException>. Para evitar isso, sempre quebram uma chamada para o <xref:System.Console.Clear%2A> método em um `try`...`catch` bloco.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Console.Clear%2A> método para limpar o console antes de executar um loop, solicita ao usuário para selecionar uma cor de primeiro plano e plano de fundo e insira uma cadeia de caracteres. Se o usuário decidir não sair do programa, originais cores de primeiro plano e plano de fundo do console são restauradas e o <xref:System.Console.Clear%2A> método é chamado novamente antes de executar novamente o loop.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 O exemplo se baseia em um `GetKeyPress` método para validar a seleção do usuário de uma cor de primeiro plano e plano de fundo.  
  
 Este exemplo demonstra as propriedades <xref:System.Console.CursorLeft%2A> e <xref:System.Console.CursorTop%2A>, além dos métodos <xref:System.Console.SetCursorPosition%2A> e <xref:System.Console.Clear%2A>. O exemplo posiciona o cursor, que determina onde a próxima gravação irá ocorrer para desenhar um caractere de 5 por 5 retângulo de caractere usando uma combinação de "+", "&#124;" e "-" cadeias de caracteres. Observe que o retângulo pode ser desenhado com menos etapas usando-se uma combinação de outras cadeias de caracteres.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição da coluna do cursor na área de buffer.</summary>
        <value>A posição atual, em colunas, do cursor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo demonstra as propriedades <xref:System.Console.CursorLeft%2A> e <xref:System.Console.CursorTop%2A>, além dos métodos <xref:System.Console.SetCursorPosition%2A> e <xref:System.Console.Clear%2A>. O exemplo posiciona o cursor, que determina onde a próxima gravação irá ocorrer para desenhar um caractere de 5 por 5 retângulo de caractere usando uma combinação de "+", "&#124;" e "-" cadeias de caracteres. Observe que o retângulo pode ser desenhado com menos etapas usando-se uma combinação de outras cadeias de caracteres.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor que zero.  
  
 -ou-  
  
 O valor em uma operação de conjuntos é maior ou igual a <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura do cursor em uma célula do caractere.</summary>
        <value>O tamanho do cursor expresso como um percentual da altura de uma célula do caractere. O valor da propriedade varia de 1 a 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A aparência do cursor varia, variando de uma linha horizontal na parte inferior da célula quando o valor da propriedade é 1, para preencher completamente a célula quando o valor da propriedade é 100.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.CursorSize%2A> propriedade. O exemplo aumenta o tamanho do cursor sempre que qualquer chave de console é pressionado, em seguida, restaura o cursor para o tamanho original antes de encerrar.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado em uma operação de definição é menor que 1 ou maior que 100.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição da linha do cursor dentro da área de buffer.</summary>
        <value>A posição atual, em linhas, do cursor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo demonstra as propriedades <xref:System.Console.CursorLeft%2A> e <xref:System.Console.CursorTop%2A>, além dos métodos <xref:System.Console.SetCursorPosition%2A> e <xref:System.Console.Clear%2A>. O exemplo posiciona o cursor, que determina onde a próxima gravação irá ocorrer para desenhar um caractere de 5 por 5 retângulo de caractere usando uma combinação de "+", "&#124;" e "-" cadeias de caracteres. Observe que o retângulo pode ser desenhado com menos etapas usando-se uma combinação de outras cadeias de caracteres.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor em uma operação de conjuntos é menor que zero.  
  
 -ou-  
  
 O valor em uma operação de conjuntos é maior ou igual a <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o cursor está visível.</summary>
        <value>
          <see langword="true" /> se o cursor estiver visível; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.CursorVisible%2A> propriedade. O exemplo faz com que o cursor visível se a primeira coluna de entrada é um caractere '+' ou invisível se a entrada é um '-' caracteres.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o fluxo de saída de erro padrão.</summary>
        <value>Um <see cref="T:System.IO.TextWriter" /> que representa o fluxo de saída de erro padrão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este fluxo de erro padrão é definido para o console, por padrão. Ele pode ser definido como outro fluxo com o <xref:System.Console.SetError%2A> método. Depois que o fluxo de erro padrão é redirecionado, ele pode ser readquirido chamando o <xref:System.Console.OpenStandardError%2A> método.  
  
 Em aplicativos de console cuja saída informativa geralmente é redirecionada para um arquivo, o erro padrão de fluxo disponíveis por meio de <xref:System.Console.Error%2A> propriedade pode ser usada para exibir informações no console, mesmo se a saída é redirecionada. O exemplo a seguir exibe as tabelas de produtos para os 10 números por vez, começando com 1. Depois de cada conjunto de números de 10, o <xref:System.Console.Error%2A> propriedade é usada para solicitar que o usuário se deseja exibir o próximo conjunto. Se a saída padrão é redirecionada para um arquivo, o usuário será solicitado ainda se a rotina deve gerar o próximo conjunto de produtos.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir é um utilitário de linha de comando chamado ExpandTabs que substitui caracteres de tabulação em um arquivo de texto com quatro espaços, o valor definido pelo `tabSize` variável. Redireciona a entrada e saída de fluxos de arquivos, mas usa o <xref:System.Console.Error%2A> propriedade para gravar o fluxo de erro padrão para o console. Ele pode ser iniciado na linha de comando fornecendo o nome do arquivo que contém caracteres de tabulação e o nome do arquivo de saída.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 O exemplo a seguir é um visualizador de arquivo de texto simples que exibe o conteúdo de um ou mais arquivos de texto para o console. Se houver nenhum argumento de linha de comando, ou se qualquer passados como argumentos de linha de comando de arquivos não existirem, o exemplo chama o <xref:System.Console.SetError%2A> chamadas de método para redirecionar as informações de erro para um arquivo, o <xref:System.Console.OpenStandardError%2A> método no processo readquirir o erro padrão fluxo e indica que as informações de erro foi gravadas em um arquivo.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Observe que o <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> está definida como `true` antes de readquirir o fluxo de erro. Isso garante que saída será enviada ao console imediatamente em vez de em buffer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor de primeiro plano do console.</summary>
        <value>Um <see cref="T:System.ConsoleColor" /> que especifica a cor de primeiro plano do console, ou seja, a cor de cada caractere exibido. O padrão é cinza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma operação get para um aplicativo baseado no Windows, no qual um console não existir, retorna <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 O exemplo a seguir verifica se o cor do plano de fundo do console é preto e, se estiver, ele altera a cor de plano de fundo vermelho e a cor de primeiro plano para preto.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 O exemplo a seguir salva os valores da <xref:System.ConsoleColor> enumeração para uma matriz e armazena os valores atuais do <xref:System.Console.BackgroundColor%2A> e <xref:System.Console.ForegroundColor%2A> propriedades para variáveis. Ele altera a cor de primeiro plano para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que coincida com o plano de fundo atual, e ele altera a cor de plano de fundo para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que corresponde a em primeiro plano atual. (Se a cor de primeiro plano é o mesmo que a cor do plano de fundo, o texto não será visível.) Finalmente, ele chama o <xref:System.Console.ResetColor%2A> método para restaurar as cores originais do console.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A cor especificada em uma operação de conjuntos não é um membro válido de <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o fluxo de entrada padrão.</summary>
        <value>Um <see cref="T:System.IO.TextReader" /> que representa o fluxo de entrada padrão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, essa propriedade é definida para o fluxo de entrada padrão. Essa propriedade pode ser definida para outro fluxo com o <xref:System.Console.SetIn%2A> método.  
  
 As operações de leitura no fluxo de entrada padrão executar de forma síncrona. Ou seja, bloquear até que a operação de leitura especificada foi concluída. Isso é verdadeiro mesmo se um método assíncrono, como <xref:System.IO.TextReader.ReadLineAsync%2A>, é chamado o <xref:System.IO.TextReader> objeto retornado pelo <xref:System.Console.In%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do `In` propriedade.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a codificação usada pelo console para ler a entrada.</summary>
        <value>A codificação usada para ler a entrada do console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O console usa a entrada de codificação para converter a entrada do teclado em um caractere correspondente. A codificação de entrada incorpora uma página de código que mapeia 256 códigos de caractere de teclado para caracteres individuais. Diferentes páginas de código contêm caracteres especiais diferentes, que geralmente são personalizados para um idioma ou um grupo de idiomas.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], uma operação de obtenção de propriedade pode retornar um valor armazenado em cache em vez do console atual codificação de entrada. Isso pode ocorrer se o valor da <xref:System.Console.InputEncoding%2A> propriedade é modificada de alguma maneira diferente de uma atribuição para o <xref:System.Console.InputEncoding%2A> propriedade, como chamar o Windows `SetConsoleCP` function ou usando o `chcp` comando de script do PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor da propriedade em uma operação de conjuntos é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro durante a execução dessa operação.</exception>
        <exception cref="T:System.Security.SecurityException">O aplicativo não tem permissão para executar essa operação.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para ler e gravar subjanelas e janelas de nível superior. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo de saída de erro foi redirecionado de fluxo de erro padrão.</summary>
        <value>
          <see langword="true" />Se a saída de erro é redirecionada; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a entrada foi redirecionada do fluxo de entrada padrão.</summary>
        <value>
          <see langword="true" /> se a entrada tiver sido redirecionada; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a saída foi redirecionada do fluxo de saída padrão.</summary>
        <value>
          <see langword="true" /> se a saída tiver sido redirecionada; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um pressionamento de tecla está disponível no fluxo de entrada.</summary>
        <value>
          <see langword="true" /> se um pressionamento de tecla estiver disponível; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é retornado imediatamente. ou seja, o <xref:System.Console.KeyAvailable%2A> propriedade não bloqueia a entrada até que um pressionamento de tecla está disponível.  
  
 Use o <xref:System.Console.KeyAvailable%2A> propriedade em conjunto com apenas o <xref:System.Console.ReadKey%2A> método, não o <xref:System.Console.Read%2A> ou <xref:System.Console.ReadLine%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Console.KeyAvailable%2A> propriedade para criar um loop que é executado até que uma tecla é pressionada.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.InvalidOperationException">A entrada padrão é redirecionada para um arquivo em vez do teclado.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o maior número possível de linhas de janela do console, com base na fonte atual e resolução da tela.</summary>
        <value>A altura da maior janela do console possível medida em linhas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o maior número possível de colunas de janela do console, com base na fonte atual e resolução da tela.</summary>
        <value>A largura da maior janela do console possível medida em colunas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">A coluna mais à esquerda da área de origem.</param>
        <param name="sourceTop">A linha superior da área de origem.</param>
        <param name="sourceWidth">O número de colunas na área de origem.</param>
        <param name="sourceHeight">O número de linhas na área de origem.</param>
        <param name="targetLeft">A coluna mais à esquerda da área de destino.</param>
        <param name="targetTop">A linha superior da área de destino.</param>
        <summary>Copia uma área de fonte especificada do buffer da tela para uma área de destino especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os parâmetros de origem e destino especificarem uma posição localizada fora dos limites do buffer da tela atual, somente a parte da área de origem que se ajusta na área de destino é copiada. Ou seja, a área de origem é recortada para caber no buffer da tela atual.  
  
 O <xref:System.Console.MoveBufferArea%2A> método copia a área de origem para a área de destino. Se a área de destino não faz intersecção com a área de origem, a área de origem é preenchida com espaços em branco usando as cores de primeiro e segundo plano atuais. Caso contrário, a parte cruzada da área de origem não está preenchida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um ou mais dos parâmetros são menores que zero.  
  
 -ou-  
  
 <paramref name="sourceLeft" /> ou <paramref name="targetLeft" /> é maior ou igual a <see cref="P:System.Console.BufferWidth" />.  
  
 -ou-  
  
 <paramref name="sourceTop" /> ou <paramref name="targetTop" /> é maior ou igual a <see cref="P:System.Console.BufferHeight" />.  
  
 -ou-  
  
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" />é maior que ou igual a <see cref="P:System.Console.BufferHeight" />.  
  
 -ou-  
  
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" />é maior que ou igual a <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">A coluna mais à esquerda da área de origem.</param>
        <param name="sourceTop">A linha superior da área de origem.</param>
        <param name="sourceWidth">O número de colunas na área de origem.</param>
        <param name="sourceHeight">O número de linhas na área de origem.</param>
        <param name="targetLeft">A coluna mais à esquerda da área de destino.</param>
        <param name="targetTop">A linha superior da área de destino.</param>
        <param name="sourceChar">O caractere usado para preencher a área de origem.</param>
        <param name="sourceForeColor">A cor de primeiro plano usada para preencher a área de origem.</param>
        <param name="sourceBackColor">A cor da tela de fundo usada para preencher a área de origem.</param>
        <summary>Copia uma área de fonte especificada do buffer da tela para uma área de destino especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os parâmetros de origem e destino especificarem uma posição localizada além dos limites do buffer da tela atual, somente a parte da área de origem que se ajusta na área de destino é copiada. Ou seja, a área de origem é recortada para caber no buffer da tela atual.  
  
 O <xref:System.Console.MoveBufferArea%2A> método copia a área de origem para a área de destino. Se a área de destino não faz intersecção com a área de origem, a área de origem é preenchida com o caractere especificado por `sourceChar`, usando as cores especificadas por `sourceForeColor` e `sourceBackColor`. Caso contrário, a parte cruzada da área de origem não está preenchida.  
  
 O <xref:System.Console.MoveBufferArea%2A> método não executa nenhuma operação se `sourceWidth` ou `sourceHeight` é zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um ou mais dos parâmetros são menores que zero.  
  
 -ou-  
  
 <paramref name="sourceLeft" /> ou <paramref name="targetLeft" /> é maior ou igual a <see cref="P:System.Console.BufferWidth" />.  
  
 -ou-  
  
 <paramref name="sourceTop" /> ou <paramref name="targetTop" /> é maior ou igual a <see cref="P:System.Console.BufferHeight" />.  
  
 -ou-  
  
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" />é maior que ou igual a <see cref="P:System.Console.BufferHeight" />.  
  
 -ou-  
  
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" />é maior que ou igual a <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Um ou ambos os parâmetros de cor não são membro da enumeração <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a alternância de teclado NUM LOCK está ativada ou desativada.</summary>
        <value>
          <see langword="true" /> se NUM LOCK estiver ativado; <see langword="false" /> se NUM LOCK estiver desativado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquire o fluxo de erro padrão.</summary>
        <returns>O fluxo de erro padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de erro padrão depois que ele foi alterado pelo <xref:System.Console.SetError%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir é um visualizador de arquivo de texto simples que exibe o conteúdo de um ou mais arquivos de texto para o console. Se houver nenhum argumento de linha de comando, ou se qualquer passados como argumentos de linha de comando de arquivos não existirem, o exemplo chama o <xref:System.Console.SetError%2A> chamadas de método para redirecionar as informações de erro para um arquivo, o <xref:System.Console.OpenStandardError%2A> método no processo readquirir o erro padrão fluxo e indica que as informações de erro foi gravadas em um arquivo.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Observe que o <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> está definida como `true` antes de readquirir o fluxo de erro. Isso garante que saída será enviada ao console imediatamente em vez de em buffer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">O tamanho do buffer de fluxo interno.</param>
        <summary>Adquire o fluxo de erro padrão, que é definido com um tamanho de buffer especificado.</summary>
        <returns>O fluxo de erro padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de erro padrão depois que ele foi alterado pelo <xref:System.Console.SetError%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é menor que ou igual a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquire o fluxo de entrada padrão.</summary>
        <returns>O fluxo de entrada padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de entrada padrão depois que ele foi alterado pelo <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do `OpenStandardInput` propriedade.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">O tamanho do buffer de fluxo interno.</param>
        <summary>Adquire o fluxo de entrada padrão, que é definido para um tamanho do buffer especificado.</summary>
        <returns>O fluxo de entrada padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de saída padrão depois que ele foi alterado pelo <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do `OpenStandardInput` propriedade.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é menor que ou igual a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adquire o fluxo de saída padrão.</summary>
        <returns>O fluxo de saída padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de saída padrão depois que ele foi alterado pelo <xref:System.Console.SetOut%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Console.OpenStandardOutput%2A>. Ele substitui quatro caracteres de espaços consecutivos em uma cadeia de caracteres por um caractere de tabulação. Para executá-lo, você precisa fornecer dois argumentos de linha de comando. O primeiro é o nome de um arquivo de texto existente para o qual redirecionar o fluxo de entrada padrão. O segundo é o nome de um arquivo para o qual redirecionar o fluxo de saída padrão. Este arquivo não precisa existir. Se for, o conteúdo será substituído.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">O tamanho do buffer de fluxo interno.</param>
        <summary>Adquire o fluxo de saída padrão, que é definido com um tamanho de buffer especificado.</summary>
        <returns>O fluxo de saída padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para readquirir o fluxo de saída padrão depois que ele foi alterado pelo <xref:System.Console.SetOut%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Console.OpenStandardOutput%2A>. Ele substitui quatro caracteres de espaços consecutivos em uma cadeia de caracteres por um caractere de tabulação. Para executá-lo, você precisa fornecer dois argumentos de linha de comando. O primeiro é o nome de um arquivo de texto existente para o qual redirecionar o fluxo de entrada padrão. O segundo é o nome de um arquivo para o qual redirecionar o fluxo de saída padrão. Este arquivo não precisa existir. Se for, o conteúdo será substituído.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é menor que ou igual a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o fluxo de saída padrão.</summary>
        <value>Um <see cref="T:System.IO.TextWriter" /> que representa o fluxo de saída padrão.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, essa propriedade é definida para o fluxo de saída padrão. Essa propriedade pode ser definida para outro fluxo com o <xref:System.Console.SetOut%2A> método.  
  
 Observe que as chamadas para `Console.Out.WriteLine` métodos são equivalentes a chamadas para o correspondente <xref:System.Console.WriteLine%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Console.Out%2A> propriedade para exibir uma matriz que contém os nomes dos arquivos no diretório atual do aplicativo para o dispositivo de saída padrão. Em seguida, ele define a saída padrão para um arquivo chamado Files.txt e lista os elementos da matriz para o arquivo. Finalmente, ele define a saída ao fluxo de saída padrão e exibe novamente os elementos da matriz para o dispositivo de saída padrão.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a codificação usada pelo console para gravar a saída.</summary>
        <value>A codificação usada para gravar a saída do console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O console usa a codificação de saída para traduzir caracteres escritos por um aplicativo em caracteres de exibição do console correspondentes. A página de código padrão que usa o console é determinada pela localidade do sistema.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], uma operação de obtenção de propriedade pode retornar um valor armazenado em cache em vez de codificação atual da saída do console. Isso pode ocorrer se o valor da <xref:System.Console.OutputEncoding%2A> propriedade é modificada de alguma maneira diferente de uma atribuição para o <xref:System.Console.OutputEncoding%2A> propriedade, como chamar o Windows `SetConsoleOutputCP` função.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor da propriedade em uma operação de conjuntos é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro durante a execução dessa operação.</exception>
        <exception cref="T:System.Security.SecurityException">O aplicativo não tem permissão para executar essa operação.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para ler e gravar subjanelas e janelas de nível superior.  Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Codificações Unicode, o <see cref="T:System.Console" /> classe dá suporte à codificação UTF-8 o <see cref="T:System.Text.UTF8Encoding" /> classe e, começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], ele dá suporte à codificação UTF-16 a <see cref="T:System.Text.UnicodeEncoding" /> classe. Codificação UTF-32 com o <see cref="T:System.Text.UTF32Encoding" /> não há suporte para a classe. Tentativa de definir a codificação de saída para UTF-32 lança um <see cref="T:System.IO.IOException" />.  
  
 Observe que com êxito exibir caracteres Unicode no console exige o seguinte:  
  
-   O console deve usar uma fonte TrueType, como Lucida Console ou Consolas, para exibir os caracteres.  
  
-   Uma fonte usada pelo console deve definir o glifo específico ou glifos a ser exibido. O console pode tirar proveito da fonte de vinculação para exibir os glifos de fontes vinculadas se a fonte de base não contém uma definição para esse glifo.  
  
 Para obter mais informações sobre o suporte para Unicode codificação pelo console do, consulte a seção "Unicode oferecem suporte para o Console de" o <see cref="T:System.Console" /> classe.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o próximo caractere do fluxo de entrada padrão.</summary>
        <returns>O próximo caractere do fluxo de entrada, ou um negativo (-1), se, no momento, não houver mais caracteres a serem lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Console.Read%2A> método bloqueia seu retorno enquanto você digita caracteres de entrada; ele termina quando você pressiona o <xref:System.ConsoleKey.Enter> chave. Pressionando Enter acrescenta uma sequência de terminação de linha dependente de plataforma para sua entrada (por exemplo, Windows acrescenta uma sequência de avanço de linha de retorno de carro). As chamadas subsequentes para o <xref:System.Console.Read%2A> método recuperar sua entrada de um caractere de cada vez. Depois que o caractere final é recuperado, <xref:System.Console.Read%2A> bloqueia seu retorno novamente e o ciclo se repete.  
  
> [!IMPORTANT]
>  O <xref:System.Console.ReadLine%2A> método, ou o <xref:System.Console.KeyAvailable%2A> propriedade e <xref:System.Console.ReadKey%2A> é preferível instalar usando o método de <xref:System.Console.Read%2A> método.  
  
 Observe que o método não retornará -1, a menos que você execute uma das seguintes ações:  
  
-   Pressione simultaneamente a <xref:System.ConsoleModifiers.Control> tecla modificadora e <xref:System.ConsoleKey.Z> chave do console (Ctrl + Z), que indica a condição de fim de arquivo.  
  
-   Pressione uma tecla equivalente que sinaliza a condição de fim de arquivo, como a tecla de função F6 no Windows.  
  
-   Redirecione o fluxo de entrada para uma fonte, como um arquivo de texto, que tem um caractere de final de arquivo real.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.Read%2A> método.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o próximo caractere ou tecla de função pressionada pelo usuário. A tecla pressionada é exibida na janela do console.</summary>
        <returns>Um objeto que descreve a constante <see cref="T:System.ConsoleKey" /> e o caractere Unicode, se houver, que correspondem à chave do console pressionada. O objeto <see cref="T:System.ConsoleKeyInfo" /> também descreve, em uma combinação bit a bit de valores <see cref="T:System.ConsoleModifiers" />, se uma ou mais teclas modificadoras Ctrl, Alt ou Shift foram pressionadas simultaneamente com a chave do console.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Console.ReadKey%2A> método espera, ou seja, blocos na emissão de thread de <xref:System.Console.ReadKey%2A> método, até que uma tecla de função ou o caractere é pressionada. Uma chave de caractere ou função pode ser pressionada em combinação com uma ou mais chaves de modificador de Alt, Ctrl ou Shift. No entanto, pressionar uma tecla modificadora por si só não fará com que o <xref:System.Console.ReadKey%2A> método para retornar.  
  
 Dependendo do seu aplicativo, você talvez queira usar o <xref:System.Console.ReadKey%2A> método junto com o <xref:System.Console.KeyAvailable%2A> propriedade.  
  
 O <xref:System.Console.ReadKey%2A> método lê do teclado, mesmo se a entrada padrão é redirecionada para um arquivo com o <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 Um dos mais comuns usa do <xref:System.Console.ReadKey> método é interromper a execução do programa até que o usuário pressiona uma tecla e o aplicativo termina ou exibe uma janela adicional de informações. O exemplo a seguir usa o <xref:System.Console.ReadKey> método para aguardar o usuário pressionar a tecla Enter antes de encerrar o aplicativo.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Observe que essa sobrecarga do <xref:System.Console.ReadKey%2A> método por padrão exibe quaisquer chaves exibível que o usuário pressiona o console. Para suprimi-los, chame o <xref:System.Console.ReadKey%2A> método com um `intercept` argumento de `true`.  
  
 O exemplo a seguir usa o <xref:System.Console.ReadKey> método para exibir informações sobre qual chave o usuário pressionou...  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Console.In" /> é redirecionada de algum fluxo que não é o console.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Determina se a tecla pressionada deve ser exibida na janela do console. <see langword="true" /> para não exibir a tecla pressionada; caso contrário, <see langword="false" />.</param>
        <summary>Obtém o próximo caractere ou tecla de função pressionada pelo usuário. A tecla pressionada é exibida opcionalmente na janela do console.</summary>
        <returns>Um objeto que descreve a constante <see cref="T:System.ConsoleKey" /> e o caractere Unicode, se houver, que correspondem à chave do console pressionada. O objeto <see cref="T:System.ConsoleKeyInfo" /> também descreve, em uma combinação bit a bit de valores <see cref="T:System.ConsoleModifiers" />, se uma ou mais teclas modificadoras Ctrl, Alt ou Shift foram pressionadas simultaneamente com a chave do console.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Console.ReadKey%2A> método espera, ou seja, blocos na emissão de thread de <xref:System.Console.ReadKey%2A> método, até que uma tecla de função ou o caractere é pressionada. Uma chave de caractere ou função pode ser pressionada em combinação com uma ou mais chaves de modificador de Alt, Ctrl ou Shift. No entanto, pressionar uma tecla modificadora por si só não fará com que o <xref:System.Console.ReadKey%2A> método para retornar.  
  
 Se o `intercept` parâmetro é `true`, a tecla pressionada for interceptada e não exibido na janela do console; caso contrário, a tecla pressionada é exibida.  
  
 Dependendo do seu aplicativo, você talvez queira usar o <xref:System.Console.ReadKey%2A> método junto com o <xref:System.Console.KeyAvailable%2A> propriedade.  
  
 O <xref:System.Console.ReadKey%2A> método lê do teclado, mesmo se a entrada padrão é redirecionada para um arquivo com o <xref:System.Console.SetIn%2A> método.  
  
   
  
## Examples  
 Um dos mais comuns usa do <xref:System.Console.ReadKey%2A> método é interromper a execução do programa até que o usuário pressiona uma tecla e o aplicativo termina ou exibe uma janela adicional de informações. O exemplo a seguir usa o <xref:System.Console.ReadKey%28System.Boolean%29> método para aguardar o usuário pressionar a tecla Enter antes de encerrar o aplicativo. Observe que, se o usuário pressionar qualquer outra chave, ele não será refletido no console.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.Console.ReadKey%28System.Boolean%29> método para exibir informações sobre a tecla pressionada por um usuário sem repetir essa chave para o console.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Console.In" /> é redirecionada de algum fluxo que não é o console.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê a próxima linha de caracteres do fluxo de entrada padrão.</summary>
        <returns>A próxima linha de caracteres do fluxo de entrada, ou <see langword="null" />, se não houver mais linhas disponíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Console.ReadLine%2A> método lê uma linha do fluxo de entrada padrão. (Para a definição de uma linha, consulte o parágrafo após a lista a seguir). Isso significa que:  
  
-   Se o dispositivo de entrada padrão é o teclado, o <xref:System.Console.ReadLine%2A> blocos de método até que o usuário pressiona o **Enter** chave.  
  
     Um dos mais comuns usa do <xref:System.Console.ReadLine%2A> método é para pausar a execução do programa antes de limpar o console e exibir novas informações para ele, ou para solicitar ao usuário a pressionar a tecla Enter antes de encerrar o aplicativo. O exemplo a seguir ilustra essa situação.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Se a entrada padrão é redirecionada para um arquivo, o <xref:System.Console.ReadLine%2A> método lê uma linha de texto de um arquivo. Por exemplo, este é um arquivo de texto chamado ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     O exemplo a seguir usa o <xref:System.Console.ReadLine%2A> método para ler a entrada que é redirecionada de um arquivo. A operação de leitura termina quando o método retorna `null`, que indica que nenhuma linha permanecem para serem lidos.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     Depois de compilar o exemplo para um executável ReadLine1.exe nomeada, você pode executá-lo na linha de comando com a sintaxe  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     para ler o conteúdo do arquivo e exibi-los para o console.  
  
 Uma linha é definida como uma cadeia de caracteres, seguido por um retorno de carro (hexadecimal 0x000d), uma alimentação de linha (hexadecimal 0x000a) ou o valor de <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriedade. A cadeia de caracteres retornada não contém o caractere de terminação (s). Por padrão, o método lê a entrada de um buffer de entrada de 256 caracteres. Porque isso inclui o <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> caractere (s), o método pode ler linhas que contêm até 254 caracteres. Para ler mais linhas, chame o <xref:System.Console.OpenStandardInput%28System.Int32%29> método.  
  
 O <xref:System.Console.ReadLine%2A> método é executado de forma síncrona. Ou seja, ele bloqueia até que uma linha é lida ou a combinação de teclado Ctrl + Z é pressionada. O <xref:System.Console.In%2A> propriedade retorna um <xref:System.IO.TextReader> objeto que representa o fluxo de entrada padrão e que tem ambos um síncrono <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> método e assíncrona <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> método. No entanto, quando usado como um fluxo de entrada padrão do console, o <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> executa de forma síncrona em vez de forma assíncrona e retorna um `Task<String>` somente depois que a operação de leitura foi concluída.  
  
 Se este método lança um <xref:System.OutOfMemoryException> exceção, a posição do leitor subjacente <xref:System.IO.Stream> objeto avança pelo número de caracteres que o método foi capaz de ler, mas os caracteres já lidos no interno <xref:System.Console.ReadLine%2A> buffer são descartadas. Desde a posição do leitor do fluxo não pode ser alterada, os caracteres leitura já são irrecuperáveis e pode ser acessados somente por reinicializar a <xref:System.IO.TextReader>. Se a posição inicial dentro do fluxo for desconhecida ou o fluxo não dá suporte para busca, subjacente <xref:System.IO.Stream> também precisa ser reiniciada. Para evitar essa situação e produzir um código robusto, você deve usar o <xref:System.Console.KeyAvailable%2A> propriedade e <xref:System.Console.ReadKey%2A> método e o repositório de leitura caracteres em um buffer pré-alocados.  
  
 Se o caractere Ctrl + Z é pressionado quando o método é a entrada de leitura no console do, o método retornará `null`. Isso permite que o usuário para evitar mais teclado entrada quando o <xref:System.Console.ReadLine%2A> método é chamado em um loop. O exemplo a seguir ilustra esse cenário.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir requer dois argumentos de linha de comando: o nome de um arquivo de texto existente e o nome de um arquivo para gravar a saída. Ele abre o arquivo de texto existente e redireciona a entrada padrão do teclado para esse arquivo. Ele também redireciona a saída padrão do console para o arquivo de saída. Ele usa o <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método para ler cada linha no arquivo, substitui cada sequência de quatro espaços com um caractere de tabulação e usa o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> método para gravar o resultado para o arquivo de saída.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para alocar um buffer à cadeia de caracteres retornada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de caracteres na próxima linha de caracteres é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define as cores do console de primeiro e segundo planos com os padrões.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As cores de primeiro plano e plano de fundo são restauradas para as cores que existiam no início do processo atual. Para obter mais informações, consulte o <xref:System.Console.ForegroundColor%2A> e <xref:System.Console.BackgroundColor%2A> propriedades.  
  
   
  
## Examples  
 O exemplo a seguir salva os valores da <xref:System.ConsoleColor> enumeração para uma matriz e armazena os valores atuais do <xref:System.Console.BackgroundColor%2A> e <xref:System.Console.ForegroundColor%2A> propriedades para variáveis. Ele altera a cor de primeiro plano para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que coincida com o plano de fundo atual, e ele altera a cor de plano de fundo para cada cor o <xref:System.ConsoleColor> enumeração exceto para a cor que corresponde a em primeiro plano atual. (Se a cor de primeiro plano é o mesmo que a cor do plano de fundo, o texto não será visível.) Finalmente, ele chama o <xref:System.Console.ResetColor%2A> método para restaurar as cores originais do console.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">A largura da área de buffer medida em colunas.</param>
        <param name="height">A altura da área de buffer medida em linhas.</param>
        <summary>Define a altura e largura da área de buffer da tela com os valores especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, e <xref:System.Console.CursorVisible%2A> , propriedades e o <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, e <xref:System.Console.ReadKey%2A> métodos. O exemplo desenha um padrão de grade no buffer da tela com base na largura do buffer da tela. Em seguida, o exemplo move a janela do console em resposta ao qual da seta para cima, seta para a direita, seta para a esquerda ou seta para baixo chaves de console é pressionado. O padrão de grade ajuda você a ver a movimentação da janela do console em relação ao buffer da tela.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="height" /> ou <paramref name="width" /> é menor ou igual a zero.  
  
 -ou-  
  
 <paramref name="height" /> ou <paramref name="width" /> é maior ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 <paramref name="width" />é menor que <see cref="P:System.Console.WindowLeft" />  +  <see cref="P:System.Console.WindowWidth" />.  
  
 -ou-  
  
 <paramref name="height" />é menor que <see cref="P:System.Console.WindowTop" />  +  <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">A posição da coluna do cursor. As colunas são numeradas da esquerda para a direita, começando em 0.</param>
        <param name="top">A posição da linha do cursor. As linhas são numeradas de cima para baixo, começando em 0.</param>
        <summary>Define a posição do cursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Console.SetCursorPosition%2A> método para especificar onde a próxima operação de gravação na janela do console começar. Se a posição do cursor especificado está fora da área que está atualmente visível na janela do console, a origem de janela é alterado automaticamente para tornar visível o cursor.  
  
 O cursor se move automaticamente para a próxima posição de caractere sempre que um caractere é gravado para a janela do console. Se o cursor estiver na posição do caractere direito inferior da janela do console, a próxima gravação operação faz com que a janela do console para rolar para que o cursor permaneça visível. Se você deseja gravar um caractere para a posição do caractere à direita inferior sem fazer com que a janela do console rolar, use o <xref:System.Console.MoveBufferArea%2A> método para mover um caractere para a posição.  
  
   
  
## Examples  
 Este exemplo demonstra as propriedades <xref:System.Console.CursorLeft%2A> e <xref:System.Console.CursorTop%2A>, além dos métodos <xref:System.Console.SetCursorPosition%2A> e <xref:System.Console.Clear%2A>. O exemplo posiciona o cursor, que determina onde a próxima gravação irá ocorrer para desenhar um caractere de 5 por 5 retângulo de caractere usando uma combinação de "+", "&#124;" e "-" cadeias de caracteres. Observe que o retângulo pode ser desenhado com menos etapas usando-se uma combinação de outras cadeias de caracteres.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> ou <paramref name="top" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="left" /> é maior ou igual a <see cref="P:System.Console.BufferWidth" />.  
  
 -ou-  
  
 <paramref name="top" /> é maior ou igual a <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Um fluxo que é a nova saída de erro padrão.</param>
        <summary>Define a propriedade <see cref="P:System.Console.Error" /> para o objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Console.Error%2A> está definida como o fluxo de saída de erro padrão.  
  
 Um <xref:System.IO.StreamWriter> que encapsula um <xref:System.IO.FileStream> pode ser usado para enviar mensagens de erro para um arquivo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como redirecionar o fluxo de erro padrão para um arquivo.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newError" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Um fluxo que é a nova saída padrão.</param>
        <summary>Define a propriedade <see cref="P:System.Console.In" /> para o objeto <see cref="T:System.IO.TextReader" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Console.In%2A> está definida como o fluxo de entrada padrão.  
  
 Um <xref:System.IO.StreamReader> que encapsula um <xref:System.IO.FileStream> pode ser usado para receber entrada de um arquivo.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Console.SetIn%2A>. Ele substitui quatro caracteres de espaços consecutivos em uma cadeia de caracteres por um caractere de tabulação. Para executá-lo, você precisa fornecer dois argumentos de linha de comando. O primeiro é o nome de um arquivo de texto existente para o qual redirecionar o fluxo de entrada padrão. O segundo é o nome de um arquivo para o qual redirecionar o fluxo de saída padrão. Este arquivo não precisa existir. Se for, o conteúdo será substituído.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newIn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Um fluxo que é a nova saída padrão.</param>
        <summary>Define a propriedade <see cref="P:System.Console.Out" /> para o objeto <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Console.Out%2A> está definida como o fluxo de saída padrão.  
  
 Um <xref:System.IO.StreamWriter> que encapsula um <xref:System.IO.FileStream> pode ser usado para enviar a saída para um arquivo. Por exemplo:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Console.SetOut%2A>. Ele substitui quatro caracteres de espaços consecutivos em uma cadeia de caracteres por um caractere de tabulação. Para executá-lo, você precisa fornecer dois argumentos de linha de comando. O primeiro é o nome de um arquivo de texto existente para o qual redirecionar o fluxo de entrada padrão. O segundo é o nome de um arquivo para o qual redirecionar o fluxo de saída padrão. Este arquivo não precisa existir. Se for, o conteúdo será substituído.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="newOut" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">A posição de coluna do canto superior esquerdo da janela do console.</param>
        <param name="top">A posição da linha do canto superior esquerdo da janela do console.</param>
        <summary>Define a posição da janela do console em relação ao buffer da tela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A janela do sistema operacional exibe a janela do console e a janela de console exibe uma parte do buffer da tela. O <xref:System.Console.SetWindowPosition%2A> método afeta a posição da janela do console em relação ao buffer da tela, mas não afeta a posição da janela do sistema operacional em relação a área de trabalho.  
  
 O console e o sistema operacional windows geralmente não afetam uns aos outros. No entanto, se o buffer da tela não pode ser exibido nos limites do atuais da janela do console, o sistema operacional anexa automaticamente barras de rolagem para a janela do sistema operacional. Nesse caso, mover as barras de rolagem da janela de sistema operacional que afeta a posição da janela do console e movendo a janela de console com o <xref:System.Console.SetWindowPosition%2A> método afeta a posição das barras de rolagem de janela de sistema operacional.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, e <xref:System.Console.CursorVisible%2A> , propriedades e o <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, e <xref:System.Console.ReadKey%2A> métodos. O exemplo desenha um padrão de grade no buffer da tela com base na largura do buffer da tela. Em seguida, o exemplo move a janela do console em resposta ao qual da seta para cima, seta para a direita, seta para a esquerda ou seta para baixo chaves de console é pressionado. O padrão de grade ajuda você a ver a movimentação da janela do console em relação ao buffer da tela.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="left" /> ou <paramref name="top" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" />é maior do que <see cref="P:System.Console.BufferWidth" />.  
  
 -ou-  
  
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" />é maior do que <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">A largura da janela do console medida em colunas.</param>
        <param name="height">A altura da janela do console medida em linhas.</param>
        <summary>Define a altura e largura da janela do console com os valores especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.SetWindowSize%2A> método e o <xref:System.Console.WindowWidth%2A> e <xref:System.Console.WindowHeight%2A> propriedades. Você deve executar o exemplo para ver o efeito total de alterar o tamanho da janela de console.  
  
 O exemplo informa as dimensões de uma janela de console definido como 43 linhas e colunas de 85 e aguarda até que uma chave seja pressionado. Quando uma tecla é pressionada, as dimensões da janela do console são reduzido à metade, as novas dimensões são relatadas e o exemplo aguarda até que outra tecla. Finalmente, quando uma tecla é pressionada, a janela do console é restaurada para dimensões originais e o exemplo termina.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="width" /> ou <paramref name="height" /> é menor ou igual a zero.  
  
 -ou-  
  
 <paramref name="width" /> mais <see cref="P:System.Console.WindowLeft" /> ou <paramref name="height" /> mais <see cref="P:System.Console.WindowTop" /> é maior ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 <paramref name="width" /> ou <paramref name="height" /> é maior do que a maior largura ou altura de janela possível da fonte do console e resolução de tela atual.</exception>
        <exception cref="T:System.Security.SecurityException">O usuário não tem permissão para executar essa ação.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o título a ser exibido na barra de título do console.</summary>
        <value>A cadeia de caracteres a ser exibida na barra de título do console. O comprimento máximo da cadeia de caracteres de título é de 24.500 caracteres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.Title%2A> propriedade. O exemplo exibe o título atual da janela do sistema operacional, aguarda um pressionamento de tecla e exibe um novo título.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Em uma operação get, o título recuperado tem mais de 24.500 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Em uma operação set, o título especificado tem mais de 24.500 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">Em uma operação set, o título especificado é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a combinação da tecla modificadora <see cref="F:System.ConsoleModifiers.Control" /> e da chave do console <see cref="F:System.ConsoleKey.C" /> (Ctrl + C) é tratada como uma entrada comum ou como uma interrupção tratada pelo sistema operacional.</summary>
        <value>
          <see langword="true" /> se Ctrl + C for tratado como uma entrada comum; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor de <xref:System.Console.TreatControlCAsInput%2A> é de propriedade `false` e Ctrl + C é pressionado, as teclas pressionadas não são armazenadas no buffer de entrada e o sistema operacional encerra o processo em execução no momento. Este é o valor padrão.  
  
> [!CAUTION]
>  Use esta propriedade criteriosamente porque sua definição como `true` tem um efeito dramático tal. A maioria dos usuários espera Ctrl + C para encerrar um aplicativo de console. Se você desabilitar o efeito de Ctrl + C, o usuário deve se lembrar usar Ctrl + Break para finalizar o aplicativo, que é uma combinação de teclas menos conhecida.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.TreatControlCAsInput%2A> propriedade.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Não é possível obter ou definir o modo de entrada do buffer de entrada do console.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura da área da janela do console.</summary>
        <value>A altura da janela do console medida em linhas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentativa de definir o valor da <xref:System.Console.WindowHeight%2A> propriedade quando a saída é redirecionada gera um <xref:System.ArgumentOutOfRangeException> ou um <xref:System.IO.IOException> exceção. Para impedir que uma exceção, você pode definir essa propriedade somente se o valor de <xref:System.Console.IsOutputRedirected%2A> propriedade retorna `false`.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.SetWindowSize%2A> método e o <xref:System.Console.WindowWidth%2A> e <xref:System.Console.WindowHeight%2A> propriedades. Você deve executar o exemplo para ver o efeito total de alterar o tamanho da janela de console.  
  
 O exemplo informa as dimensões de uma janela de console definido como 43 linhas e colunas de 85 e aguarda um pressionamento de tecla. Quando uma tecla é pressionada, as dimensões da janela do console são reduzido à metade, as novas dimensões são relatadas e o exemplo aguarda até que outra tecla. Finalmente, quando uma tecla é pressionada a janela do console é restaurada para dimensões originais e o exemplo termina.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor da propriedade <see cref="P:System.Console.WindowWidth" /> ou o valor da propriedade <see cref="P:System.Console.WindowHeight" /> é menor ou igual a 0.  
  
 -ou-  
  
 O valor da propriedade <see cref="P:System.Console.WindowHeight" /> mais o valor da propriedade <see cref="P:System.Console.WindowTop" /> é menor ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 O valor da propriedade <see cref="P:System.Console.WindowWidth" /> ou o valor da propriedade <see cref="P:System.Console.WindowHeight" /> é maior do que a maior altura ou largura de janela possível para a fonte de console e resolução de tela atual.</exception>
        <exception cref="T:System.IO.IOException">Erro na leitura ou na gravação das informações.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição mais à esquerda da área da janela do console em relação ao buffer da tela.</summary>
        <value>A posição da janela de console mais à esquerda medida em colunas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O console representa uma janela retangular em uma área retangular de buffer maior. A janela e o buffer são medidos verticalmente pelo número de linhas e horizontalmente pelo número de colunas. As dimensões da área de buffer são definidas pelo <xref:System.Console.BufferHeight%2A> e <xref:System.Console.BufferWidth%2A> propriedades. As dimensões da área do console são definidas pelo <xref:System.Console.WindowHeight%2A> e <xref:System.Console.WindowWidth%2A> propriedades. O <xref:System.Console.WindowLeft%2A> propriedade determina qual coluna da área de buffer é exibida na primeira coluna da janela do console. O valor de <xref:System.Console.WindowLeft%2A> propriedade pode variar de 0 a <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Tentativa de defini-lo como um valor fora do que o intervalo lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Quando uma janela de console abre pela primeira vez, o valor padrão de <xref:System.Console.WindowLeft%2A> propriedade é zero, o que indica que a primeira coluna mostrada pelo console corresponde à primeira coluna (a coluna na posição zero) na área de buffer. A largura padrão da janela do console e a área de buffer é 80 colunas. Isso significa que o <xref:System.Console.WindowLeft%2A> propriedade pode ser modificada apenas se a janela do console é feita mais estreita ou da área de buffer é feita mais ampla.  
  
 Observe que, se a largura da área de buffer excede a largura da janela do console, o valor da <xref:System.Console.WindowLeft%2A> propriedade é ajustada automaticamente quando o usuário usa a barra de rolagem horizontal para definir a relação da janela para a área de buffer.  
  
 Tentativa de definir o valor da <xref:System.Console.WindowLeft%2A> propriedade quando a saída é redirecionada lança um <xref:System.IO.IOException> exceção. Para evitar a exceção, você pode definir essa propriedade somente se o valor de <xref:System.Console.IsOutputRedirected%2A> propriedade retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir abre uma janela de console 80-coluna e define uma área de buffer é 120 largura de colunas. Ele exibe informações sobre a janela de tamanho e aguarda até que o usuário pressione a tecla de seta para a esquerda ou a tecla de seta para a direita. No primeiro caso, ele diminui o valor da <xref:System.Console.WindowLeft%2A> propriedade por um se o resultado é um valor válido. No último caso, aumenta o valor de <xref:System.Console.WindowLeft%2A> propriedade por um se o resultado seria legal. Observe que o exemplo não precisa lidar com um <xref:System.ArgumentOutOfRangeException>, pois ele verifica se o valor a ser atribuído ao <xref:System.Console.WindowLeft%2A> propriedade não é negativa e não faz com que a soma da <xref:System.Console.WindowLeft%2A> e <xref:System.Console.WindowWidth%2A> propriedades exceda o <xref:System.Console.BufferWidth%2A> valor da propriedade.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Em uma operação de conjuntos, o valor a ser atribuído é menor que zero.  
  
 -ou-  
  
 Como resultado da atribuição, a soma de <see cref="P:System.Console.WindowLeft" /> e <see cref="P:System.Console.WindowWidth" /> excederá <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Erro na leitura ou na gravação das informações.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição superior da área da janela do console em relação ao buffer da tela.</summary>
        <value>A posição da janela do console superior é medida em linhas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O console representa uma janela retangular em uma área retangular de buffer maior. A janela e o buffer são medidos verticalmente pelo número de linhas e horizontalmente pelo número de colunas. As dimensões da área de buffer são definidas pelo <xref:System.Console.BufferHeight%2A> e <xref:System.Console.BufferWidth%2A> propriedades. As dimensões da área do console são definidas pelo <xref:System.Console.WindowHeight%2A> e <xref:System.Console.WindowWidth%2A> propriedades. O <xref:System.Console.WindowTop%2A> propriedade determina qual linha da área de buffer é exibida na primeira coluna da janela do console. O valor de <xref:System.Console.WindowTop%2A> propriedade pode variar de 0 a <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Tentativa de defini-lo como um valor fora do que o intervalo lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Tentativa de definir o valor da <xref:System.Console.WindowTop%2A> propriedade quando a saída é redirecionada lança um <xref:System.IO.IOException> exceção. Para evitar a exceção, você pode definir essa propriedade somente se o valor de <xref:System.Console.IsOutputRedirected%2A> propriedade retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, e <xref:System.Console.CursorVisible%2A> , propriedades e o <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, e <xref:System.Console.ReadKey%2A> métodos. O exemplo desenha um padrão de grade no buffer da tela com base na largura do buffer da tela. Em seguida, o exemplo move a janela do console em resposta ao qual da seta para cima, seta para a direita, seta para a esquerda ou seta para baixo chaves de console é pressionado. O padrão de grade ajuda você a ver a movimentação da janela do console em relação ao buffer da tela.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Em uma operação de conjuntos, o valor a ser atribuído é menor que zero.  
  
 -ou-  
  
 Como resultado da atribuição, a soma de <see cref="P:System.Console.WindowTop" /> e <see cref="P:System.Console.WindowHeight" /> excederá <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Erro na leitura ou na gravação das informações.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a largura da janela do console.</summary>
        <value>A largura da janela do console medida em colunas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tentativa de definir o valor da <xref:System.Console.WindowWidth%2A> propriedade quando a saída é redirecionada gera um <xref:System.ArgumentOutOfRangeException> ou um <xref:System.IO.IOException> exceção. Para impedir que uma exceção, você pode definir essa propriedade somente se o valor de <xref:System.Console.IsOutputRedirected%2A> propriedade retorna `false`.  
  
   
  
## Examples  
 Este exemplo demonstra o <xref:System.Console.SetWindowSize%2A> método e o <xref:System.Console.WindowWidth%2A> e <xref:System.Console.WindowHeight%2A> propriedades. Você deve executar o exemplo para ver o efeito total de alterar o tamanho da janela de console.  
  
 O exemplo informa as dimensões de uma janela de console definido como 43 linhas e colunas de 85 e aguarda um pressionamento de tecla. Quando uma tecla é pressionada, as dimensões da janela do console são reduzido à metade, as novas dimensões são relatadas e o exemplo aguarda até que outra tecla. Finalmente, quando uma tecla é pressionada a janela do console é restaurada para dimensões originais e o exemplo termina.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor da propriedade <see cref="P:System.Console.WindowWidth" /> ou o valor da propriedade <see cref="P:System.Console.WindowHeight" /> é menor ou igual a 0.  
  
 -ou-  
  
 O valor da propriedade <see cref="P:System.Console.WindowHeight" /> mais o valor da propriedade <see cref="P:System.Console.WindowTop" /> é menor ou igual a <see cref="F:System.Int16.MaxValue" />.  
  
 -ou-  
  
 O valor da propriedade <see cref="P:System.Console.WindowWidth" /> ou o valor da propriedade <see cref="P:System.Console.WindowHeight" /> é maior do que a maior altura ou largura de janela possível para a fonte de console e resolução de tela atual.</exception>
        <exception cref="T:System.IO.IOException">Erro na leitura ou na gravação das informações.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor booliano especificado, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é produzido chamando <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, que gera o <xref:System.Boolean.TrueString?displayProperty=nameWithType> ou <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava o valor do caractere Unicode especificado no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de caracteres Unicode.</param>
        <summary>Grava a matriz de caracteres Unicode especificada no fluxo de saída padrão.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor <see cref="T:System.Decimal" /> especificado, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é produzido chamando <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor de ponto flutuante de precisão dupla especificado no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Double.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro com sinal de 32 bits no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro assinado de 64 bits especificado para o fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Int64.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado ou <see langword="null" />.</param>
        <summary>Grava a representação de texto do objeto especificado no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` é `null`, nada será gravado e nenhuma exceção é lançada. Caso contrário, o `ToString` método `value` é chamado para gerar sua representação de cadeia de caracteres, e a cadeia de caracteres resultante é gravada para o fluxo de saída padrão.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor de ponto flutuante de precisão simples especificado no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Single.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava o valor da cadeia de caracteres especificada no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor é `null`, nada é gravado para o fluxo de saída padrão.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro sem sinal de 32 bits especificado no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro sem sinal de 64 bits no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">Um objeto a ser gravado usando <c>formato</c>.</param>
        <summary>Grava a representação de texto do objeto especificado no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o método `WriteLine` para demonstrar os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir ilustra o uso do método <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg">Uma matriz de objetos a serem gravados usando <c>formato</c>.</param>
        <summary>Grava a representação de texto da matriz de objetos especificada, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O `arg` parâmetro é uma matriz de parâmetros. Argumentos podem ser passados para o método como uma matriz ou lista de cinco ou mais itens. Os exemplos ilustram as duas formas de chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir define um `Person` classe com um número de propriedades que fornecem informações sobre uma pessoa. Seu `GetDescription` método retorna uma matriz que contém todos os valores de propriedade exceto um. O exemplo usa a matriz retornada pelo `GetDescription` método para exibir os valores do objeto Person.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Observe que o exemplo chama o <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> método em vez de <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> método porque ele tenta exibir o valor da `Person.Remarks` propriedade na mesma linha. Para fazer isso, ele examina o valor de <xref:System.Console.CursorLeft%2A> e <xref:System.Console.WindowWidth%2A> propriedades para determinar se há espaço suficiente para o comentário caber.  Se houver, ele exibe a linha. Caso contrário, ele grava uma linha, recua três espaços e exibe o comentário.  
  
 O exemplo a seguir é idêntico ao primeiro, exceto que ele fornece uma lista de cinco itens como o `arg` argumento em vez de uma matriz de parâmetros.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="arg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Este método não é chamado pelo código C++. O compilador do C++ resolve chamadas para [System.Console.Write](xref:System.Console.Write*) que incluem uma cadeia de caracteres e uma lista de quatro ou mais parâmetros de objeto como uma chamada para <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Ele resolve chamadas para [System.Console.Write](xref:System.Console.Write*) que incluem uma cadeia de caracteres e uma matriz de objetos como uma chamada para <see cref="M:System.Console.Write(System.String,System.Object)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de caracteres Unicode.</param>
        <param name="index">A posição inicial no <c>buffer</c>.</param>
        <param name="count">O número de caracteres a serem gravados.</param>
        <summary>Grava a submatriz especificada de caracteres Unicode no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método grava `count` caracteres começando na posição `index` de `buffer` ao fluxo de saída padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          A soma de <paramref name="index" /> e <paramref name="count" /> especifica uma posição que não está no <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o método `WriteLine` para demonstrar os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <param name="arg2">O terceiro objeto gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o método `WriteLine` para demonstrar os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir ilustra o uso do método `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <param name="arg2">O terceiro objeto gravar usando <c>formato</c>.</param>
        <param name="arg3">O quarto objeto gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados e a lista de parâmetros de tamanho variável no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API não compatível com CLS. A alternativa compatível com CLS é <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Os compiladores c# e Visual Basic resolver automaticamente uma chamada para esse método como uma chamada para <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de parâmetros variáveis com o <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método. O método é chamado com uma cadeia de caracteres de formato composto e cinco itens de formato.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Este método é marcado com o <see langword="vararg" /> palavra-chave, o que significa que ele oferece suporte a um número variável de parâmetros. O método pode ser chamado do Visual C++, mas ele não pode ser chamado de código c# ou Visual Basic. Os compiladores c# e Visual Basic resolver chamadas a <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> como chamadas para <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava os dados especificados, seguidos por um terminador de linha atual, para o fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é uma cadeia de caracteres cujo valor é um retorno de carro seguido por uma alimentação de linha ("\r\n" em c#, ou `vbCrLf` no Visual Basic). Você pode alterar o terminador de linha, definindo o <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriedade o <xref:System.Console.Out%2A> propriedade para outra cadeia de caracteres.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Grava o terminador de linha atual no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é uma cadeia de caracteres cujo valor é um retorno de carro seguido por uma alimentação de linha ("\r\n" em c#, ou `vbCrLf` no Visual Basic). Você pode alterar o terminador de linha, definindo o <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> propriedade o <xref:System.Console.Out%2A> propriedade para outra cadeia de caracteres. O exemplo fornece uma ilustração.  
  
   
  
## Examples  
 O exemplo altera o terminador de linha de seu valor padrão de "\r\n" ou `vbCrLf` para "\r\n\r\n" ou `vbCrLf`  +  `vbCrLf`. Depois, ele chama o <xref:System.Console.WriteLine> e <xref:System.Console.WriteLine%28System.String%29> métodos para exibir a saída para o console.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor booliano especificado, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir gera dez inteiros aleatórios e usa o <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> método para indicar se eles ainda são.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava o caractere Unicode especificado, seguido por um terminador de linha atual, valor para o fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de caracteres Unicode.</param>
        <summary>Grava a matriz especificada de caracteres Unicode, seguida por um terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor <see cref="T:System.Decimal" /> especificado, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor de ponto flutuante de precisão dupla, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Double.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro com sinal de 32 bits, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro com sinal de 64 bits, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Int64.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do objeto especificado, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for `null`, o terminador de linha será gravado. Caso contrário, o `ToString` método `value` é chamado para gerar sua representação de cadeia de caracteres, e a cadeia de caracteres resultante é gravada para o fluxo de saída padrão.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Console.WriteLine%28System.Object%29> método para exibir cada valor em uma matriz de objeto para o console.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor de ponto flutuante de precisão simples, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.Single.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava o valor de cadeia de caracteres especificado, seguido pelo terminador de linha atual para o fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor é `null`, o terminador de linha é gravado para o fluxo de saída padrão.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção comentários a <xref:System.Console.WriteLine> método.  
  
   
  
## Examples  
 O exemplo altera o terminador de linha de seu valor padrão de "\r\n" ou `vbCrLf` para "\r\n\r\n" ou `vbCrLf`  +  `vbCrLf`. Depois, ele chama o <xref:System.Console.WriteLine> e <xref:System.Console.WriteLine%28System.String%29> métodos para exibir a saída para o console.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro sem sinal de 32 bits especificado, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser gravado.</param>
        <summary>Grava a representação de texto do valor inteiro sem sinal de 64 bits especificado, seguido do terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A representação de `value` é gerado por chamar o <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">Um objeto a ser gravado usando <c>formato</c>.</param>
        <summary>Grava a representação de texto do objeto especificado, seguido de um terminador de linha atual, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> método para exibir cinco gerado aleatoriamente <xref:System.Boolean> valores.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 A exemplo a seguir chama o <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> método para exibir a data atual.   Observe que o formato de item de `format` argumento usa "D" [cadeia de caracteres de formato de data e hora padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) para exibir a data no formato de data por extenso da cultura atual.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg">Uma matriz de objetos a serem gravados usando <c>formato</c>.</param>
        <summary>Grava a representação de texto da matriz de objetos especificada, seguido por um terminador de linha atual, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="arg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Este método não é chamado pelo código C++. O compilador do C++ resolve chamadas para [System.Console.WriteLine](xref:System.Console.WriteLine*) que incluem uma cadeia de caracteres e uma lista de quatro ou mais parâmetros de objeto como uma chamada para <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Ele resolve chamadas para [System.Console.WriteLine](xref:System.Console.WriteLine*) que incluem uma cadeia de caracteres e uma matriz de objetos como uma chamada para <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de caracteres Unicode.</param>
        <param name="index">A posição inicial no <c>buffer</c>.</param>
        <param name="count">O número de caracteres a serem gravados.</param>
        <summary>Grava a submatriz especificada de caracteres Unicode, seguida por um terminador de linha atual, no fluxo de saída padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método grava `count` caracteres começando na posição `index` de `buffer` ao fluxo de saída padrão.  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          A soma de <paramref name="index" /> e <paramref name="count" /> especifica uma posição que não está no <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados, seguido de um terminador de linha atual, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <param name="arg2">O terceiro objeto gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados, seguido de um terminador de linha atual, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os especificadores de formatação padrão para números, datas e enumerações.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 O exemplo a seguir é uma calculadora de gorjetas que calcula uma gorjeta de 18% e usa o método <xref:System.Console.WriteLine%2A> para exibir o valor da cobrança original, o valor da gorjeta e o valor total. O exemplo é um aplicativo de console que requer que o usuário forneça o valor da cobrança original como um parâmetro de linha de comando.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a gravar usando <c>formato</c>.</param>
        <param name="arg1">O segundo objeto a gravar usando <c>formato</c>.</param>
        <param name="arg2">O terceiro objeto gravar usando <c>formato</c>.</param>
        <param name="arg3">O quarto objeto gravar usando <c>formato</c>.</param>
        <summary>Grava a representação de texto dos objetos especificados e a lista de parâmetros de tamanho variável, seguido do terminador de linha atual, no fluxo de saída padrão usando as informações de formato especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API não compatível com CLS. A alternativa compatível com CLS é <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Os compiladores c# e Visual Basic resolver automaticamente uma chamada para esse método como uma chamada para <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação em uma cadeia de caracteres. A cadeia de caracteres resultante é gravada no fluxo de saída.  
  
 O parâmetro `format` consiste em zero ou mais execuções de texto combinadas com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem a um objeto na lista de parâmetros desse método. O processo de formatação substitui cada item de formato pela representação de texto do valor do objeto correspondente.  
  
 A sintaxe de um item de formato é `{` *índice*[`,`*alinhamento*] [`:`*formatString*]`}`, que especifica um índice obrigatório, o comprimento opcional e o alinhamento do texto formatado, e uma cadeia opcional de caracteres de especificadores de formato que controlam como o valor do objeto é formatada.  
  
 O .NET Framework fornece suporte extenso à formatação, que é descrito com mais detalhes nos tópicos de formatação a seguir.  
  
-   Para obter mais informações sobre o recurso de formatação composta suportada pelos métodos como <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>e alguns sobrecargas de <xref:System.Console.WriteLine%2A>, consulte [formatação composta](~/docs/standard/base-types/composite-formatting.md).  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre data e hora especificadores de formato, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter mais informações sobre especificadores de formato de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Para obter mais informações sobre o terminador de linha, consulte a seção Comentários do método <xref:System.Console.WriteLine%2A> que não usa parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de argumentos variáveis com o <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método. O método é chamado com uma cadeia de caracteres de formato composto e cinco itens de formato.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">A especificação de formato em <paramref name="format" /> é inválida.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para modificar janelas e subjanelas de nível superior seguras. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Este método é marcado com o <see langword="vararg" /> palavra-chave, o que significa que ele oferece suporte a um número variável de parâmetros. O método pode ser chamado do Visual C++, mas ele não pode ser chamado de código c# ou Visual Basic. Os compiladores c# e Visual Basic resolver chamadas a <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> como chamadas para <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
