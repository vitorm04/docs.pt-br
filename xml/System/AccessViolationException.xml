<Type Name="AccessViolationException" FullName="System.AccessViolationException">
  <TypeSignature Language="C#" Value="public class AccessViolationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit AccessViolationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.AccessViolationException" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A exceção gerada quando há uma tentativa de ler ou gravar a memória protegida.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma violação de acesso ocorre em código não gerenciado ou não seguro quando o código tenta ler ou gravar em memória que não foi alocada, ou para a qual ele não tem acesso. Isso geralmente ocorre porque um ponteiro tem um valor inválido. Nem todas as leituras ou gravações por ponteiros incorretos resultam em violações de acesso, de modo que uma violação de acesso geralmente indica que várias leituras ou gravações ocorreram por ponteiros incorretos, e que a memória pode estar corrompida. Assim, violações de acesso quase sempre indicam erros graves de programação. Um <xref:System.AccessViolationException> identifica claramente esses erros graves.  
  
 Em programas que consistam inteiramente de código gerenciado verificável, todas as referências são válidas ou nulo e violações de acesso são impossíveis. Qualquer operação que tenta referenciar uma referência nula no código verificável lança um <xref:System.NullReferenceException> exceção. Um <xref:System.AccessViolationException> ocorre somente quando o código gerenciado verificável interage com código não gerenciado ou código gerenciado não seguro.  
  
## <a name="troubleshooting-accessviolationexception-exceptions"></a>Exceções de solução de problemas AccessViolationException  
 Um <xref:System.AccessViolationException> exceção pode ocorrer apenas em código gerenciado não seguro ou ao gerenciados verificável código interage com código não gerenciado:  
  
-   Uma violação de acesso que ocorre em código gerenciado não seguro pode ser expresso como um <xref:System.NullReferenceException> exceção ou um <xref:System.AccessViolationException> exceção, dependendo da plataforma.  
  
-   Uma violação de acesso em código não gerenciado animado para código gerenciado sempre é encapsulada em um <xref:System.AccessViolationException> exceção.  
  
 Em ambos os casos, você pode identificar e corrigir a causa do <xref:System.AccessViolationException> exceção da seguinte maneira:  
  
 Verifique se a memória que você está tentando acessar foi alocada.  
 Um <xref:System.AccessViolationException> exceção sempre é gerada por uma tentativa de acessar a memória protegida – ou seja, para acessar a memória que não está alocada ou que não pertence a um processo.  
  
 O gerenciamento automático de memória é um dos serviços que o Common Language Runtime fornece. Se o código gerenciado fornece a mesma funcionalidade que seu código unmanagede, talvez você queira ir para código gerenciado para tirar proveito dessa funcionalidade. Para obter mais informações, consulte [gerenciamento automático de memória](~/docs/standard/automatic-memory-management.md).  
  
 Verifique se a memória que você está tentando acessar não foi corrompida.  
 Se várias operações de leitura ou gravação ocorreram por ponteiros incorretos, a memória pode estar corrompida. Isso normalmente ocorre ao ler ou gravar para endereços fora de um buffer predefinido.  
  
## <a name="accessviolationexception-and-trycatch-blocks"></a>Blocos try/catch e de AccessViolationException  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.AccessViolationException> exceções geradas pelo common language runtime não são controladas pelo `catch` instrução em um manipulador de exceção estruturada se a exceção ocorrer fora de memória reservada pelo common language runtime. Para lidar com tais um <xref:System.AccessViolationException> exceção, você deve aplicar o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo ao método no qual a exceção é gerada. Essa alteração não afeta <xref:System.AccessViolationException> exceções geradas pelo código do usuário, que pode continuar a ser capturado por um `catch` instrução. Para código escrito para versões anteriores do .NET Framework que você deseja recompilar e executados sem modificação no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], você pode adicionar o [ \<legacyCorruptedStateExceptionsPolicy >](~/docs/framework/configure-apps/file-schema/runtime/legacycorruptedstateexceptionspolicy-element.md) elemento ao arquivo de configuração do aplicativo. Observe que você também pode receber notificação das exceções se você tiver definido um manipulador para o <xref:System.AppDomain.FirstChanceException?displayProperty=nameWithType> ou <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> eventos.  
  
## <a name="version-information"></a>Informações de versão  
 Essa exceção é lançada no .NET Framework 2.0 e versões posteriores. Em versões anteriores do .NET Framework, uma violação de acesso em código não gerenciado ou código gerenciado não seguro é representada por um <xref:System.NullReferenceException> em código gerenciado. Um <xref:System.NullReferenceException> também é lançada quando uma referência nula é referenciada no código gerenciado pode ser verificado, uma ocorrência que não envolvem a corrupção de dados, e não é possível distinguir entre as duas situações nas versões 1.0 ou 1.1.  
  
 Os administradores podem permitir que aplicativos selecionados para reverter para o comportamento do .NET Framework versão 1.1. Coloque a seguinte linha no [ &lt;tempo de execução&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) seção do arquivo de configuração para o aplicativo:  
  
```  
<legacyNullReferenceExceptionPolicy enabled = "1"/>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.AccessViolationException" /> com uma mensagem fornecida pelo sistema que descreve o erro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa o <xref:System.Exception.Message%2A> propriedade da nova instância para uma mensagem fornecida pelo sistema que descreve o erro, como "tentativa de leitura ou gravação em memória protegida. Isso geralmente é uma indicação de que outra memória está corrompida." Esta mensagem leva em conta a cultura do sistema atual.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.AccessViolationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro localizada.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.AccessViolationException" /> classe com uma mensagem especificada que descreve o erro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.AccessViolationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro especificada em `message`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AccessViolationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém os dados do objeto serializado.</param>
        <param name="context">O <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém informações contextuais sobre a fonte ou o destino.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.AccessViolationException" /> com dados serializados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado durante a desserialização para reconstituir o objeto de exceção transmitido por um fluxo. Para obter mais informações, consulte [XML e serialização SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AccessViolationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AccessViolationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem que descreve a exceção. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.</param>
        <param name="innerException">A exceção que é a causa da exceção atual. Se o <c>innerException</c> parâmetro não é <see langword="null" />, a exceção atual é gerada em um <see langword="catch" /> bloco que manipula a exceção interna.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.AccessViolationException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma exceção que é lançada como um resultado direto de uma exceção anterior deve incluir uma referência para a exceção anterior na propriedade <xref:System.Exception.InnerException%2A>. A propriedade <xref:System.Exception.InnerException%2A> retorna o mesmo valor que é passado para o construtor, ou `null` caso a propriedade <xref:System.Exception.InnerException%2A> não forneça o valor de exceção interno para o construtor.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.AccessViolationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|`null`.|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro especificada em `message`.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
