<Type Name="String" FullName="System.String">
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa o texto como uma sequência de unidades de código UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/string.cs#8281103e6f23cb5c). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Uma cadeia de caracteres é uma coleção sequencial de caracteres que é usada para representar o texto. Um <xref:System.String> objeto é uma coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos que representam uma cadeia de caracteres; um <xref:System.Char?displayProperty=nameWithType> objeto corresponde a uma unidade de código UTF-16. O valor de <xref:System.String> objeto é o conteúdo da coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos e que o valor é imutável (ou seja, ele é somente leitura). Para obter mais informações sobre a imutabilidade de cadeias de caracteres, consulte o [imutabilidade e a classe StringBuilder](#Immutability) seção mais adiante neste tópico. O tamanho máximo de um <xref:System.String> objeto na memória é de 2 GB, ou cerca de 1 bilhão de caracteres.  
  
 Nesta seção:  
  
 [Instanciar um objeto de cadeia de caracteres](#Instantiation)   
 [Objetos de caractere e caracteres Unicode](#Characters)   
 [Cadeias de caracteres e o padrão Unicode](#Unicode)   
 [Cadeias de caracteres e caracteres nulos inseridos](#EmbeddedNulls)   
 [Cadeias de caracteres e índices](#Indexes)   
 [Cadeias de caracteres nulas e cadeias de caracteres vazias](#Nulls)   
 [A imutabilidade e a classe StringBuilder](#Immutability)   
 [Ordinal versus operações sensíveis à cultura](#CultureSensitive)   
 [Normalização](#Normalization)   
 [Operações de cadeia de caracteres por categoria](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Criando uma instância de um objeto String  
 Você pode instanciar uma <xref:System.String> objeto das seguintes maneiras:  
  
-   Atribuindo uma cadeia de caracteres literal a uma <xref:System.String> variável. Este é o método mais comumente usado para criar uma cadeia de caracteres. O exemplo a seguir usa a atribuição para criar várias cadeias de caracteres. Observe que, em c#, como a barra invertida (\\) é um caractere de escape, barras invertidas literal em uma cadeia de caracteres devem ser substituídas ou a cadeia de caracteres inteira deve ser @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Chamando um <xref:System.String> construtor de classe. O exemplo a seguir cria uma instância cadeias de caracteres chamando vários construtores de classe. Observe que alguns dos construtores de incluem ponteiros para matrizes de caracteres ou matrizes de byte assinado como parâmetros. Visual Basic não dá suporte a chamadas para esses construtores. Para obter informações detalhadas sobre <xref:System.String> construtores, consulte o <xref:System.String.%23ctor%2A> construtor resumo.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Usando o operador de concatenação de cadeia de caracteres (+ em c# e & ou + no Visual Basic) para criar uma única cadeia de caracteres de qualquer combinação de <xref:System.String> instâncias e literais de cadeia de caracteres. O exemplo a seguir ilustra o uso do operador de concatenação de cadeia de caracteres.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Recuperar uma propriedade ou chamando um método que retorna uma cadeia de caracteres. O exemplo a seguir usa os métodos do <xref:System.String> classe para extrair uma subcadeia de caracteres de uma cadeia de caracteres maior.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Chamando um método para converter um valor ou objeto em sua representação de cadeia de caracteres de formatação. O exemplo a seguir usa o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso para inserir a representação de cadeia de caracteres de dois objetos em uma cadeia de caracteres.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Objetos Char e caracteres Unicode  
 Cada caractere em uma cadeia de caracteres é definido por um valor escalar de Unicode, também chamado de um ponto de código Unicode ou o valor ordinal (numérico) do caractere Unicode. Cada ponto de código é codificado usando a codificação UTF-16, e o valor numérico de cada elemento da codificação é representado por um <xref:System.Char> objeto.  
  
> [!NOTE]
>  Observe que, como um <xref:System.String> instância consiste em uma coleção sequencial de unidades de código UTF-16, é possível criar um <xref:System.String> objeto que não é uma cadeia de caracteres Unicode bem formada. Por exemplo, é possível criar uma cadeia de caracteres que tem um substituto baixo sem um substituto alto correspondente. Embora alguns métodos, como os métodos de codificação e decodificação de objetos no <xref:System.Text> namespace, pode executa verificações para garantir que as cadeias de caracteres são formadas, <xref:System.String> membros de classe não garante que uma cadeia de caracteres está bem formada.  
  
 Um único <xref:System.Char> objeto normalmente representa um único ponto de código, ou seja, o valor numérico de <xref:System.Char> é igual ao ponto de código. Por exemplo, o ponto de código para o caractere "a" é U + 0061. No entanto, um ponto de código pode exigir mais de um elemento codificado (mais de um <xref:System.Char> objeto). O padrão Unicode define dois tipos de caracteres que correspondem a vários <xref:System.Char> objetos: graphemes e pontos de código suplementares Unicode que correspondem aos caracteres planos suplementares Unicode.  
  
-   Uma grafemas é representada por um caractere base seguido por um ou mais caracteres de combinação. Por exemplo, o caractere ä é representado por um <xref:System.Char> objeto cujo ponto de código é U + 0061 seguido por um <xref:System.Char> objeto cujo ponto de código é U + 0308. Esse caractere também pode ser definido por um único <xref:System.Char> objeto que tem um ponto de código de U + 00E4. Como mostra o exemplo a seguir, uma comparação de cultura para igualdade indica que essas duas representações são iguais, embora uma comparação ordinal comum não. No entanto, se duas cadeias de caracteres são normalizadas, uma comparação ordinal também indica que eles são iguais. (Para obter mais informações sobre cadeias de caracteres de normalização, consulte o [normalização](#Normalization) seção.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode (um par substituto) do ponto de código suplementar é representado por um <xref:System.Char> objeto cujo ponto de código é um substituto alto seguido por um <xref:System.Char> objeto cujo ponto de código é um substituto baixo. As unidades de código do intervalo de substitutos alta de U + D800 a U + DBFF. As unidades de código do intervalo de substitutos baixa de U + DC00 a U + DFFF. Os pares substitutos são usados para representar caracteres de 16 planos suplementares Unicode. O exemplo a seguir cria um caractere substituto e passa para o <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> método para determinar se ele é um par substituto.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Cadeias de caracteres e o padrão Unicode  
 Caracteres em uma cadeia de caracteres são representados por unidades de código UTF-16 codificado, que correspondem aos <xref:System.Char> valores.  
  
 Cada caractere em uma cadeia de caracteres tem uma categoria de caractere Unicode associada, que é representada no .NET Framework, o <xref:System.Globalization.UnicodeCategory> enumeração. A categoria de um caractere ou um par substituto pode ser determinada chamando o <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> método.  
  
 O .NET Framework mantém sua própria tabela de caracteres e suas categorias correspondentes, que garante que uma versão do .NET Framework em execução em diferentes plataformas retorna informações de categoria de caracteres idênticos. A tabela a seguir lista as versões do .NET Framework e as versões do padrão Unicode no qual as categorias de caracteres se baseiam.  
  
|Versão do .NET Framework|Versão do padrão Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[O padrão Unicode, versão 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|O .NET Framework 2.0|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[O padrão Unicode, versão 8.0.0](http://www.unicode.org/versions/Unicode8.0.0/)|  
  
 Além disso, o .NET Framework oferece suporte à comparação de cadeia de caracteres e classificação com base no padrão Unicode. Em versões do .NET Framework por meio de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o .NET Framework mantém sua própria tabela de dados de cadeia de caracteres. Isso também é verdadeiro para versões do .NET Framework a partir de [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 7. Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 8 e versões posteriores do sistema operacional Windows, os delegados do tempo de execução de cadeia de caracteres de comparação e classificação de operações para o sistema operacional. A tabela a seguir lista as versões do .NET Framework e as versões do padrão Unicode em caracteres de comparação e ordenação se baseiam.  
  
|Versão do .NET Framework|Versão do padrão Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[O padrão Unicode, versão 4.0.0](http://www.unicode.org/versions/Unicode4.0.0/)|  
|O .NET Framework 2.0|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]e posterior no Windows 7|[O padrão Unicode, versão 5.0.0](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]e posterior no Windows 8 e sistemas operacionais Windows posteriores|[O padrão Unicode, versão 6.3.0](http://www.unicode.org/versions/Unicode6.3.0/)|  
  
<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Cadeias de caracteres e caracteres nulos inseridos  
 No .NET Framework, um <xref:System.String> objeto pode incluir caracteres nulos inseridos, que são contados como parte do comprimento da cadeia de caracteres. No entanto, em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres; ele não é considerado parte da cadeia de caracteres e não é contabilizado como parte do comprimento da cadeia de caracteres. Isso significa que as seguintes suposições comuns que os programadores de C e C++ ou bibliotecas escritas em C ou C++ podem fazer sobre cadeias de caracteres não são necessariamente válidas quando aplicado a <xref:System.String> objetos:  
  
-   O valor retornado pelo `strlen` ou `wcslen` funções não é necessariamente igual <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   A cadeia de caracteres criada pelo `strcpy_s` ou `wcscpy_s` funções não é necessariamente idêntica à cadeia de caracteres criada pelo <xref:System.String.Copy%2A?displayProperty=nameWithType> método.  
  
 Você deve garantir que código C e C++ nativo que instancia <xref:System.String> objetos e o código que é passado <xref:System.String> objetos por meio da plataforma invocar, não presuma que um caractere nulo inserido marca o fim da cadeia de caracteres.  
  
 Caracteres nulos inseridos em uma cadeia de caracteres também são tratados diferentemente quando uma cadeia de caracteres é classificada (ou comparada) e quando uma cadeia de caracteres é pesquisada. Caracteres nulos são ignorados ao executar comparações sensíveis à cultura entre duas cadeias de caracteres, inclusive comparações usando a cultura invariável. Elas são consideradas apenas para comparações ordinal ordinal ou maiusculas de minúsculas. Por outro lado, caracteres nulos inseridos sempre são considerados ao procurar uma cadeia de caracteres com métodos como <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, e <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Cadeias de caracteres e índices  
 Um índice é a posição de um <xref:System.Char> objeto (e não um caractere Unicode) em um <xref:System.String>. Um índice é um número não negativo, com base em zero que inicia na primeira posição na cadeia de caracteres, que é a posição do índice de zero. Um número de métodos de pesquisa, como <xref:System.String.IndexOf%2A> e <xref:System.String.LastIndexOf%2A>, o índice de um caractere de retorno ou subcadeia de caracteres na instância de cadeia de caracteres.  
  
 O <xref:System.String.Chars%2A> propriedade permite que você acesse individuais <xref:System.Char> objetos por sua posição de índice na cadeia de caracteres. Porque o <xref:System.String.Chars%2A> é a propriedade padrão (no Visual Basic) ou o indexador (em c#), você pode acessar o indivíduo <xref:System.Char> objetos em uma cadeia de caracteres usando código como o seguinte. Esse código procura por espaço em branco ou caracteres de pontuação em uma cadeia de caracteres para determinar quantas palavras que contém a cadeia de caracteres.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Porque o <xref:System.String> classe implementa o <xref:System.Collections.IEnumerable> interface, você também pode percorrer o <xref:System.Char> objetos em uma cadeia de caracteres usando um `foreach` construção, como mostra o exemplo a seguir.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Valores consecutivos de índice podem não corresponder aos caracteres Unicode consecutivos, como um caractere pode ser codificado em Unicode como mais de um <xref:System.Char> objeto. Em particular, uma cadeia de caracteres pode conter caracteres de várias unidades de texto que são formadas por um caractere base seguido por um ou mais caracteres de combinação ou pares substitutos. Para trabalhar com caracteres Unicode em vez de <xref:System.Char> objetos, use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> e <xref:System.Globalization.TextElementEnumerator> classes. O exemplo a seguir ilustra a diferença entre o código que funciona com <xref:System.Char> objetos e o código que funciona com caracteres Unicode. Ele compara o número de caracteres ou elementos de texto em cada palavra da frase. A cadeia de caracteres inclui duas sequências de um caractere base seguido por um caractere de combinação.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Este exemplo funciona com elementos de texto usando o <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> método e o <xref:System.Globalization.TextElementEnumerator> classe para enumerar todos os elementos de texto em uma cadeia de caracteres. Você também pode recuperar uma matriz que contém o índice inicial de cada elemento de texto chamando o <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre como trabalhar com unidades de texto em vez de um indivíduo <xref:System.Char> valores, consulte o <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Cadeias de caracteres nulas e cadeias de caracteres vazias  
 Uma cadeia de caracteres que foi declarada mas não foi atribuída um valor é `null`. Tentativa de chamar métodos em cadeia de caracteres gera um <xref:System.NullReferenceException>. Uma cadeia de caracteres nula é diferente de uma cadeia de caracteres vazia, o que é uma cadeia de caracteres cujo valor é "" ou <xref:System.String.Empty?displayProperty=nameWithType>. Em alguns casos, passando uma cadeia de caracteres nula ou uma cadeia de caracteres vazia como um argumento em uma chamada de método lançará uma exceção. Por exemplo, passar uma cadeia de caracteres nula para o <xref:System.Int32.Parse%2A?displayProperty=nameWithType> método lança um <xref:System.ArgumentNullException>e passar uma cadeia de caracteres vazia lança um <xref:System.FormatException>. Em outros casos, um argumento de método pode ser uma cadeia de caracteres nula ou uma cadeia de caracteres vazia. Por exemplo, se você estiver fornecendo um <xref:System.IFormattable> implementação de uma classe, que você deseja igualar uma cadeia de caracteres nula e uma cadeia de caracteres vazia com o especificador de formato geral ("G").  
  
 O <xref:System.String> classe inclui os seguintes métodos de dois conveniência que permitem testar se é uma cadeia de caracteres `null` ou vazio:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, que indica se uma cadeia de caracteres é `null` ou é igual a <xref:System.String.Empty?displayProperty=nameWithType>. Esse método elimina a necessidade de usar código como o seguinte:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, que indica se uma cadeia de caracteres é `null`, é igual a <xref:System.String.Empty?displayProperty=nameWithType>, ou consistir exclusivamente em vez de caracteres de espaço em branco. Esse método elimina a necessidade de usar código como o seguinte:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.String.IsNullOrEmpty%2A> método o <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação de um personalizado `Temperature` classe. O método aceita as cadeias de caracteres de formato "G", "C", "F" e "K". Se uma cadeia de caracteres de formato vazio ou um formato de cadeia de caracteres cujo valor é `null` é passado para o método, seu valor é alterado para a cadeia de caracteres de formato "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Imutabilidade e a classe StringBuilder  
 Um <xref:System.String> objeto é chamado imutável (somente leitura), porque seu valor não pode ser modificado após ele ter sido criado. Métodos que aparecem para modificar um <xref:System.String> objeto retorna um novo <xref:System.String> objeto que contém a modificação.  
  
 Como cadeias de caracteres são imutáveis, rotinas de manipulação de cadeia de caracteres que executam repetido adições ou exclusões que parece ser que uma única cadeia de caracteres pode extrair uma penalidade de desempenho significativa. Por exemplo, o código a seguir usa um gerador de número aleatório para criar uma cadeia de caracteres com o intervalo de 0x0001 para 0x052F 1000 caracteres. Embora o código parece usar concatenação de cadeia de caracteres para acrescentar um caractere de nova a cadeia de caracteres existente denominada `str`, ele cria um novo <xref:System.String> objeto para cada operação de concatenação.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Você pode usar o <xref:System.Text.StringBuilder> classe o <xref:System.String> classe para operações que fazer várias alterações para o valor de uma cadeia de caracteres. Diferentemente das instâncias da <xref:System.String> classe <xref:System.Text.StringBuilder> objetos são mutáveis; ao concatenar, acrescentar ou excluir subcadeias de caracteres de uma cadeia de caracteres, as operações são executadas em uma única cadeia de caracteres. Quando terminar de modificar o valor de um <xref:System.Text.StringBuilder> do objeto, você pode chamar seu <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para convertê-lo em uma cadeia de caracteres. O exemplo a seguir substitui o <xref:System.String> usado no exemplo anterior para concatenar 1000 caracteres aleatório no intervalo como 0x0001 para 0x052F com um <xref:System.Text.StringBuilder> objeto.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal x operações sensíveis à cultura  
 Membros de <xref:System.String> classe executar operações (linguísticas) ordinal ou sensíveis à cultura um <xref:System.String> objeto. Uma operação ordinal age no valor numérico de cada <xref:System.Char> objeto. Uma operação de cultura age no valor da <xref:System.String> objeto e usa específicos de cultura maiusculas e minúsculas, classificação, formatação e regras de análise em conta. Operações sensíveis à cultura são executadas no contexto de uma cultura explicitamente declarada ou a cultura atual implícita. Os dois tipos de operações podem produzir resultados muito diferentes quando elas são executadas na mesma cadeia de caracteres.  
  
 O .NET Framework também oferece suporte a operações de cadeia de caracteres linguística cultura usando a cultura invariável (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), que livremente com base nas configurações de cultura do idioma inglês independente da região. Ao contrário de outras <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> garantem de configurações, as configurações de cultura invariável para manter a consistência em um único computador, do sistema ao sistema e em versões do .NET Framework. A cultura invariável pode ser visto como um tipo de caixa preta que garante a estabilidade de comparações de cadeia de caracteres e ordenação em todas as culturas.  
  
> [!IMPORTANT]
>  Se seu aplicativo toma uma decisão de segurança sobre um identificador simbólico como um nome de arquivo ou pipe nomeado ou sobre dados persistentes, como os dados com base em texto em um arquivo XML, a operação deve usar uma comparação ordinal em vez de uma comparação sensíveis à cultura. Isso ocorre porque uma comparação sensíveis à cultura pode produzir resultados diferentes dependendo da cultura em vigor, enquanto uma comparação ordinal depende somente os caracteres em comparação com o valor binário.  
  
> [!IMPORTANT]
>  A maioria dos métodos que executam operações de cadeia de caracteres inclui uma sobrecarga que tem um parâmetro de tipo <xref:System.StringComparison>, que permite que você especifique se o método executa uma operação ordinal ou sensíveis à cultura. Em geral, você deve chamar essa sobrecarga para fazer com que a intenção do método de chamada clara. Para obter as práticas recomendadas e diretrizes para usar ordinais e sensíveis à cultura operações em cadeias de caracteres, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operações para [maiusculas e minúsculas](#casing), [formatação e análise](#parsing), [de comparação e ordenação](#comparison), e [testes de igualdade](#equality) pode ser um ordinal ou sensíveis à cultura. As seções a seguir abordam cada categoria de operação.  
  
> [!TIP]
>  Você sempre deve chamar uma sobrecarga de método que faz com que a intenção do método de chamada clara. Por exemplo, em vez de chamar o <xref:System.String.Compare%28System.String%2CSystem.String%29> método para executar uma comparação de cultura de duas cadeias de caracteres usando as convenções da cultura atual, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com um valor de <xref:System.StringComparison?displayProperty=nameWithType> para o `comparisonType` argumento. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
<a name="casing"></a>   
### <a name="casing"></a>Maiúsculas  
 Regras de maiusculas e minúsculas determinam como alterar a capitalização de um caractere Unicode; Por exemplo, de minúsculas em maiusculas. Geralmente, uma operação de maiusculas e minúsculas é executada antes de uma comparação de cadeia de caracteres. Por exemplo, uma cadeia de caracteres pode ser convertida em maiusculas para que ele pode ser comparado com outra cadeia de caracteres em maiusculas. Você pode converter os caracteres em uma cadeia de caracteres em minúsculas chamando o <xref:System.String.ToLower%2A> ou <xref:System.String.ToLowerInvariant%2A> método e você pode convertê-los em letras maiusculas, chamando o <xref:System.String.ToUpper%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Além disso, você pode usar o <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> método para converter uma cadeia de caracteres para maiusculas/minúsculas.  
  
 Operações de maiusculas e minúsculas podem ser baseadas nas regras de cultura atual, uma cultura específica ou a cultura invariável. Como mapeamentos de casos podem variar dependendo da cultura usada, o resultado de operações de maiusculas e minúsculas pode variar com base na cultura. As diferenças reais em maiusculas e minúsculas são de três tipos:  
  
-   Diferenças no mapeamento de caso da LETRA maiuscula de LATINO I (U + 0049), LATINO pequena LETRA I (U + 0069), LATINO LETRA maiuscula a I mesmo com ponto superior (U + 0130) e LATIN pequena LETRA sem ponto I (U + 0131). No tr-TR (turco (Turquia)) e culturas az-Latn-AZ (Azerbaijão, latino) e na tr, az e culturas neutras az Latn, o equivalente minúsculas LETRA maiuscula LATINO I é latina pequena LETRA sem ponto I e o equivalente maiusculo LATINO pequena LETRA I é MAIUSCULO LATINO I com ponto acima. Em outras culturas, incluindo a cultura invariável, LATINO pequena LETRA I e MAIUSCULO LATINO I são equivalentes em maiusculas e minúsculas.  
  
     O exemplo a seguir demonstra como uma comparação de cadeia de caracteres projetada impedir o acesso de sistema de arquivos pode falhar se ele se baseia em uma comparação de cultura não diferencia maiusculas e minúsculas. (As convenções de maiusculas e minúsculas da cultura invariável devem ter sido usadas.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Diferenças de mapeamentos de casos entre a cultura invariável e todas as outras culturas. Nesses casos, usando as regras de maiusculas e minúsculas da cultura invariável para alterar um caractere para maiusculas ou minúsculas retorna o mesmo caractere. Para todas as culturas, ele retorna um caractere diferente. Alguns dos caracteres afetados são listados na tabela a seguir.  
  
    |Caractere|Se alterado para|Retorna|  
    |---------------|-------------------|-------------|  
    |ENTRADA DE MÍCRON (U + 00B5)|Maiúsculas|LETRA GREGA MAIUSCULA MU (U +-39C)|  
    |LETRA LATINA MAIUSCULA I COM PONTO ACIMA (U + 0130)|Minúsculas|LETRA MINÚSCULA LATINA I (U + 0069)|  
    |LETRA MINÚSCULA LATINA SEM PONTO I (U + 0131)|Maiúsculas|LETRA MAIUSCULA LATINA I (U + 0049)|  
    |LETRA LATINA MINÚSCULA S LONGO (U + 017F)|Maiúsculas|LETRA MAIUSCULA LATINA S (U + 0053)|  
    |LETRA DE MAIUSCULA LATINA D COM LETRA MINÚSCULA Z COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 5)|Minúsculas|LETRA LATINA MINÚSCULA DZ COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 6)|  
    |COMBINANDO CARACTERE GREGO IOTA SUBSCRITO (U + 0345)|Maiúsculas|LETRA MAIUSCULA GREGA IOTA (U + 0399)|  
  
-   Diferenças nos mapeamentos de casos de duas letras maiusculas pares no intervalo de caracteres ASCII. Na maioria das culturas, um par de duas letras maiusculas é igual ao par equivalente duas letras maiusculo ou minúsculo. Isso não é verdade para os seguintes pares de duas letras em culturas a seguir, porque em cada caso, eles são comparados com um dígrafo:  
  
    -   "lJ" e "nJ" a cultura hr-HR (Croata (Croácia)).  
  
    -   "cH" no cs-CZ (Tcheco (República Tcheca)) e culturas sk-SK (Eslovaco (Eslováquia)).  
  
    -   "aA" na cultura da-DK (dinamarquês (Dinamarca)).  
  
    -   "cS", "dZ", "dZS", "Nova Iorque", "sZ", "tY" e "zS" cultura hu-HU (húngaro (Hungria)).  
  
    -   "cH" e "tudo" na cultura es-ES_tradnl (Espanhol (Espanha, classificação tradicional)).  
  
    -   "cH", "gI", "kH", "nG" "nH", "pH", "ou", "tH" e "tR" cultura vi-VN (vietnamita (Vietnã)).  
  
     No entanto, é incomum encontrar uma situação em que uma comparação sensíveis à cultura desses pares cria problemas, porque esses pares são incomuns em cadeias de caracteres fixas ou identificadores.  
  
 O exemplo a seguir ilustra algumas das diferenças nas regras de maiusculas e minúsculas entre culturas ao converter cadeias de caracteres em maiusculas.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Análise e formatação  
 Formatação e análise são operações inversas. Regras de formatação determinam como converter um valor, como uma data e hora ou um número, em sua representação de cadeia de caracteres, enquanto as regras de análise determinam como converter uma representação de cadeia de caracteres em um valor como uma data e hora. Tanto a formatação e regras de análise são dependentes convenções culturais. O exemplo a seguir ilustra a ambiguidade que pode surgir ao interpretar uma cadeia de caracteres de data específicos de cultura. Sem saber as convenções de cultura que foi usado para gerar uma cadeia de caracteres de data, não é possível saber se 01/03/2011, 1/3/2011 e 01/03/2011 representam 3 de janeiro de 2011 ou 1 de março de 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Da mesma forma, como mostra o exemplo a seguir, uma única cadeia de caracteres pode produzir datas diferentes dependendo da cultura cujas convenções são usadas na operação de análise.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Comparação da cadeia de caracteres e classificação  
 Convenções para comparação e classificação de cadeias de caracteres variam de culturas. Por exemplo, a ordem de classificação pode se basear fonética ou a representação visual dos caracteres. Idiomas do Leste Asiático, caracteres são classificados por um traço e radical de ideogramas. Também classificação depende das linguagens de ordem e culturas usam para o alfabeto. Por exemplo, o idioma dinamarquês tem um caractere "Æ" que classifica depois de "Z" no alfabeto. Além disso, as comparações podem ser diferencia maiusculas de minúsculas ou maiusculas de minúsculas e, em alguns casos regras de maiusculas e minúsculas também diferem pela cultura. Comparação ordinal, por outro lado, usa os pontos de código Unicode dos caracteres individuais em uma cadeia de caracteres quando a comparação e classificação de cadeias de caracteres.  
  
 Regras de classificação determinam que a ordem alfabética de caracteres Unicode e como duas cadeias de caracteres são comparados. Por exemplo, o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método compara duas cadeias de caracteres com base no <xref:System.StringComparison> parâmetro. Se o valor do parâmetro é <xref:System.StringComparison?displayProperty=nameWithType>, o método executa uma comparação linguística que usa as convenções da cultura atual; se o valor do parâmetro for <xref:System.StringComparison?displayProperty=nameWithType>, o método executa uma comparação ordinal. Consequentemente, como mostra o seguinte exemplo, se a cultura atual é dos EUA Inglês, a primeira chamada para o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método (usando a comparação sensíveis à cultura) considera "a" menor que "A", mas a segunda chamada para o mesmo método (usando a comparação ordinal) considera "a" maior que "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 O .NET Framework dá suporte a regras de classificação ordinal, cadeia de caracteres e palavras:  
  
-   Uma classificação do word executa uma comparação de sensíveis à cultura de cadeias de caracteres na qual determinados caracteres Unicode não alfanuméricos podem ter especiais pesos atribuídos a eles. Por exemplo, o hífen (-) pode ter um peso muito pequeno atribuído a ele para que "cooperação" e "cooperação" aparecem ao lado do outro em uma lista classificada. Para obter uma lista da <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação do word, consulte o [operações de cadeia de caracteres por categoria](#ByCategory) seção.  
  
-   Um tipo de cadeia de caracteres também executa uma comparação sensíveis à cultura. É semelhante a uma classificação de palavra, exceto que não há nenhum casos especiais e todos os símbolos não alfanuméricos vir antes de todos os caracteres alfanuméricos de Unicode. Duas cadeias de caracteres podem ser comparadas usando regras de classificação de cadeia de caracteres chamando o <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> sobrecargas do método que tem um `options` parâmetro que é fornecido um valor de <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Observe que esse é o único método que o .NET Framework fornece para comparar duas cadeias de caracteres usando regras de classificação de cadeia de caracteres.  
  
-   Uma classificação ordinal compara cadeias de caracteres com base no valor numérico de cada <xref:System.Char> objeto na cadeia de caracteres. Uma comparação ordinal diferencia automaticamente porque as versões maiusculas e minúsculas de um caractere têm pontos de código diferentes. No entanto, se o caso não seja importante, você pode especificar uma comparação ordinal que diferencia maiusculas de minúsculas. Isso é equivalente à conversão de cadeia de caracteres em maiusculas usando a cultura invariável e, em seguida, executar uma comparação ordinal no resultado. Para obter uma lista da <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação ordinal, consulte o [operações de cadeia de caracteres por categoria](#ByCategory) seção.  
  
 Uma comparação sensíveis à cultura é qualquer comparação que usa explicitamente ou implicitamente um <xref:System.Globalization.CultureInfo> objeto, incluindo a cultura invariável é especificada pelo <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propriedade. A cultura implícita é a cultura atual, que é especificada pelo <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedades. Há uma variação considerável na ordem de classificação de caracteres alfabéticos (isto é, caracteres para o qual o <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> propriedade retorna `true`) entre culturas. Você pode especificar uma comparação de cultura que usa as convenções de uma cultura específica, fornecendo um <xref:System.Globalization.CultureInfo> o objeto para um método de comparação de cadeia de caracteres, como <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Você pode especificar uma comparação de cultura que usa as convenções da cultura atual, fornecendo <xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, ou qualquer membro do <xref:System.Globalization.CompareOptions> enumeração diferente <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> ou <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.String.Compare%2A> método. Uma comparação sensíveis à cultura é geralmente adequada para classificação enquanto uma comparação ordinal não é. Uma comparação ordinal geralmente é apropriada para determinar se duas cadeias de caracteres são iguais (ou seja, para determinar a identidade) enquanto uma comparação sensíveis à cultura não é.  
  
 O exemplo a seguir ilustra a diferença entre a comparação de cultura e ordinal. O exemplo será avaliado três cadeias de caracteres, "Apple", "Æble" e "AEble", usando as convenções de culturas da-DK e en-US e de comparação ordinal (cada um deles é a cultura padrão no momento em que o <xref:System.String.Compare%2A> método é chamado). Como o idioma dinamarquês trata o caractere "Æ" como uma letra individual e classifica os dados depois de "Z" no alfabeto, a cadeia de caracteres "Æble" é maior que "Apple". No entanto, "Æble" não é equivalente a "AEble", "Æble" também é maior que "AEble". A cultura en-US não inclui a letra "Æ", mas a trata como equivalente a "AE", que explica por que "Æble" é menor que "Apple" mas igual a "AEble". Comparação ordinal, por outro lado, considera "Apple" para ser menor do que "Æble" e "Æble" para ser maior que "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Use as seguintes diretrizes gerais para escolher um método de comparação de classificação ou de cadeia de caracteres apropriado:  
  
-   Se desejar que as cadeias de caracteres a ser ordenadas com base na cultura do usuário, você deve pedir acordo com as convenções da cultura atual. Se a cultura do usuário for alterado, a ordem de classificação cadeias de caracteres também alterará adequadamente. Por exemplo, um aplicativo de dicionário de sinônimos deve sempre ser classificada palavras com base na cultura do usuário.  
  
-   Se você quiser as cadeias de caracteres a ser ordenadas com base na convenção de uma cultura específica, ordene-as, fornecendo um <xref:System.Globalization.CultureInfo> objeto que representa essa cultura para um método de comparação. Por exemplo, em um aplicativo projetado para ensinar aos alunos um idioma específico, você deseja cadeias de caracteres a ser ordenadas com base na convenção de uma das culturas que faz esse idioma.  
  
-   Se você quiser que a ordem das cadeias de caracteres permanecem inalterados entre culturas, deve ordene-as com base nas convenções da cultura invariável ou usar uma comparação ordinal. Por exemplo, você usaria uma classificação ordinal para organizar os nomes de arquivos, processos, mutexes ou pipes nomeados.  
  
-   Para obter uma comparação que envolve uma decisão de segurança (como se um nome de usuário é válido), você deve sempre executar um ordinal testar a igualdade chamando uma sobrecarga de <xref:System.String.Equals%2A> método.  
  
> [!NOTE]
>  A classificação de cultura e as regras usadas na comparação de cadeia de caracteres de maiusculas e minúsculas dependem da versão do .NET Framework. No [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no [!INCLUDE[win8](~/includes/win8-md.md)] sistema operacional, classificação, de maiusculas e minúsculas, normalização e informações de caractere Unicode em conformidade com o padrão Unicode 6.0. Em outros sistemas operacionais, ele segue o padrão Unicode 5.0.  
  
 Para obter mais informações sobre regras de classificação ordinal, cadeia de caracteres e palavras, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tópico. Para obter recomendações adicionais sobre quando usar cada regra, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Em geral, você não chama cadeia de caracteres de métodos de comparação como <xref:System.String.Compare%2A> diretamente para determinar a ordem de classificação de cadeias de caracteres. Em vez disso, os métodos de comparação são chamados por métodos de classificação como <xref:System.Array.Sort%2A?displayProperty=nameWithType> ou <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. O exemplo a seguir executa as quatro operações de classificação diferentes (classificação do word usando a cultura atual, classificação do word usando a cultura invariável, classificação ordinal e classificação de cadeia de caracteres usando a cultura invariável) sem chamar explicitamente um método de comparação de cadeia de caracteres, embora elas especificam o tipo de comparação a ser usado. Observe que cada tipo de classificação produz uma ordenação exclusivo de cadeias de caracteres em sua matriz.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Internamente, o.NET Framework usa chaves de classificação para dar suporte a comparação de cadeia de caracteres culturallysensitive. Cada caractere em uma cadeia de caracteres tem várias categorias de pesos de classificação, incluindo caracteres alfabéticos, caso e sinais diacríticos. Uma chave de classificação, representado pelo <xref:System.Globalization.SortKey> classe, fornece um repositório desses pesos para uma determinada cadeia de caracteres. Se seu aplicativo executa um grande número de pesquisa ou classificação de operações no mesmo conjunto de cadeias de caracteres, você pode melhorar o desempenho gerando e armazenando chaves de classificação para todas as cadeias de caracteres que ele usa. Quando uma operação de classificação ou comparação é necessária, você usar as chaves de classificação em vez de cadeias de caracteres. Para obter mais informações, consulte a classe <xref:System.Globalization.SortKey>.  
  
 Se você não especificar uma convenção de comparação de cadeia de caracteres, classifica os métodos como <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> executar uma classificação sensíveis à cultura, diferencia maiusculas de minúsculas em cadeias de caracteres. O exemplo a seguir ilustra como alterar a cultura atual afeta a ordem de classificação cadeias de caracteres em uma matriz. Ele cria uma matriz de cadeias de caracteres de três. Primeiro, ele define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade para en-US e chama o <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> método. A ordem de classificação resultante é baseada em convenções de classificação para a cultura do inglês (Estados Unidos). Em seguida, o exemplo define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade da-DK e chama o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método novamente. Observe como a ordem de classificação resultante difere dos resultados en-US porque ele usa as convenções de classificação para dinamarquês (Dinamarca).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Se o seu principal objetivo na comparação de cadeias de caracteres é determinar se eles forem iguais, você deve chamar o <xref:System.String.Equals%2A?displayProperty=nameWithType> método. Normalmente, você deve usar <xref:System.String.Equals%2A> para executar uma comparação ordinal. O <xref:System.String.Compare%2A?displayProperty=nameWithType> método destina-se principalmente a classificação de cadeias de caracteres.  
  
 Métodos de pesquisa de cadeia de caracteres como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar comparações de cadeia de caracteres sensíveis à cultura ou ordinal. O exemplo a seguir ilustra as diferenças entre as comparações ordinais e sensíveis à cultura usando a <xref:System.String.IndexOf%2A> método. Uma pesquisa sensíveis à cultura em que a cultura atual é inglês (Estados Unidos) considera a subcadeia de caracteres "oe" para corresponder a Ligadura "œ". Como um hífen flexível (U + 00AD) é um caractere de largura zero, a pesquisa trata o hífen flexível como equivalente a <xref:System.String.Empty> e localiza uma correspondência no início da cadeia de caracteres. Uma pesquisa ordinal, por outro lado, não encontrar uma correspondência em ambos os casos.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Pesquisando cadeias de caracteres  
 Métodos de pesquisa de cadeia de caracteres como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar sensíveis à cultura ou comparações de cadeias de caracteres ordinais para determinar se um caractere ou uma subcadeia de caracteres é encontrado em uma cadeia de caracteres especificada.  
  
 Os métodos de pesquisa no <xref:System.String> classe procurar por um caractere individual, como o <xref:System.String.IndexOf%2A> método ou parte de um conjunto de caracteres, como o <xref:System.String.IndexOfAny%2A> método, realizam uma pesquisa ordinal. Para executar uma pesquisa sensíveis à cultura de um caractere, você deve chamar uma <xref:System.Globalization.CompareInfo> método como <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> ou <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Observe que os resultados da pesquisa por um caractere usando a comparação ordinal e sensíveis à cultura podem ser muito diferentes. Por exemplo, uma pesquisa de um caractere Unicode pré-compostos como a Ligadura "Æ" (U + 00 C 6) pode corresponder a qualquer ocorrência de seus componentes na sequência correta, como "AE" (U + 041U + 0045), dependendo da cultura. O exemplo a seguir ilustra a diferença entre o <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> e <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> métodos ao procurar por um caractere individual. A Ligadura "æ" (U + 00E6) foi encontrada na cadeia de caracteres "aérea" ao usar as convenções de cultura en-US, mas não ao usar as convenções da cultura da-DK ou ao executar uma comparação ordinal.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Por outro lado, <xref:System.String> métodos que pesquisar uma cadeia de caracteres em vez de um caractere de realiza uma pesquisa de cultura se as opções de pesquisa não forem especificadas explicitamente por um parâmetro de tipo de classe <xref:System.StringComparison>. A única exceção é <xref:System.String.Contains%2A>, que executa uma pesquisa ordinal.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testando igualdade  
 Use o <xref:System.String.Compare%2A?displayProperty=nameWithType> método para determinar a relação entre duas cadeias de caracteres na ordem de classificação. Normalmente, essa é uma operação de sensíveis à cultura. Por outro lado, chamar o <xref:System.String.Equals%2A?displayProperty=nameWithType> método de teste de igualdade. Como o teste de igualdade geralmente compara a entrada do usuário com alguma cadeia de caracteres conhecida, como um nome de usuário válido, uma senha ou um caminho de sistema de arquivos, normalmente é uma operação ordinal.  
  
> [!WARNING]
>  É possível testar a igualdade chamando o <xref:System.String.Compare%2A?displayProperty=nameWithType> método e determinar se o valor de retorno é zero. No entanto, essa prática não é recomendada. Para determinar se duas cadeias de caracteres são iguais, você deve chamar uma das sobrecargas do <xref:System.String.Equals%2A?displayProperty=nameWithType> método. A sobrecarga preferencial para chamar é qualquer instância <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> estático ou método <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, porque ambos os métodos incluem um <xref:System.StringComparison?displayProperty=nameWithType> parâmetro que especifica explicitamente o tipo de comparação.  
  
 O exemplo a seguir ilustra o perigo de executar uma comparação de cultura para igualdade quando um ordinal um deve ser usado em vez disso. Nesse caso, a intenção do código é impedir o acesso de sistema de arquivos de URLs que começam com "FILE://" ou "file://" ao executar uma comparação de maiusculas e minúsculas do início de uma URL com a cadeia de caracteres "FILE://". No entanto, se uma comparação sensíveis à cultura é executada usando a cultura de turco (Turquia) em uma URL que começa com "file://", a comparação de igualdade falhará, porque o turco equivalente maiusculas em minúsculas "i" é "İ" em vez de "I". Como resultado, o acesso de sistema de arquivos inadvertidamente é permitido. Por outro lado, se uma comparação ordinal é executada, a comparação de igualdade for bem-sucedida, e acesso de sistema de arquivos será negado.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalização  
 Alguns caracteres Unicode têm várias representações. Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 Várias representações para um único caractere complicam a pesquisa, classificação, correspondência e outras operações de cadeia de caracteres.  
  
 O padrão Unicode define um processo chamado de normalização que retorna uma representação binária de um caractere Unicode para qualquer uma das suas representações binárias equivalentes. Normalização pode usar vários algoritmos, chamados de formulários de normalização, que segue regras diferentes. O .NET Framework dá suporte a formulários de normalização Unicode C, D, KC e KD. Cadeias de caracteres foram normalizadas para o mesmo formulário de normalização, eles podem ser comparados usando comparação ordinal.  
  
 Uma comparação ordinal é uma comparação binária do valor escalar Unicode correspondente <xref:System.Char> objetos em cada cadeia de caracteres. O <xref:System.String> classe inclui um número de métodos que podem executar uma comparação ordinal, incluindo o seguinte:  
  
-   Nenhuma sobrecarga do <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, e <xref:System.String.LastIndexOf%2A> métodos que inclui um <xref:System.StringComparison> parâmetro. O método executa uma comparação ordinal se você fornecer um valor de <xref:System.StringComparison?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase> para esse parâmetro.  
  
-   As sobrecargas do <xref:System.String.CompareOrdinal%2A> método.  
  
-   Métodos que usam a comparação ordinal por padrão, como <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, e <xref:System.String.Split%2A>.  
  
-   Métodos de pesquisa para um <xref:System.Char> valor ou para os elementos em um <xref:System.Char> matriz em uma instância de cadeia de caracteres. Esses métodos incluem <xref:System.String.IndexOf%28System.Char%29> e <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Você pode determinar se uma cadeia de caracteres é normalizada para o formulário de normalização C chamando o <xref:System.String.IsNormalized?displayProperty=nameWithType> método, ou você pode chamar o <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para determinar se uma cadeia de caracteres é normalizada para um formulário de normalização especificado. Você também pode chamar o <xref:System.String.Normalize?displayProperty=nameWithType> método para converter uma cadeia de caracteres para o formulário de normalização C, ou você pode chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para converter uma cadeia de caracteres a um formulário de normalização especificado. Para obter informações passo a passo sobre a normalização e comparação de cadeias de caracteres, consulte o <xref:System.String.Normalize> e <xref:System.String.Normalize%28System.Text.NormalizationForm%29> métodos.  
  
 O exemplo simples a seguir ilustra a normalização de cadeia de caracteres. Ele define a letra "ố" três modos diferentes em três diferentes cadeias de caracteres e usa uma comparação ordinal para fins de igualdade para determinar o que cada cadeia de caracteres é diferente de outras cadeias de caracteres de dois. Ele converte cada cadeia de caracteres em formulários de normalização com suporte e executa novamente uma comparação ordinal de cada cadeia de caracteres em um formulário de normalização especificado. Em cada caso, o segundo teste de igualdade mostra que as cadeias de caracteres são iguais.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Para obter mais informações sobre a normalização e formulários de normalização, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, bem como [Unicode Standard Annex #15: formulários de normalização Unicode](http://unicode.org/reports/tr15/) e [perguntas Frequentes de normalização](http://www.unicode.org/faq/normalization.html) no site do site unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operações da cadeia de caracteres por categoria  
 O <xref:System.String> classe fornece membros para comparar cadeias de caracteres, cadeias de caracteres para igualdade de teste, localizando caracteres ou subcadeias em uma cadeia de caracteres, modificando uma cadeia de caracteres, extrair subcadeias de caracteres de uma cadeia de caracteres, combinando cadeias de caracteres, formatação de valores, a cópia de uma cadeia de caracteres e normalizando uma cadeia de caracteres.  
  
### <a name="comparing-strings"></a>Comparando cadeias de caracteres  
 Você pode comparar cadeias de caracteres para determinar sua posição relativa na ordem de classificação usando o seguinte <xref:System.String> métodos:  
  
-   <xref:System.String.Compare%2A>Retorna um inteiro que indica a relação de uma cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação.  
  
-   <xref:System.String.CompareOrdinal%2A>Retorna um inteiro que indica a relação de uma cadeia de caracteres para uma segunda cadeia de caracteres com base em uma comparação dos seus pontos de código.  
  
-   <xref:System.String.CompareTo%2A>Retorna um inteiro que indica a relação da instância atual de cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação. O <xref:System.String.CompareTo%28System.String%29> método fornece o <xref:System.IComparable> e <xref:System.IComparable%601> implementações para o <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Testando igualdade das cadeias de caracteres  
 Chamar o <xref:System.String.Equals%2A> método para determinar se duas cadeias de caracteres são iguais. A instância <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> e estático <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> sobrecargas permitem que você especifique se a comparação for ordinal ou sensíveis à cultura, e se o caso é considerado ou ignorado. A maioria dos testes de igualdade são ordinal e comparações de igualdade que determinam o acesso a um recurso do sistema (como um objeto do sistema de arquivos) devem ser sempre ordinal.  
  
### <a name="finding-characters-in-a-string"></a>Localizando caracteres em uma cadeia de caracteres  
 O <xref:System.String> classe inclui dois tipos de métodos de pesquisa:  
  
-   Métodos que retornam um <xref:System.Boolean> valor para indicar se uma determinada subcadeia de caracteres está presente em uma instância de cadeia de caracteres. Isso inclui o <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, e <xref:System.String.StartsWith%2A> métodos.  
  
-   Métodos que indicam a posição inicial de uma subcadeia de caracteres em uma instância de cadeia de caracteres. Isso inclui o <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, e <xref:System.String.LastIndexOfAny%2A> métodos.  
  
> [!WARNING]
>  Se você deseja pesquisar uma cadeia de caracteres para um determinado padrão em vez de uma subcadeia de caracteres específica, você deve usar expressões regulares. Para obter mais informações, consulte [Expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modificando uma cadeia de caracteres  
 O <xref:System.String> classe inclui os seguintes métodos que aparecem para modificar o valor de uma cadeia de caracteres:  
  
-   <xref:System.String.Insert%2A>Insere uma cadeia de caracteres atual <xref:System.String> instância.  
  
-   <xref:System.String.PadLeft%2A>Insere uma ou mais ocorrências de um caractere especificado no início de uma cadeia de caracteres.  
  
-   <xref:System.String.PadRight%2A>Insere uma ou mais ocorrências de um caractere especificado no início de uma cadeia de caracteres.  
  
-   <xref:System.String.Remove%2A>Exclui uma subcadeia de caracteres atual <xref:System.String> instância.  
  
-   <xref:System.String.Replace%2A>substitui uma subcadeia de caracteres por outra subcadeia de caracteres atual <xref:System.String> instância.  
  
-   <xref:System.String.ToLower%2A>e <xref:System.String.ToLowerInvariant%2A> converte todos os caracteres em uma cadeia de caracteres em letras minúsculas.  
  
-   <xref:System.String.ToUpper%2A>e <xref:System.String.ToUpperInvariant%2A> converter todos os caracteres em uma cadeia de caracteres em maiusculas.  
  
-   <xref:System.String.Trim%2A>Remove todas as ocorrências de um caractere de início e no final de uma cadeia de caracteres.  
  
-   <xref:System.String.TrimEnd%2A>Remove todas as ocorrências de um caractere de final de uma cadeia de caracteres.  
  
-   <xref:System.String.TrimStart%2A>Remove todas as ocorrências de um caractere de início de uma cadeia de caracteres.  
  
> [!IMPORTANT]
>  Todos os métodos de modificação de cadeia de caracteres retornam um novo <xref:System.String> objeto. Eles não modificam o valor da instância atual.  
  
### <a name="extracting-substrings-from-a-string"></a>Extraindo subcadeias de caracteres de uma cadeia de caracteres  
 O <xref:System.String.Split%2A?displayProperty=nameWithType> método separa uma única cadeia de caracteres em várias cadeias de caracteres. Sobrecargas do método permitem que você especifique vários delimitadores, para determinar o número máximo de subcadeias de caracteres que o método extrai e para determinar se as cadeias de caracteres vazias (que ocorrem quando os delimitadores são adjacentes) são incluídas entre as cadeias de caracteres retornadas.  
  
### <a name="combining-strings"></a>Combinando cadeias de caracteres  
 O seguinte <xref:System.String> métodos podem ser usados para concatenação de cadeia de caracteres:  
  
-   <xref:System.String.Concat%2A>combina um ou mais subcadeias de caracteres em uma única cadeia de caracteres.  
  
-   <xref:System.String.Join%2A>Concatena uma ou mais subcadeias de caracteres em um único elemento e adiciona um separador entre cada subcadeia de caracteres.  
  
### <a name="formatting-values"></a>Formatando valores  
 O <xref:System.String.Format%2A?displayProperty=nameWithType> método usa o recurso de formatação composta para substituir os espaços reservados de um ou mais de uma cadeia de caracteres com a representação de cadeia de caracteres de algum objeto ou valor. O <xref:System.String.Format%2A> método é geralmente usado para fazer o seguinte:  
  
-   Para inserir a representação de cadeia de caracteres de um valor numérico em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de um valor de data e hora em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de um valor de enumeração em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de um objeto que oferece suporte a <xref:System.IFormattable> interface em uma cadeia de caracteres.  
  
-   Justificar à direita ou justificar à esquerda de uma subcadeia de caracteres em um campo dentro de uma cadeia de caracteres maior.  
  
 Para obter informações detalhadas sobre a formatação de operações e exemplos, consulte o <xref:System.String.Format%2A> resumo de sobrecarga.  
  
### <a name="copying-a-string"></a>Copiando uma cadeia de caracteres  
 Você pode chamar o seguinte <xref:System.String> métodos para fazer uma cópia de uma cadeia de caracteres:  
  
-   <xref:System.String.Clone%2A>Retorna uma referência a um existente <xref:System.String> objeto.  
  
-   <xref:System.String.Copy%2A>cria uma cópia de uma cadeia de caracteres existente.  
  
-   <xref:System.String.CopyTo%2A>copia uma parte de uma cadeia de caracteres em uma matriz de caracteres.  
  
### <a name="normalizing-a-string"></a>Normalizando uma cadeia de caracteres  
 Em Unicode, um único caractere pode ter vários pontos de código. Normalização converte esses caracteres equivalentes na representação binária do mesmo. O <xref:System.String.Normalize%2A?displayProperty=nameWithType> método executa a normalização e o <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> método determina se uma cadeia de caracteres é normalizada.  
  
 Para obter mais informações e um exemplo, consulte o [normalização](#Normalization) seção neste tópico.  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nesta seção:  
  
 [Sintaxe do construtor sobrecarregado](#Syntax)   
 [Parâmetros](#Params)   
 [Exceções](#Exceptions)   
 [Qual método chamar?](#Tasks)   
 [Criação de cadeias de caracteres](#Creating_Strings)   
 [Manipulação de cadeias de caracteres repetitivas](#Repetitive)   
 Exemplos de cadeias de caracteres ao instanciar:   
 [Usando atribuição de cadeia de caracteres](#Ctor1_Example)  
 [Usando uma matriz de caracteres](#Ctor2_Example)  
 [Uso de uma parte de uma matriz de caracteres e um único caractere de repetição](#Ctor3_Example)  
 [Usando um ponteiro para uma matriz de caracteres](#Ctor4_Example)  
 [Usando um ponteiro e um intervalo de uma matriz](#Ctor5_Example)  
 [Usando um ponteiro para uma matriz de byte assinado](#Ctor6_Example)  
[Informações de versão](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Sintaxe de construtor sobrecarregada  
 Construtores de cadeia de caracteres se enquadram em duas categorias: aqueles sem parâmetros de ponteiro e aqueles com parâmetros de ponteiro. Os construtores que usam ponteiros não são compatíveis com CLS. Além disso, o Visual Basic não dá suporte para o uso de ponteiros, e c# requer o código que usa ponteiros para executar em um contexto sem segurança. Para obter mais informações, consulte [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Para obter orientação adicional sobre como escolher uma sobrecarga, consulte [qual método é chamada?](#Tasks)  
  
 `String(Char[] value)`  
 Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode. Este construtor copia caracteres Unicode ([exemplo](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode, uma posição de caractere inicial na matriz e um comprimento ([exemplo](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicializa a nova instância para o valor indicada por um caractere Unicode especificado repetido um número especificado de vezes ([exemplo](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode que é encerrada com um caractere nulo (U + 0000 ou '\0'). ([exemplo](#Ctor4_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode, uma posição de caractere inicial na matriz e um comprimento. O construtor copia os caracteres Unicode de `value` começando no índice `startIndex` e terminando no índice `startIndex`  +  `length` – 1 ([exemplo](#Ctor5_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value)`  
 **(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits. A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). O construtor processa caracteres de `value` a partir do local especificado pelo ponteiro até que um caractere nulo (0x00) seja atingido ([exemplo](#Ctor6_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial dentro dessa matriz e um comprimento.  A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). O construtor processa caracteres de valor iniciar em `startIndex` e final em `startIndex`  +  `length` – 1 ([exemplo](#Ctor6_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial dentro dessa matriz, comprimento e uma <xref:System.Text.Encoding> objeto.  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parâmetros  
 Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que não incluem um parâmetro de ponteiro. Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Uma matriz de caracteres Unicode.|  
|`c`|<xref:System.Char>|Um caractere Unicode.|  
|`startIndex`|<xref:System.Int32>|A posição inicial no `value` do primeiro caractere na nova cadeia de caracteres.<br /><br /> Valor padrão: 0|  
|`length`|<xref:System.Int32>|O número de caracteres em `value` para incluir na nova cadeia de caracteres.<br /><br /> Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|O número de vezes que o caractere `c` é repetida na nova cadeia de caracteres. Se `count` for zero, o valor do novo objeto é <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que incluem um parâmetro de ponteiro. Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> -ou-<br /><br /> <xref:System.SByte>\*|Um ponteiro para uma matriz de caracteres Unicode de terminada em nulo ou uma matriz de inteiros com sinal de 8 bits. Se `value` é `null` ou uma matriz vazia, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|O índice do elemento da matriz que define o primeiro caractere na nova cadeia de caracteres.<br /><br /> Valor padrão: 0|  
|`length`|<xref:System.Int32>|O número de elementos de matriz a ser usado para criar a nova cadeia de caracteres. Se o comprimento for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Um objeto que especifica como o `value` matriz é codificada.<br /><br /> Valor padrão: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, ou a página de código ANSI atual do sistema|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Exceções  
 Aqui está uma lista de exceções lançadas por construtores que não têm parâmetros de ponteiro.  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` é `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, ou `count` é menor que zero.<br /><br /> -ou-<br /><br /> A soma de `startIndex` e `length` é maior que o número de elementos em `value`.<br /><br /> -ou-<br /><br /> `count` é menor que zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Aqui está uma lista de exceções lançadas por construtores que incluem parâmetros de ponteiro.  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value`Especifica uma matriz que contém um caractere Unicode inválido.<br /><br /> -ou-<br /><br /> `value`ou `value`  +  `startIndex` Especifica um endereço que é menos de 64 K.<br /><br /> -ou-<br /><br /> Um novo <xref:System.String> instância não foi possível inicializar a partir de `value` porque a matriz de bytes `value` não usa a codificação de página de código padrão.|Todos os construtores com ponteiros.|  
|<xref:System.ArgumentNullException>|`value` é nulo.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|O processo atual não tem acesso de leitura a todos os caracteres endereçados.<br /><br /> -ou-<br /><br /> `startIndex`ou `length` é menor que zero, `value`  +  `startIndex` causar um estouro de ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.<br /><br /> -ou-<br /><br /> O comprimento da nova cadeia de caracteres é muito grande para alocar.|Todos os construtores com ponteiros.|  
|<xref:System.AccessViolationException>|`value`, ou `value`  +  `startIndex`  +  `length` – 1, especifica um endereço inválido.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Qual método devo chamar?  
  
|Para|Chamada ou usar|  
|--------|-----------------|  
|Crie uma cadeia de caracteres.|Atribuição de uma cadeia de caracteres literal ou uma cadeia de caracteres existente ([exemplo](#Ctor1_Example))|  
|Crie uma cadeia de caracteres de uma matriz de caracteres inteira.|<xref:System.String.%23ctor%28System.Char%5B%5D%29>([exemplo](#Ctor2_Example))|  
|Criar um cadeia de caracteres de uma parte de uma matriz de caracteres.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>([exemplo](#Ctor3_Example))|  
|Crie uma cadeia de caracteres que o mesmo caractere é repetida várias vezes.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29>([exemplo](#Ctor3_Example))|  
|Crie uma cadeia de caracteres de um ponteiro para uma Unicode ou uma matriz de caractere largo.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Crie uma cadeia de caracteres de uma parte de uma Unicode ou uma matriz de caractere largo usando o ponteiro.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Criar uma cadeia de caracteres de um C++ `char` matriz.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> -ou-<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Crie uma cadeia de caracteres ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Criando cadeias de caracteres  
 Mais comumente usado técnica para criar cadeias de caracteres de forma programática é atribuição simples, conforme ilustrado na [Este exemplo](#Ctor1_Example). O <xref:System.String> classe também inclui quatro tipos de sobrecargas de construtor que permitem que você crie cadeias de caracteres dos seguintes valores:  
  
-   De uma matriz de caracteres (uma matriz de caracteres codificado em UTF-16). Você pode criar um novo <xref:System.String> objeto dos caracteres em toda a matriz ou uma parte dele. O <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor copia todos os caracteres na matriz para a nova cadeia de caracteres. O <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor copia os caracteres de índice `startIndex` índice `startIndex`  +  `length` – 1 para a nova cadeia de caracteres. Se `length` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Se seu código repetidamente instancia cadeias de caracteres que têm o mesmo valor, você pode melhorar o desempenho do aplicativo usando um meio alternativo de criar cadeias de caracteres. Para obter mais informações, consulte [manipulação de cadeias de caracteres repetitivas](#Repetitive).  
  
-   Em um único caractere que é duplicado zero, um ou mais vezes, usando o <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> construtor. Se `count` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   De um ponteiro para uma matriz de caracteres terminada em nulo, usando o <xref:System.String.%23ctor%28System.Char%2A%29> ou <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor. A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres. O construtor copia uma cadeia de caracteres Unicode iniciando o ponteiro especificado ou o sinal de adição de ponteiro especificado `startIndex` e continua até o fim da matriz ou para `length` caracteres. Se `value` é um ponteiro nulo ou `length` for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>. Se a operação de cópia continua até o final da matriz e a matriz não é terminada em nulo, o comportamento de construtor é dependente do sistema. Dessas condições pode causar uma violação de acesso.  
  
     Se a matriz contém quaisquer caracteres nulos inseridos (U + 0000 ou '\0') e o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos. O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> método. Como o endereço é o início da matriz e todos os elementos da matriz devem ser adicionadas à cadeia de caracteres, o construtor instancia uma cadeia de caracteres com dez caracteres, incluindo dois nulls inseridos. Por outro lado, se a mesma matriz é passado para o <xref:System.String.%23ctor%28System.Char%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclui o primeiro caractere nulo.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     A matriz deve conter caracteres Unicode. No C++, isso significa que a matriz de caracteres deve ser definido como gerenciado <xref:System.Char>tipo [] ou não gerenciado`wchar_t`tipo [].  
  
     Se o <xref:System.String.%23ctor%28System.Char%2A%29> sobrecarga é chamada e a matriz não é terminada em nulo, ou se o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada e `startIndex`  +  `length`-1 inclui um intervalo de fora da memória alocada para a sequência de caracteres, o comportamento do construtor é dependente do sistema e pode ocorrer uma violação de acesso. Além disso, o processador Intel Itanium, chamadas para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor pode gerar um <xref:System.DataMisalignedException> exceção. Se isso ocorrer, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> em vez disso.  
  
-   De um ponteiro para uma matriz de byte assinado. A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres. A sequência de bytes que pode ser interpretada usando a codificação de página de código padrão ou uma codificação pode ser especificada na chamada de construtor. Se o construtor tenta criar uma instância de uma cadeia de caracteres de uma matriz de inteira que não é terminada em nulo, ou se o intervalo da matriz de `value`  +  `startIndex` para `value`  +  `startIndex`  +  `length` -1 está fora da memória alocada para a matriz, o comportamento desse construtor é dependente do sistema e pode ocorrer uma violação de acesso.  
  
     Os três construtores que incluem uma matriz de byte assinado como um parâmetro são projetados principalmente para converter um C++ `char` de matriz para uma cadeia de caracteres, conforme mostrado neste exemplo:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Se a matriz contém quaisquer caracteres nulos ('\0') ou bytes cujo valor é 0 e o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos. O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> método. Como o endereço é o início da matriz e todos os elementos da matriz devem ser adicionadas à cadeia de caracteres, o construtor instancia uma cadeia de caracteres com dez caracteres, incluindo dois nulls inseridos. Por outro lado, se a mesma matriz é passado para o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclui o primeiro caractere nulo.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Porque o <xref:System.String.%23ctor%28System.SByte%2A%29> e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> construtores interpretam `value` usando a página de código ANSI padrão, esses construtores com matrizes de bytes idêntico ao chamar pode criar cadeias de caracteres que têm valores diferentes em sistemas diferentes.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Identificando cadeias de caracteres repetitivas  
 Os aplicativos que analisam ou decodificam fluxos de texto geralmente usam o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor ou <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para converter as sequências de caracteres em uma cadeia de caracteres. Repetidamente, criando novas cadeias de caracteres com o mesmo valor em vez de criar e reutilizar uma cadeia de caracteres desperdiça memória. Se você tem probabilidade de criar o mesmo valor de cadeia de caracteres repetidamente chamando o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de adiantamento de construtor, mesmo se você não souber em quais podem ser os valores de cadeia de caracteres idêntica, você pode usar uma tabela de pesquisa em vez disso.  
  
 Por exemplo, suponha que você ler e analisar um fluxo de caracteres de um arquivo que contém atributos e marcas XML. Quando você analisar o fluxo, você encontrar repetidamente determinados símbolos (ou seja, as sequências de caracteres que têm um significado simbólico). Tokens equivalentes para as cadeias de caracteres "0", "1", "true" e "false" têm probabilidade de ocorrer com frequência em um fluxo XML.  
  
 Em vez de converter cada token em uma nova cadeia de caracteres, você pode criar um <xref:System.Xml.NameTable?displayProperty=nameWithType> objeto para armazenar cadeias de caracteres que normalmente ocorre. O <xref:System.Xml.NameTable> objeto melhora o desempenho, porque ela recupera cadeias de caracteres armazenadas sem alocação de memória temporária. Quando você encontrar um token, use o <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para recuperar o token da tabela. Se o token existir, o método retorna a cadeia de caracteres correspondente. Se o token não existe, use o <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para inserir o token na tabela e para obter a cadeia de caracteres correspondente.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Exemplo 1: usando atribuição da cadeia de caracteres  
 O exemplo a seguir cria uma nova cadeia de caracteres atribuindo a ele uma cadeia de caracteres literal. Ele cria uma segunda cadeia atribuindo o valor da primeira cadeia a ele. Essas são as duas formas mais comuns para instanciar um novo <xref:System.String> objeto.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Exemplo 2: usando uma matriz de caracteres  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma matriz de caracteres.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Exemplo 3: usando uma parte de uma matriz de caracteres e repetindo um único caractere  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma parte de uma matriz de caracteres e como criar um novo <xref:System.String> objeto que contém várias ocorrências de um único caractere.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Exemplo 4: usando um ponteiro para uma matriz de caracteres  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto de um ponteiro para uma matriz de caracteres. O exemplo c# deve ser compilado usando o `/unsafe` opção de compilador.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Exemplo 5: criando uma instância de uma cadeia de caracteres a partir de um ponteiro e um intervalo de uma matriz  
 O exemplo a seguir examina os elementos de uma matriz de caracteres para um ponto ou um ponto de exclamação. Se for encontrado, ele cria uma cadeia de caracteres na matriz que precede o símbolo de pontuação de. Caso contrário, ele cria uma cadeia de caracteres com todo o conteúdo da matriz. O exemplo c# deve ser compilado usando o `/unsafe` opção de compilador.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Exemplo 6: criando uma instância de uma cadeia de caracteres a partir de um ponteiro para uma matriz de bytes assinados  
 O exemplo a seguir demonstra como você pode criar uma instância do <xref:System.String> classe com o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informações de versão  
 .NET Framework  
 Todas as sobrecargas são suportadas em: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Todas as sobrecargas são suportadas em: 4, 3.5 SP1  
  
 Biblioteca de Classes Portátil  
 Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte  
  
 .NET para aplicativos da Windows Store  
 Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte em: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres Unicode terminada em nulo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O processo atual não tem acesso de leitura a todos os caracteres endereçados.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> especifica uma matriz que contém um caractere Unicode inválido ou <paramref name="value" /> especifica um endereço menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres Unicode.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.String" /> classe para o valor indicado por uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros de 8 bits com sinal com terminação nula. Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro para uma matriz de inteiros de 8 bits com sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado em ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O comprimento da nova cadeia de caracteres a ser inicializada, que é determinado pelo caractere de terminação nula <paramref name="value" />, é muito grande para ser alocado.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" /> especifica um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Um caractere Unicode.</param>
        <param name="count">O número de vezes <c>c</c> ocorre.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um caractere Unicode repetido um número de vezes especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres Unicode.</param>
        <param name="startIndex">A posição inicial dentro <c>valor</c>.</param>
        <param name="length">O número de caracteres em <c>valor</c> para usar.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um tamanho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />ou <paramref name="length" /> é menor que zero, <paramref name="value" />  +  <paramref name="startIndex" /> causar um estouro de ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" />Especifica uma matriz que contém um caractere Unicode inválido, ou <paramref name="value" />  +  <paramref name="startIndex" /> Especifica um endereço menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres Unicode.</param>
        <param name="startIndex">A posição inicial dentro <c>valor</c>.</param>
        <param name="length">O número de caracteres em <c>valor</c> para usar.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um comprimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o número de elementos em <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros com sinal de 8 bits. Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">A posição inicial dentro <c>valor</c>.</param>
        <param name="length">O número de caracteres em <c>valor</c> para usar.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz e um comprimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 O endereço especificado pelo <paramref name="value" />  +  <paramref name="startIndex" /> é muito grande para a plataforma atual; isto é, o cálculo de endereço estourou.  
  
 -ou-  
  
 O comprimento da nova cadeia de caracteres a ser inicializada é muito grande para alocar.</exception>
        <exception cref="T:System.ArgumentException">O endereço especificado pelo <paramref name="value" />  +  <paramref name="startIndex" /> é menos de 64 K.  
  
 -ou-  
  
 Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado em ANSI.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros com sinal de 8 bits.</param>
        <param name="startIndex">A posição inicial dentro <c>valor</c>.</param>
        <param name="length">O número de caracteres em <c>valor</c> para usar.</param>
        <param name="enc">Um objeto que especifica como a matriz é referenciada por <c>valor</c> é codificado. Se <c>enc</c> é <see langword="null" />, codificação ANSI é assumido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz, um comprimento e um objeto <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 O endereço especificado pelo <paramref name="value" />  +  <paramref name="startIndex" /> é muito grande para a plataforma atual; isto é, o cálculo de endereço estourou.  
  
 -ou-  
  
 O comprimento da nova cadeia de caracteres a ser inicializada é muito grande para alocar.</exception>
        <exception cref="T:System.ArgumentException">O endereço especificado pelo <paramref name="value" />  +  <paramref name="startIndex" /> é menos de 64 K.  
  
 -ou-  
  
 Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado conforme especificado por <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException">
          <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Uma posição na cadeia de caracteres atual.</param>
        <summary>Obtém o objeto <see cref="T:System.Char" /> em uma posição especificada no atual objeto <see cref="T:System.String" />.</summary>
        <value>O objeto na posição <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `index` parâmetro é baseado em zero.  
  
 Essa propriedade retorna o <xref:System.Char> objeto na posição especificada o `index` parâmetro. No entanto, um caractere Unicode pode ser representado por mais de um <xref:System.Char>. Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> caracteres de classe para trabalhar com Unicode em vez de <xref:System.Char> objetos. Para obter mais informações, consulte a seção "Char objetos e caracteres de Unicode" o <xref:System.String> visão geral da classe.  
  
 No c#, o <xref:System.String.Chars%2A> propriedade é um indexador. No Visual Basic, é a propriedade padrão da <xref:System.String> classe. Cada <xref:System.Char> objeto na cadeia de caracteres pode ser acessado usando código como o seguinte.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar este indexador em uma rotina para validar uma cadeia de caracteres.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> é maior ou igual ao tamanho desse objeto ou menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma referência a essa instância de <see cref="T:System.String" />.</summary>
        <returns>Esta instância de <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno não é uma cópia independente desta instância; ele é simplesmente outro modo de exibição dos mesmos dados. Use o <xref:System.String.Copy%2A> ou <xref:System.String.CopyTo%2A> método para criar um separado <xref:System.String> objeto com o mesmo valor que esta instância.  
  
 Porque o <xref:System.String.Clone%2A> método simplesmente retorna a instância de cadeia de caracteres existente, há poucos motivos para chamá-lo diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas as sobrecargas do <xref:System.String.Compare%2A> método retornar um inteiro assinado de 32 bits que indica a relação lexical entre os dois termos de comparação.  
  
|Valor|Condição|  
|-----------|---------------|  
|Menor que zero|A primeira substring precede a subcadeia de caracteres segundo na ordem de classificação.|  
|Zero|Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou `length` é zero.|  
|Maior que zero|A primeira substring segue a subcadeia de caracteres segundo na ordem de classificação.|  
  
> [!WARNING]
>  Sempre que possível, você deve chamar uma sobrecarga de <xref:System.String.Compare%2A> método inclui um <xref:System.StringComparison> parâmetro. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.Compare%28System.String%2CSystem.String%29> método Compare três conjuntos de cadeias de caracteres.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 No exemplo a seguir, o `ReverseStringComparer` classe demonstra como você pode avaliar duas cadeias de caracteres com o <xref:System.String.Compare%2A> método.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação sensíveis à cultura de "animal" com "ani email" (usando um hífen flexível ou U + 00AD) indica que as duas cadeias de caracteres são equivalentes.  
  
 [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)]
 [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  
  
 Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o `comparisonType` parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra que o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> método é equivalente a usar <xref:System.String.ToUpper%2A> ou <xref:System.String.ToLower%2A> ao comparar cadeias de caracteres.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação sensíveis à cultura, maiusculas e minúsculas de "animal" com "Ani email" (usando um hífen flexível ou U + 00AD) indica que as duas cadeias de caracteres são equivalentes.  
  
 [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)]
 [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  
  
 Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para usar na comparação.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />está na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura invariável ou atual, respeitam ou ignorar o caso dos termos de comparação ou usar o word (sensíveis à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres comparam igual ao final de uma cadeia de caracteres e a outra cadeia de caracteres tem caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 O exemplo a seguir compara três versões da letra "I". Os resultados são afetados pela opção de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.StringComparison" /> não é suportado.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, forneça um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Um objeto que fornece informações de comparação específicas de cultura.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, bem como usando informações culturais específicas para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa o `culture` parâmetro para obter informações específicas de cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como a cultura pode afetar uma comparação. Em tcheco - cultura República Tcheca, "ch" é um único caractere que é maior do que "d". No entanto, em inglês - Estados Unidos cultura, "ch" consiste em dois caracteres e "c" é menor que "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação de maiusculas e minúsculas de "animal" com "Ani email" (usando um hífen flexível ou U + 00AD) usando a constante cultura indica que as duas cadeias de caracteres são equivalentes.  
  
 [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)]
 [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  
  
 Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="culture">A cultura que fornece informações de comparação específicas de cultura.</param>
        <param name="options">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas cadeias de caracteres na ordem de classificação.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica o relacionamento léxico entre <paramref name="strA" /> e <paramref name="strB" />, como é mostrado na tabela a seguir  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa o `culture` parâmetro para obter informações específicas de cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura específica pode especificar que algumas combinações de caracteres seja tratada como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou seguem.  
  
> [!CAUTION]
>  O <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método destina-se principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o objetivo principal da chamada de método é determinar se duas cadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar um valor de retorno de zero). Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 A comparação adicional pode ser especificada com o `options` parâmetro, que consiste em um ou mais membros a <xref:System.Globalization.CompareOptions> enumeração. No entanto, pois a finalidade deste método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> valores não têm nenhum efeito.  
  
 Um ou ambos os termos de comparação podem ser `null`. Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maior do que uma referência nula e duas referências nulas comparados como iguais entre si.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres comparam igual ao final de uma cadeia de caracteres e a outra cadeia de caracteres tem caracteres restantes, a cadeia de caracteres com os caracteres restantes é considerada maior.  
  
   
  
## Examples  
 O exemplo a seguir compara duas cadeias de caracteres de três maneiras diferentes: usar comparação Linguística para a cultura en-US; usando a comparação diferencia maiusculas de minúsculas Linguística para a cultura en-US; e usando uma comparação ordinal. Ele ilustra como os três métodos de comparação produzem três resultados diferentes.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. O <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, forneça um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <summary>Compara subcadeias de dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description>Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar as subcadeias de caracteres a ser comparado no `strA` em `indexA` e em `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero; isto é, o primeiro caractere em `strA` e `strB` está na posição zero. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <summary>Compara as subcadeias de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description>Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar as subcadeias de caracteres a ser comparado no `strA` em `indexA`e em `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero; isto é, o primeiro caractere em `strA` e `strB` está na posição zero. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 O nome do caminho deve ser comparados de uma maneira invariável. O código correto para fazer isso é o seguinte.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 O exemplo a seguir executa duas comparações de duas subcadeias de caracteres que diferem apenas em maiusculas. A primeira comparação diferencia maiusculas de minúsculas e a segunda comparação considera caso.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para usar na comparação.</param>
        <summary>Compara as subcadeias de caracteres de dois especificado <see cref="T:System.String" /> objetos usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description>Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou o <paramref name="length" /> parâmetro é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> follllows a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar as subcadeias de caracteres a ser comparado no `strA` em `indexA` e em `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero; isto é, o primeiro caractere em `strA` e `strB` está na posição zero, não posicione um. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura invariável ou atual, respeitam ou ignorar o caso dos termos de comparação ou usar o word (sensíveis à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres comparam igual ao final de uma cadeia de caracteres e a outra cadeia de caracteres tem caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 O <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, forneça um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Um objeto que fornece informações de comparação específicas de cultura.</param>
        <summary>Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas e usando informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um número inteiro que indica a relação lexical entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description>Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar as subcadeias de caracteres a ser comparado no `strA` em `indexA`e em `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero; isto é, o primeiro caractere em `strA` e `strB` está na posição zero, não posicione um. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa o `culture` parâmetro para obter informações específicas de cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres usando diferentes culturas e ignorando no caso das subcadeias de caracteres. A escolha de cultura afeta como a letra "I" é comparado.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 <paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição inicial da subcadeia de caracteres dentro de <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição inicial da subcadeia de caracteres dentro de <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="culture">Um objeto que fornece informações de comparação específicas de cultura.</param>
        <param name="options">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</param>
        <summary>Compara duas subcadeias de caracteres <see cref="T:System.String" /> especificadas usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas subcadeias de caracteres na ordem de classificação.</summary>
        <returns>Um inteiro que indica a relação lexical entre as dois subcadeias de caracteres, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term>Zero  
  
 </term><description>Ocorrem as subcadeias de caracteres na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Iniciar as subcadeias de caracteres a ser comparado no `strA` na posição `indexA` e em `strB` na posição `indexB`. O comprimento da subcadeia de caracteres primeiro é o comprimento do `strA` menos `indexA`. O comprimento da subcadeia de caracteres segundo é o comprimento do `strB` menos `indexB`.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa o `culture` parâmetro para obter informações específicas de cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura específica pode especificar que algumas combinações de caracteres seja tratada como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou seguem.  
  
> [!CAUTION]
>  O <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método destina-se principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o objetivo principal da chamada de método é determinar se duas subcadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar um valor de retorno de zero). Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Um ou ambos `strA` e `strB` pode ser `null`. Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maior do que uma referência nula e duas referências nulas comparados como iguais entre si.  
  
 A comparação adicional pode ser especificada com o `options` parâmetro, que consiste em um ou mais membros a <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração. No entanto, pois a finalidade deste método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> valores não têm nenhum efeito.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres comparam igual ao final de uma cadeia de caracteres e a outra cadeia de caracteres tem caracteres restantes, a cadeia de caracteres com os caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método para comparar os sobrenomes de duas pessoas. Ele então as lista em ordem alfabética.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="indexA" />é maior do que <paramref name="strA" /> <see langword=".Length" />.  
  
 -ou-  
  
 <paramref name="indexB" />é maior do que <paramref name="strB" /> <see langword=".Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 <paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensíveis à cultura. Para reconhecer caracteres ignoráveis a comparação, forneça um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada cadeia de caracteres.</summary>
        <returns>Um número inteiro que indica a relação lexical entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="strA" />é menor que <paramref name="strB" />.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="strA" />e <paramref name="strB" /> são iguais.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="strA" />é maior do que <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação diferencia maiusculas de minúsculas usando regras de classificação ordinal. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para realizar uma comparação de maiusculas e minúsculas usando regras de classificação ordinal, chame o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison?displayProperty=nameWithType>.  
  
 Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`. Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais. Se apenas um dos valores for `null`, o método considera o valor não nulo para ser maior.  
  
   
  
## Examples  
 O exemplo a seguir executa e comparação ordinal de duas cadeias de caracteres que diferem apenas em maiusculas.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">O índice inicial da subcadeia de caracteres em <c>strA</c>.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">O índice inicial da subcadeia de caracteres em <c>strB</c>.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <summary>Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada subcadeia de caracteres.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> é menor que a subcadeia de caracteres em <paramref name="strB" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>As subcadeias de caracteres forem iguais, ou <paramref name="length" /> é zero.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A subcadeia de caracteres em <paramref name="strA" /> é maior do que a subcadeia de caracteres em <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 O número de caracteres em comparação é menor do que o comprimento do `strA` menos `indexA`, o comprimento de `strB` menos `indexB`, e `length`.  
  
 Esse método executa uma comparação diferencia maiusculas de minúsculas usando regras de classificação ordinal. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para realizar uma comparação de maiusculas e minúsculas usando regras de classificação ordinal, chame o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison?displayProperty=nameWithType>.  
  
 Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`. Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais. Se apenas um dos valores for `null`, o método considera o valor não nulo para ser maior.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra que <xref:System.String.CompareOrdinal%2A> e <xref:System.String.Compare%2A> usar diferentes ordens de classificação.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="strA" />não é <see langword="null" /> e <paramref name="indexA" /> é maior do que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="strB" />não é <see langword="null" /> e <paramref name="indexB" /> é maior do que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
 -ou-  
  
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara a essa instância com um objeto especificado ou <see cref="T:System.String" /> e retorna um inteiro que indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação que o objeto especificado ou <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ambas as sobrecargas do <xref:System.String.CompareTo%2A> método executar a comparação de cultura e diferencia maiusculas de minúsculas. Você não pode usar esse método para executar comparações sem diferenciação de cultura ou ordinal. Para maior clareza do código, é recomendável que você evite o <xref:System.String.CompareTo%2A> método e chamar o <xref:System.String.Compare%2A> método em vez disso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto avaliado como um <see cref="T:System.String" />.</param>
        <summary>Compara essa instância com um <see cref="T:System.Object" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme o <see cref="T:System.Object" /> especificado.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Essa instância precede <paramref name="value" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância tem a mesma posição na ordem de classificação como <paramref name="value" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Essa instância segue <paramref name="value" />.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`deve ser um <xref:System.String> objeto.  
  
> [!CAUTION]
>  O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o objetivo principal da chamada de método é determinar se duas cadeias de caracteres são equivalentes. Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre o comportamento desse método, consulte a seção comentários a <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método com um <xref:System.Object>. Porque ele tenta comparar uma <xref:System.String> instância para uma `TestClass` do objeto, o método gera uma <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é um <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.Object)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação de "animal" com "ani email" (usando um hífen flexível ou U + 00AD) indica que as duas cadeias de caracteres são equivalentes.  
  
 [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)]
 [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  
  
 Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chamar o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Compara essa instância com um objeto <see cref="T:System.String" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme a cadeia de caracteres especificada.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="strB" />.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Essa instância precede <paramref name="strB" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância tem a mesma posição na ordem de classificação como <paramref name="strB" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Essa instância segue <paramref name="strB" />.  
  
 -ou-  
  
 <paramref name="strB" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o objetivo principal da chamada de método é determinar se duas cadeias de caracteres são equivalentes. Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Para obter mais informações sobre o comportamento desse método, consulte a seção comentários a <xref:System.String.Compare%28System.String%2CSystem.String%29> método.  
  
 Implementa esse método de <xref:System.IComparable%601?displayProperty=nameWithType> interface e executa um pouco melhor do que o <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> método, porque ele não precisa determinar se o `strB` argumento é um tipo de valor mutável que deve ser boxed, e ele não tem que converter seu parâmetro de um <xref:System.Object> para um <xref:System.String>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método para comparar a instância atual da cadeia de caracteres com outra cadeia de caracteres.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 O exemplo a seguir demonstra não genéricos e versões do método CompareTo para vários tipos de valor e referência.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensíveis à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação de "animal" com "ani email" (usando um hífen flexível ou U + 00AD) indica que as duas cadeias de caracteres são equivalentes.  
  
 [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)]
 [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  
  
 Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chamar o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">Um objeto de coleção que implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> e cujo argumento de tipo genérico é <see cref="T:System.String" />.</param>
        <summary>Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />.</summary>
        <returns>As cadeias de caracteres concatenadas em <paramref name="values" /> ou <see cref="F:System.String.Empty" /> se <paramref name="values" /> for um <see langword="IEnumerable(Of String)" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto no `values`; ele não adicione qualquer delimitadores. Para especificar um delimitador entre cada membro do `values`, chame o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer elemento nulo no `values`.  
  
 Se `values` está vazio `IEnumerable(Of String)`, o método retornará <xref:System.String.Empty?displayProperty=nameWithType>. Se `values` é `null`, o método gera uma <xref:System.ArgumentNullException> exceção.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29>é um método prático que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres. É particularmente útil com expressões de consulta LINQ (consulta). O exemplo a seguir passa um `List(Of String)` objeto que contém as letras em maiusculas ou minúsculas do alfabeto em uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M"). O `IEnumerable(Of String)` coleção retornada pelo <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado a uma <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O objeto a ser representado ou <see langword="null" />.</param>
        <summary>Cria a representação de cadeia de caracteres de um objeto especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor de <paramref name="arg0" /> ou <see cref="F:System.String.Empty" /> se <paramref name="arg0" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Concat%28System.Object%29> método representa `arg0` como uma cadeia de caracteres chamando seu sem parâmetros `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objeto que contém os elementos a serem concatenados.</param>
        <summary>Concatena as representações de cadeia de caracteres dos elementos em uma matriz <see cref="T:System.Object" /> especificada.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores dos elementos em <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto na `args` chamando o sem parâmetros `ToString` método desse objeto; ele não adicione qualquer delimitadores.  
  
 <xref:System.String?displayProperty=nameWithType>é usado no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.Object> matriz.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <block subset="none" type="usage">
          <para>Este método não é chamado pelo código C++. O compilador do C++ resolve chamadas para <see cref="Overload:System.String.Concat" /> com quatro ou mais parâmetros de objeto como uma chamada para <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de instâncias de cadeia de caracteres.</param>
        <summary>Concatena os elementos de uma matriz <see cref="T:System.String" /> especificada.</summary>
        <returns>Os elementos concatenados de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto no `values`; ele não adicione qualquer delimitadores.  
  
 Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.String> matriz.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de dois objetos especificados.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Concatena o método `arg0` e `arg1` chamando o sem parâmetros `ToString` método `arg0` e `arg1`; ele não adicione qualquer delimitadores.  
  
 <xref:System.String?displayProperty=nameWithType>é usado no lugar de um argumento nulo.  
  
 Se um dos argumentos for uma referência de matriz, o método concatena uma cadeia de caracteres que representa essa matriz, em vez de seus membros (por exemplo, "System.String[]").  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <summary>Concatena duas instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" /> e <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0` e `str1`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres do idioma, como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir concatena, o meio e o último nome de uma pessoa.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <param name="arg2">O terceiro objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de três objetos especificados.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Concatena o método `arg0`, `arg1`, e `arg2` chamando o sem parâmetros `ToString` método de cada objeto; ele não adicione qualquer delimitadores.  
  
 <xref:System.String?displayProperty=nameWithType>é usado no lugar de um argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <param name="str2">A terceira cadeia de caracteres a ser concatenada.</param>
        <summary>Concatena três instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" />, <paramref name="str1" /> e <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0`, `str1`, e `str2`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres do idioma, como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Concat%2A> método concatenar três cadeias de caracteres e exibe o resultado.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <param name="arg2">O terceiro objeto a ser concatenado.</param>
        <param name="arg3">O quarto objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de quatro objetos especificados e quaisquer objetos especificados em uma lista de parâmetros opcionais de tamanho variável.</summary>
        <returns>A representação de cadeia de caracteres concatenada de cada valor na lista de parâmetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API não compatível com CLS. A alternativa compatível com CLS é <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Os compiladores c# e Visual Basic resolver automaticamente uma chamada para esse método como uma chamada para <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 O método concatena cada objeto na lista de parâmetros ao chamar seu sem parâmetros `ToString` método; ele não adicione qualquer delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType>é usado no lugar de um argumento nulo.  
  
> [!NOTE]
>  O último parâmetro do <xref:System.String.Concat%2A> método é uma lista delimitada por vírgulas opcional de um ou mais objetos adicionais para concatenar.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método concatenar uma lista de parâmetros variáveis. Nesse caso, o método é chamado com nove parâmetros.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Este método é marcado com o <see langword="vararg" /> palavra-chave, o que significa que ele oferece suporte a um número variável de parâmetros. O método pode ser chamado do Visual C++, mas ele não pode ser chamado de código c# ou Visual Basic. Os compiladores c# e Visual Basic resolver chamadas a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> como chamadas para <see cref="M:System.String.Concat(System.Object[])" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <param name="str2">A terceira cadeia de caracteres a ser concatenada.</param>
        <param name="str3">A quarta cadeia de caracteres a ser concatenada.</param>
        <summary>Concatena quatro instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> e <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0`, `str1`, `str2`, e `str3`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres do idioma, como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de quatro – letra palavras e armazena as letras individuais em uma matriz de cadeia de caracteres para embaralhá-los. Depois, ele chama o <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> método remontar as palavras embaralhadas.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos membros de <c>valores</c>.</typeparam>
        <param name="values">Um objeto de coleção que implementa a interface do <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatena os membros de uma implementação <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Os membros concatenados em <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto no `values`; ele não adicione qualquer delimitadores.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>é um método prático que permite a concatenação de cada elemento em um <xref:System.Collections.Generic.IEnumerable%601> coleção sem primeiro converter os elementos em cadeias de caracteres. É particularmente útil com expressões de consulta LINQ (consulta), como mostra o exemplo. A representação de cadeia de caracteres de cada objeto no <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada chamando esse objeto `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir define uma simples `Animal` classe que contém o nome de um animal e a ordem ao qual ele pertence. Em seguida, define um <xref:System.Collections.Generic.List%601> objeto para conter um número de `Animal` objetos. O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> é chamado de método de extensão para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Rodent". O resultado é passado para o <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método e exibidos no console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Retorna um valor que indica se uma subcadeia especificada ocorre nesta cadeia de caracteres.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> ocorrer nesta cadeia de caracteres, ou se <paramref name="value" /> for a cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura). A pesquisa começa na posição do primeiro caractere da cadeia de caracteres e continua por meio da posição do último caractere.  
  
 Para determinar se uma cadeia de caracteres contém uma subcadeia de caracteres especificada usando algo diferente de comparação ordinal (como comparação sensíveis à cultura, ou comparação ordinal de maiusculas e minúsculas), você pode criar um método personalizado. O exemplo a seguir ilustra uma dessas abordagens. Define uma <xref:System.String> método de extensão que inclui um <xref:System.StringComparison> parâmetro e indica se uma cadeia de caracteres contém uma subcadeia de caracteres ao usar o formulário especificado de comparação de cadeia de caracteres.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 O exemplo a seguir, em seguida, chama o `Contains` método de extensão para determinar se uma subcadeia de caracteres é encontrada em uma cadeia de caracteres ao usar comparação ordinal e comparação ordinal maiusculas de minúsculas.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Se você estiver interessado na posição da subcadeia de caracteres `value` na instância atual, você pode chamar o <xref:System.String.IndexOf%2A> método para obter a posição inicial da sua primeira ocorrência, ou você pode chamar o <xref:System.String.LastIndexOf%2A> método para obter a posição inicial de sua última ocorrência. O exemplo inclui uma chamada para o <xref:System.String.IndexOf%28System.String%29> método se uma subcadeia de caracteres for encontrada em uma instância de cadeia de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir determina se a cadeia de caracteres "raposa" é uma subcadeia de caracteres de uma cotação familiar. Se "raposa" for encontrado na cadeia de caracteres, ele também exibe sua posição inicial.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres a ser copiada.</param>
        <summary>Cria uma nova instância de <see cref="T:System.String" /> com o mesmo valor que um <see cref="T:System.String" /> especificado.</summary>
        <returns>Uma nova cadeia de caracteres com o mesmo valor que <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Copy%2A> método retorna um <xref:System.String> objeto que tem o mesmo valor de cadeia de caracteres original, mas que representa uma referência de objeto diferente. Ele é diferente de uma operação de atribuição, que atribui uma referência de cadeia de caracteres existente a uma variável de objeto adicionais. O exemplo ilustra a diferença.  
  
   
  
## Examples  
 O exemplo a seguir cria dois objetos de cadeia de caracteres com valores diferentes. Quando ele chama o <xref:System.String.Copy%2A> método para atribuir o primeiro valor para a segunda cadeia de caracteres, a saída indica que as cadeias de caracteres representam referências de objeto diferentes, embora seus valores agora são iguais. Por outro lado, quando a primeira cadeia de caracteres é atribuída à segunda cadeia de caracteres, as duas cadeias de caracteres têm valores idênticos, porque eles representam a mesma referência de objeto.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">O índice do primeiro caractere nessa instância a ser copiada.</param>
        <param name="destination">Uma matriz de caracteres Unicode para a qual caracteres nessa instância são copiados.</param>
        <param name="destinationIndex">O índice em <c>destino</c> no qual começa a operação de cópia.</param>
        <param name="count">O número de caracteres neste exemplo para copiar para <c>destino</c>.</param>
        <summary>Copia um número especificado de caracteres de uma posição especificada nesta instância para uma posição especificada em uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia `count` caracteres da `sourceIndex` posição dessa instância com o `destinationIndex` posição do `destination` matriz de caracteres. Esse método não redimensionar o `destination` matriz de caracteres; ele deve ter um número suficiente de elementos para acomodar os caracteres copiados ou o método gera uma <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex`e `destinationIndex` são baseadas em zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.CopyTo%2A> método.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, ou <paramref name="count" /> é negativo  
  
 -ou-  
  
 <paramref name="sourceIndex" />não identifica uma posição na instância atual.  
  
 -ou-  
  
 <paramref name="destinationIndex" />não identifica um índice válido na <paramref name="destination" /> matriz.  
  
 -ou-  
  
 <paramref name="count" />é maior que o comprimento da subcadeia de caracteres de <paramref name="sourceIndex" /> ao final desta instância  
  
 -ou-  
  
 <paramref name="count" /> é maior que o comprimento da submatriz de <paramref name="destinationIndex" /> até final da matriz <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa a cadeia de caracteres vazia. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor desse campo é a cadeia de caracteres de comprimento zero, "".  
  
 No código do aplicativo, esse campo é usado geralmente em atribuições de inicializar uma variável de cadeia de caracteres para uma cadeia de caracteres vazia. Para testar se o valor de uma cadeia de caracteres é `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, use o <xref:System.String.IsNullOrEmpty%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <summary>Determina se o final desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> corresponder ao final dessa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara `value` a subcadeia de caracteres no final desta instância que é o mesmo comprimento que `value`e retorna uma indicação se eles são iguais. São iguais, `value` deve ser uma referência a essa mesma instância ou corresponde final desta instância.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir indica se cada cadeia de caracteres em uma matriz termina com um ponto (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 O exemplo a seguir define uma `StripEndTags` método que usa o <xref:System.String.EndsWith%28System.String%29> método para remover as marcas de fim HTML do final de uma linha. Observe que o `StripEndTags` método é chamado recursivamente para garantir que várias marcas de término HTML no final da linha são removidas.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para determinar se uma cadeia de caracteres termina com uma determinada subcadeia de caracteres usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que determina como essa cadeia de caracteres e <c>valor</c> são comparados.</param>
        <summary>Determina se o fim dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado ao uso da opção de comparação especificada.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.EndsWith%2A> método compara o `value` parâmetro para a subcadeia de caracteres do final da cadeia de caracteres e retorna um valor que indica se são iguais. São iguais, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve coincidir com o fim da cadeia de caracteres. O tipo de comparação executada pelo <xref:System.String.EndsWith%2A> método depende do valor da `comparisonType` parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres termina com uma subcadeia de caracteres específica. Os resultados são afetados pela opção de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Informações de culturais que determina como essa instância e <c>valor</c> são comparados. Se <c>cultura</c> é <see langword="null" />, a cultura atual é usada.</param>
        <summary>Determina se o final dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara o `value` parâmetro para a subcadeia de caracteres do final da cadeia de caracteres que é o mesmo comprimento que `value`e retorna um valor que indica se são iguais. São iguais, `value` deve ser uma referência a essa mesma instância ou coincidir com o fim da cadeia de caracteres.  
  
 Esse método executa uma comparação de (sensíveis à cultura) do word usando o uso de maiusculas e minúsculas especificado e a cultura.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres ocorre no final da outra cadeia de caracteres. O <xref:System.String.EndsWith%2A> método é chamado várias vezes usando diferentes culturas que influenciam os resultados da pesquisa, diferenciação de maiusculas e minúsculas e maiusculas e minúsculas.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Determina se essa instância e um objeto especificado, que também deve ser um objeto <see cref="T:System.String" />, têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for um <see cref="T:System.String" /> e seu valor for o mesmo que o dessa instância; caso contrário, <see langword="false" />.  Se <paramref name="obj" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Determina se essa instância e outro objeto <see cref="T:System.String" /> especificado têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual ao valor dessa instância; caso contrário, <see langword="false" />. Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método. Ele compara a palavra de maiusculas e minúsculas título "File" com uma palavra equivalente, seu equivalente em letras minúsculas, seu equivalente em letras maiusculas e uma palavra que contém LATINO pequena LETRA sem ponto I (U + 0131) em vez de LATINO pequena LETRA I (U + 0069). Porque o <xref:System.String.Equals%28System.String%29> método executa uma comparação ordinal, somente a comparação com uma palavra idêntica retorna `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />. Se tanto <paramref name="a" /> quanto <paramref name="b" /> forem <see langword="null" />, o método retornará <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com esta instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica como as cadeias de caracteres serão comparadas.</param>
        <summary>Determina se essa cadeia de caracteres e um objeto <see cref="T:System.String" /> especificado têm o mesmo valor. Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</summary>
        <returns>
          <see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual a essa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura invariável ou atual, respeitam ou ignorar o caso das duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de cadeia de caracteres que consiste em letras maiusculas "I", "i" em letras minúsculas e "ı" sem ponto. Depois, ele chama o <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método compará-los por meio de cada possível <xref:System.StringComparison> valor de enumeração.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 O exemplo a seguir compara os quatro conjuntos de palavras usando cada membro de <xref:System.StringComparison> enumeração.  As comparações de usam as convenções do inglês (Estados Unidos) e culturas Sami (Suécia superior). Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalentes na cultura en-US, mas não na cultura Sami (Norte Suécia).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a comparação.</param>
        <summary>Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor. Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</summary>
        <returns>
          <see langword="true" /> se o valor do parâmetro <paramref name="a" /> for igual ao valor do parâmetro <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura invariável ou atual, respeitam ou ignorar o caso das duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.  
  
   
  
## Examples  
 O exemplo a seguir compara os quatro conjuntos de palavras usando cada membro de <xref:System.StringComparison> enumeração.  As comparações de usam as convenções do inglês (Estados Unidos) e culturas Sami (Suécia superior). Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalentes na cultura en-US, mas não na cultura Sami (Norte Suécia).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte o valor de objetos em cadeias de caracteres com base em formatos de especificado e as insere em outra cadeia de caracteres.  
  
 Se você estiver familiarizado com o <see cref="Overload:System.String.Format" /> método, consulte o [guia de Introdução com o método String. Format](#Starting) seção para obter uma visão geral rápida.  
  
 Consulte o [comentários](#Format_Syntax) seção para obter a documentação completa de todos os <see cref="Overload:System.String.Format" /> sobrecargas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nesta seção:  
  
 [Guia de Introdução com o método String. Format](#Starting)   
 [Sintaxe de método sobrecarregado](#Format_Syntax)   
 [Parâmetros](#Format_Params)   
 [Valor de retorno](#Format_Returns)   
 [Exceções](#Format_Exceptions)   
 [Qual método chamar?](#FTaskList)   
 [O método de formato em breve](#Format_Brief)   
 [O item de formato](#FormatItem)   
 [Como os argumentos são formatados](#HowFormatted)   
 [Itens de formato que têm o mesmo índice](#SameIndex)   
 [Formatação e cultura](#Format_Culture)   
 [Operações de formatação personalizada](#Format_Custom)   
 Exemplos:   
 [Formatação de um único argumento](#Format1_Example)  
 [Formatação de dois argumentos](#Format2_Example)  
 [Formatação de três argumentos](#Format3_Example)  
 [Formatação de mais de três argumentos](#Format4_Example)  
 [Formatação de cultura](#Format5_Example)  
 [Uma operação de formatação personalizada](#Format6_Example)  
 [Um formatador de numerais romanos e o provedor de interceptação](#Format7_Example)  
[Informações de versão](#Format_Versions)  
[Format p e r](#QA)  
  
<a name="Starting"></a>   
## <a name="getting-started-with-the-stringformat-method"></a>Guia de Introdução com o método String. Format  
 Use <xref:System.String.Format%2A?displayProperty=nameWithType> se você precisa inserir o valor de um objeto, variável ou expressão em outra cadeia de caracteres. Por exemplo, você pode inserir o valor de uma <xref:System.Decimal> valor em uma cadeia de caracteres para exibi-lo ao usuário como uma única cadeia de caracteres:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 E você pode controlar a formatação do valor:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Além de formatação, você também pode controlar alinhamento e espaçamento.  
  
 Inserir uma cadeia de caracteres  
 <xref:System.String.Format%2A?displayProperty=nameWithType>começa com uma cadeia de caracteres de formato, seguida por um ou mais objetos ou expressões que serão convertidas em cadeias de caracteres e inseridas em um local especificado na cadeia de caracteres de formato. Por exemplo:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 O `{0}` no formato de cadeia de caracteres é um item de formato. `0`é o índice do objeto cujo valor de cadeia de caracteres será inserido nessa posição. (Os índices começam em 0.) Se o objeto a ser inserido não é uma cadeia de caracteres, seu `ToString` método é chamado para convertê-lo em um antes de inseri-la na cadeia de caracteres de resultado.  
  
 Aqui está outro exemplo que usa dois itens de formato e dois objetos na lista de objetos:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Você pode ter tantos itens de formato e quantos objetos na lista de objetos que você desejar, desde que o índice de cada item de formato tem um objeto correspondente na lista de objetos. Você também não precisa se preocupar sobre qual sobrecarga chamar; o compilador irá selecionar aquela adequada para você.  
  
 Controlando a formatação  
 Você pode seguir o índice de um item de formato com uma cadeia de caracteres de formato para controlar como um objeto é formatado. Por exemplo, `{0:d}` aplica-se a cadeia de caracteres de formato "d" para o primeiro objeto na lista de objetos. Aqui está um exemplo com um único objeto, e dois itens de formato:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Um número de suporte a tipos de formato cadeias de caracteres, incluindo todos os tipos numéricos (ambos [padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) cadeias de caracteres de formato), todas as datas e horas (bot h [padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md) cadeias de caracteres de formato) e intervalos de tempo (ambos [padrão d](~/docs/standard/base-types/standard-timespan-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md) cadeias de caracteres de formato), todos os tipos de enumeração [tipos de enumeração](~/docs/standard/base-types/enumeration-format-strings.md), e                                          [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx). Você também pode adicionar suporte para cadeias de caracteres de formato para seus próprios tipos.  
  
 Controlando o espaçamento  
 Você pode definir a largura da cadeia de caracteres que é inserida na cadeia de caracteres de resultado usando sintaxe como `{0,12}`, que insere uma cadeia de caracteres de 12. Nesse caso, a representação de cadeia de caracteres do primeiro objeto é alinhado à direita do campo de 12 caracteres.  (Se a representação de cadeia de caracteres do primeiro objeto é mais de 12 caracteres, no entanto, a largura do campo preferencial é ignorada e a cadeia de caracteres inteira é inserida na cadeia de caracteres de resultado.)  
  
 O exemplo a seguir define um campo de 6 caracteres para manter a cadeia de caracteres "Ano" e algumas cadeias de caracteres do ano, bem como um campo de 15 caracteres para manter a cadeia de caracteres "População" e alguns dados de população. Observe que os caracteres são alinhadas à direita do campo.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#33)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 Controlando o alinhamento  
 Por padrão, cadeias de caracteres são alinhadas à direita em seu campo se você especificar uma largura de campo. Para alinhar à esquerda cadeias de caracteres em um campo, você precede a largura do campo com um sinal negativo, como `{0,-12}` para definir um campo de 12 caracteres alinhada à direita.  
  
 O exemplo a seguir é semelhante ao anterior, exceto que ele alinha à esquerda os rótulos e os dados.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType>usa o recurso de formatação composta. Para obter mais informações, veja [Formatação de composição](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="Format_Syntax"></a>   
## <a name="overloaded-method-syntax"></a>Sintaxe de método sobrecarregada  
 Para obter orientação adicional sobre como escolher uma sobrecarga, consulte [qual método é chamada?](#FTaskList)  
  
 `String String.Format(String format, Object arg0)`  
 Substitui os itens de formato com a representação de cadeia de caracteres de um objeto especificado ([exemplo](#Format1_Example)).  
  
 `String String.Format(String format, Object arg0, Object arg1)`  
 Substitui os itens de formato com a representação de cadeia de caracteres de dois objetos especificados ([exemplo](#Format2_Example)).  
  
 `String String.Format(String format, Object arg0, Object arg1, Object arg2)`  
 Substitui os itens de formato com a representação de cadeia de caracteres de três objetos especificados ([exemplo](#Format3_Example)).  
  
 `String String.Format(String format, params Object[] args)`  
 Substitui os itens de formato com as representações de cadeia de caracteres de objetos correspondentes em uma matriz especificada ([exemplo](#Format4_Example)).  
  
 `String String.Format(IFormatProvider provider, String format, params Object[] args)`  
 Substitui os itens de formato com a representação de cadeia de caracteres de objetos correspondentes em uma matriz especificada e usa as informações de formatação específica da cultura especificadas ([exemplo](#Format5_Example)) ou as informações de formatação personalizada ([exemplo](#Format6_Example)).  
  
<a name="Format_Params"></a>   
## <a name="parameters"></a>Parâmetros  
 Esta é uma lista completa de parâmetros para o <xref:System.String.Format%2A> método; consulte a sintaxe de sobrecarga acima para os parâmetros usados por cada sobrecarga. Somente o `format` parâmetro é usado por todas as sobrecargas.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`format`|<xref:System.String>|Uma cadeia de caracteres de formato composto que inclui um ou mais itens de formato (consulte [o item de formato](#FormatItem)).|  
|`arg0`|<xref:System.String>|O primeiro ou apenas o objeto para formatar.|  
|`arg1`|<xref:System.String>|O segundo objeto a ser formatado.|  
|`arg2`|<xref:System.String>|O terceiro objeto a ser formatado.|  
|`args`|<xref:System.String>[]|Zero ou mais objetos para formatar, fornecido em uma lista delimitada por vírgulas ou como uma matriz.|  
|`provider`|<xref:System.IFormatProvider>|Um objeto que fornece informações de formatação personalizadas ou específicos de cultura.|  
  
<a name="Format_Returns"></a>   
## <a name="return-value"></a>Valor retornado  
 Tipo: <xref:System.String>  
Uma cópia do `format` no qual os itens de formato foram substituídos pelas representações de cadeia de caracteres de argumentos correspondentes.  
  
<a name="Format_Exceptions"></a>   
## <a name="exceptions"></a>Exceções  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`format` é `null`.|Todas as sobrecargas.|  
|<xref:System.FormatException>|`format` é inválido.<br /><br /> -ou-<br /><br /> O índice de um item de formato é menor que zero, ou maior que ou igual ao número de argumentos na lista de argumentos.|Todas as sobrecargas.|  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Qual método devo chamar?  
  
|Para|Chamada|  
|--------|----------|  
|Formate um ou mais objetos usando as convenções da cultura atual.|Exceto para as sobrecargas que incluem um `provider` parâmetro, o restante <xref:System.String.Format%2A> sobrecargas incluem um <xref:System.String> parâmetro seguido por um ou mais parâmetros de objeto. Por isso, você não precisa determinar qual <xref:System.String.Format%2A> sobrecarga que você pretende chamar. O compilador de linguagem selecionará a sobrecarga apropriada entre as sobrecargas que não têm um `provider` parâmetro, com base em sua lista de argumentos. Por exemplo, se a lista de argumentos tem cinco argumentos, o compilador chamará o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método.|  
|Formate um ou mais objetos usando as convenções de uma cultura específica.|Cada <xref:System.String.Format%2A> sobrecarga que começa com um `provider` parâmetro é seguido por um <xref:System.String> parâmetro e um ou mais parâmetros do objeto. Por isso, não é necessário determinar quais específico <xref:System.String.Format%2A> sobrecarga que você pretende chamar. O compilador de linguagem selecionará a sobrecarga apropriada entre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos. Por exemplo, se a lista de argumentos tem cinco argumentos, o compilador chamará o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método.|  
|Executar uma operação de formatação personalizada com uma <xref:System.ICustomFormatter> implementação ou uma <xref:System.IFormattable> implementação.|Qualquer uma das quatro sobrecargas com um `provider` parâmetro. compilador selecionará a sobrecarga apropriada entre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>O método Format resumido  
 Cada sobrecarga do <xref:System.String.Format%2A> método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para incluir com base em zero espaços reservados indexados, chamados de itens de formato, em uma cadeia de caracteres de formato composto. Em tempo de execução, cada item de formato é substituído com a representação de cadeia de caracteres do argumento correspondente em uma lista de parâmetros. Se o valor do argumento for `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Por exemplo, a seguinte chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método inclui uma cadeia de caracteres de formato com formato de três itens, {0}, \\{1 \\} e 2} e uma lista de argumentos com três itens.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>O item de formato  
 Um item de formato tem a seguinte sintaxe:  
  
```  
  
{  
index[,alignment][ :formatString] }  
```  
  
 Colchetes indicam elementos opcionais. As chaves de abertura e fechamento são necessárias. (Para incluir um literal de abertura ou fechamento na cadeia de formato, consulte a seção "Chaves de escape" o [formatação composta](~/docs/standard/base-types/composite-formatting.md) artigo.)  
  
 Por exemplo, um item de formato para o formato que talvez de um valor de moeda é exibida como essa:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
  
 Um item de formato tem os seguintes elementos:  
  
 *índice*  
 O índice de base zero do argumento cuja representação de cadeia de caracteres será incluído nessa posição na cadeia de caracteres. Se esse argumento for `null`, uma cadeia de caracteres vazia será incluída nessa posição na cadeia de caracteres.  
  
 *alinhamento*  
 Opcional. Um inteiro que indica o comprimento total do campo em que o argumento é inserido e se ele estiver alinhado à direita (um inteiro positivo) ou alinhado à esquerda (um inteiro negativo). Se você omitir *alinhamento*, a representação de cadeia de caracteres do argumento correspondente é inserida em um campo sem espaços à esquerda ou à direita.  
  
 Se o valor de *alinhamento* é menor que o comprimento do argumento a ser inserido, *alinhamento* será ignorado e o comprimento da representação de cadeia de caracteres do argumento é usado como a largura do campo.  
  
 *formatString*  
 Opcional. Uma cadeia de caracteres que especifica o formato de cadeia de caracteres de resultado do argumento correspondente. Se você omitir *formatString*, o argumento correspondente sem parâmetros `ToString` método é chamado para gerar sua representação de cadeia de caracteres. Se você especificar *formatString*, o argumento referenciado pelo item de formato deve implementar o <xref:System.IFormattable> interface. Tipos que oferecem suporte a cadeias de caracteres de formato:  
  
-   Todos os tipos de ponto flutuantes e integrais. (Consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> e <xref:System.DateTimeOffset>. (Consulte [cadeias de caracteres de formato de data e hora padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [cadeias de caracteres de formato de data e hora personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Todos os tipos de enumeração. (Consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   valores <xref:System.TimeSpan>. (Consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de caracteres de formato TimeSpan personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Consulte o <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> método.)  
  
 No entanto, observe que qualquer tipo personalizado pode implementar <xref:System.IFormattable> ou estender um tipo existente <xref:System.IFormattable> implementação.  
  
 O exemplo a seguir usa o `alignment` e `formatString` argumentos para produzir saída formatada.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Como os argumentos são formatados  
 Itens de formato são processadas sequencialmente desde o início da cadeia de caracteres. Cada item de formato tem um índice que corresponde a um objeto na lista de argumentos do método. O <xref:System.String.Format%2A> recupera o argumento de método e sua representação de cadeia de caracteres é derivada da seguinte maneira:  
  
-   Se o argumento for `null`, o método insere <xref:System.String.Empty?displayProperty=nameWithType> na cadeia de caracteres de resultado.  
  
-   Se você chamar o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> de sobrecarga e a `provider` parâmetro implementa o <xref:System.ICustomFormatter> interface, o argumento é passado para o `provider` do objeto <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método. Se o item de formato inclui um *formatString* argumento, ele é passado como o primeiro argumento para o método. Se o <xref:System.ICustomFormatter> implementação é capaz de fornecer serviços de formatação, ele retorna a representação de cadeia de caracteres do argumento; caso contrário, retornará `null` e executa a próxima etapa.  
  
-   Se o argumento implementa o <xref:System.IFormattable> interface, seu <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> é chamada de implementação.  
  
-   O argumento sem parâmetros `ToString` método, o que pode ser substituído ou herdado da <xref:System.Object> classe, é chamado.  
  
 Para obter um exemplo que intercepta chamadas para o <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> método e permite que você veja quais informações o <xref:System.String.Format%2A> método passa para um método de formatação para cada item de formato em uma cadeia de caracteres de formato composto, consulte [exemplo 7: um provedor de interceptação formatador de numerais romanos e](#Format7_Example).  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Itens de formato que têm o mesmo índice  
 O <xref:System.String.Format%2A> método lança um <xref:System.FormatException> exceção se o índice de um item do índice é maior que ou igual ao número de argumentos na lista de argumentos. No entanto, `format` pode incluir mais itens de formato que o número de argumentos, como vários itens de formato tem o mesmo índice. Na chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%29> método no exemplo a seguir, a lista de argumento tem um único argumento, mas a cadeia de caracteres de formato inclui dois itens de formato: um exibe o valor decimal de um número, e o outro exibe seu valor hexadecimal.  
  
 [!code-csharp[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatação e cultura  
 Em geral, os objetos na lista de argumentos são convertidos em suas representações de cadeia de caracteres usando as convenções da cultura atual, que é retornado pelo <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedade. Você pode controlar esse comportamento chamando uma das sobrecargas do <xref:System.String.Format%2A> que inclui um `provider` parâmetro. O `provider` parâmetro é um <xref:System.IFormatProvider> o processo de implementação que fornece informações de formatação personalizadas e específicos de cultura que são usadas para a formatação de moderada.  
  
 O <xref:System.IFormatProvider> interface tem um único membro, <xref:System.IFormatProvider.GetFormat%2A>, que é responsável por retornar o objeto que fornece informações de formatação. O .NET Framework tem três <xref:System.IFormatProvider> implementações que fornecem a formatação de cultura específica:  
  
-   <xref:System.Globalization.CultureInfo>. Seu <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna uma cultura específica <xref:System.Globalization.NumberFormatInfo> objeto para a formatação de valores numéricos e uma cultura específica <xref:System.Globalization.DateTimeFormatInfo> objeto para a formatação de valores de data e hora.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, que é usado para formatação de cultura específica de valores de data e hora. Seu <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> método retorna ele mesmo.  
  
-   <xref:System.Globalization.NumberFormatInfo>, que é usado para formatação de valores numéricos de cultura específica. Seu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propriedade retorna ele mesmo.  
  
<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Operações de formatação personalizadas  
 Você também pode chamar qualquer uma das sobrecargas do <xref:System.String.Format%2A> método que tem um `provider` parâmetro <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> sobrecarga para executar operações de formatação personalizadas. Por exemplo, você pode formatar um número inteiro como um número de identificação ou como um número de telefone. Para executar a formatação personalizada, seu `provider` argumento deve implementar o <xref:System.IFormatProvider> e <xref:System.ICustomFormatter> interfaces. Quando o <xref:System.String.Format%2A> método é passado um <xref:System.ICustomFormatter> implementação como o `provider` argumento, o <xref:System.String.Format%2A> chamadas de método seu <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementação e solicita um objeto do tipo <xref:System.ICustomFormatter>. Em seguida, chama retornado <xref:System.ICustomFormatter> do objeto <xref:System.ICustomFormatter.Format%2A> método para formatar cada item de formato na cadeia de caracteres composta passados para ele.  
  
 Para obter mais informações sobre como fornecer soluções personalizadas de formatação, consulte [como: definir e usar provedores de formato de numérico personalizados](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) e <xref:System.ICustomFormatter>. Para obter um exemplo que converte números inteiros em números personalizados formatados, consulte [exemplo 6: uma operação de formatação personalizada](#Format6_Example). Para obter um exemplo que converte bytes sem sinal em numerais romanos, consulte [exemplo 7: um formatador de numerais romanos e o provedor de interceptação](#Format7_Example).  
  
<a name="Format1_Example"></a>   
## <a name="example-1-formatting-a-single-argument"></a>Exemplo 1: formatando um único argumento  
 O exemplo a seguir usa o <xref:System.String.Format%28System.String%2CSystem.Object%29> método para inserir a idade de uma pessoa no meio de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  
  
<a name="Format2_Example"></a>   
## <a name="example-2-formatting-two-arguments"></a>Exemplo 2: formatando dois argumentos  
 Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> método para exibir dados de hora e temperatura armazenados em um genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Observe que a cadeia de caracteres de formato tem três itens de formato, embora haja somente dois objetos para formatar. Isso ocorre porque o objeto primeiro na lista (um valor de data e hora) é usado por dois itens de formato: O primeiro exibe de item de formato a hora e a segunda exibe a data.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
  
<a name="Format3_Example"></a>   
## <a name="example-3-formatting-three-arguments"></a>Exemplo 3: formatando três argumentos  
 Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para criar uma cadeia de caracteres que ilustra o resultado de um valor booleano `And` operação com dois valores inteiros. Observe que a cadeia de caracteres de formato inclui seis itens de formato, mas o método tem somente três itens na lista de parâmetros, porque cada item é formatado de duas maneiras diferentes.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
  
<a name="Format4_Example"></a>   
## <a name="example-4-formatting-more-than-three-arguments"></a>Exemplo 4: formatando mais de três argumentos  
 Este exemplo cria uma cadeia de caracteres que contém dados sobre a temperatura alta e baixa em uma determinada data. A cadeia de caracteres de formato composto tem cinco itens de formato de exemplo do c# e seis no exemplo do Visual Basic. Dois dos itens de formato definem a largura da representação de cadeia de caracteres do seu valor correspondente, e o primeiro item de formato também inclui um padrão de data e a cadeia de caracteres de formato de hora.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Você também pode passar os objetos a serem formatados como uma matriz em vez de uma lista de argumentos.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  
  
<a name="Format5_Example"></a>   
## <a name="example-5-culture-sensitive-formatting"></a>Exemplo 5: formatação sensível à cultura  
 Este exemplo usa o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método para exibir a representação de cadeia de caracteres de alguns valores de data e hora e valores numéricos, usando várias culturas diferentes.  
  
 [!code-csharp[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  
  
<a name="Format6_Example"></a>   
## <a name="example-6-a-custom-formatting-operation"></a>Exemplo 6: uma operação de formatação personalizada  
 Este exemplo define um provedor de formato que formata um valor inteiro como um número de conta do cliente no formato x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
## <a name="example-7-an-intercept-provider-and-roman-numeral-formatter"></a>Exemplo 7: um provedor de interceptação e formatador de algarismo romano  
 Este exemplo define um provedor de formato personalizado que implementa o <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfaces de duas coisas:  
  
-   Ele exibe os parâmetros passados à sua <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementação. Isso nos permite ver quais parâmetros o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método está passando para a implementação de formatação personalizada para cada objeto que ele tenta formatar. Isso pode ser útil quando você estiver depurando seu aplicativo.  
  
-   Se o objeto a ser formatado é um valor de byte não atribuído que deve ser formatada usando a cadeia de caracteres de formato padrão de "R", o formatador personalizado formata o valor numérico como um numeral romano.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="Format_Versions"></a>   
## <a name="version-information"></a>Informações de versão  
 .NET Framework  
 Todas as sobrecargas são suportadas em: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Todas as sobrecargas são suportadas em: 4, 3.5 SP1  
  
 Biblioteca de Classes Portátil  
 Somente <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> e <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> são suportados  
  
 .NET para aplicativos da Windows Store  
 Somente <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> e <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> têm suporte no Windows 8  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>Format p e r  
  
### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Onde posso encontrar uma lista de cadeias de formato predefinidas que podem ser usados com itens de formato?  
  
-   Para todos os tipos de ponto flutuantes e integrais, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter valores de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para <xref:System.TimeSpan> valores, consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de formato TimeSpan personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Para <xref:System.Guid> valores, consulte a seção comentários a <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> página de referência.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Como controlar o alinhamento de cadeias de caracteres de resultado substituir itens de formato?  
 A sintaxe geral de um item de formato é:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 onde *alinhamento* é um inteiro que define a largura do campo. Se esse valor for negativo, o texto do campo é alinhado à esquerda. Se ele for positivo, o texto é alinhado à direita.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Como controlar o número de dígitos após o separador decimal?  
 Todos os [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) exceto "D" (que é usado com apenas números inteiros), "G", "R" e "X" permitir que um especificador de precisão que define o número de casas decimais na cadeia de caracteres de resultado. O exemplo a seguir usa cadeias de caracteres de formato numérico padrão para controlar o número de casas decimais na cadeia de caracteres de resultado.  
  
 [!code-csharp[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Se você estiver usando um [cadeia de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), use o especificador de formato "0" para controlar o número de casas decimais na cadeia de caracteres de resultado, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Como controlar o número de dígitos integrais?  
 Por padrão, as operações de formatação exibem somente dígitos integrais diferente de zero. Se você estiver formatando números inteiros, você pode usar um especificador de precisão com "D" e "X" cadeias de caracteres de formato padrão para controlar o número de dígitos.  
  
 [!code-csharp[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Você pode acrescentar um inteiro ou um número de ponto flutuante com zeros à esquerda para produzir uma cadeia de caracteres de resultado com um número especificado de dígitos integrais usando "0" [especificador de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), como mostra o exemplo a seguir.  
  
 [!code-csharp[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>O número de itens pode incluir na lista de formato?  
 Não há nenhum limite prático. O segundo parâmetro do <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método é marcado com o <xref:System.ParamArrayAttribute> atributo, que permite que você inclua uma lista delimitada ou uma matriz de objetos como sua lista de formato.  
  
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Como incluir a literal chaves ("{" e "}") na cadeia de caracteres de resultado?  
 Por exemplo, como evitar a seguinte chamada de método de lançar um <xref:System.FormatException> exceção?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Um simples de abertura ou fechamento sempre é interpretado como o início ou término de um item de formato. Para ser interpretadas literalmente, ela deverá ser substituída. Escape de uma chave com a adição de outra chave ("{{" e "}}" em vez de "{" e "}"), conforme mostrado no seguinte chamada de método:  
  
 [!code-csharp[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 No entanto, até mesmo chaves são facilmente mal interpretadas. É recomendável que você inclua chaves na lista de formato e usa itens de formato para inseri-los na cadeia de caracteres de resultado, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Por que minha chamada ao método String. Format lança um FormatException?  
 A causa mais comum da exceção é que o índice de um item de formato não corresponde a um objeto na lista de formato. Geralmente isso indica que você tenha misnumbered os índices de itens de formato ou tiver esquecido incluir um objeto na lista de formato. Ocasionalmente, a exceção é o resultado de um erro de digitação; Por exemplo, um erro comum é digitar "[" (o colchete esquerdo), em vez de "{" (o colchete esquerdo).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Se o método Format(System.IFormatProvider,System.String,System.Object[]) oferece suporte a matrizes de parâmetro, por que meu código lançar uma exceção quando usar uma matriz?  
 Por exemplo, o código a seguir gera um <xref:System.FormatException> exceção:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Este é um problema de resolução de sobrecarga do compilador. Porque o compilador não pode converter uma matriz de inteiros em uma matriz de objetos, ele trata a matriz de inteiros como um único argumento, portanto, ele chama o <xref:System.String.Format%28System.String%2CSystem.Object%29> método. A exceção é gerada porque há quatro itens de formato, mas apenas um único item na lista de formato.  
  
 Como o Visual Basic nem c# pode converter uma matriz de inteiros em uma matriz de objeto, você precisa executar a conversão antes de chamar o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método. O exemplo a seguir fornece uma implementação.  
  
 [!code-csharp[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Substitui um ou mais itens de formato em uma cadeia de caracteres especificada com a representação de cadeia de caracteres de um objeto especificado.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">O item de formato em <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato não é zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</param>
        <summary>Substitui o item de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres de um objeto correspondente em uma matriz especificada.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero, ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Substitui o item ou itens de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres do objeto correspondente. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual o item ou itens de formato foram substituídos pela representação de cadeia de caracteres do <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="arg0" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero ou maior ou igual a um.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres especificada pelas representações de cadeia de caracteres de objetos correspondentes em uma matriz especificada. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero, ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres especificada pela representação da cadeia de caracteres de um objeto especificado.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato não é zero nem um.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres especificada pela representação da cadeia de caracteres de um objeto especificado. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />, <paramref name="arg0" /> ou <paramref name="arg1" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero ou maior ou igual a dois.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres de três objetos especificados.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero ou maior que dois.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres de três objetos especificados. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Format`, consulte o resumo da sobrecarga <xref:System.String.Format%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" />, <paramref name="arg0" />, <paramref name="arg1" /> ou <paramref name="arg2" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que zero ou maior ou igual a três.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um objeto que pode iterar os caracteres individuais nessa cadeia de caracteres.</summary>
        <returns>Um objeto enumerador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  Em vez de chamar o <xref:System.String.GetEnumerator%2A> método para recuperar um <xref:System.CharEnumerator> do objeto que você usa para enumerar uma cadeia de caracteres, em vez disso, você deve usar construção de iteração do idioma (em c#, em C + + CLR e no Visual Basic).                   [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) em c#, [para cada](http://msdn.microsoft.com/library/0c3a364b-2747-43f3-bb8d-b7d3b7023f79) em C + + CLR, e [para cada](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) no Visual Basic).  
  
 Esse método permite que você iterar os caracteres individuais em uma cadeia de caracteres. Por exemplo, o Visual Basic `For Each` e c# `foreach` instruções invocar esse método para retornar um <xref:System.CharEnumerator> objeto que pode fornecer acesso somente leitura aos caracteres nesta instância de cadeia de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir itera os caracteres em várias cadeias de caracteres e exibe informações sobre seus caracteres individuais. Ele usa a construção de iteração de idioma em vez de uma chamada para o <xref:System.String.GetEnumerator%2A> método.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash desta cadeia de caracteres.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento de <xref:System.String.GetHashCode%2A> depende de sua implementação, o que pode ser alterado de uma versão do common language runtime para outro. Um motivo por que isso pode acontecer é melhorar o desempenho de <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Se dois objetos de cadeia de caracteres forem iguais, o <xref:System.String.GetHashCode%2A> método retorna valores idênticos. No entanto, não há um valor de código hash exclusivo para cada valor de cadeia de caracteres exclusiva. Cadeias de caracteres diferentes podem retornar o mesmo código de hash.  
>   
>  Não há garantia de que o código de hash estável. Códigos de hash para cadeias de caracteres idênticos podem ser diferentes entre versões do .NET Framework e entre plataformas (como 32 bits e 64 bits) para uma única versão do .NET Framework. Em alguns casos, eles ainda podem diferir por domínio de aplicativo. Isso significa que duas execuções subsequentes do mesmo programa podem retornar códigos hash diferente.  
>   
>  Como resultado, hash códigos nunca devem ser usados fora do domínio de aplicativo no qual eles foram criados, eles nunca devem ser usados como campos de chave em uma coleção e nunca deve ser mantidos.  
>   
>  Por fim, não use o código de hash em vez de um valor retornado por uma função de hash criptográfica, se você precisar de um hash forte criptograficamente. Para hashes criptográficos, use uma classe derivada do <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Para obter mais informações sobre códigos de hash, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Em aplicativos de área de trabalho, você pode usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) para gerar códigos de hash exclusivo em um por cada domínio de aplicativo. Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash. O exemplo a seguir mostra como usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Define um para gerar códigos de hash exclusivo em um por cada domínio de aplicativo. Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash. O exemplo a seguir mostra como usar o. Define uma `DisplayString` classe que inclui uma constante de cadeia de caracteres privada, `s`, cujo valor é "É uma cadeia de caracteres." Ele também inclui um `ShowStringHashCode` método que exibe o valor de cadeia de caracteres e o código de hash junto com o nome do domínio do aplicativo no qual o método está em execução.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Quando você executa o exemplo sem fornecer um arquivo de configuração, ele exibe a saída semelhante à seguinte. Observe que os códigos de hash para a cadeia de caracteres são idênticos nos domínios de aplicativo de dois.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 No entanto, se você adicionar o seguinte arquivo de configuração para o diretório de exemplo e, em seguida, executa o exemplo, os códigos de hash para a mesma cadeia de caracteres serão diferentes por domínio de aplicativo.  
  
```  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Quando o arquivo de configuração estiver presente, o exemplo exibe a saída a seguir:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Códigos de hash são usados para inserir e recuperar objetos de chave das tabelas de hash com eficiência. No entanto, códigos hash não identificar exclusivamente cadeias de caracteres. Cadeias de caracteres idênticas tem códigos hash igual, mas o common language runtime também pode atribuir o mesmo código hash para cadeias de caracteres diferentes. Além disso, códigos hash podem variar por versão do .NET Framework, plataforma dentro de uma única versão e o domínio de aplicativo. Por isso, você não deve serializar ou manter valores de código hash, nem você usá-los como chaves em uma tabela de hash ou dicionário.  
  
 Para obter informações adicionais sobre o uso de códigos hash e o `GetHashCode` método, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.GetHashCode%2A> método usando várias cadeias de caracteres de entrada.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>O valor retornado por <see cref="M:System.String.GetHashCode" /> é dependente de plataforma. Ele é diferente nas versões de 32 bits e 64 bits do .NET Framework. Ele também pode ser diferente entre as versões do .NET Framework.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para a classe <see cref="T:System.String" />.</summary>
        <returns>A constante enumerada, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o <xref:System.TypeCode> enumerada constante para o <xref:System.String> tipo.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode pesquisar um <xref:System.String> para um caractere usando o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso essa cadeia de caracteres seja encontrada ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa na posição do primeiro caractere desta instância e continua até a última posição do caractere.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.IndexOf%28System.String%29> método sempre retorna 0 (zero) para indicar que a correspondência for localizada no início da instância atual. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%29> método é usado para localizar três subcadeias de caracteres (um hífen flexível (U + 00AD), um hífen suave, seguido por "n" e um hífen suave, seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen flexível é um caractere ignorável, o resultado é o mesmo como se o hífen flexível não foi incluído no `value`. Ao procurar por um hífen flexível somente, o método retornará 0 (zero) para indicar que encontrou uma correspondência no início da cadeia de caracteres.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 O exemplo a seguir procura por "n" em "animal". Como os índices de cadeia de caracteres começam em zero em vez de um, o <xref:System.String.IndexOf%28System.String%29> método indica que o "n" na posição 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para determinar a posição inicial de um nome de animais em uma sentença. Ele então usa essa posição para inserir um adjetivo que descreve o animal na sentença.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua `comparisonType` parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` é igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 A pesquisa varia de `startIndex` ao final da cadeia de caracteres.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho da cadeia de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` é igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa a `startIndex` posição desta instância do caractere e continua até a última posição do caractere.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método sempre retornará `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar a posição de um hífen flexível (U + 00AD) seguida por um "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 O exemplo a seguir procura todas as ocorrências de uma cadeia de caracteres especificada dentro de uma cadeia de caracteres de destino.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres que ocorre após uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua `comparisonType` parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice do parâmetro <paramref name="value" /> caso essa cadeia de caracteres seja encontrada, ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método que localiza a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método sempre retorna 0 (zero) para indicar que a correspondência for localizada no início da instância atual.  
  
 No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método é usado para localizar três subcadeias de caracteres (um hífen flexível (U + 00AD), um hífen suave, seguido por "n" e um hífen suave, seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, como o hífen flexível é um caractere ignorável, uma pesquisa sensíveis à cultura retorna o mesmo valor que será retornado se o hífen flexível não foram incluídas na cadeia de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen flexível em uma cadeia de caracteres com êxito e relatórios que está ausente da segunda cadeia de caracteres.  
  
 [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)]
 [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere especificado nessa instância. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa começa em `startIndex` e continua a `startIndex`  +  `count` -1. O caractere no `startIndex`  +  `count` não está incluído na pesquisa.  
  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 <paramref name="startIndex" />é maior que o comprimento da cadeia de caracteres.  
  
 -ou-  
  
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa em `startIndex` e continua a `startIndex`  +  `count` -1. O caractere no `startIndex`  +  `count` não está incluído na pesquisa.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método sempre retornará `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método é usado para localizar a posição de um hífen flexível (U + 00AD) seguida por um "m" iniciando no terceiro à sexta posição do caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências da cadeia de caracteres "OL" dentro de uma subcadeia de caracteres de outra cadeia de caracteres. Observe que o número de caracteres a ser pesquisada deve ser recalculado para cada iteração de pesquisa.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 <paramref name="startIndex" />é maior que o comprimento da cadeia de caracteres.  
  
 -ou-  
  
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para usar as regras de comparação da cultura atual para executar esta operação, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua `comparisonType` parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Os parâmetros especificam a posição de pesquisa inicial na cadeia de caracteres atual e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` é igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método que localiza a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retornará <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
 No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen flexível (U + 00AD) seguida por um "m" começando com a terceira posição do caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
 [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)]
 [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Parâmetros especificam a posição inicial de pesquisa na cadeia de caracteres de atual, o número de caracteres na cadeia de caracteres atual para pesquisar e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 A pesquisa começa em `startIndex` e continua a `startIndex`  +  `count` -1. O caractere no `startIndex`  +  `count` não está incluído na pesquisa.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método que localiza a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 <paramref name="startIndex" /> é maior que o tamanho desta instância.  
  
 -ou-  
  
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retornará <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
 No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen flexível (U + 00AD) seguida por um "m" iniciando no terceiro à sexta posição do caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen suave, seguido por um "m", o método não retornar o índice do hífen flexível, mas em vez disso, retorna o índice do "m" quando ele executa uma comparação sensíveis à cultura. O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
 [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)]
 [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas. Se `anyOf` é uma matriz vazia, localiza o método uma correspondência no início da cadeia de caracteres (ou seja, no índice zero).  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza a primeira vogal em uma cadeia de caracteres.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.  
  
 A pesquisa varia de `startIndex` ao final da cadeia de caracteres.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 <paramref name="startIndex" /> é maior que o número de caracteres nessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa começa em `startIndex` e continua a `startIndex`  +  `count` -1. O caractere no `startIndex`  +  `count` não está incluído na pesquisa.  
  
 A numeração de índice começa do zero. O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 <paramref name="count" /> + <paramref name="startIndex" />é maior que o número de caracteres nesta instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de índice baseado em zero da inserção.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual uma cadeia de caracteres especificada é inserida em uma posição de índice especificada nesta instância.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a esta instância, mas com <paramref name="value" /> inserido na posição <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `startIndex` é igual ao comprimento dessa instância `value` é acrescentado ao final desta instância.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual `value` é inserida na instância atual.  
  
 Por exemplo, o valor de retorno de `"abc".Insert(2, "XYZ")` é "abXYZc".  
  
   
  
## Examples  
 O exemplo a seguir insere um caractere de espaço na posição de caractere (o caractere no índice 3) quarta de uma cadeia de caracteres.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 O aplicativo de console a seguir solicita aos usuários inserir um ou mais adjetivos para descrever dois animais. Depois, ele chama o <xref:System.String.Insert%2A> método para inserir o texto inserido pelo usuário em uma cadeia de caracteres.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é negativo ou maior que o comprimento dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Uma cadeia de caracteres para pesquisar no pool interno.</param>
        <summary>Recupera a referência do sistema para o <see cref="T:System.String" /> especificado.</summary>
        <returns>A referência do sistema para <paramref name="str" />, se interno; caso contrário, uma nova referência para uma cadeia de caracteres com o valor de <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime preserva o armazenamento de cadeia de caracteres, mantendo uma tabela, o pool interno, que contém uma única referência para cada literal cadeia de caracteres exclusiva declarado ou criado por meio de programação em seu programa de chamada. Consequentemente, uma instância de uma cadeia de caracteres literal com um determinado valor existe apenas uma vez no sistema.  
  
 Por exemplo, se você atribuir a mesma cadeia de caracteres literal para diversas variáveis, o tempo de execução recupera a mesma referência para a cadeia de caracteres literal do pool interno e atribui a cada variável.  
  
 O <xref:System.String.Intern%2A> método usa o pool interno para pesquisar uma cadeia de caracteres igual ao valor de `str`. Se existir uma cadeia de caracteres, sua referência no pool interno será retornada. Se a cadeia de caracteres não existir, uma referência a `str` é adicionado ao pool interno, em seguida, essa referência é retornada.  
  
 No exemplo a seguir, a cadeia de caracteres s1, que tem um valor de "MyTest", é já definidos como internos porque é um literal no programa. O <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe gera um novo objeto de cadeia de caracteres que tem o mesmo valor de s1. Uma referência a essa cadeia de caracteres é atribuída para s2. O <xref:System.String.Intern%2A> método procura uma cadeia de caracteres que tem o mesmo valor como s2. Como existe uma cadeia de caracteres, o método retornará a mesma referência que é atribuída a s1. Essa referência é então atribuída à s3. S2 e referências s1 comparam diferentes porque elas fazem referência a objetos diferentes. referências s1 e s3 comparam como iguais porque eles se referem à mesma cadeia de caracteres.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Comparar este método para o <xref:System.String.IsInterned%2A> método.  
  
## <a name="version-considerations"></a>Considerações da versão  
 No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], o <xref:System.String.Intern%2A> método será revertido para seu comportamento no .NET Framework 1.0 e 1.1 em relação a como internos a cadeia de caracteres vazia. No exemplo a seguir, a variável `str1` é atribuído a uma referência a <xref:System.String.Empty>e a variável `str2` é atribuído a referência ao <xref:System.String.Empty> que é retornado ao chamar o <xref:System.String.Intern%2A> método depois de converter um <xref:System.Text.StringBuilder> objeto cujo valor é <xref:System.String.Empty> para uma cadeia de caracteres. Em seguida, as referências contidas no `str1` e `str2` são comparadas quanto à igualdade.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 No [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], e [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` e `str2` são iguais. No [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] e [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` e `str2` não são iguais.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Se você estiver tentando reduzir a quantidade total de memória aloca seu aplicativo, tenha em mente que tem dois efeitos colaterais indesejáveis como internos uma cadeia de caracteres. Primeiro, a memória alocada para definidos como internos <xref:System.String> objetos não é provavelmente ser liberado até que encerra o common language runtime (CLR). A razão é que a referência do CLR para o internos <xref:System.String> objeto pode persistir depois de seu aplicativo, ou até mesmo seu domínio de aplicativo, será encerrado. Segundo, para intern uma cadeia de caracteres, você deve primeiro criar a cadeia de caracteres. A memória usada pelo <xref:System.String> objeto ainda precisa ser alocado, embora a memória eventualmente serão limpos.  
  
 O .NET Framework versão 2.0 introduz o <xref:System.Runtime.CompilerServices.CompilationRelaxations?displayProperty=nameWithType> membro de enumeração. O <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membro marca um assembly como não exigindo a cadeia de caracteres literal como internos. Você pode aplicar <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> para um assembly usando o <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atributo. Além disso, quando você usa o [Ngen.exe (gerador de imagem nativa)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para compilar um assembly com antecedência sobre tempo de execução, cadeias de caracteres não são definidos como internos em módulos.  
  
   
  
## Examples  
 O exemplo a seguir usa três cadeias de caracteres que são iguais em valor para determinar se uma cadeia de caracteres recém-criado e uma cadeia de caracteres interno são iguais.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres para pesquisar no pool interno.</param>
        <summary>Recupera uma referência a um <see cref="T:System.String" /> especificado.</summary>
        <returns>Uma referência a <paramref name="str" /> se ele estiver no pool interno de Common Language Runtime; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime mantém automaticamente uma tabela, chamada de pool interno, que contém uma única instância de cada constante de literal de cadeia de caracteres exclusiva declarado em um programa, bem como qualquer instância exclusiva do <xref:System.String> você adicionar programaticamente ao chamar o <xref:System.String.Intern%2A> método.  
  
 O pool interno preserva o armazenamento de cadeia de caracteres. Se você atribuir uma constante de cadeia de caracteres literal para diversas variáveis, cada variável é definida para referenciar a mesma constante no pool interno, em vez de fazer referência a várias instâncias diferentes do <xref:System.String> que têm valores idênticos.  
  
 Este método pesquisa `str` no pool interno. Se `str` já tenham sido definidos como internos, uma referência a essa instância é retornado; caso contrário, `null` será retornado.  
  
 Comparar este método para o <xref:System.String.Intern%2A> método.  
  
 Este método não retorna um valor booliano. Se você chamar o método porque deseja que um valor booliano que indica se uma determinada cadeia de caracteres é definidos como internos, você pode usar código como o seguinte.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Iniciando com o .NET Framework versão 2.0, você pode substituir o uso do pool interno de quando você usa o [Ngen.exe (gerador de imagem nativa)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para instalar um assembly no cache de imagem nativa em um computador local. Para obter mais informações, consulte Considerações de desempenho na seção comentários para o <xref:System.String.Intern%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra que cadeias de caracteres literais são definidos como internos automaticamente pelo compilador.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se essa cadeia de caracteres está no formulário C de normalização Unicode.</summary>
        <returns>
          <see langword="true" /> se essa cadeia de caracteres estiver no formulário C de normalização; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. O .NET Framework dá suporte aos formulários de normalização C, D, KC e KD no momento.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres com êxito é normalizada para vários formulários de normalização.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage">
          <para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidas por caracteres Unicode inválidas, o <see cref="Overload:System.String.Normalize" /> método lançará um <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Um formato de normalização Unicode.</param>
        <summary>Indica se essa cadeia de caracteres é o formulário de normalização Unicode especificado.</summary>
        <returns>
          <see langword="true" />Se essa cadeia de caracteres é o formulário de normalização especificado pelo <paramref name="normalizationForm" /> parâmetro; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. O .NET Framework dá suporte aos formulários de normalização C, D, KC e KD no momento.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.IsNormalized%2A> e <xref:System.String.Normalize%2A> métodos.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage">
          <para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidas por caracteres Unicode inválidas, o <see cref="Overload:System.String.Normalize" /> método lançará um <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser testada.</param>
        <summary>Indica se a cadeia de caracteres especificada é <see langword="null" /> ou uma cadeia de caracteres <see cref="F:System.String.Empty" />.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou uma cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A>é um método prático que permite que você teste simultaneamente se um <xref:System.String> é `null` ou seu valor é <xref:System.String.Empty>. É equivalente ao seguinte código:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Você pode usar o <xref:System.String.IsNullOrWhiteSpace%2A> método para testar se é uma cadeia de caracteres `null`, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>, ou consiste apenas em caracteres de espaço em branco.  
  
## <a name="what-is-a-null-string"></a>O que é uma cadeia de caracteres nula?  
 Uma cadeia de caracteres é `null` se ele não tiver sido atribuído um valor (em C++ e Visual Basic) ou se tiver sido atribuído explicitamente um valor de `null`. Embora o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso normalmente pode lidar com uma cadeia de caracteres nula, como mostra o seguinte exemplo, a tentativa de chamada de um se seus membros lançar um <xref:System.NullReferenceException>.  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>O que é uma cadeia de caracteres vazia?  
 Uma cadeia de caracteres está vazia se ele for atribuído explicitamente uma cadeia de caracteres vazia ("") ou <xref:System.String.Empty?displayProperty=nameWithType>. Uma cadeia de caracteres vazia tem um <xref:System.String.Length%2A> de 0.  O exemplo a seguir cria uma cadeia de caracteres vazia e exibe seu valor e seu tamanho.  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir examina três cadeias de caracteres e determina se cada cadeia de caracteres tem um valor, é uma cadeia de caracteres vazia ou é `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser testada.</param>
        <summary>Indica se uma cadeia de caracteres especificada é <see langword="null" />, vazia ou consiste apenas em caracteres de espaço em branco.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou <see cref="F:System.String.Empty" />, ou se <paramref name="value" /> consistir exclusivamente em caracteres de espaço em branco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A>é um método prático que é semelhante ao código a seguir, exceto que ele oferece um desempenho superior:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Caracteres de espaço em branco é definido pelo padrão Unicode. O <xref:System.String.IsNullOrWhiteSpace%2A> método interpreta qualquer caractere que retorna um valor de `true` quando ele é passado para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método como um caractere de espaço em branco.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de cadeia de caracteres e, em seguida, passa a cada elemento da matriz para o <xref:System.String.IsNullOrWhiteSpace%2A> método.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usado como separador. <c>separador</c> está incluído no somente se a cadeia de caracteres retornada <c>valores</c> tem mais de um elemento.</param>
        <param name="values">Uma coleção que contém as cadeias de caracteres a serem concatenadas.</param>
        <summary>Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />, usando o separador especificado entre cada membro.</summary>
        <returns>Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29>é um método prático que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres. É particularmente útil com expressões de consulta LINQ (consulta). O exemplo a seguir passa um `List(Of String)` objeto que contém as letras em maiusculas ou minúsculas do alfabeto em uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M"). O `IEnumerable(Of String)` coleção retornada pelo <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado a uma <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <c>separador</c> está incluído no somente se a cadeia de caracteres retornada <c>valores</c> tem mais de um elemento.</param>
        <param name="values">Uma matriz que contém os elementos a concatenar.</param>
        <summary>Concatena os elementos de uma matriz de objetos, usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres composta pelos elementos de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` é `null` ou se qualquer elemento de `values` que o primeiro elemento é `null`, uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>) é usado em vez disso. Consulte as notas de seção chamadores se o primeiro elemento da `values` é `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29>é um método prático que lhe permite concatenar cada elemento em uma matriz de objeto sem conversão explícita de seus elementos em cadeias de caracteres. A representação de cadeia de caracteres de cada objeto na matriz é derivada chamando esse objeto `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado de uma matriz de inteiros, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> método.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Se o primeiro elemento da <paramref name="values" /> é <see langword="null" />, o <see cref="M:System.String.Join(System.String,System.Object[])" /> método concatene os elementos no <paramref name="values" /> , mas em vez disso, retorna <see cref="F:System.String.Empty" />. Um número de soluções alternativas para esse problema está disponível. É a maneira mais fácil atribuir um valor de <see cref="F:System.String.Empty" /> para o primeiro elemento da matriz, como o exemplo a seguir mostra.  
  
 [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)]
 [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <c>separador</c> está incluído no somente se a cadeia de caracteres retornada <c>valor</c> tem mais de um elemento.</param>
        <param name="value">Uma matriz que contém os elementos a concatenar.</param>
        <summary>Concatena todos os elementos de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres que consiste nos elementos em <paramref name="value" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="value" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "Uva" e "pera" `Join(separator, value)` retorna "apple, laranja, Uva, pera".  
  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer elemento no `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Join%2A> método.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <c>separador</c> está incluído no somente se a cadeia de caracteres retornada <c>valor</c> tem mais de um elemento.</param>
        <param name="value">Uma matriz que contém os elementos a concatenar.</param>
        <param name="startIndex">O primeiro elemento em <c>valor</c> para usar.</param>
        <param name="count">O número de elementos de <c>valor</c> para usar.</param>
        <summary>Concatena os elementos especificados de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres que consiste em cadeias de caracteres em <paramref name="value" /> delimitada pela cadeia de caracteres <paramref name="separator" />.  
  
 -ou-  
  
 <see cref="F:System.String.Empty" /> se <paramref name="count" /> for zero, <paramref name="value" /> não tiver elementos ou <paramref name="separator" /> e todos os elementos de <paramref name="value" /> forem <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "Uva" e "pera" `Join(separator, value, 1, 2)` retorna "laranja, Uva".  
  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer elemento no `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir concatena dois elementos de uma matriz de nomes de frutas.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="startIndex" />Além de <paramref name="count" /> é maior que o número de elementos em <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos membros de <c>valores</c>.</typeparam>
        <param name="separator">A cadeia de caracteres a ser usado como separador. <c>separador</c> está incluído no somente se a cadeia de caracteres retornada <c>valores</c> tem mais de um elemento.</param>
        <param name="values">Uma coleção que contém os objetos a serem concatenados.</param>
        <summary>Concatena os membros de uma coleção, usando o separador especificado entre cada membro.</summary>
        <returns>Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29>é um método prático que permite a concatenação de cada membro de um <xref:System.Collections.Generic.IEnumerable%601> coleção sem antes convertê-los em cadeias de caracteres. A representação de cadeia de caracteres de cada objeto no <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada chamando esse objeto `ToString` método.  
  
 Esse método é determinado útil com expressões de consulta LINQ (consulta). Por exemplo, o código a seguir define uma simples `Animal` classe que contém o nome de um animal e a ordem ao qual ele pertence. Em seguida, define um <xref:System.Collections.Generic.List%601> objeto que contém um número de `Animal` objetos. O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> é chamado de método de extensão para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Rodent". O resultado é passado para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado a uma <xref:System.Collections.Generic.List%601> objeto do tipo número inteiro, ele passa para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 Esse método inicia a pesquisa na última posição do caractere desta instância e continua para trás até o início até que o `value` foi encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir define uma `ExtractFilename` método que usa o <xref:System.String.LastIndexOf%28System.Char%29> método para encontrar o último caractere do separador de diretório em uma cadeia de caracteres e extrair o nome de arquivo da cadeia de caracteres. Se o arquivo existir, o método retorna o nome do arquivo sem o caminho.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</summary>
        <returns>A posição do índice inicial com base em zero de <paramref name="value" />, se a cadeia de caracteres for encontrada, ou -1, caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na posição do último caractere desta instância e continua para trás até o início até `value` foi encontrado ou a posição do primeiro caractere foi examinada.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.LastIndexOf%28System.String%29> método sempre retorna <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, que representa a última posição de índice na instância atual. No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%29> método é usado para localizar três subcadeias de caracteres (um hífen flexível (U + 00AD), um hífen suave, seguido por "n" e um hífen suave, seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen flexível é um caractere ignorável, o resultado é o mesmo como se o hífen flexível não foi incluído no `value`. Ao procurar por um hífen flexível somente, o método retorna 6 e 5. Esses valores correspondem ao índice do último caractere em duas cadeias de caracteres.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 O exemplo a seguir remove a abertura e fechamento de marcas HTML de uma cadeia de caracteres se as marcas begin e end a cadeia de caracteres. Se uma cadeia de caracteres termina com um fechamento colchete caractere (">"), o exemplo usa o <xref:System.String.LastIndexOf%2A> método para localizar o início da marca de fim.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para encontrar o último índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e a última é em <xref:System.String.Length%2A> -1. esse método inicia a pesquisa no `startIndex` caractere posição dessa instância e prossegue com versões anteriores para o início da instância atual até que o `value` foi encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método pesquisa cada caractere do último caractere na cadeia de caracteres para o início. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma cadeia de caracteres, trabalhando do final da cadeia de caracteres para o início da cadeia de caracteres.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa no `startIndex` caractere posição dessa instância e prossegue com versões anteriores para o início até `value` foi encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método pesquisa cada caractere do último caractere na cadeia de caracteres para o início.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método sempre retornará `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar uma subcadeia de caracteres que inclui um hífen flexível (U + 00AD) e que precede ou inclui o "m" final em uma cadeia de caracteres. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, porque o hífen flexível na cadeia de pesquisa é ignorado, chamando o método para encontrar uma subcadeia de caracteres que consiste o hífen flexível e o "m" retorna a posição do "m" na cadeia de caracteres, enquanto chamá-lo para localizar uma subcadeia de caracteres que consiste o hífen flexível e "n" retorna a posição do "n". Quando a cadeia de caracteres de pesquisa contém apenas o hífen flexível, o método retorna o índice do "m", que representa o valor de `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na cadeia de caracteres de destino, trabalhando do final da cadeia de caracteres de destino para o início da cadeia de caracteres de destino.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para localizar o índice de uma subcadeia de caracteres que precede uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual. Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial com base em zero do parâmetro <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
 A pesquisa começa na posição do último caractere desta instância e continua para trás até o início até `value` foi encontrado ou a posição do primeiro caractere foi examinada.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método que localiza a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="options" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método sempre retorna <see cref="P:System.String.Length" /> – 1, que representa a última posição de índice na instância atual.  
  
 No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método é usado para localizar três subcadeias de caracteres (um hífen flexível (U + 00AD), um hífen suave, seguido por "n" e um hífen suave, seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, como o hífen flexível é um caractere ignorável, uma pesquisa sensíveis à cultura retorna o mesmo valor que será retornado se o hífen flexível não foram incluídas na cadeia de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen flexível em uma cadeia de caracteres com êxito e relatórios que está ausente da segunda cadeia de caracteres.  
  
 [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)]
 [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice que começa com zero da última ocorrência do caractere Unicode especificado em uma subcadeia de caracteres dentro dessa instância. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 Esse método inicia a pesquisa no `startIndex` caractere posição e continua com versões anteriores para o início desta instância até que o `value` é encontrado ou `count` posições de caractere foram examinadas. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres a partir do último caractere na cadeia de caracteres. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma subcadeia de caracteres, trabalhando do final da subcadeia de caracteres para o início da subcadeia de caracteres.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" />  -  <paramref name="count" /> + 1 é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa no `startIndex` caractere posição dessa instância e prossegue com versões anteriores para o início até que o `value` é encontrado ou `count` posições de caractere foram examinadas. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres a partir do último caractere na cadeia de caracteres.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis o <xref:System.String.LastIndexOf%2A> método sempre retornará `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.LastIndexOf%2A> método é usado para localizar a posição de um hífen flexível (U + 00AD) em dois caracteres que precedem o final "m" de duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na subcadeia de caracteres, trabalhando do final da subcadeia de caracteres para o início da subcadeia de caracteres.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é negativo.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é maior que o tamanho dessa instância.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" />  -  <paramref name="count" />+ 1 especifica uma posição que não está dentro dessa instância.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="start" /> é menor que -1 ou maior que zero.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> é maior que 1.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para executar essa operação usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres. Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa no `startIndex` caractere posição e continua com versões anteriores até que o `value` foi encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método pesquisa cada caractere do último caractere na cadeia de caracteres para o início.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método que localiza a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retornará <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
 No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen flexível (U + 00AD) seguida por um "m", começando com o final "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
 [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)]
 [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa inicia em uma posição do caractere especificado e para trás continua até o início da cadeia de caracteres para o número especificado de posições de caractere. Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa no `startIndex` caractere posição e continua com versões anteriores até que o `value` é encontrado ou `count` posições de caractere foram examinadas. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres a partir do último caractere na cadeia de caracteres.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método que localiza a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres com os valores diferentes do <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é negativo.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é maior que o tamanho dessa instância.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> + 1 - <paramref name="count" /> especifica uma posição que não está dentro dessa instância.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="start" /> é menor que -1 ou maior que zero.  
  
 -ou-  
  
 A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> é maior que 1.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage">
          <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retornará <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
 No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição do primeiro caractere antes do final "m", mas a posição de um hífen flexível (U + 00AD) seguido por um "m" em todos os em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo for executado sob o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, nos dois casos, porque o hífen flexível é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensíveis à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen suave, seguido por um "m", o método não retornar o índice do hífen flexível, mas em vez disso, retorna o índice do "m" quando ele executa uma comparação sensíveis à cultura. O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
 [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)]
 [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método inicia a pesquisa na última posição do caractere desta instância e continua para trás até o início até que um caractere em `anyOf` foi encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método inicia a pesquisa no `startIndex` caractere posição dessa instância e prossegue com versões anteriores para o início até que um caractere em `anyOf` foi encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> especifica uma posição que não está dentro dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa. Continua a pesquisa de <c>startIndex</c> em direção ao início desta instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método inicia a pesquisa no `startIndex` caractere posição dessa instância e prossegue com versões anteriores para o início até que um caractere em `anyOf` é encontrado ou `count` posições de caractere foram examinadas. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
 -ou-  
  
 A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> menos <paramref name="count" /> + 1 é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de caracteres no objeto <see cref="T:System.String" /> atual.</summary>
        <value>O número de caracteres na cadeia de caracteres atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Length%2A> propriedade retorna o número de <xref:System.Char> objetos nesta instância, não o número de caracteres Unicode. O motivo é que um caractere Unicode pode ser representado por mais de um <xref:System.Char>. Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe para trabalhar com cada caractere Unicode em vez de cada <xref:System.Char>.  
  
 Em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres. No .NET Framework, um caractere null pode ser inserido em uma cadeia de caracteres. Quando uma cadeia de caracteres inclui um ou mais caracteres null, eles são incluídos no comprimento da cadeia de caracteres total. Por exemplo, na seguinte cadeia, as subcadeias de caracteres "abc" e "def" são separados por um caractere nulo. O <xref:System.String.Length%2A> propriedade retorna 7, que indica que ele inclui os seis caracteres alfabéticos, bem como o caractere nulo.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Length%2A> propriedade.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C Unicode.</summary>
        <returns>Uma nova cadeia de caracteres normalizada cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":  
  
-   U + 1EAF  
  
-   U + 0103 U + 0301  
  
-   U + 0061 U + 0306 U + 0301  
  
 A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. O .NET Framework oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, theycan ser comparados usando comparação ordinal.  
  
 Normalizar e comparar duas cadeias de caracteres, faça o seguinte:  
  
1.  Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.  
  
2.  Chamar o <xref:System.String.Normalize> método normalizar cadeias de caracteres para o formulário de normalização C.  
  
3.  Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinal, como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e forneça um valor de <xref:System.StringComparison?displayProperty=nameWithType> ou <xref:System.StringComparison?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento. Para classificar uma matriz de cadeias de caracteres normalizadas, passar um `comparer` valor <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado e lista os pontos de código na cadeia de caracteres normalizado.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage">
          <para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidas por caracteres Unicode inválidas, o <see cref="Overload:System.String.Normalize" /> método lançará um <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Um formato de normalização Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização Unicode especificado.</summary>
        <returns>Uma nova cadeia de caracteres cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização especificado pelo parâmetro <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. O .NET Framework oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, eles podem ser comparados usando comparação ordinal.  
  
 Normalizar e comparar duas cadeias de caracteres, faça o seguinte:  
  
1.  Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.  
  
2.  Chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29> método normalizar cadeias de caracteres a um formulário de normalização especificado.  
  
3.  Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinal, como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e forneça um valor de <xref:System.StringComparison?displayProperty=nameWithType> ou <xref:System.StringComparison?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento. Para classificar uma matriz de cadeias de caracteres normalizadas, passar um `comparer` valor <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado e lista os pontos de código na cadeia de caracteres normalizado.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage">
          <para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidas por caracteres Unicode inválidas, o <see cref="Overload:System.String.Normalize" /> método pode lançar um <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se duas cadeias de caracteres especificadas têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.op_Equality%2A> método define a operação do operador de igualdade para o <xref:System.String> classe. Ele permite que o código, como mostrado na seção de exemplo. O operador, por sua vez, chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e não levam em conta a cultura).  
  
> [!NOTE]
>  O compilador do Visual Basic não resolve o operador de igualdade como uma chamada para o <xref:System.String.op_Equality%2A> método. Em vez disso, o operador de igualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o operador de igualdade.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se duas cadeias de caracteres especificadas têm valores diferentes.</summary>
        <returns>
          <see langword="true" /> se o valor de <paramref name="a" /> for diferente do valor de <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.op_Inequality%2A> método define a operação do operador de desigualdade para o <xref:System.String> classe.   Ele permite que o código, como mostrado na seção de exemplos.  
  
 O <xref:System.String.op_Inequality%2A> operador por sua vez chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e não levam em conta a cultura).  
  
> [!NOTE]
>  O compilador do Visual Basic não resolve o operador de desigualdade como uma chamada para o <xref:System.String.op_Inequality%2A> método. Em vez disso, o operador de desigualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o operador de desigualdade.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os com espaços à esquerda, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de espaços necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um espaço de Unicode é definido como 0x0020 hexadecimal.  
  
 O <xref:System.String.PadLeft%28System.Int32%29> método preenche o início da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, preencha a parte direita da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à esquerda para que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <param name="paddingChar">Um caractere de preenchimento de Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os à esquerda com um caractere Unicode especificado, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> método preenche o início da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, preencha a parte direita da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com líderes `paddingChar` caracteres de forma que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os com espaços à direita, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com quantos caracteres forem necessários para criar um tamanho de <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um espaço de Unicode é definido como 0x0020 hexadecimal.  
  
 O <xref:System.String.PadRight%28System.Int32%29> método preenche o final da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, preencha a parte esquerda da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à direita para que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <param name="paddingChar">Um caractere de preenchimento de Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os à direita com um caractere Unicode especificado, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> método preenche o final da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, preencha a parte esquerda da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com à direita `paddingChar` caracteres de forma que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalWidth" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição baseada em zero para iniciar a exclusão de caracteres.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual, começando na posição especificada e continuando até a última posição, foram excluídos.</summary>
        <returns>Uma nova cadeia de caracteres que é equivalente a esta cadeia de caracteres, exceto os caracteres removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseadas em zero. O valor de `startIndex` parâmetro pode variar de zero a menos que o comprimento da instância de cadeia de caracteres.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres da posição `startIndex` ao final da cadeia de caracteres original foram removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Remove%2A> método. O próximo ao último caso remove todo o texto a partir do índice até o fim da cadeia de caracteres especificado. O último caso remove três caracteres, começando do índice especificado.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> especifica uma posição que não está nessa cadeia de caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição baseada em zero para iniciar a exclusão de caracteres.</param>
        <param name="count">O número de caracteres a serem excluídos.</param>
        <summary>Retorna uma nova cadeia de caracteres em que um número especificado de caracteres na instância atual que começa na posição especificada foi excluído.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, exceto os caracteres removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseadas em zero. O valor de `startIndex` parâmetro pode variar de zero a menos que o comprimento da instância de cadeia de caracteres.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual o número de caracteres especificado pelo `count` parâmetro foi removido. Os caracteres são removidos na posição especificada pelo `startIndex`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode remover o nome do meio de um nome completo.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> especificam uma posição fora dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere Unicode a ser substituído.</param>
        <param name="newChar">O caractere Unicode para substituir todas as ocorrências de <c>oldChar</c>.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências de um caractere Unicode especificado nessa instância são substituídas por outro caractere Unicode especificado.</summary>
        <returns>Uma cadeia de caracteres equivalente a essa instância, com exceção de que todas as instâncias de <paramref name="oldChar" /> são substituídas por <paramref name="newChar" />. Se <paramref name="oldChar" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e não levam em conta a cultura) para encontrar `oldChar`.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldChar` são substituídos por `newChar`.  
  
 Como esse método retorna a cadeia de caracteres modificada, você pode encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original. Chamadas de método são executadas da esquerda para a direita. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir cria uma lista de valores separados por vírgula, substituindo vírgulas para os espaços em branco entre uma série de números.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres para substituir todas as ocorrências de <c>oldValue</c>.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências de uma cadeia de caracteres especificada na instância atual são substituídas por outra cadeia de caracteres especificada.</summary>
        <returns>Uma cadeia de caracteres equivalente à atual cadeia de caracteres, com exceção de que todas as instâncias de <paramref name="oldValue" /> são substituídas por <paramref name="newValue" />. Se <paramref name="oldValue" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `newValue` é `null`, todas as ocorrências de `oldValue` são removidos.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldValue` são substituídos por `newValue`.  
  
 Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e não levam em conta a cultura) para encontrar `oldValue`.  
  
 Como esse método retorna a cadeia de caracteres modificada, você pode encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original. Chamadas de método são executadas da esquerda para a direita. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar o <xref:System.String.Replace%2A> método para corrigir um erro de ortografia.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="oldValue" /> é a cadeia de caracteres vazia ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma matriz de cadeia de caracteres que contém as subcadeias de caracteres desta instância são delimitadas por elementos de uma cadeia de caracteres especificada ou uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A>é usado para dividir uma cadeia de caracteres delimitada em subcadeias de caracteres. Você pode usar uma matriz de caracteres para especificar zero, um ou vários caracteres de delimitação (o <xref:System.String.Split%28System.Char%5B%5D%29> método), ou você pode usar uma matriz de caracteres para especificar zero, uma ou várias cadeias de caracteres de delimitação. Sobrecargas do <xref:System.String.Split%2A> método permitem que você limite o número de subcadeias de caracteres retornada pelo método (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> método), para determinar se as cadeias de caracteres vazias são incluídas nas subcadeias de caracteres retornadas (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> métodos, ou para ambas as opções (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> métodos).  
  
> [!IMPORTANT]
>  Para obter mais informações sobre o <xref:System.String.Split%2A> método, como também para exemplos que chamam cada sobrecarga, consulte a documentação para as sobrecargas individuais do <xref:System.String.Split%2A>.  
  
 O <xref:System.String.Split%2A> método nem sempre é a melhor maneira de dividir uma cadeia de caracteres delimitada em subcadeias de caracteres. Se você não quiser extrair todas as subcadeias de caracteres de uma cadeia de caracteres delimitada, ou se você quiser analisar uma cadeia de caracteres com base em um padrão em vez de um conjunto de caracteres de delimitador, considere as alternativas a seguir.  
  
## <a name="regular-expressions"></a>Expressões regulares  
 Se suas cadeias de caracteres estão em conformidade com um padrão fixo, você pode usar uma expressão regular para extrair e tratar seus elementos. Por exemplo, se as cadeias de caracteres assumem a forma "*número* *operando* *número*" você pode usar um [expressão regular](~/docs/standard/base-types/regular-expressions.md) para extrair e lidar com os elementos da cadeia de caracteres. Veja um exemplo:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 O padrão de expressão regular `(\d+)\s+([-+*/])\s+(\d+)` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(\d+)`|Corresponde a um ou mais dígitos decimais. Este é o primeiro grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`([-+*/])`|Corresponde a um sinal de operador aritmético (+, -, *, ou /). Este é o segundo grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`(\d+)`|Corresponde a um ou mais dígitos decimais. Este é o terceiro grupo de captura.|  
  
 Você também pode usar uma expressão regular para extrair subcadeias de caracteres de uma cadeia de caracteres com base em um padrão em vez de um conjunto fixo de caracteres. Este é um cenário comum quando uma das seguintes condições ocorre:  
  
-   Um ou mais dos caracteres delimitador não sempre servir como um delimitador no <xref:System.String> instância.  
  
-   A sequência e o número de caracteres de delimitador é desconhecido ou variável.  
  
 Por exemplo, o <xref:System.String.Split%2A> método não pode ser usado para dividir a seguinte cadeia de caracteres, porque o número de `\n` (em c#) ou `vbCrLf` (no Visual Basic), caracteres é variável, e eles sempre não servem como delimitadores.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Uma expressão regular pode dividir facilmente, como a exemplo a seguir mostra essa cadeia de caracteres.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 O padrão de expressão regular `\[([^\[\]]+)\]` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\[`|Corresponde um colchete de abertura.|  
|`([^\[\]]+)`|Corresponde qualquer caractere que não seja uma colchete de abertura ou um fechamento uma ou mais vezes. Este é o primeiro grupo de captura.|  
|`\]`|Corresponde um colchete de fechamento.|  
  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método é quase idêntico ao <xref:System.String.Split%2A?displayProperty=nameWithType>, exceto que ele divide uma cadeia de caracteres com base em um padrão de expressão regular, em vez de um conjunto de caracteres fixa. Por exemplo, o exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir uma cadeia de caracteres que contém as subcadeias de caracteres delimitadas por várias combinações de outros caracteres e hífens.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 O padrão de expressão regular `\s-\s?[+*]?\s?-\s` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\s-`|Corresponde um caractere de espaço em branco seguido por um hífen.|  
|`\s?`|Corresponde a zero ou um caractere de espaço em branco.|  
|`[+*]?`|Corresponde a zero ou uma ocorrência de um a + ou * caractere.|  
|`\s?`|Corresponde a zero ou um caractere de espaço em branco.|  
|`-\s`|Coincide com um hífen seguido por um caractere de espaço em branco.|  
  
## <a name="search-methods-and-the-substring-method"></a>Métodos de pesquisa e o método Substring  
 Se você não estiver interessado em todas as subcadeias de caracteres em uma cadeia de caracteres, você pode preferir trabalhar com um dos métodos de comparação de cadeia de caracteres que retorna o índice no qual a correspondência começa. Em seguida, você pode chamar o <xref:System.String.Substring%2A> método para extrair a subcadeia de caracteres que você deseja. Os métodos de comparação de cadeia de caracteres incluem:  
  
-   <xref:System.String.IndexOf%2A>, que retorna o índice baseado em zero da primeira ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.IndexOfAny%2A>, que retorna o índice baseado em zero na instância atual de cadeia de caracteres da primeira ocorrência de qualquer caractere em uma matriz de caracteres.  
  
-   <xref:System.String.LastIndexOf%2A>, que retorna o índice baseado em zero da última ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.LastIndexOfAny%2A>, que retorna um índice com base em zero na instância atual de cadeia de caracteres da última ocorrência de qualquer caractere em uma matriz de caracteres.  
  
 O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para localizar os períodos em uma cadeia de caracteres. Ele usa o <xref:System.String.Substring%2A> método para retornar frases completas.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma cadeia de caracteres delimitada por um conjunto conhecido de caracteres, você pode usar o <xref:System.String.Split%28System.Char%5B%5D%29> método para separá-lo em subcadeias de caracteres. Para outras maneiras de extrair subcadeias de caracteres de uma cadeia de caracteres, consulte o [alternativas para Split](#Alternatives) seção.  
  
## <a name="return-value-details"></a>Detalhes do valor de retorno  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada. Por exemplo, se a matriz de separador inclui o caractere "-" e o valor da instância atual de cadeia de caracteres é "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contenha nenhum dos caracteres na `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Se dois delimitadores são adjacentes, ou um delimitador for encontrado no início ou no final desta instância, o elemento correspondente na matriz retornada contém <xref:System.String.Empty>. Estes são alguns exemplos:  
  
|Valor da cadeia de caracteres|Separador|Matriz retornada|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|novo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c "" c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|novo Char [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|novo Char [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nada (Visual Basic)|{"Darb", "Smarba"}|  
  
## <a name="the-separator-array"></a>A matriz de separador  
 Cada elemento do separador define um delimitador separado que consiste em um único caractere. Se o `separator` é `null` ou não contém nenhum caractere, o método trata os caracteres de espaço em branco como delimitadores. Caracteres de espaço em branco é definido por padrão; Unicode elas retornam `true` se eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a>Resolução de sobrecarga de compilador e String.Split(Char[])  
 Embora o único parâmetro para essa sobrecarga de <xref:System.String.Split%2A?displayProperty=nameWithType> é uma matriz de caracteres, você pode chamá-lo com um único caractere, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Porque o `separator` parâmetros está decorado com o <xref:System.ParamArrayAttribute> atributo, compiladores interpretará um único caractere como uma matriz de caracteres de elemento único. Isso não é o caso para outros <xref:System.String.Split%2A?displayProperty=nameWithType> sobrecargas que incluem um `separator` parâmetro; deve passar essas sobrecargas explicitamente uma matriz de caracteres como o `separator` argumento.  
  
## <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%28System.Char%5B%5D%29> método extrai as subcadeias de caracteres na cadeia de caracteres delimitadas por um ou mais dos caracteres a `separator` de matriz e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%28System.Char%5B%5D%29> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre classificações ordinal, cadeia de caracteres e palavras, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a>Alternativas para split  
 O <xref:System.String.Split%2A> método nem sempre é a melhor maneira de dividir uma cadeia de caracteres delimitada em subcadeias de caracteres. Se você não quiser extrair todas as subcadeias de caracteres de uma cadeia de caracteres delimitada, ou se você quiser analisar uma cadeia de caracteres com base em um padrão em vez de um conjunto de caracteres de delimitador, considere as alternativas a seguir.  
  
### <a name="regular-expressions"></a>Expressões regulares  
 Se suas cadeias de caracteres estão em conformidade com um padrão fixo, você pode usar uma expressão regular para extrair e tratar seus elementos. Por exemplo, se as cadeias de caracteres assumem a forma "*número* *operando* *número*" você pode usar um [expressão regular](~/docs/standard/base-types/regular-expressions.md) para extrair e lidar com os elementos da cadeia de caracteres. Veja um exemplo:  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 O padrão de expressão regular `(\d+)\s+([-+*/])\s+(\d+)` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(\d+)`|Corresponde a um ou mais dígitos decimais. Este é o primeiro grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`([-+*/])`|Corresponde a um sinal de operador aritmético (+, -, *, ou /). Este é o segundo grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`(\d+)`|Corresponde a um ou mais dígitos decimais. Este é o terceiro grupo de captura.|  
  
 Você também pode usar uma expressão regular para extrair subcadeias de caracteres de uma cadeia de caracteres com base em um padrão em vez de um conjunto fixo de caracteres. Este é um cenário comum quando uma das seguintes condições ocorre:  
  
-   Um ou mais dos caracteres delimitador não sempre servir como um delimitador no <xref:System.String> instância.  
  
-   A sequência e o número de caracteres de delimitador é desconhecido ou variável.  
  
 Por exemplo, o <xref:System.String.Split%2A> método não pode ser usado para dividir a seguinte cadeia de caracteres, porque o número de `\n` (em c#) ou `vbCrLf` (no Visual Basic), caracteres é variável, e eles sempre não servem como delimitadores.  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 Uma expressão regular pode dividir facilmente, como a exemplo a seguir mostra essa cadeia de caracteres.  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 O padrão de expressão regular `\[([^\[\]]+)\]` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\[`|Corresponde um colchete de abertura.|  
|`([^\[\]]+)`|Corresponde qualquer caractere que não seja uma colchete de abertura ou um fechamento uma ou mais vezes. Este é o primeiro grupo de captura.|  
|`\]`|Corresponde um colchete de fechamento.|  
  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método é quase idêntico ao <xref:System.String.Split%2A?displayProperty=nameWithType>, exceto que ele divide uma cadeia de caracteres com base em um padrão de expressão regular, em vez de um conjunto de caracteres fixa. Por exemplo, o exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir uma cadeia de caracteres que contém as subcadeias de caracteres delimitadas por várias combinações de outros caracteres e hífens.  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 O padrão de expressão regular `\s-\s?[+*]?\s?-\s` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\s-`|Corresponde um caractere de espaço em branco seguido por um hífen.|  
|`\s?`|Corresponde a zero ou um caractere de espaço em branco.|  
|`[+*]?`|Corresponde a zero ou uma ocorrência de um a + ou * caractere.|  
|`\s?`|Corresponde a zero ou um caractere de espaço em branco.|  
|`-\s`|Coincide com um hífen seguido por um caractere de espaço em branco.|  
  
### <a name="search-methods-and-the-substring-method"></a>Métodos de pesquisa e o método Substring  
 Se você não estiver interessado em todas as subcadeias de caracteres em uma cadeia de caracteres, você pode preferir trabalhar com um dos métodos de comparação de cadeia de caracteres que retorna o índice no qual a correspondência começa. Em seguida, você pode chamar o <xref:System.String.Substring%2A> método para extrair a subcadeia de caracteres que você deseja. Os métodos de comparação de cadeia de caracteres incluem:  
  
-   <xref:System.String.IndexOf%2A>, que retorna o índice baseado em zero da primeira ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.IndexOfAny%2A>, que retorna o índice baseado em zero na instância atual de cadeia de caracteres da primeira ocorrência de qualquer caractere em uma matriz de caracteres.  
  
-   <xref:System.String.LastIndexOf%2A>, que retorna o índice baseado em zero da última ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.LastIndexOfAny%2A>, que retorna um índice com base em zero na instância atual de cadeia de caracteres da última ocorrência de qualquer caractere em uma matriz de caracteres.  
  
 O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para localizar os períodos em uma cadeia de caracteres. Ele usa o <xref:System.String.Substring%2A> método para retornar frases completas.  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Se seu aplicativo requer o desempenho ideal ou gerenciar a alocação de memória é essencial para seu aplicativo, considere o uso de <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método. Você também tem a opção de usar o <xref:System.String.Compare%2A> método para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Para dividir uma cadeia de caracteres em um caractere separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar um caractere separador na cadeia de caracteres. Para dividir uma cadeia de caracteres em uma cadeia de caracteres do separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar o primeiro caractere da cadeia de caracteres do separador. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como extrair palavras individuais de um bloco de texto tratando marcas de pontuação e espaço em branco como delimitadores. A matriz de caracteres passada para o `separator` parâmetro o <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método consiste em um caractere de espaço e um caractere de tabulação, junto com alguns símbolos de pontuação comuns.  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz. Especifique também o número máximo de subcadeias de caracteres a serem retornadas.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.  
  
 Se esta instância não contenha nenhum dos caracteres na `separator`, a matriz retornada consiste em um único elemento que contém essa instância. Se `count` for zero, uma matriz vazia será retornada.  
  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Se dois delimitadores são adjacentes, ou um delimitador for encontrado no início ou no final desta instância, o elemento correspondente da matriz contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres neste exemplo, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` for maior que o número de subcadeias de caracteres, serão retornadas as subcadeias de caracteres disponíveis e nenhuma exceção é lançada.  
  
 A tabela a seguir fornece exemplos.  
  
|Valor da cadeia de caracteres|Separador|Contagem|Matriz retornada|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|novo Char [] {',', ' '} (c#)<br /><br /> Char () = {"," c "" c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|novo Char [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|novo Char [] {'. '} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] {} (c#)<br /><br /> Char () = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] null (c#)<br /><br /> Char () = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] null (c#)<br /><br /> Char () = Nothing|100|{"Darb", "Smarba"}|  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como `count` afeta o número de cadeias de caracteres retornadas por <xref:System.String.Split%2A>.  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é negativo.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Detalhes do valor de retorno  
 Caracteres delimitadores (os caracteres a `separator` matriz) não são incluídos nos elementos da matriz retornada. Por exemplo, se o `separator` matriz inclui o caractere "-" e o valor da instância atual de cadeia de caracteres é "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contenha nenhum dos caracteres na `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.  
  
 Cada elemento de `separator` define um delimitador separado que consiste em um único caractere. Se o `options` argumento é <xref:System.StringSplitOptions.None>e dois delimitadores são adjacentes ou um delimitador for encontrado no início ou no final desta instância, o elemento correspondente da matriz contém <xref:System.String?displayProperty=nameWithType>. Por exemplo, se `separator` inclui dois elementos, "-" e "_", o valor da instância de cadeia de caracteres é "- _aa -\_" e o valor da `options` é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de cadeia de caracteres com cinco elementos a seguir:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" caracteres no índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" no índice 0 e o caractere "_" no índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o caractere "_" no índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue a "-" no índice 5.  
  
## <a name="the-separator-array"></a>A matriz de separador  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga de compilador falha. Para identificar inequivocamente o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres delimitadas por um ou mais dos caracteres a `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre classificações ordinal, cadeia de caracteres e palavras, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres com base nas cadeias de caracteres em uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma cadeia de caracteres delimitada por um conjunto conhecido de cadeias de caracteres, você pode usar o <xref:System.String.Split%2A> método para separá-lo em subcadeias de caracteres.  
  
## <a name="return-value-details"></a>Detalhes do valor de retorno  
 Cadeias de caracteres de delimitador não são incluídas nos elementos da matriz retornada. Por exemplo, se o `separator` matriz inclui a cadeia de caracteres "-" e o valor da instância atual de cadeia de caracteres é "aa - bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contém qualquer uma das cadeias de caracteres em `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.  
  
 Cada elemento de `separator` define um delimitador separado que consiste em um ou mais caracteres. Se o `options` argumento é <xref:System.StringSplitOptions.None>e dois delimitadores são adjacentes ou um delimitador for encontrado no início ou no final desta instância, o elemento correspondente da matriz contém <xref:System.String?displayProperty=nameWithType>. Por exemplo, se `separator` inclui dois elementos, "-" e "_", o valor da instância de cadeia de caracteres é "- _aa -\_" e o valor da `options` é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de sequência com cinco elementos a seguir:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" subcadeia de caracteres no índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" subcadeia de caracteres no índice 0 e a subcadeia de caracteres "_" no índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue a subcadeia de caracteres "_" no índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue a "-" subcadeia de caracteres no índice 5.  
  
## <a name="the-separator-array"></a>A matriz de separador  
 Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador. Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string". Retorna a matriz de quatro elementos a seguir: {"This", "for", "a", "string". }.  
  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga de compilador falha. Para identificar inequivocamente o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres no `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre classificações ordinal, cadeia de caracteres e palavras, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
 O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").  
  
 Para evitar resultados ambíguos quando cadeias de caracteres em `separator` caracteres não têm em comum, o <xref:System.String.Split%2A> operação continua desde o início até o final do valor da instância e faz a correspondência do primeiro elemento em `separator` que é igual a um delimitador na instância. A ordem na qual as subcadeias de caracteres forem encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.  
  
 Por exemplo, considere uma instância cujo valor é "abcdef". Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação split deve ser uma matriz de cadeia de caracteres que contém dois elementos, "a" e "f". Isso ocorre porque a subcadeia de caracteres na instância, "bcde" for encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.  
  
 No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação split deve ser uma matriz de cadeia de caracteres que contém dois elementos, "a" e "ef". Isso ocorre porque "bcd" é o primeiro delimitador na `separator` que corresponde a um delimitador na instância. Se a ordem dos separadores de foi revertida para o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "def".  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a diferença nas matrizes retornado ao chamar uma cadeia de caracteres <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> método com seu `options` parâmetro igual a <xref:System.StringSplitOptions?displayProperty=nameWithType> e <xref:System.StringSplitOptions?displayProperty=nameWithType>.  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 O exemplo a seguir define uma matriz de separadores que incluem a pontuação e caracteres de espaço em branco. Passando essa matriz juntamente com um valor de <xref:System.StringSplitOptions?displayProperty=nameWithType> para o <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> método retorna uma matriz que consiste em palavras individuais da cadeia de caracteres.  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Observe que o método é chamado com o `options` argumento definido como <xref:System.StringSplitOptions?displayProperty=nameWithType>. Isso impede que a matriz retornada incluindo <xref:System.String.Empty?displayProperty=nameWithType> valores que representam a subcadeia de caracteres vazia faz a correspondência entre sinais de pontuação e caracteres de espaço em branco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.  
  
 Se esta instância não contenha nenhum dos caracteres na `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância. Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha. Para identificar inequivocamente o método chamado, seu código deve indicar o tipo de null. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Se o `count` parâmetro for zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia será retornada.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres neste exemplo, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` for maior que o número de subcadeias de caracteres, serão retornadas as subcadeias de caracteres disponíveis e nenhuma exceção é lançada.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <param name="options">
          <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nas cadeias de caracteres de uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a>Detalhes do valor de retorno  
 Cadeias de caracteres de delimitador não são incluídas nos elementos da matriz retornada.  
  
 Se esta instância não contém qualquer uma das cadeias de caracteres em `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância. Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha. Para identificar inequivocamente o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Se o `count` parâmetro for zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia será retornada.  
  
 Cada elemento de `separator` define um delimitador separado que consiste em um ou mais caracteres. Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres neste exemplo, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` for maior que o número de subcadeias de caracteres, serão retornadas as subcadeias de caracteres disponíveis e nenhuma exceção é lançada.  
  
## <a name="the-separator-array"></a>A matriz de separador  
 Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador. Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string". Retorna a matriz de quatro elementos: {"This", "for", "a", "string". }.  
  
## <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres no `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre classificações ordinal, cadeia de caracteres e palavras, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
 O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").  
  
 Para evitar resultados ambíguos quando cadeias de caracteres em `separator` caracteres não têm em comum, o <xref:System.String.Split%2A> método continua desde o início até o final do valor da instância e faz a correspondência do primeiro elemento em `separator` que é igual a um delimitador na instância. A ordem na qual as subcadeias de caracteres forem encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.  
  
 Por exemplo, considere uma instância cujo valor é "abcdef". Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação de divisão seria "a" e "f". Isso ocorre porque a subcadeia de caracteres na instância, "bcde" for encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.  
  
 No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação de divisão seria "a" e "ef". Isso ocorre porque "bcd" é o primeiro delimitador na `separator` que corresponde a um delimitador na instância. Se a ordem dos separadores de foi revertida para o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria "a" e "def".  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. No [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco do Unicode.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <summary>Determina se o começo desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</summary>
        <returns>
          <see langword="true" /> se o <paramref name="value" /> corresponde ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara `value` a subcadeia de caracteres no início desta instância que é o mesmo comprimento que `value`e retorna uma indicação se eles são iguais. São iguais, `value` deve ser uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início desta instância.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir define uma `StripStartTags` método que usa o <xref:System.String.StartsWith%28System.String%29> método para remover HTML marcas iniciais do início de uma cadeia de caracteres. Observe que o `StripStartTags` método é chamado recursivamente para garantir que várias marcas de início HTML no início da linha são removidas. O exemplo não remover marcas HTML inseridas em uma cadeia de caracteres.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de comparação de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para determinar se uma cadeia de caracteres começa com uma determinada subcadeia de caracteres usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para sua <paramref name="comparisonType" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <param name="comparisonType">Um dos valores de enumeração que determina como essa cadeia de caracteres e <c>valor</c> são comparados.</param>
        <summary>Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado à opção de comparação especificada.</summary>
        <returns>
          <see langword="true" /> se essa instância começar com <paramref name="value" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.StartsWith%2A> método compara o `value` parâmetro para a subcadeia de caracteres no início da cadeia de caracteres e retorna um valor que indica se são iguais. São iguais, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve coincidir com o início da cadeia de caracteres. O tipo de comparação executada pelo <xref:System.String.StartsWith%2A> método depende do valor da `comparisonType` parâmetro. A comparação pode usar as convenções da cultura atual (<xref:System.StringComparison?displayProperty=nameWithType> e <xref:System.StringComparison?displayProperty=nameWithType>) ou a cultura invariável (<xref:System.StringComparison?displayProperty=nameWithType> e <xref:System.StringComparison?displayProperty=nameWithType>), ou pode consistir em uma comparação de caractere por caractere de pontos de código (<xref:System.StringComparison?displayProperty=nameWithType> ou <xref:System.StringComparison?displayProperty=nameWithType>). A comparação também pode diferenciar maiusculas de minúsculas (<xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, ou <xref:System.StringComparison?displayProperty=nameWithType>), ou ele pode ignorar maiusculas e minúsculas (<xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>, <xref:System.StringComparison?displayProperty=nameWithType>).  
  
   
  
## Examples  
 O exemplo a seguir procura a cadeia de caracteres "a" no início de uma cadeia de caracteres mais longa que começa com a palavra "The". Como a saída mostra o exemplo, uma chamada para o <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> método que executa uma comparação sem diferenciação de cultura mas diferencia maiusculas de minúsculas não corresponde a cadeia de caracteres, enquanto uma chamada que executa uma comparação de cultura e case insensitive corresponde a cadeia de caracteres.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 O exemplo a seguir determina se uma cadeia de caracteres começa com uma subcadeia de caracteres específica. Inicializa uma matriz bidimensional de cadeia de caracteres. O primeiro elemento na segunda dimensão contém uma cadeia de caracteres, e o segundo elemento contém a cadeia de caracteres para pesquisar no início da primeira cadeia de caracteres. Os resultados são afetados pela opção de cultura, se o caso é ignorado, e se uma comparação ordinal é executada. Observe que quando a instância de cadeia de caracteres contém uma ligadura, comparações de cultura com os caracteres consecutivos com êxito correspondem.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Informações de culturais que determina como essa cadeia de caracteres e <c>valor</c> são comparados. Se <c>cultura</c> é <see langword="null" />, a cultura atual é usada.</param>
        <summary>Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método compara o `value` parâmetro para a subcadeia de caracteres no início da cadeia de caracteres que é o mesmo comprimento que `value`e retorna um valor que indica se são iguais. São iguais, `value` deve ser uma cadeia de caracteres vazia (<xref:System.String?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início desta instância.  
  
 Esse método executa uma comparação com o uso de maiusculas e minúsculas especificado e a cultura.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres ocorre no início de outra cadeia de caracteres. O <xref:System.String.StartsWith%2A> método é chamado várias vezes usando diferentes culturas que influenciam os resultados da pesquisa, diferenciação de maiusculas e minúsculas e maiusculas e minúsculas.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</param>
        <summary>Recupera uma subcadeia de caracteres desta instância. A subcadeia de caracteres começa em uma posição de caractere especificado e continua até o final da cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres equivalente à subcadeia de caracteres que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.String.Substring%2A> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa na posição do caractere especificado e termina no final da cadeia de caracteres. A posição do caractere inicial é um baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1. Para extrair uma subcadeia de caracteres que começa na posição do caractere especificado e termina antes até o final da cadeia de caracteres, chame o <xref:System.String.Substring%2A> método.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que começa a `startIndex` posição na cadeia de caracteres atual.  
  
 Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou cadeia de caracteres, chamar um método, como <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> para obter o valor de `startIndex`. O segundo exemplo ilustra isso. ele extrai um valor de chave que começa uma posição de caractere após o caractere "=".  
  
 Se `startIndex` é igual a zero, o método retorna a cadeia de caracteres original inalterada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como obter uma subcadeia de caracteres de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere igual na cadeia de caracteres. A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai a chave nome., que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método. A chamada para o <xref:System.String.Substring%28System.Int32%29> método extrai o valor atribuído à chave. Ele começa na posição de um caractere além do caractere de igual e se estende até o final da cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres.</param>
        <summary>Recupera uma subcadeia de caracteres desta instância. A subcadeia de caracteres começa em uma posição de caractere especificado e tem um comprimento especificado.</summary>
        <returns>Uma cadeia de caracteres é equivalente à subcadeia de caracteres de comprimento <paramref name="length" /> que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância e <paramref name="length" /> for zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa na posição do caractere especificado e termina antes do final da cadeia de caracteres. A posição do caractere inicial é um baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1. Para extrair uma subcadeia de caracteres que começa na posição do caractere especificado e continua até o final da cadeia de caracteres, chame o <xref:System.String.Substring%28System.Int32%29> método.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres com `length` caracteres a partir de `startIndex` posição na cadeia de caracteres atual.  
  
 O `length` parâmetro representa o número total de caracteres para extrair a instância atual da cadeia de caracteres. Isso inclui o caractere inicial foi encontrado no índice `startIndex`.  Em outras palavras, o <xref:System.String.Substring%2A> método tenta extrair caracteres de índice `startIndex` índice `startIndex`  +  `length` - 1.  
  
 Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou cadeia de caracteres, chamar um método, como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o valor de `startIndex`.  
  
 Se a subcadeia de caracteres se estende de `startIndex` para uma sequência de caracteres especificada, você pode chamar um método como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o índice do final de caractere ou cadeia de caracteres.  Em seguida, você pode converter esse valor para uma posição de índice na cadeia de caracteres da seguinte maneira:  
  
-   Se você procurar um único caractere que é marcar o fim da subcadeia de caracteres, o `length` parâmetro for igual a `endIndex`  -  `startIndex` + 1, onde `endIndex` é o valor de retorno de <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método. O exemplo a seguir extrai um bloco contínuo de caracteres "b" de uma cadeia de caracteres.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Se você pesquisou vários caracteres marcar o fim da subcadeia de caracteres, o `length` parâmetro for igual a `endIndex`  +  `endMatchLength`  -  `startIndex`, onde `endIndex` é o valor de retorno de <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método. e `endMatchLength` é o comprimento da sequência de caracteres que marca o fim da subcadeia de caracteres. O exemplo a seguir extrai um bloco de texto que contém um XML `<definition>` elemento.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Se o caractere ou cadeia de caracteres não está incluída no final da subcadeia de caracteres, o `length` parâmetro for igual a `endIndex`  -  `startIndex`, onde `endIndex` é o valor de retorno de <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método.  
  
 Se `startIndex` é igual a zero e igual que o comprimento da cadeia de caracteres atual, o método retorna a cadeia de caracteres original inalterada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra uma chamada simple para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método que extrai os dois caracteres de uma cadeia de caracteres começando na posição do sexto caractere (isto é, no índice cinco).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método nas três caixas a seguir para isolar as subcadeias de caracteres dentro de uma cadeia de caracteres. Nos dois casos as subcadeias de caracteres são usadas em comparações e o terceiro caso uma exceção será lançada porque parâmetros inválidos foram especificados.  
  
-   Ele extrai o caractere único e a terceira posição na cadeia de caracteres (no índice 2) e o compara com um "c". Esta comparação retorna `true`.  
  
-   Ele extrai caracteres começando na quarta posição na cadeia de caracteres (no índice 3) e o transmite para o <xref:System.String.IsNullOrEmpty%2A> método. Isso retorna true, porque a chamada para o <xref:System.String.Substring%2A> método retornará <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Ele tenta extrair um caractere começando na quarta posição na cadeia de caracteres. Porque não há nenhum caractere na posição, a chamada do método lança um <xref:System.ArgumentOutOfRangeException> exceção.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere igual na cadeia de caracteres. A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai a chave nome., que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método. A chamada para o <xref:System.String.Substring%28System.Int32%29> método extrai o valor atribuído à chave. Ele começa na posição de um caractere além do caractere de igual e se estende até o final da cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          A soma de <paramref name="startIndex" /> e <paramref name="length" /> indica uma posição que não está dentro dessa instância.  
  
 -ou-  
  
 <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</summary>
        <returns>Um enumerador fortemente tipado que pode ser usado para iterar pelo objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele pode ser usado somente quando o <xref:System.String> instância é convertida em um <xref:System.Collections.Generic.IEnumerable%601> objeto de interface. Para obter mais informações, consulte o método <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</summary>
        <returns>Um enumerador que pode ser usado para iterar por meio da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.Collections.IEnumerable>. Para obter mais informações, consulte o método <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />Se o valor da cadeia de caracteres atual é <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> se o valor da cadeia de caracteres atual é <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor da cadeia de caracteres atual não é <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>O caractere no índice 0 no objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor atual <see cref="T:System.String" /> objeto é um número menor que <see cref="F:System.Decimal.MinValue" /> ou que <see cref="F:System.Decimal.MaxValue" /> maior.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do objeto retornado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ChangeType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">O valor do objeto <see cref="T:System.String" /> atual não pode ser convertido para o tipo especificado pelo parâmetro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt16.MaxValue" /> ou menor que <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt32.MaxValue" /> ou menor que <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os caracteres nesta instância para uma matriz de caracteres Unicode.</summary>
        <returns>Uma matriz de caracteres Unicode cujos elementos são os caracteres individuais desta instância. Se a instância for uma cadeia de caracteres vazia, a matriz retornada estará vazia e terá comprimento zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia cada caractere (ou seja, cada <xref:System.Char> objeto) em uma cadeia de caracteres para uma matriz de caracteres. O primeiro caractere copiado é zero de índice da matriz de caracteres retornada; é o último caractere copiado no índice <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.  
  
 Para criar uma cadeia de caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor.  
  
 Para criar uma matriz de bytes que contém os caracteres codificados em uma cadeia de caracteres, instanciar o <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> método. Algumas das codificações padrão disponíveis no .NET Framework incluem o seguinte:  
  
|Codificando|Objeto|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obter mais informações, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.ToCharArray%2A> método para extrair os caracteres em uma cadeia de caracteres para uma matriz de caracteres. Ele exibe a cadeia de caracteres original e os elementos na matriz.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 O exemplo a seguir define uma cadeia de caracteres que contém os caracteres que servem como delimitadores em uma cadeia de caracteres delimitada. Depois, ele chama o <xref:System.String.ToCharArray%2A> método para criar uma matriz de caracteres que pode ser passada para o <xref:System.String.Split%28System.Char%5B%5D%29> método para separar a cadeia de caracteres delimitada em seus subcadeias de caracteres individuais.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição inicial de uma subcadeia de caracteres nesta instância.</param>
        <param name="length">O comprimento da subcadeia de caracteres nesta instância.</param>
        <summary>Copia os caracteres em uma subcadeia de caracteres especificada nesta instância para uma matriz de caracteres Unicode.</summary>
        <returns>Uma matriz de caracteres Unicode cujos elementos são o número de caracteres <paramref name="length" /> nesta instância a partir da posição do caractere <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia os caracteres em uma parte de uma cadeia de caracteres em uma matriz de caractere. Para criar uma cadeia de caracteres de um intervalo de caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor.  
  
 O `startIndex` parâmetro é baseado em zero. Ou seja, o índice do primeiro caractere na instância de cadeia de caracteres é zero.  
  
 Se `length` for zero, a matriz retornada está vazia e tem um comprimento zero. Se esta instância for `null` ou uma cadeia de caracteres vazia (""), a matriz retornada está vazia e tem um comprimento zero.  
  
 Para criar uma matriz de bytes que contém os caracteres codificados em uma parte de uma cadeia de caracteres, instanciar o <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> método. Algumas das codificações padrão disponíveis no .NET Framework incluem o seguinte:  
  
|Codificando|Objeto|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obter mais informações, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 O exemplo a seguir converte uma subcadeia de caracteres dentro de uma cadeia de caracteres em uma matriz de caracteres, em seguida, enumera e exibe os elementos da matriz.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o comprimento desta instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em minúsculas.</summary>
        <returns>Uma cadeia de caracteres em letras minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método leva em conta as regras de maiusculas e minúsculas da cultura atual.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 A operação de maiusculas e minúsculas que é o resultado de chamar o <xref:System.String.ToLower> método leva em conta às convenções de maiusculas e minúsculas da cultura atual. Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos. Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToLower> método) e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte várias mistas cadeias de caracteres maiusculas em minúsculas.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para converter um caractere em minúsculas, usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para sua <paramref name="culture" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
        <summary>Retorna uma cópia desta cadeia de caracteres convertida em minúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</summary>
        <returns>O equivalente da cadeia de caracteres atual em minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a forma como o caso da cadeia de caracteres é alterado.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você passar o <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> método um <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em conta. Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte duas cadeias de caracteres em maiusculas para minúsculas usando as culturas inglês norte-americano e Turco Turquia e compara as cadeias de caracteres em minúsculas. As cadeias de caracteres em maiusculas são idênticas, exceto pelo fato de cada ocorrência da Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, de outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em minúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</summary>
        <returns>O equivalente da cadeia de caracteres atual em minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cultura invariável representa uma cultura insensível. Ele está associado com o idioma inglês, mas não com um país ou região específica. Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToLowerInvariant%2A> método. O <xref:System.String.ToLowerInvariant%2A> método é equivalente a `ToLower(CultureInfo.InvariantCulture)`. O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas. O <xref:System.String.ToLowerInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão de maiusculas e minúsculas de cada palavra. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz de maiusculas e minúsculas com base na ordem de elementos na matriz de letras minúsculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</summary>
        <returns>A cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como este método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente. Geralmente é chamado implicitamente em uma operação, como mostra o exemplo de formatação de composição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.ToString%2A> método. Observe que o exemplo não chamar explicitamente o <xref:System.String.ToString%2A> método. Em vez disso, o método é chamado implicitamente, o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(Reservado) Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</summary>
        <returns>A cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider`é reservado e não participar no momento nesta operação.  
  
 Como este método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em maiúsculas.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa as regras de maiusculas e minúsculas da cultura atual para converter cada caractere na instância atual para seu equivalente em letras maiusculas. Se um caractere não tem um equivalente em letras maiusculas, ele está incluído alterados na cadeia de caracteres retornada.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
 O <xref:System.String.ToUpper%2A> método é geralmente usado para converter uma cadeia de caracteres em maiusculas para que ele pode ser usado em uma comparação que diferencia maiusculas de minúsculas. Um método melhor para executar uma comparação de maiusculas e minúsculas é chamar um método de comparação de cadeia de caracteres que tenha uma <xref:System.StringComparison> parâmetro cujo valor é definido como <xref:System.StringComparison?displayProperty=nameWithType> para obter uma comparação sensíveis à cultura, diferencia maiusculas de minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 A operação de maiusculas e minúsculas que é o resultado de chamar o <xref:System.String.ToUpper> método leva em conta às convenções de maiusculas e minúsculas da cultura atual. Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToUpper> método) e executa com mais eficiência.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.ToUpper%2A> método para converter uma série de cadeias de caracteres de um caractere que contêm cada caractere nos conjuntos de caracteres estendidos A Latim básico, o suplemento de Latin-1 e latino. Ele exibe, em seguida, cada cadeia de caracteres cujo caractere maiusculo é diferente do seu caractere minúsculo.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), recomendamos que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substitua os valores padrão e em vez disso, chama os métodos que exigem parâmetros seja especificado explicitamente. Para converter uma cadeia de caracteres em letras maiusculas, usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para sua <paramref name="culture" /> parâmetro.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
        <summary>Retorna uma cópia desta cadeia de caracteres convertida em maiúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a forma como no caso de uma cadeia de caracteres é alterado.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você passar o <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> método um <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em conta. Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres minúsculos em duas cadeias de caracteres em maiusculas usando as culturas inglês norte-americano e Turco Turquia e compara as cadeias de caracteres em maiusculas. As cadeias de caracteres em maiusculas são idênticas, exceto pelo fato de cada ocorrência da Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, de outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em maiúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cultura invariável representa uma cultura insensível. Ele está associado com o idioma inglês, mas não com um país ou região específica. Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToUpperInvariant%2A> método. O <xref:System.String.ToUpperInvariant%2A> método é equivalente a `ToUpper(CultureInfo.InvariantCulture)`. O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você precisa da versão em maiusculas ou minúscula de um identificador de sistema operacional, como um nome de arquivo denominado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas. O <xref:System.String.ToUpperInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão de maiusculas e minúsculas de cada palavra. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz de maiusculas e minúsculas com base na ordem de elementos na matriz de maiusculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita do objeto <see cref="T:System.String" /> atual.</summary>
        <returns>A cadeia de caracteres que permanece depois que todos os caracteres de espaço em branco forem removidos do início e do final da cadeia de caracteres atual. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Trim%2A> método Remove todos os caracteres de espaço em branco à esquerda e à direita da cadeia de caracteres atual. Cada operação de preparo à esquerda e à direita é interrompido quando um caractere de espaço em branco não é encontrado. Por exemplo, se a cadeia de caracteres atual é "xyz abc", o <xref:System.String.Trim%2A> método retorna "xyz abc". Para remover caracteres de espaço em branco entre as palavras em uma cadeia de caracteres, use um [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual são removidos todos os caracteres de espaço em branco à esquerda e à direita encontrados na instância atual.  
  
 Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de espaço em branco, o método retornará <xref:System.String.Empty>.  
  
 Caracteres de espaço em branco é definido pelo padrão Unicode. O <xref:System.String.Trim> método remove qualquer caractere à esquerda e à direita que produzem um valor de retorno `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Trim?displayProperty=nameWithType> método para remover qualquer espaço em branco extra de cadeias de caracteres inseridas pelo usuário antes de concatená-las.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e mantém uma lista interna de caracteres de espaço em branco que este método corta a versões anteriores. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o método corta todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Devido a essa alteração, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, espaço de largura ZERO (U + 200B) e o espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e versões posteriores não remover. Além disso, o <see cref="M:System.String.Trim" /> método o [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não trim três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), o espaço de sem quebra ESTREITA (U + 202F) e a média MATEMÁTICA espaço (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início e do final da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Trim%2A> método Remove da cadeia de caracteres atual todos os caracteres à esquerda e à direita que estão no `trimChars` parâmetro. Cada à esquerda e à direita trim para de operação quando um caractere que não está em `trimChars` for encontrado. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.Trim%2A> método retorna "abc456xyz".  
  
> [!NOTE]
>  Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os à esquerda e à direita `trimChars` encontrados na instância atual de caracteres são removidos.  
  
 Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de `trimChars` de matriz, o método retornará <xref:System.String.Empty>.  
  
 Se `trimChars` é `null` ou uma matriz vazia, esse método remove qualquer caractere à esquerda ou à direita que resultam em que o método retorna `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método,  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> método para remover espaço, asterisco (*) e caracteres de apóstrofe (') de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que este método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método corta todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Devido a essa alteração, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, espaço de largura ZERO (U + 200B) e o espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e versões posteriores não remover. Além disso, o <see cref="M:System.String.Trim" /> método o [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não trim três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), o espaço de sem quebra ESTREITA (U + 202F) e a média MATEMÁTICA espaço (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do final da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco Unicode serão removidos. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.TrimEnd%2A> método Remove da cadeia de caracteres atual todos os caracteres à direita que estão no `trimChars` parâmetro. A operação de preparo é interrompido quando o primeiro caractere que não está no `trimChars` é encontrado no final da cadeia de caracteres. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimEnd%2A> método retorna "123abc456xyz".  
  
> [!NOTE]
>  Se o <xref:System.String.TrimEnd%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres em que todos os caracteres encontrados no `trimChars` são removidas da cadeia de caracteres atual.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar o <xref:System.String.TrimEnd%28System.Char%5B%5D%29> método Cortar espaços em branco ou marcas de pontuação do final de uma cadeia de caracteres.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que este método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método corta todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Devido a essa alteração, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, espaço de largura ZERO (U + 200B) e o espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e versões posteriores não remover. Além disso, o <see cref="M:System.String.Trim" /> método o [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não trim três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), o espaço de sem quebra ESTREITA (U + 202F) e a média MATEMÁTICA espaço (U + 205F).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à esquerda de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências de caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.TrimStart%2A> método Remove da cadeia de caracteres atual todos os caracteres à esquerda que estão no `trimChars` parâmetro. A operação de preparo é interrompido quando um caractere que não está em `trimChars` for encontrado. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimStart%2A> método retorna "abc456xyz789".  
  
> [!NOTE]
>  Se o <xref:System.String.TrimStart%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual são removidos todos os caracteres de espaço em branco à esquerda encontrados na instância atual.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.TrimStart%2A> método Cortar espaços em branco e caracteres de comentário de linhas do código-fonte. O `StripComments` método ajusta uma chamada para <xref:System.String.TrimStart%2A> e passa uma matriz de caracteres que contém um espaço e o caractere de comentário, que é um apóstrofo (') no Visual Basic e uma barra (/) no c#. O <xref:System.String.TrimStart%2A> método também é chamado para remover o espaço em branco para avaliar se uma cadeia de caracteres é um comentário.  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 O exemplo a seguir mostra uma chamada para o método `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que este método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método corta todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Devido a essa alteração, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, espaço de largura ZERO (U + 200B) e o espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e versões posteriores não remover. Além disso, o <see cref="M:System.String.Trim" /> método o [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não trim três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), o espaço de sem quebra ESTREITA (U + 202F) e a média MATEMÁTICA espaço (U + 205F).</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
