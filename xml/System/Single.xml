<Type Name="Single" FullName="System.Single">
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um número de ponto flutuante de precisão simples.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single> tipo de valor representa um número de 32 bits de precisão simples com valores que variam do negativo 3.402823 E38 ao positivo 3.402823 E38, bem como zero positivo ou negativo, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>e não um número (<xref:System.Single.NaN>). Destina-se para representar valores que são muito grandes (como distâncias entre planetas ou galáxias) ou extremamente pequeno (como a massa molecular de uma substância em kg) e que geralmente são imprecisa (como a distância da Terra em outro sistema solar). O <xref:System.Single> tipo compatível com o 60559:1989 IEC (IEEE 754) padrão para aritmética de ponto flutuante binário.  
  
 Este tópico é composto pelas seguintes seções:  
  
-   [Precisão e a representação de ponto flutuante](#Precision)  
  
-   [Teste de igualdade](#Equality)  
  
-   [Exceções e valores de ponto flutuante](#Exceptions)  
  
-   [Conversão de tipo e a estrutura única](#Conversion)  
  
-   [Funcionalidade de ponto flutuante](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType>fornece métodos para comparar instâncias desse tipo para converter o valor de uma instância em sua representação de cadeia de caracteres e converter a representação de cadeia de caracteres de um número a uma instância desse tipo. Para obter informações sobre como os códigos de especificação de formato controlam a representação de cadeia de caracteres de tipos de valor, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md), [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Representação de ponto flutuante e precisão  
 O <xref:System.Single> tipo de dados armazena valores de ponto flutuante de precisão simples em um formato binário de 32 bits, conforme mostrado na tabela a seguir:  
  
|Parte|Bits|  
|----------|----------|  
|Significando ou mantissa|0-22|  
|Expoente|23-30|  
|Entrada (0 = positivo, 1 = negativo)|31|  
  
 Assim como frações decimais não conseguem precisamente representam alguns valores fracionários (como 1/3 ou <xref:System.Math.PI?displayProperty=nameWithType>), frações binárias são não consegue representar alguns valores fracionários. Por exemplo, 2/10, que é representada com precisão,.2 como uma fração decimal, é representado por.0011111001001100 como uma fração binária, com o padrão "1100" Repetir até o infinito. Nesse caso, o valor de ponto flutuante fornece uma representação imprecisa do número que representa. Executar operações matemáticas adicionais no valor de ponto flutuante original geralmente aumenta sua falta de precisão. Por exemplo, se você comparar os resultados da multiplicação.3 por 10 e adicionando.3 para.3 nove vezes, você verá essa adição produz o resultado menos preciso, porque ela envolve oito mais operações de multiplicação. Observe que essa diferença é aparente apenas se você exibir os dois <xref:System.Single> valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), que, se necessário, exibe todos os 9 dígitos de precisão com suporte a <xref:System.Single> tipo.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Como alguns números não podem ser representados exatamente como valores binários fracionários, números de ponto flutuante podem apenas em números reais aproximados.  
  
 Todos os números de ponto flutuantes tem um número limitado de dígitos significativos, que também determina a precisão com um valor de ponto flutuante aproxima um número real. Um <xref:System.Single> valor tem até 7 dígitos decimais de precisão, embora um máximo de 9 dígitos seja mantido internamente. Isso significa que algumas operações de ponto flutuantes podem não ter a precisão para alterar um valor de ponto flutuante. O exemplo a seguir define um valor de ponto flutuante de precisão única grande e, em seguida, adiciona o produto de <xref:System.Single.Epsilon?displayProperty=nameWithType> e um quatrilhão a ele. No entanto, o produto é muito pequeno para modificar o valor de ponto flutuante original. Seus dígitos menos significativo é milésimos, enquanto o dígito mais significativo do produto é 1<sup>-312</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 A precisão limitada do número de ponto flutuante tem várias consequências:  
  
-   Dois números de ponto flutuantes que pareçam iguais para uma determinada precisão podem não comparados como iguais porque seus dígitos menos significantes são diferentes. No exemplo a seguir, uma série de números são adicionados juntos e seu total é comparado com o total esperado. Embora os dois valores parecem ser os mesmos, uma chamada para o `Equals` método indica que não são.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Se você alterar os itens de formato no <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instrução do `{0}` e `{1}` para `{0:R}` e `{1:R}` para exibir todos os dígitos significativos dos dois <xref:System.Single> valores, é claro que os dois valores são diferentes devido a uma perda de precisão durante as operações de adição. Nesse caso, o problema pode ser resolvido por meio da chamada de <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> método para arredondar o <xref:System.Single> valores para a precisão desejada antes de executar a comparação.  
  
-   Uma operação matemática ou de comparação que usa um número de ponto flutuante pode não produzir o mesmo resultado se for usado um número decimal, porque o número de ponto flutuante binário não pode ser igual ao número de decimal. Um exemplo anterior ilustrado isso exibindo o resultado da multiplicação.3 por 10 e adicionando.3 para.3 nove vezes.  
  
     Quando a precisão em operações numéricas com valores fracionários é importante, use o <xref:System.Decimal> digite, em vez do <xref:System.Single> tipo. Quando a precisão em operações numéricas com valores integrais além do intervalo da <xref:System.Int64> ou <xref:System.UInt64> tipos é importante, use o <xref:System.Numerics.BigInteger> tipo.  
  
-   Um valor pode não ida e volta se um número de ponto flutuante estiver envolvido. Um valor é chamado de viagem se uma operação converte um número de ponto flutuante original em outro formato, uma operação inversa transforma a forma convertida de volta para um número de ponto flutuante e o número de ponto flutuante final é igual ao número de ponto flutuante original. A viagem de ida e pode falhar porque um ou mais dígitos menos significantes são perdidos ou alterados na conversão. No exemplo a seguir, três <xref:System.Single> valores são convertidos em cadeias de caracteres e salvos em um arquivo. Como mostra a saída, embora os valores parecem idênticos, os valores restaurados não são iguais aos valores originais.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     Nesse caso, os valores podem ser recuperado com êxito usando "G9" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) para preservar a precisão completa de <xref:System.Single> valores, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single>valores têm menos precisão que <xref:System.Double> valores. Um <xref:System.Single> valor que é convertido em um equivalente aparentemente <xref:System.Double> geralmente não é igual a <xref:System.Double> valor devido a diferenças na precisão. No exemplo a seguir, o resultado de operações de divisão idênticos é atribuído a um <xref:System.Double> valor e um <xref:System.Single> valor. Após o <xref:System.Single> valor é convertido em um <xref:System.Double>, uma comparação entre dois valores mostra que elas são diferentes.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Para evitar esse problema, use o <xref:System.Double> de tipo de dados em vez do <xref:System.Single> tipo de dados ou usar o <xref:System.Math.Round%2A> método para que ambos os valores têm a mesma precisão.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testando igualdade  
 Para ser considerado igual, dois <xref:System.Single> valores devem representar valores idênticos. No entanto, devido às diferenças na precisão entre valores, ou devido a uma perda de precisão por um ou ambos os valores, valores de ponto flutuante que devem ser idênticos geralmente ficam diferenciem devido a diferenças nos seus dígitos menos significantes. Como resultado, chamadas para o <xref:System.Single.Equals%2A> método para determinar se dois valores são iguais ou chamadas para o <xref:System.Single.CompareTo%2A> método para determinar a relação entre duas <xref:System.Single> valores, geralmente produzir resultados inesperados. Isso fica evidente no exemplo a seguir, onde duas igual aparentemente <xref:System.Single> valores se tornar diferentes, como o primeiro valor possui 7 dígitos de precisão, enquanto o segundo valor tem 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Valores calculados que seguem caminhos de código diferentes e que geralmente são manipuladas de diferentes maneiras mostrará como diferentes. No exemplo a seguir, um <xref:System.Single> valor é quadrado e, em seguida, a raiz quadrada é calculada para restaurar o valor original. Um segundo <xref:System.Single> é multiplicado por 3.51 e quadrado antes da raiz quadrada do resultado é dividida por 3.51 para restaurar o valor original. Embora os dois valores parecem idênticos, uma chamada para o <xref:System.Single.Equals%28System.Single%29> método indica que não são iguais. Usando a cadeia de caracteres de formato padrão de "G9" para retornar uma cadeia de caracteres de resultado que exibe todos os dígitos significativos de cada <xref:System.Single> valor mostra que o segundo valor é.0000000000001 menor do que o primeiro.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 Em casos em que uma perda de precisão é provavelmente afetará o resultado de uma comparação, você pode usar as técnicas a seguir em vez de chamar o <xref:System.Single.Equals%2A> ou <xref:System.Single.CompareTo%2A> método:  
  
-   Chamar o <xref:System.Math.Round%2A?displayProperty=nameWithType> método para garantir que os dois valores tenham a mesma precisão. O exemplo a seguir modifica um exemplo anterior para usar essa abordagem para que os dois valores fracionários são equivalentes.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Observe que o problema de precisão ainda se aplica a valores de ponto médio de arredondamento. Para obter mais informações, consulte o método <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Teste de igualdade aproximada, em vez de igualdade. Essa técnica exige que você defina um absoluto qualquer valor pelo qual os dois valores podem diferir mas ainda pode ser igual ou que você definir uma quantidade relativa pelo qual o menor valor possível divergir do maior valor.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType>às vezes, é usado como uma medida absoluta da distância entre dois <xref:System.Single> valores de durante o teste de igualdade.  No entanto, <xref:System.Single.Epsilon?displayProperty=nameWithType> mede o menor valor possível que pode ser adicionado ou subtraído de um <xref:System.Single> cujo valor é zero. Para a maioria dos positivo e negativo <xref:System.Single> valores, o valor de <xref:System.Single.Epsilon?displayProperty=nameWithType> é muito pequeno para ser detectada. Portanto, exceto os valores que forem zero, não recomendamos seu uso em testes de igualdade.  
  
     O exemplo a seguir usa a segunda abordagem para definir um `IsApproximatelyEqual` método que testa a diferença relativa entre dois valores. Ele também compara o resultado de chamadas para o `IsApproximatelyEqual` método e o <xref:System.Single.Equals%28System.Single%29> método.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Valores de ponto flutuante e exceções  
 Operações com valores de ponto flutuante não emitem exceções, ao contrário de operações com tipos integrais, que lançam exceções em casos de operações ilegais como a divisão por zero ou estouro.  Em vez disso, nessas situações, o resultado de uma operação de ponto flutuante é zero, infinito positivo, infinito negativo ou não é um número (NaN):  
  
-   Se o resultado de uma operação de ponto flutuante é muito pequeno para o formato de destino, o resultado será zero. Isso pode ocorrer quando dois números de ponto flutuantes muito pequenos são multiplicados, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   Se a magnitude do resultado de uma operação de ponto flutuante excede o intervalo de formato de destino, o resultado da operação é <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>, conforme apropriado para o sinal do resultado. O resultado de uma operação que estoura <xref:System.Single.MaxValue?displayProperty=nameWithType> é <xref:System.Single.PositiveInfinity>e o resultado de uma operação que estoura <xref:System.Single.MinValue?displayProperty=nameWithType> é <xref:System.Single.NegativeInfinity>, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity>também resulta de uma divisão por zero com um dividendo positivo, e <xref:System.Single.NegativeInfinity> resulta de uma divisão por zero com um dividendo negativo.  
  
-   Se uma operação de ponto flutuante é inválida, o resultado da operação é <xref:System.Single.NaN>. Por exemplo, <xref:System.Single.NaN> resultados entre as seguintes operações:  
  
    -   Divisão por zero com um dividendo igual a zero. Observe que os outros casos de divisão por zero resultado no <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>.  
  
    -   Qualquer operação de ponto flutuante com uma entrada inválida. Por exemplo, a tentativa de localizar retorna a raiz quadrada de um valor negativo <xref:System.Single.NaN>.  
  
    -   Qualquer operação com um argumento cujo valor é <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Conversões de tipo e a estrutura única  
 O <xref:System.Single> estrutura não define os operadores de conversão explícita ou implícita; em vez disso, as conversões são implementadas pelo compilador.  
  
 A tabela a seguir lista as conversões possíveis de um valor de outros tipos numéricos primitivo para um <xref:System.Single> valor, ele também indica se a conversão é widening ou restringir e se resultante <xref:System.Single> pode ter menos precisão do que o valor original.  
  
|Conversão de|Widening/narrowing|Possível perda de precisão|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Não|  
|<xref:System.Decimal>|Widening<br /><br /> Observe que c# requer um operador cast.|Sim. <xref:System.Decimal>dá suporte a 29 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
|<xref:System.Double>|Restringir; valores fora do intervalo são convertidos em <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> ou <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Sim. <xref:System.Double>dá suporte a 17 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
|<xref:System.Int16>|Widening|Não|  
|<xref:System.Int32>|Widening|Sim. <xref:System.Int32>dá suporte a 10 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
|<xref:System.Int64>|Widening|Sim. <xref:System.Int64>dá suporte a 19 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
|<xref:System.SByte>|Widening|Não|  
|<xref:System.UInt16>|Widening|Não|  
|<xref:System.UInt32>|Widening|Sim. <xref:System.UInt32>dá suporte a 10 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
|<xref:System.UInt64>|Widening|Sim. <xref:System.Int64>dá suporte a 20 dígitos decimais de precisão; <xref:System.Single> oferece suporte a 9.|  
  
 O exemplo a seguir converte o valor mínimo ou máximo de outros tipos primitivos numéricos para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Além disso, o <xref:System.Double> valores <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> oculto para <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Observe que a conversão do valor de alguns tipos numéricos para um <xref:System.Single> valor pode envolver uma perda de precisão. Como mostra o exemplo, uma perda de precisão é possível ao converter <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, e <xref:System.UInt64> valores <xref:System.Single> valores.  
  
 A conversão de um <xref:System.Single> valor para um <xref:System.Double> é uma conversão de ampliação. A conversão pode resultar em perda de precisão, se o <xref:System.Double> tipo não tem uma representação exata para o <xref:System.Single> valor.  
  
 A conversão de um <xref:System.Single> valor para um valor de qualquer tipo de dados numérico primitivo diferente de um <xref:System.Double> é uma conversão de restrição e requer um operador cast (em c#) ou um método de conversão (no Visual Basic). Os valores que estão fora do intervalo do tipo de dados de destino, que são definidos pelo tipo de destino `MinValue` e `MaxValue` se comportam como propriedades, conforme mostrado na tabela a seguir.  
  
|Tipo de destino|Resultado|  
|-----------------|------------|  
|Qualquer tipo integral|Um <xref:System.OverflowException> exceção se a conversão ocorre em um contexto verificado.<br /><br /> Se a conversão ocorre em um contexto desmarcado (o padrão em c#), a operação de conversão for bem-sucedida, mas o valor estoura.|  
|<xref:System.Decimal>|Um <xref:System.OverflowException> exceção,|  
  
 Além disso, <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> lançar um <xref:System.OverflowException> para conversões em números inteiros em um contexto verificado, mas estouro esses valores quando convertidos em inteiros em um contexto desmarcado. Para conversões em <xref:System.Decimal>, eles sempre lançam um <xref:System.OverflowException>. Para conversões em <xref:System.Double>, eles convertidos <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Observe que uma perda de precisão pode resultar de converter um <xref:System.Single> valor em outro tipo numérico. No caso de conversão não integral <xref:System.Double> valores, como mostra a saída do exemplo, o componente fracionário é perdido quando o <xref:System.Single> valor é arredondado (como Visual Basic) ou truncado (como em c#). Para conversões em <xref:System.Decimal> e <xref:System.Single> valores, o <xref:System.Double> valor não pode ter uma representação exata no tipo de dados de destino.  
  
 O exemplo a seguir converte um número de <xref:System.Single> valores em vários outros tipos numéricos. As conversões ocorrem em um contexto verificado no Visual Basic (o padrão) e em c# (porque o [check](~/docs/csharp/language-reference/keywords/checked.md) palavra-chave). A saída do exemplo mostra o resultado para conversões em ambas as um check um contexto desmarcado. Você pode executar conversões em um contexto desmarcado no Visual Basic compilando com o `/removeintchecks+` opção de compilador e no c# comentando o `checked` instrução.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Para obter mais informações sobre a conversão de tipos numéricos, consulte [conversão de tipo do .NET Framework](~/docs/standard/base-types/type-conversion.md) e [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funcionalidade de ponto flutuante  
 O <xref:System.Single> estrutura e tipos relacionados fornecem métodos para executar as seguintes categorias de operações:  
  
-   **Comparação de valores**. Você pode chamar o <xref:System.Single.Equals%2A> método para determinar se dois <xref:System.Single> valores forem iguais, ou o <xref:System.Single.CompareTo%2A> método para determinar a relação entre dois valores.  
  
     O <xref:System.Single> estrutura também oferece suporte a um conjunto completo de operadores de comparação. Por exemplo, você pode testar a igualdade ou desigualdade ou determinar se um valor é maior que ou igual a outro valor. Se um dos operandos for uma <xref:System.Double>, o <xref:System.Single> valor é convertido em um <xref:System.Double> antes de executar a comparação. Se um dos operandos for um tipo integral, ele é convertido em um <xref:System.Single> antes de executar a comparação. Embora essas são as conversões de ampliação, eles podem envolver uma perda de precisão.  
  
    > [!WARNING]
    >  Devido às diferenças na precisão, dois <xref:System.Single> valores que você espera que seja igual podem se tornar diferentes, que afeta o resultado da comparação. Consulte o [testes de igualdade](#Equality) para obter mais informações sobre como comparar dois <xref:System.Single> valores.  
  
     Você também pode chamar o <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, e <xref:System.Single.IsNegativeInfinity%2A> métodos para testar esses valores especiais.  
  
-   **Operações matemáticas**. Operações aritméticas comuns, como adição, subtração, multiplicação e divisão são implementadas por compiladores de linguagem e instruções de linguagem comum intermediário (CIL) em vez de <xref:System.Single> métodos. Se o outro operando em uma operação matemática é um <xref:System.Double>, o <xref:System.Single> é convertido em um <xref:System.Double> antes de executar a operação e o resultado da operação também é um <xref:System.Double> valor. Se o outro operando for um tipo integral, ele é convertido em um <xref:System.Single> antes de executar a operação e o resultado da operação também é um <xref:System.Single> valor.  
  
     Você pode executar outras operações matemáticas chamando `static` (`Shared` no Visual Basic) métodos de <xref:System.Math?displayProperty=nameWithType> classe. Isso inclui métodos adicionais usados para aritmética (como <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, e <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometria (como <xref:System.Math.Cos%2A?displayProperty=nameWithType> e <xref:System.Math.Sin%2A?displayProperty=nameWithType>) e cálculo (como <xref:System.Math.Log%2A?displayProperty=nameWithType>).  Em todos os casos, o <xref:System.Single> valor é convertido em um <xref:System.Double>.  
  
     Você também pode manipular bits individuais em um <xref:System.Single> valor. O <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> método retorna o padrão de bit em uma matriz de bytes.  Passando essa matriz de bytes para o <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> método, você também pode preservar o <xref:System.Single> valor do padrão de bits em um inteiro de 32 bits.  
  
-   **Arredondamento**. Arredondamento geralmente é usado como uma técnica para reduzir o impacto das diferenças entre valores causadas por problemas de representação de ponto flutuante e precisão. Você poderá arredondar um <xref:System.Single> valor chamando o <xref:System.Math.Round%2A?displayProperty=nameWithType> método. No entanto, observe que o <xref:System.Single> valor é convertido em um <xref:System.Double> antes do método é chamado e a conversão pode envolver uma perda de precisão.  
  
-   **Formatação**. Você pode converter um <xref:System.Single> valor em sua representação de cadeia de caracteres chamando o <xref:System.Single.ToString%2A> método ou usando o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso. Para obter informações sobre como controlam a representação de cadeia de caracteres de valores de ponto flutuante a cadeias de caracteres de formato, consulte o [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) tópicos.  
  
-   **Analisando cadeias de caracteres**. Você pode converter a representação de cadeia de caracteres de um valor de ponto flutuante para um <xref:System.Single> valor chamando o <xref:System.Single.Parse%2A> ou <xref:System.Single.TryParse%2A> método. Se a operação de análise falhar, o <xref:System.Single.Parse%2A> método lançará uma exceção, enquanto o <xref:System.Single.TryParse%2A> método retornará `false`.  
  
-   **Conversão de tipo**. O <xref:System.Single> estrutura fornece uma implementação de interface explícita para o <xref:System.IConvertible> interface, que oferece suporte à conversão entre quaisquer dois tipos de dados padrão do .NET Framework. Compiladores de linguagem também suportam a conversão implícita de valores para todos os outros tipos numéricos padrão, exceto a conversão de <xref:System.Double> para <xref:System.Single> valores. Conversão de um valor de qualquer tipo numérico padrão diferente de um <xref:System.Double> para um <xref:System.Single> é uma conversão de ampliação e não requer o uso de um método de operador ou conversão de conversão.  
  
     No entanto, a conversão de valores inteiros de 32 bits e 64 bits pode envolver uma perda de precisão. A tabela a seguir lista as diferenças na precisão de 32 bits, 64 bits, e <xref:System.Double> tipos:  
  
    |Tipo|Precisão máxima (em dígitos decimais)|Precisão interna (em dígitos decimais)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> e <xref:System.UInt32>|10|10|  
    |<xref:System.Int64> e <xref:System.UInt64>|19|19|  
    |<xref:System.Single>|7|9|  
  
     O problema de precisão com mais frequência afeta <xref:System.Single> valores são convertidos em <xref:System.Double> valores. No exemplo a seguir, dois valores produzidos por operações de divisão idênticos são diferentes, como um dos valores é um único valor flutuante de precisão ponto que é convertido em um <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros desse tipo são thread-safe. Os membros que aparentam modificar efetivamente o estado retornam uma nova instância inicializada com o novo valor. Assim como acontece com qualquer outro tipo, a leitura e a gravação em uma variável compartilhada que contém uma instância desse tipo devem ser protegidas por um bloqueio para garantir thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto a ser comparado ou <see langword="null" />.</param>
        <summary>Compara esta instância a um objeto especificado e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância não é um número (<see cref="F:System.Single.NaN" />) e <paramref name="value" /> é um número.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 -ou-  
  
 Essa instância e o valor são ambos não é um número (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" />, ou <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância é um número e <paramref name="value" /> não é um número (<see cref="F:System.Single.NaN" />).  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser `null` ou uma instância de <xref:System.Single>; caso contrário, uma exceção será lançada. Qualquer instância do <xref:System.Single>, independentemente de seu valor é considerado maior `null`.  
  
 Os valores devem ser idênticos para serem considerados iguais. Particularmente quando valores de ponto flutuante dependem de várias operações matemáticas, é comum para a perda de precisão e seus valores sejam quase idênticos, exceto seus dígitos menos significantes. Por isso, o valor de retorno de <xref:System.Single.CompareTo%2A> método pode parecer surpreendente às vezes. Por exemplo, a multiplicação por um determinado valor seguido por divisão pelo mesmo valor deve gerar o valor original, mas no exemplo a seguir, o valor calculado se torna maior que o valor original. Mostrando todos os dígitos significativos dos dois valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que o valor calculado é diferente do valor original em seus dígitos menos significantes. Para obter informações sobre como lidar com essas comparações, consulte a seção comentários a <xref:System.Single.Equals%28System.Single%29> método.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Esse método é implementado para dar suporte a <xref:System.IComparable> interface. Observe que, embora uma <xref:System.Single.NaN> não é igual ao outro <xref:System.Single.NaN> (até mesmo em si), o <xref:System.IComparable> interface requer que `A.CompareTo(A)` retornar zero.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.CompareTo%2A> método.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é um <see cref="T:System.Single" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Compara essa instância a um número de ponto flutuante de precisão simples especificado e retorna um inteiro que indica se o valor dessa instância é menor que, igual a ou maior que o valor do número de ponto flutuante de precisão simples especificado.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância não é um número (<see cref="F:System.Single.NaN" />) e <paramref name="value" /> é um número.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 -ou-  
  
 Esta instância e <paramref name="value" /> não são um número (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância é um número (<paramref name="value" />) e <see cref="F:System.Single.NaN" /> não é um número.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os valores devem ser idênticos para serem considerados iguais. É comum para valores de ponto flutuante para perder a precisão e se quase idênticos, exceto seus dígitos menos significantes, especialmente quando os valores dependem de várias operações matemáticas. Por isso, o valor de retorno de <xref:System.Single.CompareTo%2A> método às vezes pode parecer surpreendente. Por exemplo, a multiplicação por qualquer valor seguido por divisão pelo mesmo valor deve gerar o valor original. No entanto, no exemplo a seguir, o valor calculado se torna maior que o valor original. Mostrando todos os dígitos significativos dos dois valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que o valor calculado é diferente do valor original em seus dígitos menos significantes. Para obter informações sobre como lidar com essas comparações, consulte a seção comentários a <xref:System.Single.Equals%28System.Single%29> método.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Implementa esse método de <xref:System.IComparable%601?displayProperty=nameWithType> interface e executa um pouco melhor do que o <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> método porque ele não tem que converter a `value` parâmetro para um objeto.  
  
 Observe que, embora um objeto cujo valor é <xref:System.Single.NaN> não é considerado igual a outro objeto cujo valor é <xref:System.Single.NaN> (até mesmo em si), o <xref:System.IComparable%601> interface requer que `A.CompareTo(A)` retornar zero.  
  
## <a name="widening-conversions"></a>Conversões de expansão  
 Dependendo da linguagem de programação, talvez seja possível código um <xref:System.Single.CompareTo%2A> método em que o tipo de parâmetro tem bits menos (é mais estreita) que o tipo de instância. Isso é possível porque algumas linguagens de programação executam uma conversão de ampliação implícita que representa o parâmetro como um tipo com tantos bit quanto a instância.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Single> e o tipo de parâmetro seja <xref:System.Int32>. O compilador Microsoft c# gera instruções para representar o valor do parâmetro como um <xref:System.Single> do objeto e, em seguida, gera um <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> método que compara os valores da instância e a representação ampliou do parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador executa conversões ampliadoras implícitas de tipos numéricos. Para obter mais informações, consulte o [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md) tópico.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra genéricas e versões dos <xref:System.Single.CompareTo%2A> método para vários tipos de valor e referência.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Representa o menor valor <see cref="T:System.Single" /> positivo maior que zero. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da <xref:System.Single.Epsilon> propriedade reflete o positivo menor <xref:System.Single> valor significativo em operações numéricas ou comparações quando o valor da <xref:System.Single> instância é zero. Por exemplo, a código a seguir mostra que zero e <xref:System.Single.Epsilon> são considerados valores diferentes, enquanto zero e metade do valor de <xref:System.Single.Epsilon> são considerados iguais.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Mais precisamente, o formato de ponto flutuante de precisão simples consiste em um sinal, um mantissa 23-bit ou significando e um expoente de 8 bits. Como mostra o exemplo a seguir, zero tem um expoente de-126 e um mantissa de 0. <xref:System.Single.Epsilon>tem um expoente de-126 e um mantissa de 1. Isso significa que <xref:System.Single.Epsilon?displayProperty=nameWithType> é o menor positivo <xref:System.Single> valor que é maior que zero e representa o menor valor possível e o menor incremento possíveis para um <xref:System.Single> cujo expoente é-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 No entanto, o <xref:System.Single.Epsilon> propriedade não é uma medida geral de precisão do <xref:System.Single> digite; ele se aplica somente ao <xref:System.Single> instâncias que têm um valor de zero.  
  
> [!NOTE]
>  O valor de <xref:System.Single.Epsilon> propriedade não é equivalente a épsilon de máquina, que representa o limite superior do erro relativo devido a um arredondamento em aritmética de ponto flutuante.  
  
 O valor dessa constante é 1.4e-45.  
  
 Dois números de ponto flutuantes aparentemente equivalentes não podem comparar igual devido a diferenças nos seus dígitos menos significantes. Por exemplo, a expressão de c#, `(float)1/3 == (float)0.33333`, não comparados como iguais porque a operação de divisão no lado esquerdo tem precisão máxima, enquanto a constante à direita é precisa apenas de dígitos especificados. Se você criar um algoritmo personalizado que determina se dois números de ponto flutuantes podem ser considerados iguais, você deve usar um valor que é maior do que o <xref:System.Single.Epsilon> constante para estabelecer a margem aceitável absoluta da diferença para os dois valores a serem considerados iguais. (Normalmente, é muitas vezes maior que a margem de diferença <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Notas de plataforma  
 Em sistemas ARM, o valor de <xref:System.Single.Epsilon> constante é muito pequeno para ser detectada, para que ele é igual a zero. Você pode definir um valor de épsilon alternativo que é igual a 1.175494351E-38 em vez disso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> é uma instância de <see cref="T:System.Single" /> e é igual ao valor dessa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.Equals%2A> método deve ser usado com cuidado, porque dois valores aparentemente equivalentes podem ser diferentes devido à precisão diferente dos dois valores. O exemplo a seguir relata que o <xref:System.Single> valor.3333 e o <xref:System.Single> retornado pela divisão de 1 a 3 são diferentes.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Em vez de comparação de igualdade, um recomendado técnica envolve a definição de uma margem aceitável de diferença entre dois valores (como. 01% de um dos valores). Se o valor absoluto da diferença entre os dois valores é menor ou igual a que a margem, a diferença é provavelmente devido a diferenças na precisão e, portanto, os valores devem ser iguais. O exemplo a seguir usa essa técnica para comparar.33333 e 1/3, os dois <xref:System.Single> valores encontrado diferenciem o exemplo de código anterior.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 Nesse caso, os valores são iguais.  
  
> [!NOTE]
>  Porque <xref:System.Single.Epsilon> define a expressão mínimo de um valor positivo cujo intervalo é quase zero, a margem de diferença deve ser maior que <xref:System.Single.Epsilon>. Normalmente, é muitas vezes maior do que <xref:System.Single.Epsilon>.  
  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.Equals%2A> método.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Single.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Single" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Single.Equals(System.Single)" /> método. Caso contrário, eles chamam o <see cref="M:System.Single.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Single" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos numéricos primitivo exceto <see cref="T:System.Double" /> no Visual Basic e exceto para <see cref="T:System.Decimal" /> e <see cref="T:System.Double" /> em c#, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chamadas o <see cref="M:System.Single.Equals(System.Single)" /> método, enquanto a segunda comparação retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Single.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância.</param>
        <summary>Retorna um valor que indica se essa instância e um objeto <see cref="T:System.Single" /> especificado representam o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for igual a essa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementa esse método de <xref:System.IEquatable%601?displayProperty=nameWithType> de interface e executa um pouco melhor do que <xref:System.Single.Equals%2A> porque ele não tem que converter a `obj` parâmetro para um objeto.  
  
## <a name="widening-conversions"></a>Conversões de expansão  
 Dependendo da linguagem de programação, talvez seja possível código um <xref:System.Single.Equals%2A> método em que o tipo de parâmetro tem bits menos (é mais estreita) que o tipo de instância. Isso é possível porque algumas linguagens de programação executam uma conversão de ampliação implícita que representa o parâmetro como um tipo com tantos bit quanto a instância.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Single> e o tipo de parâmetro seja <xref:System.Int32>. O compilador Microsoft c# gera instruções para representar o valor do parâmetro como um <xref:System.Single> de objeto e, em seguida, gera um <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> método que compara os valores da instância e a representação ampliou do parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador executa conversões ampliadoras implícitas de tipos numéricos. Para obter mais informações, consulte o [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md) tópico.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 O <xref:System.Single.Equals%2A> método deve ser usado com cuidado, porque dois valores aparentemente equivalentes podem ser diferentes devido a precisão diferente dos dois valores. O exemplo a seguir relata que o <xref:System.Single> valor.3333 e o <xref:System.Single> retornado pela divisão de 1 a 3 são diferentes.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Técnica de uma comparação que evita os problemas associados à comparação de igualdade envolve a definição de uma margem aceitável de diferença entre dois valores (como. 01% de um dos valores). Se o valor absoluto da diferença entre os dois valores é menor ou igual a que a margem, a diferença é provavelmente um resultado das diferenças na precisão e, portanto, os valores devem ser iguais. O exemplo a seguir usa essa técnica para comparar.33333 e 1/3, que são os dois <xref:System.Single> valores encontrado diferenciem o exemplo de código anterior.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 Nesse caso, os valores são iguais.  
  
> [!NOTE]
>  Porque <xref:System.Single.Epsilon> define a expressão mínimo de um valor positivo cujo intervalo é quase zero, a margem de diferença deve ser maior que <xref:System.Single.Epsilon>. Normalmente, é muitas vezes maior do que <xref:System.Single.Epsilon>. Por isso, recomendamos que você não use <xref:System.Double.Epsilon> ao comparar <xref:System.Double> valores para igualdade.  
  
 Uma segunda técnica que evita os problemas associados à comparação de igualdade envolve comparar a diferença entre dois números de ponto flutuante com um valor absoluto. Se a diferença for menor ou igual ao valor absoluto, os números são iguais. Se for maior, os números não são iguais. Uma maneira de fazer isso é selecionar arbitrariamente um valor absoluto. No entanto, isso será um problema, porque uma margem aceitável de diferença depende da magnitude do <xref:System.Single> valores. Uma segunda maneira tira proveito de um recurso de design do formato de ponto flutuante: A diferença entre os componentes de mantissa em representações de inteiro de dois valores de ponto flutuantes indica o número de possíveis valores de ponto flutuante que separa os dois valores. Por exemplo, a diferença entre 0,0 e <xref:System.Single.Epsilon> é 1, pois <xref:System.Single.Epsilon> é o menor valor representável ao trabalhar com um <xref:System.Single> cujo valor é zero. O exemplo a seguir usa essa técnica para comparar.33333 e 1/3, que são os dois <xref:System.Double> valores que o exemplo de código anterior com o <xref:System.Single.Equals%28System.Single%29> método encontrado para ser diferentes. Observe que o exemplo usa o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> e <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> métodos para converter um valor de ponto flutuante de precisão simples em sua representação de inteiro.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação de dois números pode produzir resultados diferentes dependendo da versão do .NET Framework, porque a precisão da representação interna dos números pode ser alterados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Single.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Single" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Single.Equals(System.Single)" /> método. Caso contrário, eles chamam o <see cref="M:System.Single.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Single" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos numéricos primitivo exceto <see cref="T:System.Double" /> no Visual Basic e exceto para <see cref="T:System.Decimal" /> e <see cref="T:System.Double" /> em c#, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chamadas o <see cref="M:System.Single.Equals(System.Single)" /> método, enquanto a segunda comparação retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Single.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para tipo de valor <see cref="T:System.Single" />.</summary>
        <returns>A constante enumerada, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliada como infinito positivo ou negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> for avaliado como <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.IsInfinity%2A> método.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna um valor que indica se o valor especificado não é um número (<see cref="F:System.Single.NaN" />).</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> não for avaliado como um número (<see cref="F:System.Single.NaN" />); caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Single.NaN> para sinalizar que o resultado da operação é indefinido. Por exemplo, dividindo 0,0, 0,0 resulta em <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A>Retorna `false` se um <xref:System.Single> valor seja <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>. Para testar esses valores, use o <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, e <xref:System.Single.IsNegativeInfinity%2A> métodos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.IsNaN%2A> método.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliado quanto ao infinito negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> for avaliado como <see cref="F:System.Single.NegativeInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Single.NegativeInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.IsNegativeInfinity%2A> método.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliado quanto ao infinito positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="f" /> for avaliado como <see cref="F:System.Single.PositiveInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Single.PositiveInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.IsPositiveInfinity%2A> método.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Representa o maior valor possível de <see cref="T:System.Single" />. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é positivo 3.40282347E + 38.  
  
 O resultado de uma operação que excede <xref:System.Single.MaxValue?displayProperty=nameWithType> é <xref:System.Single?displayProperty=nameWithType>. No exemplo a seguir, <xref:System.Single?displayProperty=nameWithType> quando o resultado excede os resultados de operações de adição, a multiplicação e a exponenciação <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.MaxValue> constante.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Representa o menor valor possível de <see cref="T:System.Single" />. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é negativo 3.402823 E38.  
  
 O resultado de uma operação que é menor que <xref:System.Single.MinValue?displayProperty=nameWithType> é <xref:System.Single?displayProperty=nameWithType>. No exemplo a seguir, <xref:System.Single?displayProperty=nameWithType> resultados de operações de subtração, multiplicação quando o resultado é menor que <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.MinValue> constante.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Representa algo que não é um número (<see langword="NaN" />). Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um método ou operador retorna <xref:System.Single.NaN> quando o resultado de uma operação é indefinido. Por exemplo, o resultado da divisão por zero de zero é <xref:System.Single.NaN>, como mostra o exemplo a seguir. (Mas observe que a divisão de um número diferente de zero por zero retorna <xref:System.Single.PositiveInfinity> ou <xref:System.Single.NegativeInfinity>, dependendo do sinal do divisor.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Além disso, uma chamada de método com um <xref:System.Single.NaN> valor ou uma operação em um <xref:System.Single.NaN> valor retorna <xref:System.Single.NaN>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Use o <xref:System.Single.IsNaN%2A> método para determinar se um valor não é um número. Em geral, <xref:System.Single> operadores não podem ser usados para comparar <xref:System.Single.NaN?displayProperty=nameWithType> com outros <xref:System.Single> valores, embora os métodos de comparação (como <xref:System.Single.Equals%2A> e <xref:System.Single.CompareTo%2A>) pode. O exemplo a seguir ilustra a diferença no comportamento entre <xref:System.Single> métodos e operadores de comparação.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Single.NaN> constante.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Representa o infinito negativo. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é o resultado da divisão por zero de um número negativo.  
  
 Esta constante é retornado quando o resultado de uma operação é menor que <xref:System.Single.MinValue>.  
  
 Use <xref:System.Single.IsNegativeInfinity%2A> para determinar se um valor é avaliada como infinito negativo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.NegativeInfinity> constante.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se os dois valores <see cref="T:System.Single" /> especificados são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_Equality%2A> método define o operador de igualdade para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Single" /> especificado é maior que outro valor <see cref="T:System.Single" /> especificado.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_GreaterThan%2A> método define a operação de maior-que o operador para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um especificado <see cref="T:System.Single" /> valor é maior que ou igual a outro especificado <see cref="T:System.Single" /> valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> for maior ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_GreaterThanOrEqual%2A> método define a operação do operador greater-than-ou-equal para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois especificada <see cref="T:System.Single" /> valores não forem iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_Inequality%2A> método define o operador de desigualdade para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor especificado de <see cref="T:System.Single" /> é menor que outro valor especificado de <see cref="T:System.Single" />.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_LessThan%2A> método define a operação de menos-que o operador para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um especificado <see cref="T:System.Single" /> valor é menor ou igual a outro especificado <see cref="T:System.Single" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.op_LessThanOrEqual%2A> método define a operação do operador less-than-or-equal para <xref:System.Single> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `s` parâmetro pode conter a cultura atual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou uma cadeia de caracteres do formulário:  
  
 [*ws*][*sign*] [*integral-digits*[*,*]]*integral-digits*[*.* [*dígitos fracionários*]] [e [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo ou um símbolo de sinal positivo. Os caracteres de sinal válido são determinados pelas propriedades <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> da cultura atual. Somente um sinal pode ser usado.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Executa de *integral dígitos* pode ser particionado por um símbolo de separador de grupo. Por exemplo, em algumas culturas, uma vírgula (,) separa grupos de milhares. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|*,*|Um símbolo de separador de milhares específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 O parâmetro `s` é interpretado usando-se uma combinação dos sinalizadores <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> sobrecarga do método.  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analisar uma cadeia de caracteres usando as informações de formatação de uma cultura específica, use o <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> ou <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método.  
  
 Normalmente, se você passa ao método <xref:System.Single.Parse%2A>, uma cadeia de caracteres criada chamando-se o método <xref:System.Single.ToString%2A>, o valor <xref:System.Single> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Single.Parse%28System.String%29> método para converter uma matriz de cadeias de caracteres para equivalente <xref:System.Single> valores.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não representa um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indica os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico para ser especificado é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo especificado para o número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples que é equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `style` define os elementos de estilo (como espaço em branco, separadores de milhares e símbolos de moeda) que são permitidos no parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 O `s` parâmetro pode conter a cultura atual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. Dependendo do valor de `style`, ele também pode assumir a forma:  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.* [*dígitos fracionários*]] [E [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
 *ws*  
 Uma série de caracteres de espaço em branco. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 $  
 Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 *logon*  
 Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+). O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 *dígitos de integral*  
 Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.  
  
 ,  
 Um separador de grupo específico de cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 .  
 Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 *dígitos fracionários*  
 Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 E  
 O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.  
  
 *dígitos exponencial*  
 Uma série de dígitos que varia de 0 a 9 que especificam um expoente.  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. Os elementos de controle dos membros <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em `s` além de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador de milhares (.).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o símbolo de ponto decimal (.). O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de milhares (.) e elementos de vírgula decimal (,).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal.|  
  
 Alguns exemplos de `s` são "100", "-123,456,789", "123.45e + 6", "+500", "5e2", "3.1416", "600.", "-. 123" e "-infinito".  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para especificar a cultura cujas informações de formatação são usadas para a operação de análise, chame o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> sobrecarga.  
  
 Normalmente, se você passa ao método <xref:System.Single.Parse%2A>, uma cadeia de caracteres criada chamando-se o método <xref:System.Single.ToString%2A>, o valor <xref:System.Single> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analisar as representações de cadeia de caracteres de <xref:System.Single> valores. O exemplo usa as informações de formatação para a cultura en-US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico da cultura para o número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é normalmente usada para converter um texto que pode ser formatado de várias maneiras de um <xref:System.Single> valor. Por exemplo, ele pode ser usado para converter o texto inserido por usuário em uma caixa de texto HTML em um valor numérico.  
  
 O parâmetro `s` é interpretado usando-se uma combinação dos sinalizadores <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para a cultura especificada pelo `provider`, ou ele pode conter uma cadeia de caracteres do formulário:  
  
 [*ws*][*sign*]*integral-digits*[*.* [*dígitos fracionários*]] [E [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Os elementos que contêm o termo "digits" consistem em uma série de caracteres numéricos que varia de 0 a 9.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+).|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Executa de *integral dígitos* pode ser particionado por um símbolo de separador de grupo. Por exemplo, em algumas culturas, uma vírgula (,) separa grupos de milhares. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|.|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Para obter mais informações sobre formatos numéricos, consulte o [tipos de formatação](~/docs/standard/base-types/formatting-types.md) tópico.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cujo <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura. Quando o <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e o transmite um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> , em seguida, o método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações sobre o formato da `s` parâmetro. Existem três maneiras de usar o parâmetro `provider` para fornecer informações de formatação personalizadas para a operação de análise:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Se `provider` é `null` ou <xref:System.Globalization.NumberFormatInfo> não pode ser obtido, as informações de formatação para a cultura atual do sistema é usada.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Alguns exemplos de `s` são "100", "-123,456,789", "123.45e + 6", "+500", "5e2", "3.1416", "600.", "-. 123" e "-infinito".  
  
   
  
## Examples  
 O exemplo a seguir é o manipulador de eventos de clique do botão de um formulário da Web. Ele usa a matriz retornada pela propriedade <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> para determinar a localidade do usuário. Em seguida, ele instancia um objeto <xref:System.Globalization.CultureInfo> que corresponde à localidade. O <xref:System.Globalization.NumberFormatInfo> que pertence ao objeto <xref:System.Globalization.CultureInfo> objeto é transmitido para o <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> método para converter o usuário de entrada para um <xref:System.Single> valor.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não representa um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indica os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico para ser especificado é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo e formato específico da cultura especificados em seu equivalente de número de ponto flutuante de precisão simples.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `style` define os elementos de estilo (como espaço em branco, separadores de milhares e símbolos de moeda) que são permitidos no parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para a cultura especificada pelo `provider`. Dependendo do valor de `style`, ele também pode assumir a forma:  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[ *dígitos fracionários*]] [E[*sign*]*exponential-digits*][*ws*]  
  
 Elementos entre colchetes ([e]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|$|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+). O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|,|Um separador de grupo específico de cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>|  
|.|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `s` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. Os elementos de controle dos membros <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em `s` além de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador de milhares (.).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o símbolo de ponto decimal (.). O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de milhares (.) e elementos de vírgula decimal (,).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal.|  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato de `value`. Normalmente, `provider` pode ser qualquer um dos seguintes:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que fornece informações de formatação numéricas. Seu <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação numéricas.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider> e usa o <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> método para instanciar e retornar o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método para analisar as representações de cadeia de caracteres de <xref:System.Single> valores. Cada cadeia de caracteres em uma matriz é analisada usando as convenções de formatação de en-US, nl-NL e uma cultura personalizada. A cultura personalizada define seu símbolo de separador de grupo como o caractere de sublinhado ("_") e o tamanho do grupo como dois.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />não representa um valor numérico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito positivo. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é o resultado da divisão de um número positivo por zero.  
  
 Esta constante é retornado quando o resultado de uma operação é maior do que <xref:System.Single.MaxValue>.  
  
 Use <xref:System.Single.IsPositiveInfinity%2A> para determinar se um valor é avaliada como infinito positivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Single.PositiveInfinity> constante.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> caso o valor da instância atual não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. A tentativa de usar esse método lança um <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. A tentativa de usar esse método lança um <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual converter isso <see cref="T:System.Single" /> valor.</param>
        <param name="provider">Um objeto que fornece informações sobre o formato do valor retornado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o método `static` (`Shared` no Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Single> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.ToString> formatos do método um <xref:System.Single> valor padrão ("G" ou geral), formato da cultura atual. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Single.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Single.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> ou uma cadeia de caracteres do formulário:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Os elementos que contêm o termo "digits" consistem em uma série de caracteres numéricos que varia de 0 a 9. A tabela a seguir lista cada elemento:  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*logon*|Um símbolo de sinal negativo ou de sinal positivo.|  
|*dígitos de integral*|Uma série de dígitos que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|'.'|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que especificam a parte fracionária do número.|  
|'e'|Um caractere minúsculo 'e', indicando a notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que especificam um expoente.|  
  
 Alguns exemplos do valor de retorno são "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o padrão <xref:System.Single.ToString%2A?displayProperty=nameWithType> método para exibir as representações de cadeia de caracteres de um número de <xref:System.Single> valores.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 O exemplo de código a seguir ilustra o uso do <xref:System.Single.Parse%28System.String%29> método junto com o <xref:System.Single.ToString> método.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.ToString%28System.IFormatProvider%29> formatos do método um <xref:System.Single> valor padrão ("G" ou geral) formato de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura atual, use as outras sobrecargas do <xref:System.Single.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Single.ToString>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Single.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> ou uma cadeia de caracteres do formulário:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Elementos que contém os termo "dígitos" consistem em uma série de caracteres numéricos, variando de 0 a 9. A tabela a seguir lista cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|sinal|Um símbolo de sinal negativo ou de sinal positivo.|  
|dígitos integrais|Uma série de dígitos que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|'.'|Um símbolo de vírgula decimal específico de cultura.|  
|dígitos fracionários|Uma série de dígitos que especificam a parte fracionária do número.|  
|'e'|Um caractere minúsculo 'e', indicando a notação exponencial (científica).|  
|dígitos exponenciais|Uma série de dígitos que especificam um expoente.|  
  
 Alguns exemplos do valor de retorno são "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um objeto <xref:System.Globalization.CultureInfo> ou um objeto <xref:System.Globalization.NumberFormatInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Se `provider` é `null`, o valor de retorno é formatado usando o <xref:System.Globalization.NumberFormatInfo> dados para a cultura atual.  
  
 Para converter um <xref:System.Single> valor em sua representação de cadeia de caracteres usando uma cultura especificada e uma cadeia de caracteres de formato específico, chamada de <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir exibe a representação de cadeia de caracteres de dois <xref:System.Single> valores usando <xref:System.Globalization.CultureInfo> objetos que representam várias culturas diferentes.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato numérico.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.ToString%28System.String%29> formatos do método um <xref:System.Single> valor em um formato especificado usando as convenções da cultura atual. Se você quiser usar o padrão ("G" ou geral) formatar ou especificar uma cultura diferente, use as outras sobrecargas do <xref:System.Single.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Single.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou a representação de cadeia de caracteres do valor da instância atual, conforme especificado por `format`.  
  
 O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, exceto para D e X, bem como qualquer combinação de especificadores de formato numérico personalizados. Se o formato é `null` ou uma cadeia de caracteres vazia, o valor de retorno é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Por padrão, o valor de retorno contém somente 7 dígitos de precisão Embora um máximo de 9 dígitos seja mantido interiormente. Se o valor desta instância tem maior do que 7 dígitos, <xref:System.Single.ToString%28System.String%29> retorna <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> em vez do número esperado. Se você precisar de mais precisão, especificar `format` com a especificação de formato "G9", que sempre retorna 9 dígitos de precisão ou "R", que retorna 7 dígitos se o número pode ser representado com que a precisão ou 9 dígitos, se o número só pode ser representado com precisão máxima.  
  
   
  
## Examples  
 O exemplo a seguir define um valor numérico e formata como um valor de moeda usando a cadeia de caracteres de formato numérico padrão "C" e como um valor numérico para três casas decimais, usando a cadeia de caracteres de formato numérico padrão de "N". As cadeias de caracteres de resultado são formatadas usando as convenções de cultura en-US. Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 O exemplo a seguir exibe vários <xref:System.Single> valores usando cada um dos especificadores de formato numérico padrão com suporte, juntamente com duas cadeias de caracteres de formato numérico personalizado. Uma dessas cadeias de caracteres de formato personalizado ilustra como preencher uma <xref:System.Single> valor com zeros à esquerda. Na conversão dos valores numéricos em cadeias de caracteres, o exemplo usa as convenções de formatação da cultura en-US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato numérico.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> formatos do método um <xref:System.Single> valor em um formato especificado de uma cultura específica. Se você quiser usar as configurações padrão de formato ou a cultura, use as outras sobrecargas do <xref:System.Single.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Single.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Single.ToString%28System.String%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou a representação de cadeia de caracteres do valor da instância atual, conforme especificado por `format`.  
  
 O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, exceto para D e X, bem como qualquer combinação de especificadores de formato numérico personalizados. Se `format` é `null` ou uma cadeia de caracteres vazia, o valor de retorno para esta instância é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um objeto <xref:System.Globalization.CultureInfo> ou um objeto <xref:System.Globalization.NumberFormatInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Se `provider` é `null`, o valor de retorno é formatado com o <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual.  
  
 Por padrão, o valor de retorno contém somente 7 dígitos de precisão Embora um máximo de 9 dígitos seja mantido interiormente. Se o valor desta instância tem maior do que 7 dígitos, <xref:System.Single.ToString%2A> retorna <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> em vez do número esperado. Se você precisar de mais precisão, especificar `format` com a especificação de formato "G9", que sempre retorna 9 dígitos de precisão ou "R", que retorna 7 dígitos se o número pode ser representado com que a precisão ou 9 dígitos, se o número só pode ser representado com precisão máxima.  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Single> valor usando cada um dos especificadores de formato numérico padrão com suporte para várias culturas diferentes.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que representa um número a ser convertido.</param>
        <param name="result">Quando este método retorna, contém o número de ponto flutuante de precisão simples equivalente para o valor numérico ou símbolo contidos em <c>s</c>, se a conversão foi bem-sucedida ou zero se a conversão falha. A conversão falhará se o <c>s</c> parâmetro é <see langword="null" /> ou <see cref="F:System.String.Empty" />, não é um número em um formato válido ou representa um número menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />. Este parâmetro é passado não inicializado; qualquer valor fornecido originalmente no <c>resultados</c> será substituído.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no número de ponto flutuante de precisão simples equivalente. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga difere de <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> método retornando um valor booliano que indica se a operação de análise foi bem-sucedida em vez de retornar o valor numérico analisado. Ele elimina a necessidade de usar a identificação de exceções para testar um <xref:System.FormatException> caso esse `s` seja inválido e não possa ser analisado com êxito.  
  
 O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (a comparação de cadeia de caracteres diferencia maiusculas de minúsculas), ou uma cadeia de caracteres do formulário:  
  
 [ws] [entrada] [integral dígitos,] integral dígitos [. [ dígitos de fração]] [exponencial e [logon] dígitos] [ws]  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo ou de sinal positivo.|  
|*dígitos de integral*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|*,*|Um símbolo de separador do grupo específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam a parte fracionária do número.|  
|*E*|Um maiusculo ou minúsculo caractere 'e', que indica a notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam um expoente.|  
  
 O parâmetro `s` é interpretado usando-se uma combinação dos sinalizadores <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> sobrecarga do método.  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analisar uma cadeia de caracteres usar as informações de formatação de alguma outra especificado cultura, use o <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> sobrecarga do método.  
  
 Normalmente, se você passa ao método <xref:System.Single.TryParse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Single.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Single> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> método para converter as representações de cadeia de caracteres de valores numéricos para <xref:System.Single> valores. Ele pressupõe que en-US é a cultura atual.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que representa um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indica o formato permitido de <c>s</c>. Um valor típico para ser especificado é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>s</c>.</param>
        <param name="result">Quando este método retorna, contém o número de ponto flutuante de precisão simples equivalente para o valor numérico ou símbolo contidos em <c>s</c>, se a conversão foi bem-sucedida ou zero se a conversão falha. A conversão falhará se o <c>s</c> parâmetro é <see langword="null" /> ou <see cref="F:System.String.Empty" />, não está em um formato compatível com <c>estilo</c>, representa um número menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />, ou se <c>estilo</c> não é uma combinação válida de <see cref="T:System.Globalization.NumberStyles" /> constantes enumeradas. Este parâmetro é passado não inicializado; qualquer valor fornecido originalmente no <c>resultados</c> será substituído.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo e formato específico da cultura especificados em seu equivalente de número de ponto flutuante de precisão simples. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga difere de <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método retornando um valor booliano que indica se a operação de análise foi bem-sucedida em vez de retornar o valor numérico analisado. Ele elimina a necessidade de usar a identificação de exceções para testar um <xref:System.FormatException> caso esse `s` seja inválido e não possa ser analisado com êxito.  
  
 O parâmetro `style` define o formato permitido do parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> para a cultura indicada pelo `provider`. Além disso, dependendo do valor de `style`, o `s` parâmetro pode incluir os seguintes elementos:  
  
 [ws] [$] [entrada] [integral dígitos,] dígitos integral [fracionários dígitos] [exponencial e [logon] dígitos] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início do `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador. Ele pode aparecer no final da `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. Sua posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> ou <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriedades do <xref:System.Globalization.NumberFormatInfo> objeto retornado pelo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método do `provider` parâmetro. O símbolo de moeda pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|*,*|Um símbolo de separador de milhares específico da cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*e*|O caractere e ou E, que indica que `s` pode representar um número usando a notação exponencial. O `s` parâmetro pode representar um número em notação exponencial se estilo inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. O restante <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementos que podem ser, mas não precisa estar presente na cadeia de entrada de controle de membros. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em s além de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O elemento de linguagem *.* e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O parâmetro `s` também pode usar notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *integral dígitos*E*exponencial dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres em notação exponencial com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os. O parâmetro `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o *.* símbolo. O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, milhares separador (*,),* e ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os estilos, exceto caso `s` não possa representar um número hexadecimal.|  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cujo <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura. Quando o <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e o transmite um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> , em seguida, o método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações sobre o formato da `s` parâmetro. Existem três maneiras de usar o parâmetro `provider` para fornecer informações de formatação personalizadas para a operação de análise:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Se `provider` é `null`, a formatação de `s` é interpretado com base no <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> método ao analisar a representação da cadeia de números que tem um estilo específico e são formatados usando as convenções de uma determinada cultura.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
