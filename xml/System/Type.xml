<Type Name="Type" FullName="System.Type">
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa as declarações de tipo: tipos de classe, tipos de interface, tipos de matriz, tipos de valor, tipos de enumeração, parâmetros de tipo, definições de tipo genérico e tipos genéricos construídos abertos ou fechados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 `Type`é a raiz do <xref:System.Reflection> funcionalidade e é a principal maneira de acessar os metadados. Use os membros de <xref:System.Type> para obter informações sobre uma declaração de tipo, sobre os membros de um tipo (como os construtores, métodos, campos, propriedades e eventos de uma classe), bem como o módulo e o assembly no qual a classe seja implantada.  
  
 Nenhuma permissão é necessária para o código usar a reflexão para obter informações sobre os tipos e seus membros, independentemente de seus níveis de acesso. Nenhuma permissão é necessária para o código usar reflexão para acessar membros públicos ou outros membros cujos níveis de acesso poderiam torná-las visíveis durante a compilação normal. No entanto, para o seu código para usar reflexão para acessar os membros que normalmente seria inacessível, como métodos privados ou internos, ou protegido campos de um tipo de classe não herda, seu código deve ter <xref:System.Security.Permissions.ReflectionPermission>. Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  
  
 `Type`é uma classe base abstrata que permite que várias implementações. O sistema sempre fornecerá a classe derivada `RuntimeType`. Reflexão, começando com a palavra em tempo de execução de todas as classes são criadas apenas uma vez por objeto nas operações de comparação de sistema e suporte.  
  
> [!NOTE]
>  Em cenários de multithreading, não bloqueiam <xref:System.Type> objetos para sincronizar o acesso ao `static` dados. Outro código, em que você não tem controle, também pode bloquear seu tipo de classe. Isso pode resultar em um deadlock. Em vez disso, sincronizar o acesso a dados estáticos, bloqueando uma particular `static` objeto.  
  
> [!NOTE]
>  Uma classe derivada pode acessar membros de classes base do código de chamada. Além disso, o acesso é permitido para membros de assembly do assembly do código de chamada. Como regra, se a permissão de acesso no código de early bound, em seguida, você também podem acessar no código de associação tardia.  
  
> [!NOTE]
>  Interfaces que estendem as interfaces não herdam os métodos definidos nas interfaces de estendida.  
  
 Nesta seção:  
  
 [Os tipos representa um objeto de tipo?](#WhatTypes)   
 [Recuperar um objeto de tipo](#Retrieve)   
 [Objetos de tipo de comparação de igualdade](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Os tipos representa um objeto de tipo?  
 Essa classe é thread-safe; vários threads ao mesmo tempo podem ler de uma instância desse tipo. Uma instância do <xref:System.Type> classe pode representar qualquer um dos seguintes tipos:  
  
-   Classes  
  
-   Tipos de valor  
  
-   Matrizes  
  
-   Interfaces  
  
-   Enumerações  
  
-   Delegados  
  
-   Definições de tipo genérico e tipos genéricos construídos  
  
-   Argumentos de tipo e digite parâmetros de tipos genéricos construídos, definições de tipo genérico e definições de método genérico  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Recuperar um objeto de tipo  
 O <xref:System.Type> associado a um determinado tipo de objeto pode ser obtido das seguintes maneiras:  
  
-   A instância <xref:System.Object.GetType%2A?displayProperty=nameWithType> método retorna um <xref:System.Type> objeto que representa o tipo de uma instância. Como todos os tipos gerenciados derivam da <xref:System.Object>, o <xref:System.Object.GetType%2A> método pode ser chamado em uma instância de qualquer tipo.  
  
     A exemplo a seguir chama o <xref:System.Object.GetType%2A?displayProperty=nameWithType> método para determinar o tipo de tempo de execução de cada objeto em uma matriz de objetos.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Estático <xref:System.Type.GetType%2A?displayProperty=nameWithType> métodos retornam um <xref:System.Type> objeto que representa um tipo especificado pelo seu nome totalmente qualificado.  
  
-   O <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> métodos retornam `Type` objetos que representam os tipos definidos em um módulo. O primeiro método pode ser usado para obter uma matriz de <xref:System.Type> objetos para todos os tipos de públicos e privados definidos em um módulo. (Você pode obter uma instância de `Module` por meio de <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> método, ou por meio de <xref:System.Type.Module%2A?displayProperty=nameWithType> propriedade.)  
  
-   O <xref:System.Reflection.Assembly?displayProperty=nameWithType> objeto contém um número de métodos para recuperar as classes definidas em um assembly, incluindo <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, e <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   O <xref:System.Type.FindInterfaces%2A> método retorna uma lista filtrada de tipos de interface com suporte por um tipo.  
  
-   O <xref:System.Type.GetElementType%2A> método retorna um `Type` objeto que representa o elemento.  
  
-   O <xref:System.Type.GetInterfaces%2A> e <xref:System.Type.GetInterface%2A> métodos retornam <xref:System.Type> objetos que representam os tipos de interface com suporte por um tipo.  
  
-   O <xref:System.Type.GetTypeArray%2A> método retorna uma matriz de <xref:System.Type> objetos que representam os tipos especificados por um conjunto arbitrário de objetos. Os objetos são especificados com uma matriz do tipo <xref:System.Object>.  
  
-   O <xref:System.Type.GetTypeFromProgID%2A> e <xref:System.Type.GetTypeFromCLSID%2A> métodos são fornecidos para interoperabilidade COM. Elas retornam uma <xref:System.Type> objeto que representa o tipo especificado por uma `ProgID` ou `CLSID`.  
  
-   O <xref:System.Type.GetTypeFromHandle%2A> método é fornecido para fins de interoperabilidade. Ele retorna um `Type` objeto que representa o tipo especificado por um identificador de classe.  
  
-   C# `typeof` operador, o C++ `typeid` operador e o Visual Basic `GetType` operador obter a `Type` objeto para um tipo.  
  
-   O <xref:System.Type.MakeGenericType%2A> método retorna um <xref:System.Type> objeto que representa um tipo genérico construído, que é um tipo construído aberto se seu <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, e um tipo construído caso contrário. Um tipo genérico pode ser instanciado somente se ele está fechado.  
  
-   O <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, e <xref:System.Type.MakeByRefType%2A> métodos retornam <xref:System.Type> objetos que representam, respectivamente, uma matriz de um tipo especificado, um ponteiro para um tipo especificado e o tipo de um parâmetro de referência (`ref` em c#, `ByRef` no Visual Basic).  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Objetos de tipo de comparação de igualdade  
 Um <xref:System.Type> objeto que representa um tipo é exclusivo; ou seja, duas <xref:System.Type> referências de objeto referem-se ao mesmo objeto apenas se eles representam o mesmo tipo. Isso possibilita a comparação de <xref:System.Type> objetos usando a igualdade de referência. O exemplo a seguir compara o <xref:System.Type> objetos que representam um número de valores inteiros para determinar se eles são do mesmo tipo.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir mostra alguns recursos representativos de <xref:System.Type>. C# `typeof` operador (`GetType` operador no Visual Basic, `typeid` operador no Visual C++) é usado para obter um <xref:System.Type> objeto representando <xref:System.String>. Neste <xref:System.Type> objeto, o <xref:System.Type.GetMethod%2A> método é usado para obter um <xref:System.Reflection.MethodInfo> que representa o <xref:System.String.Substring%2A> sobrecarga que usa um ponto de partida e um comprimento.  
  
 Para identificar a assinatura de sobrecarga, o exemplo de código cria uma matriz temporária que contém duas <xref:System.Type> objetos representando `int` (`Integer` no Visual Basic).  
  
> [!NOTE]
>  Para ser preciso, a matriz contém duas referências à instância do <xref:System.Type> que representa `int` no domínio do aplicativo atual. Para qualquer tipo, há apenas uma instância de <xref:System.Type> por domínio de aplicativo.  
  
 O exemplo de código usa o <xref:System.Reflection.MethodInfo> para chamar o <xref:System.String.Substring%2A> método na cadeia de caracteres "Olá, mundo!" e exibe o resultado.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Ao herdar de <see langword="Type" />, você deve substituir os seguintes membros:  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é invocado por classes derivadas durante a construção de objetos de tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo é declarado. Para tipos genéricos, obtém o <see cref="T:System.Reflection.Assembly" /> no qual o tipo genérico é definido.</summary>
        <value>Uma instância de <see cref="T:System.Reflection.Assembly" /> que descreve o assembly que contém o tipo atual. Para tipos genéricos, a instância descreve o assembly que contém a definição de tipo genérico, não o assembly que cria e usa um tipo construído específico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> objeto representa um tipo genérico construído, essa propriedade retorna o assembly que contém a definição de tipo genérico. Por exemplo, suponha que você cria um assembly chamado MyGenerics.dll que contém a definição de tipo genérico `MyGenericStack<T>` (`MyGenericStack(Of T)` no Visual Basic, `generic<T> ref class MyGenericStack` em C++). Se você criar uma instância de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` no Visual Basic) em outro assembly, o <xref:System.Type.Assembly%2A> propriedade para o tipo construído retorna um <xref:System.Reflection.Assembly> objeto que representa o MyGenerics.dll.  
  
 Da mesma forma, se o atual <xref:System.Type> objeto representa um parâmetro genérico não atribuído `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.  
  
 Se o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade não está disponível em uma implementação específica do .NET, como .NET Core ou a plataforma Universal do Windows, use o <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propriedade em vez disso.      
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do tipo qualificado pelo assembly, que inclui o nome do assembly do qual este objeto <see cref="T:System.Type" /> foi carregado.</summary>
        <value>O nome qualificado pelo assembly do <see cref="T:System.Type" />, que inclui o nome do assembly do qual o <see cref="T:System.Type" /> foi carregado, ou <see langword="null" /> se a instância atual representa um parâmetro de tipo genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome qualificado do assembly de um tipo consiste do nome do tipo, incluindo o namespace, seguido por uma vírgula, seguida do nome de exibição do assembly. O nome de exibição de um assembly é obtido por meio de <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 O nome simples de uma classe aninhada emissão de todos os compiladores que dão suporte a common language runtime e reflexão constrói um nome danificado quando consultada, de acordo com as convenções a seguir.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Colchetes ([])|Depois de um nome de tipo denota uma matriz de tipo.<br /><br /> -ou-<br /><br /> Para um tipo genérico, inclui a lista de argumentos de tipo genérico.<br /><br /> -ou-<br /><br /> Dentro de uma lista de argumentos de tipo inclui um tipo qualificado por assembly.|  
  
 Por exemplo, o nome qualificado de assembly para uma classe pode ser assim:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Se o espaço para nome continha um sinal de adição, por exemplo TopNamespace.Sub+Namespace, em seguida, o sinal de adição (+) deve ser precedido por um caractere de escape (\\) para impedir que ele seja interpretado como um separador de aninhamento. Seria emissão de reflexão essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 Argumentos genéricos de tipos genéricos são qualificado pelo nome do assembly. Por exemplo, no nome do tipo qualificado por assembly de `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic), `int` é expandido para o nome de tipo qualificado de assembly para <xref:System.Int32>.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome do assembly associado à classe e o nome totalmente qualificado do tipo.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pelo <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os atributos associados ao <see cref="T:System.Type" />.</summary>
        <value>Um objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa o conjunto de atributos do <see cref="T:System.Type" />, a menos que <see cref="T:System.Type" /> represente um parâmetro de tipo genérico; nesse caso, o valor não é especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns membros do <xref:System.Reflection.TypeAttributes> enumeração são máscaras que representam um grupo de valores. Cada grupo inclui um membro cujo valor subjacente for zero. Por exemplo, o valor subjacente do <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> membro no <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> grupo for zero, como o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> membro no <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> grupo. Por isso, você deve usar a máscara antes de testar para esses valores. O exemplo fornece uma ilustração.  
  
> [!TIP]
>  Para a maioria das finalidades, como propriedades <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, e <xref:System.Type.IsSpecialName%2A> são mais fáceis de usar do que os atributos de tipo.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna os atributos da definição de tipo genérico. Por exemplo, os atributos retornados para `MyGenericClass<int>` (`MyGenericClass(Of Integer)` no Visual Basic) são os atributos de `MyGenericClass<T>` (`MyGenericClass(Of T)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico — ou seja, se o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` — o <xref:System.Reflection.TypeAttributes> valor retornado por essa propriedade não for especificado.  
  
   
  
## Examples  
 A seguir usesthe exemplo <xref:System.Type.Attributes%2A> propriedade.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do qual o <see cref="T:System.Type" /> atual é herdado diretamente.</summary>
        <value>O <see cref="T:System.Type" /> do qual o <see cref="T:System.Type" /> atual é herdado diretamente ou <see langword="null" /> se o <see langword="Type" /> atual representar a classe <see cref="T:System.Object" /> ou uma interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo base é o tipo do qual o tipo atual herda diretamente. <xref:System.Object>é o único tipo que não tem um tipo base, portanto `null` é retornado como o tipo base do <xref:System.Object>.  
  
 Interfaces herdam a zero ou mais interfaces base; Portanto, essa propriedade retorna `null` se o `Type` objeto representa uma interface. As interfaces base podem ser determinadas com <xref:System.Type.GetInterfaces%2A> ou <xref:System.Type.FindInterfaces%2A>.  
  
 Se o atual <xref:System.Type> representa um genérico construído de tipo, o tipo base reflete os argumentos genéricos. Por exemplo, considere as declarações a seguir:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Para o tipo construído `C<int>` (`C(Of Integer)` no Visual Basic), o <xref:System.Type.BaseType%2A> propriedade retorna `B<int>`.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de uma definição de tipo genérico, <xref:System.Type.BaseType%2A> retorna a restrição de classe, isto é, a classe que o parâmetro de tipo deve ser herdada. Se não houver nenhuma restrição de classe, <xref:System.Type.BaseType%2A> retorna <xref:System.Object?displayProperty=nameWithType>.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Type.BaseType%2A> propriedade.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 O exemplo a seguir usa a recursão para listar a hierarquia de herança completa de cada classe encontrado em um assembly. O exemplo define uma classe denominada `C` que deriva de uma classe denominada `B`, que, por sua vez, deriva de uma classe denominada `A`.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto <see cref="T:System.Type" /> atual tem parâmetros de tipo que não foram substituídos por tipos específicos.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> objeto é um parâmetro de tipo genérico ou tem parâmetros de tipo para os quais tipos específicos não foram fornecidos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um tipo, não deve haver nenhuma definição de tipo genérico ou tipos construídos abertos nos argumentos de tipo do tipo, em qualquer delimitadores tipos genéricos ou em todos os elementos do tipo. Outra forma de dizer isso é que, quando examinados recursivamente, o tipo não deve conter nenhum parâmetro de tipo genérico.  
  
 Como tipos podem ser arbitrariamente complexos, é difícil fazer essa determinação. Para conveniência e reduzir a chance de erro, o <xref:System.Type.ContainsGenericParameters%2A> propriedade fornece uma maneira padrão para distinguir entre tipos construídos fechados, que podem ser instanciados e aberta construída tipos, que não é possível. Se o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`, o tipo não pode ser instanciado.  
  
 O <xref:System.Type.ContainsGenericParameters%2A> propriedade pesquisa recursivamente para parâmetros de tipo. Por exemplo, ele retorna `true` para uma matriz cujos elementos são tipo `A<T>` (`A(Of T)` no Visual Basic), mesmo que a matriz propriamente dito não é genérico. Compare isso com o comportamento do <xref:System.Type.IsGenericType%2A> propriedade, que retorna `false` para matrizes.  
  
 Para um conjunto de classes de exemplo e uma tabela que mostra os valores de <xref:System.Type.ContainsGenericParameters%2A> propriedade, consulte <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e, em seguida, define uma classe genérica segundo que deriva da classe primeiro. Classe base a classe derivada da tem dois argumentos de tipo: a primeira é <xref:System.Int32> e o segundo é um parâmetro de tipo do tipo derivado. O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo, se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico.</summary>
        <value>Se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo de um método genérico, um <see cref="T:System.Reflection.MethodBase" /> que representa o método declarativo; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de declaração é uma definição de método genérico. Ou seja, se <xref:System.Type.DeclaringMethod%2A> não retorna `null`, em seguida, `DeclaringMethod.IsGenericMethodDefinition` retorna `true`.  
  
 O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico em que o parâmetro de tipo genérico foi definido originalmente:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo de que a definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, o <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> objeto que representa uma definição de tipo genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de tipo genérico.  
  
-   Obtendo o <xref:System.Type.DeclaringMethod%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Reflection.MethodBase> que é retornado pelo <xref:System.Type.DeclaringMethod%2A> propriedade é um <xref:System.Reflection.MethodInfo> no caso de um método genérico, ou um <xref:System.Reflection.ConstructorInfo> no caso de um construtor genérico.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, não há suporte para construtores genéricos.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define uma classe que tem um método genérico, atribui um argumento de tipo para o método e invoca o método genérico de construído resultante. Ele também exibe informações sobre a definição de método genérico e o método construído. Ao exibir informações sobre os parâmetros de tipo da definição de método genérico no `DisplayGenericMethodInfo` método, o código de exemplo mostra o valor da <xref:System.Type.DeclaringMethod%2A> propriedade para o parâmetro de tipo genérico do método.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo que declara o tipo aninhado atual ou o parâmetro de tipo genérico.</summary>
        <value>Um objeto <see cref="T:System.Type" /> que representará o tipo de delimitador se o tipo atual for um tipo aninhado, a definição de tipo genérico se o tipo atual for um parâmetro de tipo de um tipo genérico ou o tipo que declara o método genérico se o tipo atual for um parâmetro de tipo de um método genérico. Caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico, essa propriedade retorna a definição de tipo genérico.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro de tipo de um método genérico, essa propriedade retorna o tipo que contém a definição de método genérico. Se o tipo for genérico, a definição de tipo genérico é retornada. Ou seja, o código a seguir retorna a definição de tipo genérico de <xref:System.Collections.Generic.List%601> classe genérica, que contém o <xref:System.Collections.Generic.List%601.ConvertAll%2A> método genérico:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, o <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo genérico ou definição de método genérico em que o parâmetro de tipo genérico foi definido originalmente:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo de que a definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, o <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> objeto que representa uma definição de tipo genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de tipo genérico.  
  
-   Obtendo o <xref:System.Type.DeclaringType%2A> propriedade em um tipo cujo <xref:System.Type.IsGenericParameter%2A> é de propriedade `false` lança um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 Este exemplo exibe o tipo de declaração de um método em uma classe derivada.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao associador padrão, que implementa regras internas para selecionar os membros adequados a serem chamados por <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</summary>
        <value>Uma referência ao associador padrão usado pelo sistema.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O associador padrão fornecido com o common language runtime é aplicável em todas, exceto as circunstâncias mais especializadas. Se você precisar de um associador de definir regras de maneira que diferem do fichário padrão fornecido, um tipo derivado de <xref:System.Reflection.Binder> classe e passar uma instância do que o uso de tipo o `binder` parâmetro de um do <xref:System.Type.InvokeMember%2A> sobrecargas.  
  
 Reflexão de modelos de regras de acessibilidade do sistema de tipo comum. Por exemplo, se o chamador estiver no mesmo assembly, o chamador não precisa de permissões especiais para membros internos. Caso contrário, o chamador precisa <xref:System.Security.Permissions.ReflectionPermission>. Isso é consistente com a pesquisa de membros que são protegidas, privadas e assim por diante.  
  
 O princípio geral é que <xref:System.Reflection.Binder.ChangeType%2A> devem ser executadas somente conversões, que nunca perderem dados de ampliação. Um exemplo de uma conversão de ampliação é converter um valor que é um inteiro assinado de 32 bits para um valor que é um inteiro assinado de 64 bits. Isso é diferenciado de uma conversão de restrição, o que pode perder dados. Um exemplo de uma conversão de restrição é converter um inteiro assinado de 64 bits em um inteiro assinado de 32 bits.  
  
 A tabela a seguir lista as conversões com suporte do fichário de padrão.  
  
|Tipo de fonte|Tipo de destino|  
|-----------------|-----------------|  
|Qualquer tipo|Seu tipo base.|  
|Qualquer tipo|A interface que ele implementa.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single e Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single e Double|  
|Int16|Int32, Int64, Single e Double|  
|UInt32|UInt64, Int64, Single e Double|  
|Int32|Int64, Single e Double|  
|UInt64|Single e Double|  
|Int64|Single e Double|  
|Simples|Duplo|  
|Não referência|Por referência.|  
  
   
  
## Examples  
 O exemplo a seguir obtém o associador de padrão da `DefaultBinder` propriedade e invoca um membro de MyClass passando o `DefaultBinder` valor como um parâmetro para <xref:System.Type.InvokeMember%2A>.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Separa nomes no namespace de <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa uma matriz vazia do tipo <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código mostra o `EmptyTypes` campo usado em uma da `GetConstructor` métodos para obter um construtor sem parâmetros.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />. Para a comparação seja bem-sucedida, <c>o</c> devem poder ser convertido ou convertido em um objeto do tipo <see cref="T:System.Type" />.</param>
        <summary>Determina se o tipo de sistema subjacente do objeto <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Object" /> especificado.</summary>
        <returns>
          <see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />. Esse método sempre retorna <see langword="false" /> se: .  
  
-   <paramref name="o" /> é <see langword="null" />.  
  
-   <paramref name="o" /> não pode ser convertido em um objeto <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Ele projeta `o` para um objeto do tipo <xref:System.Type> e chama o <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Type.Equals%28System.Object%29> para comparar vários <xref:System.Type> objeto instâncias com vários <xref:System.Object> instâncias.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Duas coisas são particularmente importante a observar sobre o exemplo:  
  
-   A comparação de um <xref:System.Type> objeto que representa um inteiro com um <xref:System.Reflection.TypeInfo> objeto que representa um inteiro retorno `true` porque <xref:System.Reflection.TypeInfo> é derivado de <xref:System.Type>.  
  
-   A comparação de um <xref:System.Type> objeto que representa um <xref:System.Collections.Generic.IList%601> objeto (um tipo genérico aberto) com um `List(Of String)` retorna o objeto (um tipo genérico fechado) `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cujo tipo subjacente do sistema a ser comparado com o tipo de sistema subjacente do atual <see cref="T:System.Type" />.</param>
        <summary>Determina se o tipo de sistema subjacente do <see cref="T:System.Type" /> atual é o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> especificado.</summary>
        <returns>
          <see langword="true" /> se o tipo de sistema subjacente do <paramref name="o" /> for o mesmo que o tipo de sistema subjacente do <see cref="T:System.Type" /> atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa `Equals` para comparar dois tipos.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro usado em atributos. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência para o representante usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por este delegado usa dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` pode ser atribuído o valor de qualquer um dos campos nas classes de <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, ou <xref:System.Reflection.MethodImplAttributes>.  
  
 Por exemplo, o `Object` pode ser atribuído o valor de um campo de `FieldAttributes` como público. Nesse caso, quando o `FilterAttribute` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto está decorado com o atributo de campo público nos metadados.  
  
   
  
## Examples  
 O exemplo a seguir obtém o `FilterAttribute` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os membros especificados e seus atributos.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro diferencia maiusculas e minúsculas usado nos nomes. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência para o representante usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por este delegado usa dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "*" curinga. Correspondência de cadeia de caracteres de final de curinga somente tem suporte.  
  
 Por exemplo, o `Object` pode ser atribuído o valor "Bytes *". Nesse caso, quando o `FilterName` delegado é invocado, ele retornará `true` somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "Bytes".  
  
   
  
## Examples  
 O exemplo de código a seguir obtém os métodos associados definido pelo usuário `Application` tipo.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o filtro de membro de maiusculas e minúsculas usado nos nomes. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo contém uma referência para o representante usado pelo <xref:System.Type.FindMembers%2A> método. O método encapsulado por este delegado usa dois parâmetros: a primeira é uma <xref:System.Reflection.MemberInfo> objeto e o segundo é um `Object`. O método determina se o `MemberInfo` objeto corresponde aos critérios especificados pelo `Object`. O `Object` é atribuído um valor de cadeia de caracteres, que pode incluir à direita "*" curinga. Correspondência de cadeia de caracteres de final de curinga somente tem suporte.  
  
 Por exemplo, o `Object` pode ser atribuído o valor "Bytes *". Nesse caso, quando o `FilterName` delegado é invocado, ele retornará true somente se o método representado pelo `MemberInfo` objeto tem um nome que começa com "bytes", ignorando maiusculas e minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir obtém o `MemberFilter` representante, passa-o como um parâmetro para o <xref:System.Type.FindMembers%2A> método e exibe os métodos e seus atributos do `String` classe que começam com a letra "c", desconsiderando o caso.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">O representante que compara as interfaces contra <c>filterCriteria</c>.</param>
        <param name="filterCriteria">Os critérios de pesquisa que determinam se uma interface deve ser incluída na matriz retornada.</param>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representa uma lista filtrada das interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de <see cref="T:System.Type" /> objetos que representam uma lista filtrada de interfaces implementada ou herdada por atual <see cref="T:System.Type" />, ou uma matriz vazia do tipo <see cref="T:System.Type" /> se interfaces não corresponde ao filtro é implementado ou herdado por atual<see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 O <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> e <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegados fornecidos pelo <xref:System.Reflection.Module?displayProperty=nameWithType> classe também pode ser usada, substitui o <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.  
  
 Todas as interfaces implementadas por esta classe são consideradas durante a pesquisa se declarado por uma classe base ou essa classe em si.  
  
 Esse método de pesquisa a hierarquia de classe base, retornando cada uma das interfaces correspondentes cada classe implementa, bem como todos os a correspondência interfaces cada implementa essas interfaces (isto é, o fechamento transitivo das interfaces correspondentes é retornado). Interfaces não duplicado será retornado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, <xref:System.Type.FindInterfaces%2A> pesquisas de todas as interfaces declaradas em restrições no parâmetro de tipo, e todas as interfaces herdadas por meio das interfaces declaradas nas restrições de. Se o atual <xref:System.Type> representa um argumento de tipo de um tipo genérico, <xref:System.Type.FindInterfaces%2A> pesquisa todas as interfaces implementadas pelo tipo, se eles corresponderem restrições ou não.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>pode retornar interfaces genéricas, mesmo em tipos que não são genéricos. Por exemplo, um tipo não genérico pode implementar `IEnumerable<int>` (`IEnumerable(Of Integer)` no Visual Basic).  
  
   
  
## Examples  
 O exemplo a seguir localiza a interface especificada implementada ou herdada por tipo especificado e, em seguida, exibe os nomes de interface.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador estático é invocado e lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">Um objeto que indica o tipo de membro a ser pesquisado.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="filter">O representante que faz as comparações, retornando <see langword="true" /> se o membro atualmente sendo inspecionados correspondências a <c>filterCriteria</c> e <see langword="false" /> caso contrário. Use os delegados <see langword="FilterAttribute" />, <see langword="FilterName" /> e <see langword="FilterNameIgnoreCase" /> fornecidos por essa classe. O primeiro usa os campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, e <see langword="MethodImplAttributes" /> como critérios de pesquisa e usam os dois delegados <see langword="String" /> objetos como critério de pesquisa.</param>
        <param name="filterCriteria">Os critérios de pesquisa que determina se um membro é retornado na matriz de <see langword="MemberInfo" /> objetos.  
  
 Os campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, e <see langword="MethodImplAttributes" /> pode ser usado em conjunto com o <see langword="FilterAttribute" /> representante fornecido por esta classe.</param>
        <summary>Retorna uma matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> do tipo do membro especificado.</summary>
        <returns>Um conjunto filtrado de <see cref="T:System.Reflection.MemberInfo" /> objetos do tipo de membro especificado.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros do tipo <paramref name="memberType" /> que correspondem aos critérios de filtro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Instance` para incluir membros de instância na pesquisa.  
  
-   Especifique `BindingFlags.Static` para incluir membros estáticos na pesquisa.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Os valores válidos para <xref:System.Type.MemberType%2A> são definidos em <xref:System.Reflection.MemberInfo>. Se esses membros não for encontrados, uma matriz vazia será retornada.  
  
 Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico ou método genérico, <xref:System.Type.FindMembers%2A> processa todos os membros declarados, a restrição de classe e as restrições de interface do parâmetro de tipo.  
  
   
  
## Examples  
 O exemplo a seguir localiza todos os membros em uma classe que correspondem aos critérios de pesquisa especificados e, em seguida, exibe os membros correspondentes.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filter" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly.</summary>
        <value>O nome totalmente qualificado do tipo, incluindo o namespace, mas não o assembly; ou <see langword="null" />, se a instância atual representar um parâmetro de tipo genérico, um tipo de matriz, um tipo de ponteiro ou um tipo <see langword="byref" /> baseado em um parâmetro de tipo, ou um tipo genérico que não é uma definição de tipo genérica, mas que contém parâmetros de tipo não resolvidos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, o nome totalmente qualificado do <xref:System.String> é do tipo `System.String`. Compare isso com o nome qualificado de assembly retornado pelo <xref:System.Type.AssemblyQualifiedName%2A> propriedade, que consiste do nome completo e o nome completo do assembly.  
  
 Se o tipo atual representa um tipo genérico fechado, os argumentos de tipo na cadeia de caracteres retornada pelo <xref:System.Type.FullName%2A> propriedade são qualificados pelo nome de assembly completo, mesmo que a representação de cadeia de caracteres do tipo genérico em si não está qualificada pelo seu completo nome do assembly. O exemplo a seguir ilustra a diferença na propriedade FullName para um tipo que representa a definição de tipo genérico e um que representa um tipo genérico fechado.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Essa propriedade retorna `null` se:  
  
-   Atual <xref:System.Type> objeto representa um parâmetro de tipo de um tipo genérico.  
  
     O exemplo a seguir recupera o parâmetro de tipo de <xref:System.Nullable%601> tipo e tenta exibir seu <xref:System.Type.FullName%2A> propriedade.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Atual <xref:System.Type> objeto representa um tipo de matriz, um tipo de ponteiro ou um `byref` tipo com base em um parâmetro de tipo genérico.  
  
     O exemplo a seguir define um tipo genérico, `Generictype1<T>`, com três métodos: `Display(T[])`, que é passado a uma matriz do tipo T; `HandleT(T)`, que é passado um objeto T; e `ChangeValue(ref T)`, que é passado um objeto T por referência. C# e Visual Basic não permitem definir T como um ponteiro no `HandleT` método, é necessário chamar o <xref:System.Type.MakePointerType%2A> método no <xref:System.Type> objeto que representa o tipo de parâmetro do método para criar um ponteiro para um tipo genérico. A saída do exemplo mostra que em todos os três casos, o <xref:System.Type.FullName%2A> é de propriedade `null`.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   O tipo atual contém parâmetros de tipo genérico que não foram substituídos por tipos específicos (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`), mas o tipo não é uma definição de tipo genérico (ou seja, o <xref:System.Type.IsGenericTypeDefinition%2A> retorna de propriedade`false`  
  
     No exemplo a seguir, `Derived<T>` herda de `Base<T>`. O <xref:System.Type.BaseType%2A> propriedade obtém o <xref:System.Type> objeto que representa o tipo base de `Derived<T>`e sua <xref:System.Type.FullName%2A> propriedade retorna `null`.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Para obter um <xref:System.Type.FullName%2A> não `null`, você pode usar o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter a definição de tipo genérico, como mostra o exemplo.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome completo do tipo especificado.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pelo <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma combinação de <see cref="T:System.Reflection.GenericParameterAttributes" /> sinalizadores que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</summary>
        <value>Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa propriedade contém os sinalizadores que descrevem se o parâmetro de tipo genérico atual é covariante e sinalizadores que descrevem quaisquer restrições especiais. Use o <xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType> valor para selecionar os sinalizadores de covariância e usar o <xref:System.Reflection.GenericParameterAttributes?displayProperty=nameWithType> valor para selecionar os sinalizadores de restrição.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo com restrições diferentes. Quando o programa é executado, as restrições são examinadas usando o <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Atual <see cref="T:System.Type" /> objeto não é um parâmetro de tipo genérico. Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a posição do parâmetro de tipo na lista de parâmetros de tipo do tipo genérico ou método que declarado do parâmetro, quando o <see cref="T:System.Type" /> objeto representa um parâmetro de tipo de um tipo genérico ou método genérico.</summary>
        <value>A posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico ou método que define o parâmetro. Números de posição começam em 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GenericParameterPosition%2A> propriedade retorna a posição de um parâmetro de tipo na lista de parâmetros da definição de tipo genérico ou definição de método genérico em que o parâmetro de tipo foi definido originalmente. O <xref:System.Type.DeclaringType%2A> e <xref:System.Type.DeclaringMethod%2A> propriedades identificam a definição de tipo ou método genérica:  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna um <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa uma definição de método genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo de que a definição de método genérico.  
  
-   Se o <xref:System.Type.DeclaringMethod%2A> propriedade retorna `null`, em seguida, o <xref:System.Type.DeclaringType%2A> propriedade sempre retorna um <xref:System.Type> objeto que representa uma definição de tipo genérico e atual <xref:System.Type> objeto representa um parâmetro de tipo dessa definição de tipo genérico.  
  
 Para fornecer o contexto correto para o valor da <xref:System.Type.GenericParameterPosition%2A> propriedade, é necessário identificar o tipo genérico ou método um parâmetro de tipo pertence. Por exemplo, considere o valor de retorno do método genérico `GetSomething` no código a seguir:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 O tipo retornado por `GetSomething` depende dos argumentos de tipo fornecidos a classe `A` e `GetSomething` em si. Você pode obter um <xref:System.Reflection.MethodInfo> para `GetSomething`, e que você pode obter o tipo de retorno. Quando você examinar os parâmetros de tipo do tipo de retorno, <xref:System.Type.GenericParameterPosition%2A> retorna 0 para ambos. A posição do `V` é 0 porque `V` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para a classe `A`. A posição do `X` é 0 porque `X` é o primeiro parâmetro de tipo na lista de parâmetros de tipo para `GetSomething`.  
  
> [!NOTE]
>  Chamando o <xref:System.Type.GenericParameterPosition%2A> propriedade gera uma exceção se o atual <xref:System.Type> não representa um parâmetro de tipo. Quando você examinar os argumentos de tipo de um tipo construído aberto, use o <xref:System.Type.IsGenericParameter%2A> propriedade dizer que são parâmetros de tipo e tipos. O <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para um parâmetro de tipo; em seguida, você pode usar o <xref:System.Type.GenericParameterPosition%2A> método obter sua posição e usar o <xref:System.Type.DeclaringMethod%2A> e <xref:System.Type.DeclaringType%2A> propriedades para determinar o método genérico ou digite definição que o define.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe genérica com dois parâmetros de tipo e define uma classe genérica segundo que deriva da classe primeiro. Classe base a classe derivada da tem dois argumentos de tipo: a primeira é <xref:System.Int32>, e o segundo é um parâmetro de tipo do tipo derivado. O exemplo exibe informações sobre essas classes genéricas, incluindo as posições relatados pelo <xref:System.Type.GenericParameterPosition%2A> propriedade.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não representa um parâmetro de tipo. Ou seja, <see cref="P:System.Type.IsGenericParameter" /> retorna <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma matriz dos argumentos de tipo genérico para esse tipo.</summary>
        <value>Uma matriz dos argumentos de tipo genérico para esse tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade obtém apenas os argumentos de tipo genérico; ou seja, os tipos que foram especificados para os parâmetros de tipo genérico do tipo atual. Se o tipo atual é uma definição de tipo genérico, essa propriedade retorna uma matriz vazia.  
  
> [!NOTE]
>  Se um tipo genérico é usado em um método genérico ou em outro tipo genérico, alguns dos seus argumentos de tipo genérico podem ser parâmetros de tipo genérico do método ou tipo de delimitador.  
  
 Para obter os parâmetros de tipo genérico de um tipo que representa uma definição de tipo genérico, use o <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propriedade. Para obter um <xref:System.Reflection.TypeInfo> objeto atual <xref:System.Type> de objeto, use o <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> método de extensão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o número de dimensões em uma matriz.</summary>
        <returns>Um inteiro que contém o número de dimensões no tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o número de dimensões em uma matriz.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a funcionalidade desse método na classe base. Em vez disso, ela deve ser implementada em uma classe derivada.</exception>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma matriz.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.Attributes" /> propriedade e obtém um bitmask que indica os atributos associado a <see cref="T:System.Type" />.</summary>
        <returns>Um <see cref="T:System.Reflection.TypeAttributes" /> objeto que representa o conjunto de atributos do <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o construtor desejado.  
  
 -ou-  
  
 Uma matriz vazia de <see cref="T:System.Type" /> objetos, para obter um construtor sem parâmetros. Tal uma matriz vazia é fornecida pelo <see langword="static" /> campo <see cref="F:System.Type.EmptyTypes" />.</param>
        <summary>Pesquisa um construtor de instância pública cujos parâmetros correspondem aos tipos na matriz especificada.</summary>
        <returns>Um objeto que representa o construtor de instância pública cujos parâmetros correspondem aos tipos na matriz de parâmetros de tipo, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método procura construtores de instância pública e não pode ser usada para obter um inicializador de classe (. cctor). Para obter um inicializador de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o construtor solicitado é não-públicos, este método retorna `null`.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, esse método sempre retornará `null`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo de `MyClass`, obtém o <xref:System.Reflection.ConstructorInfo> objeto e, em seguida, exibe a assinatura de construtor.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Uma matriz de <see cref="T:System.Type" /> objetos que representam o número, ordem e tipo dos parâmetros para o construtor para obter.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.  
  
 -ou-  
  
 <see cref="F:System.Type.EmptyTypes" />.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente na matriz de tipo de parâmetro. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um <see cref="T:System.Reflection.ConstructorInfo" /> objeto que representa o construtor que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, esse método sempre retornará `null`.  
  
   
  
## Examples  
 O programa a seguir obtém o tipo de `MyClass1` classe, obtém o <xref:System.Reflection.ConstructorInfo> objeto correspondência os sinalizadores de associação especificado e exibe a assinatura do construtor.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a serem usadas em relação a ordem e o layout de argumentos, como o valor de retorno for passado, quais registros são usados para argumentos e a pilha é limpa.</param>
        <param name="types">Uma matriz de <see cref="T:System.Type" /> objetos que representam o número, ordem e tipo dos parâmetros para o construtor para obter.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa por um construtor cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o construtor que corresponde aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando esse método, você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.ConstructorInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, esse método sempre retornará `null`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo de `MyClass1`, obtém o <xref:System.Reflection.ConstructorInfo> objeto que coincide com os sinalizadores de associação especificado e exibe a assinatura de construtor.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a serem usadas em relação a ordem e o layout de argumentos, como o valor de retorno for passado, quais registros são usados para argumentos e a pilha é limpa.</param>
        <param name="types">Uma matriz de <see cref="T:System.Type" /> objetos que representam o número, ordem e tipo dos parâmetros para o construtor para obter.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, Type[] types = new Type[0]) para obter um construtor sem parâmetros.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, procura um construtor cujos parâmetros correspondem a tipos de argumento especificados e os modificadores, usando as restrições de associação especificada e a convenção de chamada especificada.</summary>
        <returns>Um <see cref="T:System.Reflection.ConstructorInfo" /> objeto que representa o construtor que corresponde aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Esse método implementa <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os construtores públicos definidos para o <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa todos os construtores de instância pública definidos para o <see cref="T:System.Type" /> atual, mas não incluindo o inicializador de tipo (construtor estático). Se nenhum construtor de instância pública for definido para o <see cref="T:System.Type" /> atual ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo ou método genérico, uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração. Seu código deve não dependam da ordem em que os construtores são retornados, porque que varia de ordem.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Essa sobrecarga de método chama o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga de método com <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Ele não localizará inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.  
  
   
  
## Examples  
 Este exemplo mostra a saída de <xref:System.Type.GetConstructors%2A> sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 A saída desse código é:  
  
 2  
  
 False  
  
 False  
  
 Porque o <xref:System.Type.GetConstructors> usa apenas a sobrecarga <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, o construtor estático não é contado pelo `for` expressão nem avaliadas pelo `IsStatic`.  
  
 Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarregar e passar a combinação (lógico `OR`) de <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Agora, o resultado é:  
  
 3  
  
 False  
  
 verdadeiro  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa os construtores definidos para o <see cref="T:System.Type" /> atual usando os <see langword="BindingFlags" /> especificados.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representam todos os construtores definidos para o atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificado, incluindo o inicializador de tipo, se ele está definido. Retorna uma matriz vazia do tipo <see cref="T:System.Reflection.ConstructorInfo" /> se nenhum construtor estiver definido para o <see cref="T:System.Type" /> atual, se nenhum dos construtores definidos corresponderem às restrições de associação ou se o <see cref="T:System.Type" /> atual representar um parâmetro de tipo na definição de um tipo genérico ou método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetConstructors%2A> método não retorna construtores em uma ordem específica, como ordem de declaração. Seu código deve não dependam da ordem em que os construtores são retornados, porque que varia de ordem.  
  
 `bindingAttr`pode ser usado para especificar se deve retornar apenas os construtores públicos ou construtores públicos e não público.  
  
 Se uma correspondência exata não existir, o `binder` tentará forçar os tipos de parâmetro especificados na matriz `types` para selecionar uma correspondência. Se o `binder` não for capaz de selecionar uma correspondência, `null` será retornado.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais construtores devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir construtores públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir construtores não públicos (ou seja, construtores particulares, internos e protegidos) na pesquisa. Construtores de classes base não são retornados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.ConstructorInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem um construtor `C(T t1)` (`Sub New(ByVal t1 As T)` no Visual Basic), chamar <xref:System.Type.GetConstructors%2A> na `C<int>` retorna um <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` em c# (`Sub New(ByVal t1 As Integer)` no Visual Basic).  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo genérico, o <xref:System.Type.GetConstructors%2A> método retorna uma matriz vazia.  
  
   
  
## Examples  
 Este exemplo mostra a saída de <xref:System.Type.GetConstructors> sobrecarga de uma classe que tem dois construtores de instância e um construtor estático.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 A saída desse código é:  
  
 2  
  
 False  
  
 False  
  
 Porque o <xref:System.Type.GetConstructors%2A> usa apenas a sobrecarga <xref:System.Reflection.BindingFlags.Public> e <xref:System.Reflection.BindingFlags.Instance>, o construtor estático não é contado pelo `for` expressão nem avaliadas pelo `IsStatic`.  
  
 Para localizar os construtores estáticos, use o <xref:System.Type.GetConstructors%2A> sobrecarga e passe a combinação (OR lógico) de <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>, conforme mostrado no exemplo de código a seguir:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Agora, o resultado é:  
  
 3  
  
 False  
  
 verdadeiro  
  
 False  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Procura membros definidos atual <see cref="T:System.Type" /> cujo <see cref="T:System.Reflection.DefaultMemberAttribute" /> está definido.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam todos os membros padrão atual <see cref="T:System.Type" />.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o atual <see cref="T:System.Type" /> não tem membros padrão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetDefaultMembers%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado. Por exemplo, se classe `C<T>` tem uma propriedade `P` que retorna `T`, chamar <xref:System.Type.GetDefaultMembers%2A> na `C<int>` retorna `int P` em c# (`Property P As Integer` no Visual Basic).  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém as informações do membro padrão de `MyClass` e exibe os membros padrão.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna o <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de matriz, ponteiro ou tipo de referência.</summary>
        <returns>O <see cref="T:System.Type" /> do objeto englobado ou referenciado pelo tipo de referência, ponteiro ou matriz atual ou <see langword="null" /> se <see cref="T:System.Type" /> atual não é uma matriz ou um ponteiro ou não é passado por referência ou representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna `null` para o <xref:System.Array> classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `GetElementType` método.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujo nome a ser recuperado.</param>
        <summary>Retorna o nome da constante que tem o valor especificado para o tipo de enumeração atual.</summary>
        <returns>O nome do membro do tipo de enumeração atual que tem o valor especificado, ou <see langword="null" /> se tal constante não for encontrado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.  
  
 -ou-  
  
 <paramref name="value" />não é nem o tipo atual nem tem o mesmo tipo subjacente com a atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os nomes dos membros do tipo de enumeração atual.</summary>
        <returns>Uma matriz que contém os nomes dos membros da enumeração.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz de valores de retorno são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes enumeradas. Se a matriz contém constantes enumeradas com o mesmo valor, a ordem de seus nomes correspondentes é especificada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o tipo subjacente do tipo de enumeração atual.</summary>
        <returns>O tipo subjacente da enumeração atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o tipo subjacente de uma enumeração em c# e Visual Basic é <xref:System.Int32>. Outros tipos de inteiro podem ser especificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.  
  
 -ou-  
  
 O tipo de enumeração não é válido, porque ela contém mais de um campo de instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de valores das constantes no tipo de enumeração especificado.</summary>
        <returns>Uma matriz que contém os valores. Os elementos da matriz são classificados pelos valores binários (ou seja, os valores sem sinal) das constantes de enumeração.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome de um evento que é declarado ou herdado pelo <see cref="T:System.Type" /> atual.</param>
        <summary>Retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento público especificado.</summary>
        <returns>O objeto que representa o evento público especificado que é declarado ou herdado por atual <see cref="T:System.Type" />, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado privado, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui eventos de instância pública estático e público.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.EventInfo> de objeto e obtém o evento para uma classe de botão para o evento especificado.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome de um evento declarado ou herdado pelo <see cref="T:System.Type" /> atual.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, retorna o objeto <see cref="T:System.Reflection.EventInfo" /> que representa o evento especificado, usando as restrições de associação especificadas.</summary>
        <returns>O objeto que representa o evento especificado que é declarado ou herdado por atual <see cref="T:System.Type" />, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir os eventos a serem incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos privados, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly`para pesquisar somente os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado privado, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.EventInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> método para pesquisar um tipo para um público ou não público evento chamado "Clique" que não seja `static` (`Shared` no Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representam todos os eventos públicos que são declarados ou herdados pelo <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o <see cref="T:System.Type" /> atual não tiver eventos públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado privado, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os eventos são retornados, porque que varia de ordem.  
  
 Este método pode ser substituído por uma classe derivada.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos, obtém todos os eventos para um `Button` classe e exibe os nomes de evento. Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, procura por eventos que são declarados ou herdados por atual <see cref="T:System.Type" />, usando as restrições de associação especificada.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.EventInfo" /> objetos que representam todos os eventos que são declarados ou herdados por atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.EventInfo" />, se o atual <see cref="T:System.Type" /> não tem eventos, ou se nenhum dos eventos corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetEvents%2A> método não retorna eventos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os eventos são retornados, porque que varia de ordem.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir os eventos a serem incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir eventos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir eventos de não-públicos (ou seja, eventos privados, internos e protegidos) na pesquisa. Protegido e eventos internos em classes base são retornados; eventos particulares em classes de base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly`para pesquisar somente os eventos declarados no <xref:System.Type>, não os eventos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um evento é considerado público para reflexão caso tenha pelo menos um método ou um acessador público. Caso contrário, o evento é considerado privado, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.EventInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os eventos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém uma matriz de <xref:System.Reflection.EventInfo> objetos que correspondem os sinalizadores de associação especificada, obtém todos os eventos para um `Button` classe e exibe os nomes de evento. Para compilar o exemplo do Visual Basic, use a seguinte linha de comando:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</param>
        <summary>Pesquisa o campo público com o nome especificado.</summary>
        <returns>Um objeto que representa o campo público com o nome especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui campos de instância pública estático e público.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém o `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo e exibe o valor do campo.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Este objeto <see cref="T:System.Type" /> é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> cujo <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método ainda não foi chamado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do campo de dados a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa o campo especificado usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o campo que corresponde aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos privados, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly`para pesquisar somente os campos declarados no <xref:System.Type>, não os campos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.FieldInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir obtém o `Type` de objeto para a classe especificada, obtém o <xref:System.Reflection.FieldInfo> objeto para o campo que coincide com os sinalizadores de associação especificado e exibe o valor do campo.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os campos públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos os campos públicos definidos para o <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo público for definido para o <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetFields%2A> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os campos são retornados, porque que varia de ordem.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso de `GetFields()` método.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa os campos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representam todos os campos definidos para a atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.FieldInfo" /> se nenhum campo estiver definido para o <see cref="T:System.Type" /> atual ou se nenhum dos campos definidos corresponderem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetFields%2A> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os campos são retornados, porque que varia de ordem.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir quais campos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir campos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir campos não públicos (ou seja, campos privados, internos e protegidos) na pesquisa. Protegido e campos internos em classes base são retornados; campos particulares em classes de base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly`para pesquisar somente os campos declarados no <xref:System.Type>, não os campos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.FieldInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa os campos públicos da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso de `GetFields(BindingFlags)` método.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico fechado ou os parâmetros de tipo de uma definição de tipo genérico.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um tipo genérico. Retorna uma matriz vazia se o tipo atual não é um tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz são retornados na ordem em que aparecem na lista de argumentos de tipo para o tipo genérico.  
  
-   Se o tipo atual é um tipo construído fechado (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `false`), a matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método contém os tipos que foram atribuídos a parâmetros de tipo genérico de definição de tipo genérico.  
  
-   Se o tipo atual é uma definição de tipo genérico, a matriz contém os parâmetros de tipo.  
  
-   Se o tipo atual é um tipo construído aberto (ou seja, o <xref:System.Type.ContainsGenericParameters%2A> propriedade retorna `true`) no qual tipos específicos não tiverem sido atribuídos a todos os parâmetros de tipo e os parâmetros de tipo de delimitador tipos ou métodos genéricos, a matriz contém tipos e tipo de parâmetros. Use o <xref:System.Type.IsGenericParameter%2A> propriedade distingui-los. Para ver uma demonstração desse cenário, consulte o exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetGenericArguments%2A> método para exibir os argumentos de tipo de um tipo construído e os parâmetros de tipo de sua definição de tipo genérico.  
  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade. Consulte o exemplo maior para a saída de exemplo.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam as restrições no parâmetro de tipo genérico atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada restrição em um parâmetro de tipo genérico é expresso como um <xref:System.Type> objeto. Use o <xref:System.Type.IsClass%2A> propriedade para determinar se uma restrição é a restrição de classe base; se a propriedade retornará `false`, a restrição é uma restrição de interface. Se um parâmetro de tipo sem restrição de classe e sem restrições de interface, uma matriz vazia será retornada.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir define um tipo genérico `Test` com dois parâmetros de tipo com restrições diferentes. Quando o programa é executado, as restrições são examinadas usando o <xref:System.Type.GenericParameterAttributes%2A> propriedade e o <xref:System.Type.GetGenericParameterConstraints%2A> método.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Atual <see cref="T:System.Type" /> objeto não é um parâmetro de tipo genérico. Ou seja, a propriedade <see cref="P:System.Type.IsGenericParameter" /> do método retorna <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma definição de tipo genérico do qual o tipo genérico atual pode ser criado.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa um tipo genérico do qual o tipo atual pode ser criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma definição de tipo genérico é um modelo do qual os outros tipos podem ser criados. Por exemplo, da definição de tipo genérico `G<T>` (expresso na sintaxe do c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode criar e instanciar o tipo `G<int>` (`G(Of Integer)` no Visual Basic). Dado um <xref:System.Type> construída de objeto que representa este tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna a definição de tipo genérico.  
  
 Se dois tipos construídos são criados da mesma definição de tipo genérico, usando os mesmos argumentos de tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método retorna o mesmo <xref:System.Type> objeto para os dois tipos.  
  
 Se você chamar o <xref:System.Type.GetGenericTypeDefinition%2A> método em um <xref:System.Type> objeto que já representa uma definição de tipo genérico, ele retorna atual <xref:System.Type>.  
  
> [!IMPORTANT]
>  Uma matriz de tipos genéricos propriamente dito não é genérico. No código do c# `A<int>[] v;` ou o código do Visual Basic `Dim v() As A(Of Integer)`, o tipo de variável `v` não é genérico. Use <xref:System.Type.IsGenericType%2A> para determinar se um tipo genérico antes de chamar <xref:System.Type.GetGenericTypeDefinition%2A>.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma instância de um tipo construído usando a criação de instância comum e, em seguida, usa o <xref:System.Type.GetType%2A> e <xref:System.Type.GetGenericTypeDefinition%2A> métodos para recuperar o tipo construído e a definição de tipo genérico. Este exemplo usa a <xref:System.Collections.Generic.Dictionary%602> tipo; o tipo construído representa um <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não é um tipo genérico.  Ou seja, <see cref="P:System.Type.IsGenericType" /> retorna <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>O código hash para essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir exibe o código hash de `System.Windows.Forms.Button` classe.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da interface a ser obtida. Para interfaces genéricas, este é o nome danificado.</param>
        <summary>Pesquisa a interface com o nome especificado.</summary>
        <returns>Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
> [!NOTE]
>  Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo. Isso é verdadeiro para definições de interface genérica e interfaces genéricas construídos. Por exemplo, para localizar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), procure ``"IExample`1"``.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%29> método para pesquisar o <xref:System.Collections.Hashtable> de classe para o <xref:System.Runtime.Serialization.IDeserializationCallback> interface e lista os métodos da interface.  
  
 O exemplo de código também demonstra o <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da interface a ser obtida. Para interfaces genéricas, este é o nome danificado.</param>
        <param name="ignoreCase">
          <see langword="true" />para ignorar o caso essa parte do <c>nome</c> que especifica o nome da interface simples (a parte que especifica o namespace deve ser corretamente maiusculas e minúsculas).  
  
 -ou-  
  
 <see langword="false" />para realizar uma pesquisa diferencia maiusculas de minúsculas para todas as partes do <c>nome</c>.</param>
        <summary>Quando substituído em uma classe derivada, procura pela interface especificada, indicando se deseja fazer uma pesquisa que não diferencia maiúsculas de minúsculas pelo nome da interface.</summary>
        <returns>Um objeto que representa a interface com o nome especificado, implementado ou herdado pelo <see cref="T:System.Type" /> atual, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ignoreCase` parâmetro aplica-se somente para o nome da interface simples, não para o namespace. A parte de `name` que especifica o namespace deve ter a capitalização correta ou a interface não será localizada. Por exemplo, a cadeia de caracteres "System. IComparable" localiza o <xref:System.IComparable> interface, mas a cadeia de caracteres "System. IComparable" não.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Type> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
> [!NOTE]
>  Para interfaces genéricas, o `name` parâmetro é o nome danificado, terminando com um acento grave (\`) e o número de parâmetros de tipo. Isso é verdadeiro para definições de interface genérica e interfaces genéricas construídos. Por exemplo, para localizar `IExample<T>` (`IExample(Of T)` no Visual Basic) ou `IExample<string>` (`IExample(Of String)` no Visual Basic), procure `"IExample`1"'.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> método para realizar uma pesquisa de maiusculas e minúsculas da <xref:System.Collections.Hashtable> de classe para o <xref:System.Collections.IEnumerable> interface.  
  
 O exemplo de código também demonstra o <xref:System.Type.GetInterface%28System.String%29> sobrecarga de método e o <xref:System.Type.GetInterfaceMap%2A> método.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">O <see cref="T:System.Type" /> atual representa um tipo que implementa a mesma interface genérica com argumentos de tipo diferente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">O tipo de interface para o qual um mapeamento será recuperado.</param>
        <summary>Retorna um mapeamento de interface para o tipo de interface especificado.</summary>
        <returns>Um objeto que representa o mapeamento de interface para <paramref name="interfaceType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mapa de interface indica como uma interface é mapeada para os membros reais em uma classe que implementa a interface.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, tipo de parâmetros são substituídos pelos argumentos nos elementos do tipo apropriado de <xref:System.Reflection.InterfaceMapping> retornado por esse método.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Type.GetInterfaceMap%2A> método para determinar como o <xref:System.IFormatProvider> interface é mapeado para <xref:System.Globalization.CultureInfo> métodos e como o <xref:System.IAppDomainSetup> interface é mapeado para <xref:System.AppDomainSetup> propriedades. Observe que, como o <xref:System.IAppDomainSetup> interface define um conjunto de propriedades, retornados <xref:System.Reflection.InterfaceMapping> objeto inclui separada <xref:System.Reflection.MethodInfo> objetos para get da propriedade e o conjunto de acessadores.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="interfaceType" /> não é implementado pelo tipo atual.  
  
 - ou -  
  
 O parâmetro <paramref name="interfaceType" /> não faz referência a uma interface.  
  
 -ou-  
  
 <paramref name="interfaceType" />é uma interface genérica, e o tipo atual é um tipo de matriz.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Atual <see cref="T:System.Type" /> representa um parâmetro de tipo genérico; ou seja, <see cref="P:System.Type.IsGenericParameter" /> é <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém todas as interfaces implementadas ou herdadas pelo <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa todas as interfaces implementadas ou herdadas pela <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhuma interface implementada ou herdada por atual <see cref="T:System.Type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetInterfaces%2A> método não retornam interfaces em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem em que as interfaces são retornadas, porque que varia de ordem.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Type> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as restrições de interface e de quaisquer interfaces herdadas de restrições de classe ou interface.  
  
   
  
## Examples  
 O exemplo a seguir obtém o tipo de classe especificado e exibe todas as interfaces que o tipo implementa ou herda. Para compilar o exemplo do Visual Basic, use os seguintes comandos do compilador:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador estático é invocado e lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros públicos a serem obtidos.</param>
        <summary>Pesquisa a propriedade pública com o nome especificado.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui membros de instância pública estático e público.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Essa sobrecarga de método não localizará inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os membros de `String` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar uma matriz vazia.</param>
        <summary>Pesquisa os membros especificados usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`. Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os membros estáticos públicos do `myString` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome dos membros a serem obtidos.</param>
        <param name="type">O valor a ser procurado.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar uma matriz vazia.</param>
        <summary>Localiza os membros especificados do tipo de membro especificado, usando as restrições de associação especificada.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos com o nome especificado, se encontrado; caso contrário, uma matriz vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMember%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar ". cctor" para `name`, <xref:System.Reflection.MemberTypes?displayProperty=nameWithType> para `type`, e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`. Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MemberInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os métodos do `myString` classe que começam com a letra C.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Uma classe derivada deve fornecer uma implementação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os membros públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos os membros públicos do <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se o <see cref="T:System.Type" /> atual não tiver membros públicos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMembers%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Essa sobrecarga de método chama o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga de método com <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Ele não localizará inicializadores de classe (. cctor). Para localizar os inicializadores de classe, use uma sobrecarga que utiliza <xref:System.Reflection.BindingFlags>e especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o atual <xref:System.Type> representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers> sobrecarga do método para coletar informações sobre todos os membros públicos de uma classe especificada.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), para retornar uma matriz vazia.</param>
        <summary>Quando substituído em uma classe derivada, procura membros definidos atual <see cref="T:System.Type" />, usando as restrições de associação especificada.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam todos os membros definidos atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MemberInfo" />, se nenhum membro é definido para o atual <see cref="T:System.Type" />, ou se nenhum membro definido corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Entre os membros estão propriedades, campos, métodos, eventos etc.  
  
 O <xref:System.Type.GetMembers%2A> método não retorna membros em uma ordem específica, como em ordem alfabética ou ordem de declaração. O código não deve depender de ordem na qual os membros são retornados, porque essa ordem varia.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa. Protegido e membros internos em classes base são retornados; membros privados em classes de base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 Chamar esse método somente com o `Public` sinalizador ou apenas o `NonPublic` sinalizador retornará os membros especificados e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter o inicializador de classe (. cctor) usando essa sobrecarga de método, você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags?displayProperty=nameWithType> in Visual Basic). Também é possível obter o inicializador da classe usando-se a propriedade <xref:System.Type.TypeInitializer%2A>.  
  
 Se o T:System.Type atual representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.MemberInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método procura membros da restrição de classe ou os membros de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga do método para coletar informações sobre todos os membros de instância pública de uma classe especificada.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <summary>Pesquisa o método público com o nome especificado.</summary>
        <returns>Um objeto que representa o método público com o nome especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui métodos de instância pública estático e público.  
  
 Se um método é sobrecarregado e tem mais de um método público, o <xref:System.Type.GetMethod%28System.String%29> método lança um <xref:System.Reflection.AmbiguousMatchException> exceção. No exemplo a seguir, uma exceção será lançada porque há mais de uma sobrecarga pública do <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.  Por outro lado, pois o `Person.ToString` substituições de método <xref:System.Object.ToString%2A?displayProperty=nameWithType> e, portanto, não está sobrecarregado, o <xref:System.Type.GetMethod%28System.String%29> método é capaz de recuperar o <xref:System.Reflection.MethodInfo> objeto.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Você pode fazer o seguinte para recuperar um método específico:  
  
-   Chamar o <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> método e especifique um `bindingAttr` argumento que identifica exclusivamente o método. Por exemplo, se a exceção é lançada como um tipo tem um estático e uma sobrecarga de instância, você pode especificar um `bindingAttr` argumento de <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
-   Chame uma sobrecarga de <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.  
  
-   Chamar o <xref:System.Type.GetMethods> método para recuperar uma matriz que contém todos os métodos públicos que pertence a um tipo. Em seguida, você pode iterá-la para identificar os métodos duplicados chamados `name`.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir obtém um método chamado `MethodA`.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrado mais de um método com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa o método especificado, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir métodos públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir os métodos não-públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para ignorar o caso de `name`.  
  
-   <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Se um método é sobrecarregado e mais de uma sobrecarga atende as restrições especificadas pelo `bindingAttr` argumento, o método gera uma <xref:System.Reflection.AmbiguousMatchException> exceção. No exemplo a seguir, uma exceção será lançada porque:  
  
-   O `TestClass` tipo tem duas sobrecargas de instância pública do `DisplayValue` método `DisplayValue(String)` e `DisplayValue(String, Object[])`.  
  
-   O `TestClass` tipo tem duas sobrecargas de instância pública do `Equals` método, um dos quais é herdado do <xref:System.Object>: `Equals(TestClass)` e `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Você pode fazer o seguinte para recuperar um método específico:  
  
-   Altere as restrições de associação. No exemplo anterior, a tentativa de recuperar uma instância pública `Equals` recupera do método que é declarado pelo tipo e não herdado com êxito `Equals(TestClass)`.  
  
-   Chame uma sobrecarga de <xref:System.Type.GetMethod%2A> método inclui um `types` parâmetro que define os tipos de parâmetros do método.  
  
-   Chamar o <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> método para recuperar uma matriz que contém todos os métodos que pertence a um tipo que tem os atributos de associação especificada. Em seguida, você pode iterá-la para identificar os métodos duplicados chamados `name`. Essa abordagem é ilustrada no manipulador do exemplo anterior para o <xref:System.Reflection.AmbiguousMatchException> exceção.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir obtém o método que coincide com os sinalizadores de associação especificada.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
 -ou-  
  
 Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <summary>Pesquisa o método público especificado cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa o método público cujos parâmetros correspondam aos tipos de argumento especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui métodos de instância pública estático e público.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  O `name` parâmetro não pode incluir argumentos de tipo. Por exemplo, o código c# `GetMethod("MyGenericMethod<int>")` procura um método com o nome de texto "`MyGenericMethod<int>`", em vez de um método chamado `MyGenericMethod` que tem um argumento genérico do tipo `int`. Em vez disso, use `GetMethod("MyGenericMethod")` com o parâmetro apropriado na `types` matriz.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas de `MethodA`, especificar uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 O exemplo a seguir recupera <xref:System.Reflection.MethodInfo> objetos que representam o `Add` métodos de um tipo não genérico (o <xref:System.Collections.ArrayList> classe), um tipo genérico aberto (o <xref:System.Collections.Generic.List%601> classe) e um tipo genérico fechado (o `List(Of String)` tipo.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 O exemplo define uma `GetAddMethod` método que recupera as <xref:System.Reflection.MethodInfo> objeto. Para fornecer o `types` argumento para um tipo genérico aberto, ele chama o <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método. Para fornecer o `types` argumento para um tipo genérico fechado, ele recupera o valor da <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método foi encontrado com o nome especificado e os parâmetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método público a ser obtido.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
 -ou-  
  
 Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método público especificado cujos parâmetros correspondem aos modificadores e tipos de argumento especificados.</summary>
        <returns>Um objeto que representa o método público que corresponde aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui métodos de instância pública estático e público.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMethod("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`. Em vez disso, use `GetMethod("MyMethod")` com o parâmetro apropriado na `types` matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método foi encontrado com o nome especificado e os parâmetros especificados.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
 -ou-  
  
 Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir confidenciais métodos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas de `MethodA`, especificar restrições de associação e uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a serem usadas em relação a ordem e o layout dos argumentos, como o valor de retorno é passado, quais registros são usados para argumentos e como a pilha é limpa.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
 -ou-  
  
 Uma matriz vazia de objetos <see cref="T:System.Type" /> (conforme fornecido pelo campo <see cref="F:System.Type.EmptyTypes" /> ) para obter um método que não usa parâmetros.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. Deve ser usado apenas durante a chamada por meio da interoperabilidade COM e apenas os parâmetros passados por referência são manipulados. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa o método especificado cujos parâmetros correspondem aos tipos de argumento e modificadores especificados, usando as restrições de associação especificadas e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `GetXXX` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir confidenciais métodos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Caso o T: System.Type atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.MethodInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
> [!NOTE]
>  Para métodos genéricos, não inclua os argumentos de tipo em `name`. Por exemplo, o código do C# `GetMember("MyMethod<int>")` procura um membro com o nome de texto "`MyMethod<int>`", e não um método chamado `MyMethod` que tem um argumento genérico do tipo `int`.  
  
   
  
## Examples  
 O exemplo a seguir localiza sobrecargas específicas de `MethodA`, especificar restrições de associação, convenções de chamada e uma variedade de tipos de argumento.  
  
> [!NOTE]
>  O [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] exemplo requer o `/unsafe` opção de compilador.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do método a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="callConvention">O objeto que especifica o conjunto de regras a serem usadas em relação a ordem e o layout dos argumentos, como o valor de retorno é passado, quais registros são usados para argumentos e qual processo limpa a pilha.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para o método a ser obtido.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (isto é, o tipo [] tipos = novo Type[0]) para obter um método que não usa nenhum parâmetro.  
  
 -ou-  
  
 <see langword="null" />. Se <c>tipos</c> é <see langword="null" />, argumentos não correspondem.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, procura o método especificado cujos parâmetros correspondem a tipos de argumento especificados e os modificadores, usando as restrições de associação especificada e a convenção de chamada especificada.</summary>
        <returns>Um objeto que representa o método que corresponde aos requisitos especificados, se encontrado; do contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Se `types` é `null`, argumentos não correspondem.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir os métodos não-públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método é encontrado com o nome especificado e correspondendo às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" /> ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todos os métodos públicos do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representam todos os métodos públicos definidos para o <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método público for definido para o <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os métodos são retornados, porque que varia de ordem.  
  
 Construtores não são incluídos na matriz retornada por essa chamada de métodos. Fazer uma chamada separada para `GetConstructors()` para obter os métodos de construtor.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Se o T:System.Type atual representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa os métodos definidos para o <see cref="T:System.Type" /> atual usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representam todos os métodos definidos atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.MethodInfo" />, se nenhum método estiver definido para o atual <see cref="T:System.Type" />, ou se nenhum dos métodos definidos corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetMethods%2A> método não retorna métodos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os métodos são retornados, porque que varia de ordem.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais métodos devem ser incluídos na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir métodos públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir os métodos não-públicos (ou seja, métodos particulares, internos e protegidos) na pesquisa. Protegido e métodos internos em classes base são retornados; métodos privados em classes de base não são retornados.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os métodos declarados no <xref:System.Type>, e não os métodos que foram simplesmente herdados.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Não é possível omitir parâmetros durante a pesquisa de construtores e métodos. Só é possível omitir parâmetros durante a invocação.  
  
 Se o T:System.Type atual representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.MethodInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os métodos de restrição da classe ou os métodos de <xref:System.Object> caso não haja restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe com dois métodos públicos e um método protegido, cria um `Type` objeto correspondente para `MyTypeClass`, obtém todos os métodos públicos e não público e exibe seus nomes.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</param>
        <summary>Pesquisa o tipo aninhado público com o nome especificado.</summary>
        <returns>Um objeto que representa o tipo público aninhado com o nome especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas.  
  
 Use o nome simples da classe aninhada para `name`. Não qualifique-o com o nome da classe externa. Para uma classe aninhada genérica, use o nome danificado — ou seja, acrescente um acento grave e o número de argumentos genéricos. Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico as classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic). Não inclua a sintaxe de específicos de idioma para parâmetros de tipo.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro para tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do tipo aninhado a ser obtido.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando substituído em uma classe derivada, pesquisa as propriedades do tipo aninhado especificado, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa o tipo aninhado que atenda aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o nome simples da classe aninhada para `name`. Não qualifique-o com o nome da classe externa. Para uma classe aninhada genérica, use o nome danificado — ou seja, acrescente um acento grave e o número de parâmetros genéricos. Por exemplo, use a cadeia de caracteres "interna\`1" obter o genérico as classes aninhadas `Inner<T>` (`Inner(Of T)` no Visual Basic). Não inclua a sintaxe de específicos de idioma para parâmetros de tipo.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de sinalizadores podem ser usados para definir quais aninhados de filtro para incluir na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir tipos aninhados não públicos (ou seja, privados, internos e protegidos tipos aninhados) na pesquisa.  
  
 Esse método retorna apenas os tipos aninhados do tipo atual. Ele pesquisa as classes base do tipo atual. Para localizar tipos aninhados nas classes de base, você deve percorrer a hierarquia de herança, chamar <xref:System.Type.GetNestedType%2A> em cada nível.  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> são ignorados.  
  
 Chamar esse método somente com o <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro para tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os tipos públicos aninhados no <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de <see cref="T:System.Type" /> objetos que representam os tipos públicos aninhados no <see cref="T:System.Type" /> atual (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" /> se não há tipos públicos são aninhados no <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetNestedTypes%2A> método não retornar tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os tipos são retornados, porque que varia de ordem.  
  
 Somente os tipos públicos imediatamente aninhados no tipo atual são retornados; a pesquisa não é recursivo.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro para tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe aninhada e um `struct` na `MyClass`e, em seguida, obtém objetos dos tipos aninhados usando o tipo de `MyClass`.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa as propriedades do <see cref="T:System.Type" /> atual, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representam todos os tipos aninhados no <see cref="T:System.Type" /> atual que coincidem com as restrições de associação especificadas (a pesquisa não é recursiva) ou uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhum dos tipos aninhados são encontrados que correspondem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa por tipos aninhados não é recursivos.  
  
 O <xref:System.Type.GetNestedTypes%2A> método não retornar tipos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os tipos são retornados, porque que varia de ordem.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de sinalizadores podem ser usados para definir quais aninhados de filtro para incluir na pesquisa:  
  
-   Você deve especificar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> ou <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter um retorno.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir tipos aninhados públicos na pesquisa.  
  
-   Especifique <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para incluir tipos aninhados não públicos (ou seja, privados, internos e protegidos tipos aninhados) na pesquisa.  
  
 Esse método retorna apenas os tipos aninhados do tipo atual. Ele pesquisa as classes base do tipo atual. Para localizar tipos aninhados nas classes de base, você deve percorrer a hierarquia de herança, chamar <xref:System.Type.GetNestedTypes%2A> em cada nível.  
  
 <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>e <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> são ignorados.  
  
 Chamar esse método somente com o <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> sinalizador ou apenas o <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> sinalizador retornará especificado aninhados de tipos e não requer quaisquer outros sinalizadores.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, este método pesquisa os tipos aninhados da restrição de classe.  
  
 Se um tipo aninhado for genérico, este método retornará sua definição de tipo genérico. Isso será verdadeiro mesmo se o tipo genérico delimitador for um tipo construído fechado.  
  
> [!NOTE]
>  Caso o <xref:System.Type> atual represente um tipo genérico definido no C#, no Visual Basic ou no C++, seus tipos aninhados são todos genéricos mesmo que não tenham parâmetros genéricos próprios. Isso não é necessariamente verdadeiro para tipos aninhados definidos em assemblies dinâmicos ou compilados com o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  
  
 Para obter informações sobre tipos genéricos aninhados e sobre como construir tipos genéricos aninhados das definições de tipo genérico, consulte <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir cria duas classes públicas aninhadas e duas classes protegidos aninhadas e exibe informações de classes que correspondam às restrições de associação especificada.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todas as propriedades públicas do <see cref="T:System.Type" /> atual.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas as propriedades públicas do <see cref="T:System.Type" /> atual.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades públicas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga é equivalente a chamar o <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> sobrecarga com um `bindingAttr` argumento igual a `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` em c# e `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` no Visual Basic. Retorna todas as instância pública e propriedades estáticas, tanto os definidos pelo tipo representado pelo atual <xref:System.Type> herdado de objeto, bem como os de seus tipos base.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetProperties%2A> método não retorna propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual as propriedades são retornadas, porque que varia de ordem.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Se o T:System.Type atual representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do método `GetProperties`.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Quando é substituído em uma classe derivada, pesquisa as propriedades do atual <see cref="T:System.Type" />, usando as restrições de associação especificadas.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.PropertyInfo" /> objetos que representam todas as propriedades do atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Reflection.PropertyInfo" />, se o <see cref="T:System.Type" /> atual não tiver propriedades, ou se nenhuma das propriedades corresponderem às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 O <xref:System.Type.GetProperties%2A> método não retorna propriedades em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual as propriedades são retornadas, porque que varia de ordem.  
  
 O seguinte <xref:System.Reflection.BindingFlags> tipos de sinalizadores podem ser usados para definir quais aninhados de filtro para incluir na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa. Protegido e propriedades internas em classes base são retornadas; Propriedades privadas em classes de base não são retornadas.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Se o T:System.Type atual representa um tipo genérico construído, esse método retorna o <xref:System.Reflection.PropertyInfo> objetos com os parâmetros de tipo substituídos pelos argumentos de tipo apropriado.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe denominada `PropertyClass` que inclui seis propriedades: dois são públicos, um é privado, um está protegido, um é interno (`Friend` no Visual Basic), e um está protegido interno (`Protected Friend` no Visual Basic). Ele exibe algumas informações básicas de propriedade (o nome da propriedade e o tipo, se ele é leitura/gravação e a visibilidade de seu `get` e `set` acessadores) para as propriedades que correspondem às restrições de associação especificado.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <summary>Pesquisa a propriedade pública com o nome especificado.</summary>
        <returns>Um objeto que representa a propriedade pública com o nome especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
 Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:  
  
-   Um tipo contém duas propriedades indexadas que têm o mesmo nome mas diferentes números de parâmetros. Para resolver a ambiguidade, use uma sobrecarga de <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.  
  
-   Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic). Para resolver a ambiguidade, use o <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> método de sobrecarga e adicione o <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> sinalizador para restringir a pesquisa a membros que não são herdados.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Internamente, essa propriedade é referenciada nos metadados por nome de "Item". Qualquer tentativa de obter `PropertyInfo` usando a reflexão deve especificar esse nome interno para retornar corretamente o `PropertyInfo` propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <summary>Pesquisa a propriedade especificada usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa a propriedade que atenda aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir propriedades para incluir na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
 Situações nas quais <xref:System.Reflection.AmbiguousMatchException> ocorre incluem o seguinte:  
  
-   Um tipo contém duas propriedades indexadas que têm o mesmo nome mas diferentes números de parâmetros. Para resolver a ambiguidade, use uma sobrecarga de <xref:System.Type.GetProperty%2A> método que especifica os tipos de parâmetro.  
  
-   Um tipo derivado declara uma propriedade que oculta uma propriedade herdada com o mesmo nome, usando o `new` modificador (`Shadows` no Visual Basic). Para resolver a ambiguidade, incluir <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para restringir a pesquisa a membros que não são herdados.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de uma classe definida pelo usuário, recupera uma propriedade de classe e exibe o nome da propriedade de acordo com as restrições de associação especificada.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <summary>Pesquisa a propriedade pública com o nome e tipo retornado especificados.</summary>
        <returns>Um objeto que representa a propriedade pública com o nome especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe com uma propriedade e recupera o nome e o tipo da propriedade.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          O <paramref name="name" /> é <see langword="null" /> ou o <paramref name="returnType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa a propriedade pública cujos parâmetros correspondam aos tipos de argumento especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera o `Type` objeto de uma classe definida pelo usuário, recupera a propriedade de classe e exibe o nome da propriedade e o tipo da propriedade conforme especificado pelos argumentos passados para `GetProperty`.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e que correspondem aos tipos de argumento especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento especificados.</summary>
        <returns>Um objeto que representa a propriedade pública cujos parâmetros correspondam aos tipos de argumento especificado, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e que correspondem aos tipos de argumento especificado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade pública a ser obtida.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa a propriedade pública especificada cujos parâmetros correspondem aos tipos de argumento e modificadores especificados.</summary>
        <returns>Um objeto que representa a propriedade pública que atenda aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A pesquisa de `name` diferencia maiúsculas de minúsculas. A pesquisa inclui propriedades de instância estática pública e pública.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
   
  
## Examples  
 O exemplo a seguir obtém um `Type` objeto correspondente para `MyPropertyClass`, e a propriedade indexada dessa classe é recuperada usando os argumentos passados para o `GetProperty` método.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Foi encontrada mais de uma propriedade com o nome especificado e os tipos de argumento especificado e os modificadores de correspondência.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Pesquisa a propriedade especificada cujos parâmetros correspondem aos modificadores e tipos de argumento especificados, usando as restrições de associação especificadas.</summary>
        <returns>Um objeto que representa a propriedade que atenda aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma propriedade é considerada pública para reflexão caso tenha pelo menos um acessador público. Caso contrário, a propriedade é considerada privada, e você deve usar <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> (no Visual Basic, combinar os valores usando `Or`) para obtê-lo.  
  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir propriedades para incluir na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, este método retorna o <xref:System.Reflection.PropertyInfo> com os parâmetros de tipo substituídos pelos argumentos de tipo apropriados.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou método genérico, este método pesquisa as propriedades da restrição de classe.  
  
## <a name="indexers-and-default-properties"></a>Indexadores e propriedades padrão  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] e [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] simplificaram a sintaxe para acessar propriedades indexadas e permitem que uma propriedade indexada seja um padrão para o tipo. Por exemplo, se a variável `myList` refere-se a uma <xref:System.Collections.ArrayList>, a sintaxe `myList[3]` (`myList(3)` no Visual Basic) recupera o elemento com o índice de 3. É possível sobrecarregar a propriedade.  
  
 No C#, este recurso é chamado de indexador e não pode ser referenciado por nome. Por padrão, um indexador c# aparece nos metadados como uma propriedade indexada, chamada "Item". No entanto, um desenvolvedor de biblioteca de classes pode usar o atributo <xref:System.Runtime.CompilerServices.IndexerNameAttribute> para alterar o nome do indexador nos metadados. Por exemplo, a classe <xref:System.String> tem um indexador chamado <xref:System.String.Chars%2A>. As propriedades indexadas criadas usando-se linguagens diferentes do C# também podem ter nomes diferentes do item.  
  
 Para determinar se um tipo tem uma propriedade padrão, use o método <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> para testar o atributo <xref:System.Reflection.DefaultMemberAttribute>. Caso o tipo tenha <xref:System.Reflection.DefaultMemberAttribute>, a propriedade <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> retorna o nome da propriedade padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NullReferenceException">Um elemento de <paramref name="types" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome da propriedade a ser obtida.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para retornar <see langword="null" />.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e permite que a associação, que pode envolver a seleção de um membro sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio de reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="types">Uma matriz de objetos <see cref="T:System.Type" /> que representam o número, a ordem e o tipo de parâmetros para a propriedade indexada a ser obtida.  
  
 -ou-  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" /> (ou seja, tipos Type[] = novo Type[0]) para obter uma propriedade que não seja indexada.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>tipos</c> matriz. O associador padrão não processa este parâmetro.</param>
        <summary>Quando substituído em uma classe derivada, procura a propriedade especificada cujos parâmetros correspondem a tipos de argumento especificados e os modificadores, usando as restrições de associação especificada.</summary>
        <returns>Um objeto que representa a propriedade que atenda aos requisitos especificados, se encontrado; Caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Reflection.ParameterModifier> (o parâmetro `modifiers` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `modifiers`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de filtro podem ser usados para definir propriedades para incluir na pesquisa:  
  
-   Você deve especificar `BindingFlags.Instance` ou `BindingFlags.Static` para obter um retorno.  
  
-   Especifique `BindingFlags.Public` para incluir propriedades públicas na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir propriedades não públicas (ou seja, propriedades particulares, internas e protegidas) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir os membros estáticos `public` e `protected` acima na hierarquia; os membros estáticos `private` em classes herdadas não são incluídos.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas as propriedades declaradas no <xref:System.Type>, e não as propriedades que foram simplesmente herdadas.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">É encontrada mais de uma propriedade com o nome especificado e que corresponde às restrições de associação especificadas.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="types" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="types" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="types" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="modifiers" /> é multidimensional.  
  
 -ou-  
  
 <paramref name="types" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.</exception>
        <exception cref="T:System.NotSupportedException">O tipo atual é um <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, ou <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o <see cref="T:System.Type" /> atual.</summary>
        <returns>O <see cref="T:System.Type" /> atual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo é no assembly atualmente em execução ou em Mscorlib.dll, é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, com a execução de uma pesquisa que diferencia maiúsculas de minúsculas.</summary>
        <returns>O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter um <xref:System.Type> de objeto para um tipo em outro assembly, se você souber o nome qualificado de namespace. <xref:System.Type.GetType%2A>faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos do <xref:System.Reflection.Assembly> classe obter <xref:System.Type> objetos. Se for um tipo em um conjunto conhecido para o seu programa em tempo de compilação, é mais eficiente usar em c#, <xref:System.Type.GetType%2A> no Visual Basic ou C++.  
  
> [!NOTE]
>  Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%29> método retornará `null`. Ele não gerará uma exceção. Para controlar se uma exceção será lançada, chame uma sobrecarga de <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.  
  
 <xref:System.Type.GetType%2A>só funciona em assemblies carregados do disco. Se você chamar <xref:System.Type.GetType%2A> para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> services, você pode obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criados usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de encontrar o assembly salvo em disco, carrega o assembly e recupera o tipo de assembly. Se o assembly não tiver sido salvo em disco quando `GetType` é chamado, o método retornará `null`. `GetType`não entender transitórios assemblies dinâmicos; Portanto, ao chamar `GetType` para recuperar um tipo em um transitório retorna assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Matrizes ou tipos COM não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName`pode ser o nome de tipo qualificado por seu namespace ou um nome qualificado do assembly que inclui uma especificação de nome de assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa somente o assembly do objeto de chamada e mscorlib, nessa ordem. Se typeName é totalmente qualificado com o nome do assembly parcial ou completa, este método pesquisa no assembly especificado. Se o assembly tiver um nome forte, é necessário um nome de assembly completo.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e argumentos de tipo genérico. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos criando um <xref:System.Reflection.AssemblyName> objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado por assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace foram TopNamespace.Sub+Namespace, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ele seja interpretado como um separador de aninhamento. Reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade de desconfiguração esse nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, reflexão retorna os nomes danificados `Tuple`1` and `tupla`2` de métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> de `MyType` com as chaves do tipo <xref:System.String> pode ser representado como segue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado por assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado de assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, um <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, com as chaves do tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado por assembly pode estar entre colchetes somente quando aparece em uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor nulo <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o valor nulo <xref:System.Boolean> tipo retornado pelo `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor nulo.<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Um ponteiro não gerenciado para`MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado para um ponteiro para`MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro gerenciado ou uma referência para`MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyType[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyType[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Uma matriz de matrizes unidimensionais|`Type.GetType("MyType[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores do desconhecido|`Type.GetType("MyType[,]")`|  
|Um tipo genérico com um argumento de tipo|`Type.GetType("MyGenericType`1[MYTYPE]")'|  
|Um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`2[MYTYPE,AnotherType]")'|  
|Um tipo genérico com dois argumentos de tipo qualificado por assembly|`Type.GetType("MyGenericType`2[[MYTYPE,myAssembly],[AnotherType,AnotherAssembly]]")'|  
|Um tipo genérico qualificado de assembly com um argumento de tipo qualificado por assembly|`Type.GetType("MyGenericType`1[[MYTYPE,myAssembly]],MyGenericTypeAssembly")'|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade `System.Int32`.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.IO.IOException" />, em vez disso.  
  
</para>
          </block>  
  
 O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo é no assembly atualmente em execução ou em Mscorlib.dll, é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, realizando uma pesquisa que diferencia minúsculas e maiúsculas e especificando se deve ou não lançar uma exceção se o tipo não for encontrado.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter um <xref:System.Type> de objeto para um tipo em outro assembly, se você souber o nome qualificado de namespace. <xref:System.Type.GetType%2A>faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos do <xref:System.Reflection.Assembly> classe obter <xref:System.Type> objetos. Se for um tipo em um conjunto conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.  
  
 `GetType`só funciona em assemblies carregados do disco. Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> services, você pode obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criados usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de encontrar o assembly salvo em disco, carrega o assembly e recupera o tipo de assembly. Se o assembly não tiver sido salvo em disco quando `GetType` é chamado, o método retornará `null`. `GetType`não entender transitórios assemblies dinâmicos; Portanto, ao chamar `GetType` para recuperar um tipo em um transitório retorna assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 O `throwOnError` parâmetro especifica o que acontece quando o tipo não for localizado e também suprime determinadas outras condições de exceção, conforme descrito na seção de exceções. Algumas exceções são geradas, independentemente do valor de `throwOnError`. Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é acionada mesmo se `throwOnError` é `false`.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Matrizes ou tipos COM não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName`pode ser o nome de tipo qualificado por seu namespace ou um nome qualificado do assembly que inclui uma especificação de nome de assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa somente o assembly do objeto de chamada e mscorlib, nessa ordem. Se typeName é totalmente qualificado com o nome do assembly parcial ou completa, este método pesquisa no assembly especificado. Se o assembly tiver um nome forte, é necessário um nome de assembly completo.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e argumentos genéricos. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos criando um <xref:System.Reflection.AssemblyName> objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado por assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace foram TopNamespace.Sub+Namespace, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ele seja interpretado como um separador de aninhamento. Reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade de desconfiguração esse nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, reflexão retorna os nomes danificados `Tuple`1` and `tupla`2` de métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> de `MyType` com as chaves do tipo <xref:System.String> pode ser representado como segue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado por assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado de assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, um <xref:System.Collections.Generic.Dictionary%602> de `MyType` de myAssembly, com as chaves do tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado por assembly pode estar entre colchetes somente quando aparece em uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor nulo <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o valor nulo <xref:System.Boolean> tipo retornado pelo `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor nulo.<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Um ponteiro não gerenciado para`MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado para um ponteiro para`MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro gerenciado ou uma referência para`MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyArray[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyArray[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Matriz de uma matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores do desconhecido|`Type.GetType("MyArray[,]")`|  
|Um tipo genérico com um argumento de tipo|`Type.GetType("MyGenericType`1[MYTYPE]")'|  
|Um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`2[MYTYPE,AnotherType]")'|  
|Um tipo genérico com dois argumentos de tipo qualificado por assembly|`Type.GetType("MyGenericType`2[[MYTYPE,myAssembly],[AnotherType,AnotherAssembly]]")'|  
|Um tipo genérico qualificado de assembly com um argumento de tipo qualificado por assembly|`Type.GetType("MyGenericType`1[[MYTYPE,myAssembly]],MyGenericTypeAssembly")'|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
   
  
## Examples  
 O exemplo a seguir recupera o tipo de `System.Int32` e usa esse objeto de tipo para exibir o <xref:System.Type.FullName%2A> propriedade `System.Int32`. Se um objeto de tipo refere-se a um assembly que não existe, este exemplo gera uma exceção.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
 -ou-  
  
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" />é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida. Por exemplo, "MyType [, *,]".  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.IO.IOException" />, em vez disso.  
  
</para>
          </block>  
  
 O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do tipo a ser obtido. Consulte <see cref="P:System.Type.AssemblyQualifiedName" />. Se o tipo é no assembly atualmente em execução ou em Mscorlib.dll, é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="throwOnError">
          <see langword="true" />para lançar uma exceção se o tipo não pode ser encontrado; <see langword="false" /> para retornar <see langword="null" />. Especificando <see langword="false" /> suprime também algumas outras condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase">
          <see langword="true" />para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>, <see langword="false" /> para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deve ou não lançar uma exceção se o tipo não for encontrado e se deseja executar uma pesquisa diferenciando maiúsculas de minúsculas.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Type.GetType%2A> método para obter um <xref:System.Type> de objeto para um tipo em outro assembly, se você souber o nome qualificado de namespace. <xref:System.Type.GetType%2A>faz com que o carregamento do assembly especificado em `typeName`. Você também pode carregar um assembly usando o <xref:System.Reflection.Assembly.Load%2A> método e, em seguida, use o <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetTypes%2A> métodos do <xref:System.Reflection.Assembly> classe obter <xref:System.Type> objetos. Se for um tipo em um conjunto conhecido para o seu programa em tempo de compilação, é mais eficiente usar `typeof` em c#, <xref:System.Type.GetType%2A> no Visual Basic, ou `typeid` em C++.  
  
 `GetType`só funciona em assemblies carregados do disco. Se você chamar `GetType` para pesquisar um tipo definido em um assembly dinâmico definido usando o <xref:System.Reflection.Emit> services, você pode obter um comportamento inconsistente. O comportamento depende se o assembly dinâmico é persistente, ou seja, criados usando o `RunAndSave` ou `Save` acessar modos do <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeração. Se o assembly dinâmico é persistente e foi gravado no disco antes de `GetType` é chamado, o carregador de encontrar o assembly salvo em disco, carrega o assembly e recupera o tipo de assembly. Se o assembly não tiver sido salvo em disco quando `GetType` é chamado, o método retornará `null`. `GetType`não entender transitórios assemblies dinâmicos; Portanto, ao chamar `GetType` para recuperar um tipo em um transitório retorna assembly dinâmico `null`.  
  
 Para usar `GetType` em um módulo dinâmico, assinar o <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos e chamadas `GetType` antes de salvar. Caso contrário, você obterá duas cópias do assembly na memória.  
  
 O `throwOnError` parâmetro especifica o que acontece quando o tipo não for localizado e também suprime determinadas outras condições de exceção, conforme descrito na seção de exceções. Algumas exceções são geradas, independentemente do valor de `throwOnError`. Por exemplo, se o tipo é encontrado, mas não pode ser carregado, um <xref:System.TypeLoadException> é acionada mesmo se `throwOnError` é `false`.  
  
 A tabela a seguir mostra quais membros de uma classe base são retornados pelos métodos `Get` durante a reflexão em um tipo.  
  
|Tipo do membro|Estático|Não estático|  
|-----------------|------------|-----------------|  
|Construtor|Não|Não|  
|Campo|Não|Sim. Um campo permanece sempre oculto por nome e assinatura.|  
|Evento|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
|Método|Não|Sim. Um método (virtual e não virtual) pode permanecer oculto por nome ou por nome e assinatura.|  
|Tipo aninhado|Não|Não|  
|Propriedade|Não aplicável|A regra de sistema do tipo comum é que a herança é a mesma dos métodos que implementam a propriedade. Reflexão trata propriedades como ocultas por nome e assinatura. Consulte a observação 2 abaixo.|  
  
1.  Oculto por nome e assinatura considera todas as partes da assinatura, inclusive modificadores personalizados, tipos de retorno, tipos de parâmetro, sentinelas e convenções de chamada não gerenciadas. Esta é uma comparação binária.  
  
2.  Para reflexão, propriedades e eventos permanecem ocultos por nome e assinatura. Se você tiver uma propriedade com um acessador get e set na classe base, mas a classe derivada tiver apenas um acessador get, a propriedade de classe derivada ocultará a propriedade da classe base e você não poderá acessar o setter na classe base.  
  
3.  Atributos personalizados não fazem parte do sistema de tipo comum.  
  
 Matrizes ou tipos COM não são pesquisados, a menos que já foram carregadas na tabela de classes disponíveis.  
  
 `typeName`pode ser o nome de tipo qualificado por seu namespace ou um nome qualificado do assembly que inclui uma especificação de nome de assembly. Consulte <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Se `typeName` inclui o namespace, mas não o nome do assembly, este método pesquisa somente o assembly do objeto de chamada e mscorlib, nessa ordem. Se typeName é totalmente qualificado com o nome do assembly parcial ou completa, este método pesquisa no assembly especificado. Se o assembly tiver um nome forte, é necessário um nome de assembly completo.  
  
 O <xref:System.Type.AssemblyQualifiedName%2A> propriedade retorna um nome de tipo totalmente qualificado, incluindo tipos aninhados, o nome do assembly e argumentos de tipo. Todos os compiladores que dão suporte ao Common Language Runtime emitirão o nome simples de uma classe aninhada, e reflexão constrói um nome danificado quando consultado, de acordo com as convenções a seguir.  
  
> [!NOTE]
>  No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Type.AssemblyQualifiedName%2A>, por motivos de compatibilidade. Você também pode carregar tipos criando um <xref:System.Reflection.AssemblyName> objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Você pode usar o <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método carregar tipos do assembly. Confira também <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Delimitador|Significado|  
|---------------|-------------|  
|Barra invertida (\\)|Caractere de escape.|  
|Acento grave (')|Precede um ou mais dígitos que representa o número de parâmetros de tipo, localizado no final do nome de um tipo genérico.|  
|Colchetes ([])|Coloque uma lista de argumentos de tipo genérico, para um tipo genérico construído; dentro de uma lista de argumentos de tipo, coloque um tipo qualificado por assembly.|  
|Vírgula (,)|Precede o nome Assembly.|  
|Ponto final (.)|Denota identificadores de namespace.|  
|Sinal de adição (+)|Precede uma classe aninhada.|  
  
 Por exemplo, o nome totalmente qualificado para uma classe pode ser semelhante a:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Se o namespace foram TopNamespace.Sub+Namespace, a cadeia de caracteres precisa preceder o sinal de adição (+) com um caractere de escape (\\) para impedir que ele seja interpretado como um separador de aninhamento. Reflexão emite essa cadeia de caracteres da seguinte maneira:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".  
  
 Este nome qualificado pode ser mantido e posteriormente usado para carregar o <xref:System.Type>. Para procurar e carregar <xref:System.Type>, use <xref:System.Type.GetType%2A> apenas com o nome do tipo ou com o nome do tipo qualificado do assembly. <xref:System.Type.GetType%2A> com o nome de tipo só irá procurar o <xref:System.Type> no assembly do chamador e, em seguida, no assembly System. <xref:System.Type.GetType%2A> com o nome de tipo qualificado de assembly irá procurar o <xref:System.Type> em qualquer assembly.  
  
 Nomes de tipo podem incluir caracteres à direita que denotam informações adicionais sobre o tipo, como se o tipo é um tipo de referência, ponteiro ou matriz. Para recuperar o nome do tipo sem esses caracteres à direita, use `t.GetElementType().ToString()`, em que `t` é o tipo.  
  
 Espaços são relevantes em todos os componentes de nome do tipo, exceto o nome do assembly. No nome do assembly, espaços antes do separador ',' são relevantes, mas espaços depois do separador ',' são ignorados.  
  
 O nome de um tipo genérico termina com um acento grave (\`) seguido por dígitos que representa o número de argumentos de tipo genérico. A finalidade de desconfiguração esse nome é permitir que os compiladores dar suporte a tipos genéricos com o mesmo nome mas com diferentes números de parâmetros de tipo, que ocorrem no mesmo escopo. Por exemplo, reflexão retorna os nomes danificados `Tuple`1` and `tupla`2` de métodos genéricos `Tuple(Of T)` e `Tuple(Of T0, T1)` no Visual Basic, ou `Tuple<T>` e tupla`\<T0, T1>` no Visual c#.  
  
 Para tipos genéricos, a lista de argumentos de tipo entre colchetes e os argumentos de tipo são separados por vírgulas. Por exemplo, um genérico <xref:System.Collections.Generic.Dictionary%602> tem dois parâmetros de tipo. Um <xref:System.Collections.Generic.Dictionary%602> de `MyType` com as chaves do tipo <xref:System.String> pode ser representado como segue:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Para especificar um tipo qualificado por assembly dentro de uma lista de argumentos de tipo, coloque o tipo qualificado por assembly entre colchetes. Caso contrário, as vírgulas que separam as partes do nome qualificado de assembly são interpretadas como argumentos de tipo adicionais de delimitação. Por exemplo, um <xref:System.Collections.Generic.Dictionary%602> de `MyType` de myAssembly, com as chaves do tipo <xref:System.String>, pode ser especificada da seguinte maneira:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Um tipo qualificado por assembly pode estar entre colchetes somente quando aparece em uma lista de parâmetros de tipo. As regras para a pesquisa de assemblies para tipos qualificados e não qualificados em listas de parâmetros de tipo são o mesmo que as regras para tipos não genéricos qualificados e não qualificados.  
  
 Tipos anuláveis são um caso especial de tipos genéricos. Por exemplo, um valor nulo <xref:System.Int32> é representado pela cadeia de caracteres "System.Nullable'1[System.Int32]".  
  
> [!NOTE]
>  No c#, C++ e Visual Basic, você também pode obter usando operadores de tipo de tipos anuláveis. Por exemplo, o valor nulo <xref:System.Boolean> tipo retornado pelo `typeof(Nullable<bool>)` em c#, por `Nullable<Boolean>::typeid` em C++ e pelo `GetType(Nullable(Of Boolean))` no Visual Basic.  
  
 A tabela a seguir mostra a sintaxe que você usa com `GetType` para vários tipos.  
  
|Para obter|Use|  
|------------|---------|  
|Um valor nulo.<xref:System.Int32>|`Type.GetType("System.Nullable`1[System.Int32]")'|  
|Um ponteiro não gerenciado para`MyType`|`Type.GetType("MyType*")`|  
|Um ponteiro não gerenciado para um ponteiro para`MyType`|`Type.GetType("MyType**")`|  
|Um ponteiro gerenciado ou uma referência para`MyType`|`Type.GetType("MyType&")`. Observe que, ao contrário dos ponteiros, as referências são limitadas a um nível.|  
|Uma classe pai e uma classe aninhada|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Uma matriz unidimensional com um limite inferior de 0|`Type.GetType("MyArray[]")`|  
|Uma matriz unidimensional com um limite inferior desconhecido|`Type.GetType("MyArray[*]")`|  
|Uma matriz de n-dimensional|Uma vírgula (,) dentro dos colchetes um total de vezes que n-1. Por exemplo, `System.Object[,,]` representa um tridimensional `Object` matriz.|  
|Matriz de uma matriz bidimensional|`Type.GetType("MyArray[][]")`|  
|Uma matriz bidimensional retangular com limites inferiores do desconhecido|`Type.GetType("MyArray[,]")`|  
|Um tipo genérico com um argumento de tipo|`Type.GetType("MyGenericType`1[MYTYPE]")'|  
|Um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`2[MYTYPE,AnotherType]")'|  
|Um tipo genérico com dois argumentos de tipo qualificado por assembly|`Type.GetType("MyGenericType`2[[MYTYPE,myAssembly],[AnotherType,AnotherAssembly]]")'|  
|Um tipo genérico qualificado de assembly com um argumento de tipo qualificado por assembly|`Type.GetType("MyGenericType`1[[MYTYPE,myAssembly]],MyGenericTypeAssembly")'|  
|Um tipo genérico cujo argumento de tipo é um tipo genérico com dois argumentos de tipo|`Type.GetType("MyGenericType`1 [AnotherGenericType`2[MyType,AnotherType]]")`|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
 -ou-  
  
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="throwOnError" />é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida. Por exemplo, "MyType [, *,]".  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 A versão 2.0 ou posterior do Common Language Runtime está carregada no momento e o assembly foi compilado com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o <c>typeResolver</c> parâmetro for fornecido, o nome do tipo pode ser qualquer cadeia de caracteres que <c>typeResolver</c> é capaz de resolver. Se o <c>assemblyResolver</c> parâmetro for fornecido ou se a resolução de tipo padrão é usada, <c>typeName</c> deve ser um nome qualificado de assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo está em execução no momento assembly ou no mscorlib, nesse caso é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o conjunto especificado em <c>typeName</c>. O nome do assembly é passado para <c>assemblyResolver</c> como um <see cref="T:System.Reflection.AssemblyName" /> objeto. Se <c>typeName</c> não contém o nome de um assembly, <c>assemblyResolver</c> não é chamado. Se <c>assemblyResolver</c> não é fornecido, o padrão de assembly a resolução é executada.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado pelo <c>typeName</c> do assembly que é retornado por <c>assemblyResolver</c> ou resolução de assembly padrão. Se nenhum assembly for fornecido, o <c>typeResolver</c> método pode fornecer uma. O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <summary>Obtém o tipo com o nome especificado, fornecendo opcionalmente métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado ou <see langword="null" /> se o tipo não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cenários de uso para este método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método.  
  
> [!NOTE]
>  Se `typeName` não for encontrado, a chamada para o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> método retornará `null`. Ele não gerará uma exceção. Para controlar se uma exceção será lançada, chame uma sobrecarga de <xref:System.Type.GetType%2A> método que tem um `throwOnError` parâmetro.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `throwOnError` e `ignoreCase` parâmetros.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.  
  
 -ou-  
  
 <paramref name="typeName" />contém um nome de assembly inválido.  
  
 -ou-  
  
 <paramref name="typeName" />é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o <c>typeResolver</c> parâmetro for fornecido, o nome do tipo pode ser qualquer cadeia de caracteres que <c>typeResolver</c> é capaz de resolver. Se o <c>assemblyResolver</c> parâmetro for fornecido ou se a resolução de tipo padrão é usada, <c>typeName</c> deve ser um nome qualificado de assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo está em execução no momento assembly ou no mscorlib, nesse caso é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o conjunto especificado em <c>typeName</c>. O nome do assembly é passado para <c>assemblyResolver</c> como um <see cref="T:System.Reflection.AssemblyName" /> objeto. Se <c>typeName</c> não contém o nome de um assembly, <c>assemblyResolver</c> não é chamado. Se <c>assemblyResolver</c> não é fornecido, o padrão de assembly a resolução é executada.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado pelo <c>typeName</c> do assembly que é retornado por <c>assemblyResolver</c> ou resolução de assembly padrão. Se nenhum assembly for indicado, o método poderá fornecer um. O método também utiliza um parâmetro que especifica se deve ser executada uma pesquisa que não diferencia maiúsculas de minúsculas. <see langword="false" /> é passado para esse parâmetro.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <summary>Obtém o tipo com o nome definido, especificando se deverá ser lançada uma exceção se o tipo não for encontrado e, opcionalmente, fornecendo métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cenários de uso para este método e os detalhes sobre o `assemblyResolver` e `typeResolver` parâmetros podem ser encontrados no <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga de método e especificando `false` para o `ignoreCase` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
 -ou-  
  
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
 -ou-  
  
 <paramref name="throwOnError" />é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,*,]").  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.  
  
 -ou-  
  
 <paramref name="typeName" />contém um nome de assembly inválido.  
  
 -ou-  
  
 <paramref name="typeName" />é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome do tipo a ser obtido. Se o <c>typeResolver</c> parâmetro for fornecido, o nome do tipo pode ser qualquer cadeia de caracteres que <c>typeResolver</c> é capaz de resolver. Se o <c>assemblyResolver</c> parâmetro for fornecido ou se a resolução de tipo padrão é usada, <c>typeName</c> deve ser um nome qualificado de assembly (consulte <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que o tipo está em execução no momento assembly ou no mscorlib, nesse caso é suficiente fornecer o nome de tipo qualificado por seu namespace.</param>
        <param name="assemblyResolver">Um método que localiza e retorna o conjunto especificado em <c>typeName</c>. O nome do assembly é passado para <c>assemblyResolver</c> como um <see cref="T:System.Reflection.AssemblyName" /> objeto. Se <c>typeName</c> não contém o nome de um assembly, <c>assemblyResolver</c> não é chamado. Se <c>assemblyResolver</c> não é fornecido, o padrão de assembly a resolução é executada.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis. Isso poderá resultar na elevação de privilégio de código mal-intencionado. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.</param>
        <param name="typeResolver">Um método que localiza e retorna o tipo especificado pelo <c>typeName</c> do assembly que é retornado por <c>assemblyResolver</c> ou resolução de assembly padrão. Se nenhum assembly for indicado, o método poderá fornecer um. O método também usa um parâmetro que especifica se deve executar uma pesquisa diferencia maiusculas de minúsculas; o valor de <c>ignoreCase</c> é passado para esse parâmetro.  
  
 Cuidado não passe métodos de chamadores desconhecidos ou não confiáveis.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase">
          <see langword="true" />para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>, <see langword="false" /> para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>.</param>
        <summary>Obtém o tipo com o nome definido, especificando se uma pesquisa que diferencia maiúsculas de minúsculas deverá ser realizada e se uma exceção deverá ser gerada se o tipo não for encontrado, com a opção de também fornecer métodos personalizados para resolver o assembly e o tipo.</summary>
        <returns>O tipo com o nome especificado. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwOnError" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwOnError" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método e suas sobrecargas associadas (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> e <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) para substituir a implementação padrão da <xref:System.Type.GetType%2A> método com implementações mais flexíveis. Fornecendo seus próprios métodos que resolver nomes de tipo e os nomes dos assemblies que contêm, você pode fazer o seguinte:  
  
-   Controle qual versão de um assembly de um tipo é carregado.  
  
-   Fornece outro local para procurar um nome de tipo que não inclua um nome de assembly.  
  
-   Carregar assemblies usando nomes de assembly parcial.  
  
-   Retornar as subclasses de <xref:System.Type?displayProperty=nameWithType> que não são criados pelo common language runtime (CLR).  
  
 Por exemplo, na serialização tolerantes à versão esse método permite que você procure um assembly de "melhor ajuste" usando um nome parcial. Outras sobrecargas do <xref:System.Type.GetType%2A> método requer um nome de tipo qualificado por assembly, que inclui o número de versão.  
  
 Talvez seja necessário retornar as subclasses de implementações alternativas do sistema de tipo <xref:System.Type?displayProperty=nameWithType> que não são criados pelo CLR; todos os tipos que são retornados por outras sobrecargas do <xref:System.Type.GetType%2A> método são tipos de tempo de execução.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Notas de uso  
 Essa sobrecarga de método e suas sobrecargas associadas analisam `typeName` no nome de um tipo e o nome de um assembly e, em seguida, resolva os nomes. Resolução do nome do assembly ocorre antes da resolução do nome do tipo, porque um nome de tipo deve ser resolvido no contexto de um assembly.  
  
> [!NOTE]
>  Se você estiver familiarizado com o conceito de nomes de tipo qualificado por assembly, consulte o <xref:System.Type.AssemblyQualifiedName%2A> propriedade.  
  
 Se `typeName` não é um nome qualificado de assembly, resolução de assembly é ignorada. Nomes de tipo não qualificados podem ser resolvidos no contexto de mscorlib. dll ou o assembly em execução no momento ou, opcionalmente, você pode fornecer um assembly no `typeResolver` parâmetro. Os efeitos de incluindo ou omitir o nome do assembly para diferentes tipos de resolução de nomes são exibidos como uma tabela no [misto resolução de nome](#mixed_name_resolution) seção.  
  
 Observações de uso geral:  
  
-   Não passe métodos para `assemblyResolver` ou `typeResolver` se eles vêm chamadores desconhecidos ou não confiáveis. Use apenas métodos fornecidos por você ou com os quais esteja familiarizado.  
  
    > [!CAUTION]
    >  Usando métodos de chamadores desconhecidos ou não confiáveis pode resultar na elevação de privilégio para um código mal-intencionado.  
  
-   Se você omitir o `assemblyResolver` e/ou `typeResolver` parâmetros, o valor de `throwOnError` parâmetro é passado para os métodos que executam a resolução padrão.  
  
-   Se `throwOnError` é `true`, este método lança um <xref:System.TypeLoadException> quando `typeResolver` retorna `null`e um <xref:System.IO.FileNotFoundException> quando `assemblyResolver` retorna `null`.  
  
-   Esse método não capturar exceções geradas por `assemblyResolver` e `typeResolver`. Você é responsável por todas as exceções que são geradas pelos métodos de resolução.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Resolvendo assemblies  
 O `assemblyResolver` método recebe um <xref:System.Reflection.AssemblyName> objeto, que é produzido pela análise do nome de assembly de cadeia de caracteres que está incluído no `typeName`. Se `typeName` não contém um nome de assembly, `assemblyResolver` não é chamado e `null` é passado para `typeResolver`.  
  
 Se `assemblyResolver` não é fornecida, o padrão de montagem de investigação é usada para localizar o assembly. Se `assemblyResolver` for fornecido, o <xref:System.Type.GetType%2A> método não faz a sondagem padrão; nesse caso você deve garantir que seu `assemblyResolver` pode lidar com todos os assemblies que você passa para ele.  
  
 O `assemblyResolver` método deve retornar `null` se o assembly não pode ser resolvido. Se `assemblyResolver` retorna `null`, `typeResolver` não é chamado e nenhum processamento adicional ocorre; Além disso, se `throwOnError` é `true`, um <xref:System.IO.FileNotFoundException> é gerada.  
  
 Se o <xref:System.Reflection.AssemblyName> que é passado para `assemblyResolver` é parciais de um nome, um ou mais de suas partes são `null`. Por exemplo, se ele não possui versão, o <xref:System.Reflection.AssemblyName.Version%2A> é de propriedade `null`. Se o <xref:System.Reflection.AssemblyName.Version%2A> propriedade, o <xref:System.Reflection.AssemblyName.CultureInfo%2A> propriedade e o <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> método todos retornam `null`, em seguida, somente o nome simple do assembly foi fornecido. O `assemblyResolver` método pode usar ou ignorar todas as partes do nome do assembly.  
  
 Os efeitos das opções de resolução de assembly diferentes são exibidos como uma tabela no [misto resolução de nome](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Resolvendo tipos  
 Se `typeName` não especificar um nome de assembly, `typeResolver` é chamado. Se `typeName` Especifica um nome de assembly, `typeResolver` é chamado apenas quando o nome do assembly é resolvido com êxito. Se `assemblyResolver` ou assembly padrão probing retorna `null`, `typeResolver` não for chamado.  
  
 O `typeResolver` método recebe três argumentos:  
  
-   O assembly para pesquisar ou `null` se `typeName` não contém um nome de assembly.  
  
-   O nome simples do tipo. No caso de um tipo aninhado, esse é o tipo de conteúdo externo. No caso de um tipo genérico, esse é o nome simple do tipo genérico.  
  
-   Um valor booliano que é `true` se o caso de nomes de tipo será ignorada.  
  
 A implementação determina a maneira como esses argumentos são usados. O `typeResolver` método deve retornar `null` se ele não puder resolver o tipo. Se `typeResolver` retorna `null` e `throwOnError` é `true`, essa sobrecarga de <xref:System.Type.GetType%2A> lança um <xref:System.TypeLoadException>.  
  
 Os efeitos das opções de resolução de tipo diferentes são exibidos como uma tabela no [misto resolução de nome](#mixed_name_resolution) seção para nomes de tipo simples e qualificado por assembly.  
  
#### <a name="resolving-nested-types"></a>Resolvendo tipos aninhados  
 Se `typeName` é um tipo aninhado, apenas o nome do mais externo que contém o tipo é passado para `typeResolver`. Quando `typeResolver` retorna este tipo, o <xref:System.Type.GetNestedType%2A> método é chamado repetidamente até que o tipo aninhado interno foi resolvido.  
  
#### <a name="resolving-generic-types"></a>Resolvendo tipos genéricos  
 O <xref:System.Type.GetType%2A> é chamado recursivamente para resolver tipos genéricos: primeiro para resolver o tipo genérico em si e, em seguida, para resolver seus argumentos de tipo. Se um argumento de tipo genérico, <xref:System.Type.GetType%2A> é chamado recursivamente para resolver seus argumentos de tipo e assim por diante.  
  
 A combinação de `assemblyResolver` e `typeResolver` que você fornecer deve ser capaz de resolver todos os níveis dessa recursão. Por exemplo, suponha que você fornecer um `assemblyResolver` que controla o carregamento de `MyAssembly`. Suponha que você deseja resolver o tipo genérico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` no Visual Basic). Você pode transmitir o seguinte nome de tipo genérico:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Observe que `MyType` é o argumento de tipo qualificado por assembly apenas. Os nomes do <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String> classes não são qualificado de assembly. O `typeResolver` deve ser capaz de identificador ou um assembly ou `null`, pois ela receberá `null` para <xref:System.Collections.Generic.Dictionary%602> e <xref:System.String>. Pode lidar com esse caso chamando uma sobrecarga de <xref:System.Type.GetType%2A> método que utiliza uma cadeia de caracteres, porque ambos os nomes de tipo não qualificados em Mscorlib.dll:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 O `assemblyResolver` método não é chamado para o tipo de dicionário e o tipo de cadeia de caracteres, porque os nomes de tipo não qualificado de assembly.  
  
 Agora suponha que, em vez de `System.String`, o primeiro tipo de argumento genérico é `YourType`, de `YourAssembly`:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Como este assembly é mscorlib, nem o assembly em execução no momento, não é possível resolver `YourType` sem um nome qualificado do assembly. Porque o `assemblyResolve` será chamado recursivamente, deve ser capaz de lidar com isso. Em vez de retornar `null` para assemblies que `MyAssembly`, ele executa uma carga de assembly usando fornecido <xref:System.Reflection.AssemblyName> objeto.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Voltar ao [Observações sobre uso de](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Resolvendo nomes de tipo com caracteres especiais  
 Determinados caracteres têm um significado especial nos nomes de assembly qualificado. Se um nome de tipo simples contenha esses caracteres, os caracteres causam erros de análise quando o nome simples faz parte de um nome qualificado do assembly. Para evitar os erros de análise, você deve escapar caracteres especiais com uma barra invertida antes que você pode passar o nome qualificado de assembly para o <xref:System.Type.GetType%2A> método. Por exemplo, se um tipo é denominado `Strange]Type`, o caractere de escape deve ser adicionado à frente do colchete da seguinte maneira: `Strange\]Type`.  
  
> [!NOTE]
>  Nomes com caracteres especiais, não podem ser criados no Visual Basic ou c#, mas podem ser criados usando o Microsoft intermediate language (MSIL) ou emitindo assemblies dinâmicos.  
  
 A tabela a seguir mostra os caracteres especiais para nomes de tipo.  
  
|Caractere|Significado|  
|---------------|-------------|  
|, (vírgula)|Delimitador de nomes de assembly qualificado.|  
|[] (colchetes)|Como um par de sufixo, indica um tipo de matriz; como um par de delimitadores, inclui listas de argumentos genéricos e nomes de assembly qualificado.|  
|& (E comercial)|Como um sufixo, indica que um tipo é um tipo de referência.|  
|asterisco (*)|Como um sufixo, indica que um tipo é um tipo de ponteiro.|  
|+ (mais)|Delimitador de tipos aninhados.|  
|\ (barra invertida)|Caractere de escape.|  
  
 Propriedades como <xref:System.Type.AssemblyQualifiedName%2A> retorno corretamente cadeias de caracteres de escape. Você deve passar cadeias de caracteres de escapadas corretamente para o <xref:System.Type.GetType%2A> método. Por sua vez, o <xref:System.Type.GetType%2A> método passa nomes corretamente com caracteres de escape para `typeResolver` e os métodos de resolução de tipo padrão. Se você precisa comparar um nome para um nome sem escape no `typeResolver`, você deve remover os caracteres de escape.  
  
 Voltar ao [Observações sobre uso de](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Resolução de nome misto  
 A tabela a seguir resume as interações entre `assemblyResolver`, `typeResolver`e a resolução de nome padrão, para todas as combinações de nome de tipo e nome de assembly em `typeName`:  
  
|Conteúdo do nome do tipo|Método do resolvedor de assembly|Método de resolução de tipo|Resultado|  
|---------------------------|------------------------------|--------------------------|------------|  
|tipo, assembly|nulo|nulo|Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método.|  
|tipo, assembly|fornecido|nulo|`assemblyResolver`Retorna o assembly ou retorna `null` se ele não é possível resolver o assembly. Se o assembly for resolvido, o <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método é usada para carregar o tipo do assembly; caso contrário, não haverá nenhuma tentativa de resolver o tipo.|  
|tipo, assembly|nulo|fornecido|Equivalente ao converter o nome do assembly para um <xref:System.Reflection.AssemblyName> objeto e chamar o <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> sobrecarga do método para obter o assembly. Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.|  
|tipo, assembly|fornecido|fornecido|`assemblyResolver`Retorna o assembly ou retorna `null` se ele não é possível resolver o assembly. Se o assembly for resolvido, ele é passado para `typeResolver`; caso contrário, `typeResolver` não é chamado e não há nenhuma outra tentativa de resolver o tipo.|  
|tipo|nulo, fornecido|nulo|Equivalente a chamar o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método. Porque o nome do assembly não for fornecido, apenas mscorlib. dll e o assembly em execução no momento são pesquisados. Se `assemblyResolver` for fornecido, ele será ignorado.|  
|tipo|nulo, fornecido|fornecido|`typeResolver`é chamado, e `null` é passado para o assembly. `typeResolver`pode fornecer um tipo de qualquer assembly, incluindo assemblies que ele carrega o propósito. Se `assemblyResolver` for fornecido, ele será ignorado.|  
|assembly|nulo, fornecido|nulo, fornecido|Um <xref:System.IO.FileLoadException> é gerada, porque o nome do assembly é analisado como se fosse um nome de tipo qualificado por assembly. Isso resulta em um nome de assembly inválido.|  
  
 Para: [Observações sobre uso](#usage_notes), [resolver Assemblies](#resolving_assemblies), [Resolvendo tipos](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="throwOnError" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
 -ou-  
  
 <paramref name="typeName" /> representa uma matriz de <see cref="T:System.TypedReference" />.</exception>
        <exception cref="T:System.ArgumentException">Ocorre um erro quando <paramref name="typeName" /> é analisado em um nome de tipo e um nome de assembly (por exemplo, quando o nome do tipo simples inclui um caractere especial sem escape).  
  
 -ou-  
  
 <paramref name="throwOnError" />é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida (por exemplo, "MyType[,*,]").  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.  
  
 -ou-  
  
 <paramref name="typeName" />contém um nome de assembly inválido.  
  
 -ou-  
  
 <paramref name="typeName" />é um nome de assembly válido sem um nome de tipo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objetos cujos tipos devem ser determinados.</param>
        <summary>Obtém os tipos dos objetos na matriz especificada.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Type" /> que representa os tipos de elementos correspondentes em <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Type.GetTypeArray%2A> método para listar os tipos de elementos de uma matriz.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="args" /> é <see langword="null" />.  
  
 - ou -  
  
 Um ou mais dos elementos no <paramref name="args" /> são <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Os inicializadores de classe são invocados e pelo menos um gera uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo cujo código de tipo subjacente será obtido.</param>
        <summary>Obtém o código de tipo subjacente do <see cref="T:System.Type" /> especificado.</summary>
        <returns>O código do tipo subjacente ou <see cref="F:System.TypeCode.Empty" /> se <paramref name="type" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao herdar de <xref:System.Type>, você pode alterar o comportamento desse método, substituindo o <xref:System.Type.GetTypeCodeImpl%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como o <xref:System.TypeCode> enumeração pode ser usada. Em um bloco de decisão dentro de `WriteObjectInfo` método, o <xref:System.TypeCode> de um <xref:System.Object> parâmetro é examinado e uma mensagem apropriada é gravada no console.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código de tipo subjacente desse <see cref="T:System.Type" /> instância.</summary>
        <returns>O código de tipo do tipo subjacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fornece a implementação para o `static` (em c#) ou `Shared` (no Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> método. Ao herdar de <xref:System.Type>, você pode substituir esse método para fornecer sua própria implementação de <xref:System.Type.GetTypeCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <summary>Obtém o tipo associado ao identificador de classe especificado (CLSID).</summary>
        <returns>
          <see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia para objetos COM não gerenciados do .NET Framework a aplicativos quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor de <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acessar COM associação tardia objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando um objeto COM não gerenciado da sua CLSID é um processo de duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o`__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Consulte o exemplo para uma ilustração.  
  
 O <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> sobrecarga ignora qualquer exceção que pode ocorrer ao instanciar um <xref:System.Type> objeto com base no `clsid` argumento. Observe que nenhuma exceção é lançada se `clsid` não foi encontrado no registro.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar um tipo COM que representa o aplicativo Microsoft Word. Ele instancia o tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e o fecha chamando o [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Esse método é destinado ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não pode usá-lo <see cref="T:System.Type" /> objeto para criar uma instância de tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto que é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="throwOnError">
          <see langword="true" /> para lançar qualquer exceção que ocorra.  
  
 -ou-  
  
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao CLSID (identificador de classe) especificado, especificando se deverá gerar uma exceção se ocorrer um erro ao carregar o tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia para objetos COM não gerenciados do .NET Framework a aplicativos quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor de <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acessar COM associação tardia objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando um objeto COM não gerenciado da sua CLSID é um processo de duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Consulte o exemplo para uma ilustração.  
  
 Exceções, como <xref:System.OutOfMemoryException> será lançada ao especificar `true` para `throwOnError`, mas ele não irá falhar para CLSIDs cancelados.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar um tipo COM que representa o aplicativo Microsoft Word. Ele instancia o tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e o fecha chamando o [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método. Uma exceção é lançada se ocorrer um erro ao carregar o tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Esse método é destinado ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não pode usá-lo <see cref="T:System.Type" /> objeto para criar uma instância de tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto que é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <summary>Obtém o tipo associado ao CLSID (identificador de classe) especificado do servidor especificado.</summary>
        <returns>
          <see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia para objetos COM não gerenciados do .NET Framework a aplicativos quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor de <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acessar COM associação tardia objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando um objeto COM não gerenciado da sua CLSID é um processo de duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com. Ele instancia o tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e o fecha chamando o [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Esse método é destinado ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o método retorna um <see cref="T:System.Type" /> objetos do objeto que corresponde ao GUID para o .NET Framework, você não pode usá-lo <see cref="T:System.Type" /> objeto para criar uma instância de tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto que é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <param name="throwOnError">
          <see langword="true" /> para lançar qualquer exceção que ocorra.  
  
 -ou-  
  
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado com o identificador de classe especificada (CLSID) do servidor especificado, especificando se deve lançar uma exceção se ocorrer um erro ao carregar o tipo.</summary>
        <returns>
          <see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.GetTypeFromCLSID%2A> método dá suporte ao acesso de associação tardia para objetos COM não gerenciados do .NET Framework a aplicativos quando você souber o identificador de classe do objeto COM (CLSID).  Classes COM o identificador de classe é definido na chave HKEY_CLASSES_ROOT\CLSID do registro. Você pode recuperar o valor de <xref:System.Type.IsCOMObject%2A> propriedade para determinar se o tipo retornado por esse método é um objeto COM.  
  
> [!TIP]
>  Você pode chamar o <xref:System.Type.GetTypeFromProgID%2A> método para acessar COM associação tardia objetos cujo identificador programático (ProgID) que você sabe.  
  
 Criando um objeto COM não gerenciado da sua CLSID é um processo de duas etapas:  
  
1.  Obter um <xref:System.Type> objeto que representa o `__ComObject` que corresponde ao CLSID chamando o <xref:System.Type.GetTypeFromCLSID%2A> método.  
  
2.  Chamar o <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para instanciar o objeto COM.  
  
 Exceções, como <xref:System.OutOfMemoryException> será lançada ao especificar `true` para `throwOnError`, mas ele não irá falhar para CLSIDs cancelados.  
  
   
  
## Examples  
 O exemplo a seguir usa o CLSID do Microsoft Word [objeto Application](http://msdn.microsoft.com/library/office/ff838565.aspx) para recuperar um tipo COM que representa o aplicativo Microsoft Word de um servidor chamado computer17.central.contoso.com. Ele instancia o tipo chamando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e o fecha chamando o [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) método. Uma exceção é lançada se ocorrer um erro ao carregar o tipo.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Esse método é destinado ao trabalhar com objetos COM, não com objetos do .NET Framework. Todos os objetos gerenciados, incluindo aqueles que são visíveis no COM (ou seja, seus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo é <see langword="true" />) tem um GUID que é retornado pelo <see cref="P:System.Type.GUID" /> propriedade. Embora o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> método retorna um <see cref="T:System.Type" /> objeto corresponde ao GUID de um objeto gerenciado específico, você não pode usá-lo <see cref="T:System.Type" /> objeto para criar uma instância de tipo chamando o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como o exemplo a seguir programas.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 Em vez disso, o <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> só deve ser usado para recuperar o GUID de um objeto COM não gerenciado e resultante <see cref="T:System.Type" /> objeto que é passado para o <see cref="M:System.Activator.CreateInstance(System.Type)" /> método deve representar um objeto COM não gerenciado.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">O objeto que se refere ao tipo.</param>
        <summary>Obtém o tipo referenciado pelo identificador do tipo especificado.</summary>
        <returns>O tipo referenciado pelo <see cref="T:System.RuntimeTypeHandle" /> especificado ou <see langword="null" />, se a propriedade <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.GetTypeFromHandle%2A> método para obter um <xref:System.Type> de objeto um <xref:System.RuntimeTypeHandle> fornecidos pelo <xref:System.Type.GetTypeHandle%2A> método.  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">O ProgID do tipo a ser obtido.</param>
        <summary>Obtém o tipo associado ao identificador de programa (ProgID) especificado, retornando null se for encontrado um erro ao carregar o <see cref="T:System.Type" />.</summary>
        <returns>O tipo associado ao ProgID especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo for associado a ele; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. ProgIDs não são usados no Microsoft .NET Framework, porque eles têm foi substituídos pelo conceito de namespace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">O ProgID do tipo a ser obtido.</param>
        <param name="throwOnError">
          <see langword="true" /> para lançar qualquer exceção que ocorra.  
  
 -ou-  
  
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao ProgID (identificador de programa) especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro ao carregar o tipo.</summary>
        <returns>O tipo associado ao ProgID (identificador de programa) especificado, se <paramref name="progID" /> for uma entrada válida no Registro e um tipo estiver associado a ele; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. IDs de programa não são usados no Microsoft .NET Framework, porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um ProgID, especificando se deve lançar uma exceção se o ProgID é inválido. O exemplo, em seguida, exibe ClassID relacionado a ProgID, juntamente com qualquer mensagem de exceção aplicável.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">O ProgID especificado não está registrado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">O progID do tipo a ser obtido.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <summary>Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, retornando nulo caso seja encontrado algum erro ao carregar o tipo.</summary>
        <returns>O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. IDs de programa não são usados no Microsoft .NET Framework, porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor. O exemplo exibe o ClassID relacionado para o ProgID ou lança uma exceção se o ProgID ou o nome do servidor é inválido.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="prodID" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">A progID do <see cref="T:System.Type" /> a ser obtida.</param>
        <param name="server">O servidor do qual carregar o tipo. Caso o nome do servidor seja <see langword="null" />, este método retorna automaticamente para o computador local.</param>
        <param name="throwOnError">
          <see langword="true" /> para lançar qualquer exceção que ocorra.  
  
 -ou-  
  
 <see langword="false" /> para ignorar qualquer exceção que ocorra.</param>
        <summary>Obtém o tipo associado ao progID (identificador de programa) especificado do servidor especificado, especificando se uma exceção deverá ser gerada se ocorrer um erro durante o carregamento do tipo.</summary>
        <returns>O tipo associado ao progID (identificador de programa) especificado, se o <paramref name="progID" /> for uma entrada válida no Registro e houver um tipo associado a ele, caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para suporte COM. IDs de programa não são usados no Microsoft .NET Framework, porque eles têm foi substituídos pelo conceito de namespace.  
  
   
  
## Examples  
 O exemplo a seguir recupera um tipo, passando um nome de ProgID e o servidor. O exemplo, em seguida, exibe o ClassID relacionado a ProgID, especificando se deve lançar uma exceção se o ProgID ou o nome do servidor é inválido.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="progID" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">A progID especificada não está registrada.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto para o qual o identificador de tipo será obtido.</param>
        <summary>Obtém o identificador para o <see cref="T:System.Type" /> de um objeto especificado.</summary>
        <returns>O identificador para o <see cref="T:System.Type" /> especificada <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.  
  
   
  
## Examples  
 O exemplo a seguir define a classe `MyClass1`, obtém uma instância dele e recupera o identificador de tempo de execução do objeto.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o GUID associado ao <see cref="T:System.Type" />.</summary>
        <value>O GUID associado ao <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um GUID está associado a um tipo usando o <xref:System.Runtime.InteropServices.GuidAttribute> atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria a classe de `MyClass1` com um método público, cria um `Type` objeto correspondente para `MyClass1`e obtém o <xref:System.Guid> estrutura usando o `GUID` propriedade o `Type` classe.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual abrange ou se refere a outro tipo; ou seja, se o <see cref="T:System.Type" /> atual é uma matriz, um ponteiro ou é passado por referência.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, Type.GetType("Int32[]"). Retorna HasElementType `true`, mas Type.GetType("Int32"). Retorna HasElementType `false`. Também retorna HasElementType `true` para Int32 "*" e "Int32 &".  
  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir retorna `true` ou `false` dependendo se o objeto é uma matriz, um tipo de referência ou um ponteiro.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.HasElementType" /> propriedade e determina se atual <see cref="T:System.Type" /> abrange ou se refere a outro tipo; se atual <see cref="T:System.Type" /> é uma matriz, um ponteiro, ou é passada por referência.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for uma matriz ou um ponteiro ou se for passado por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, Type.GetType("Int32[]"). Retorna HasElementTypeImpl `true`, mas Type.GetType("Int32"). Retorna HasElementTypeImpl `false`. Também retorna HasElementTypeImpl `true` para Int32 "*" e "Int32 &".  
  
   
  
## Examples  
 O exemplo a seguir define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método. Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
 -ou-  
  
 Uma cadeia de caracteres vazia ("") para chamar o membro padrão.  
  
 -ou-  
  
 Para <see langword="IDispatch" /> membros, uma cadeia de caracteres que representa o DispID, por exemplo "[DispID = 3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser uma da <see langword="BindingFlags" /> como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de consulta for omitido, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> são usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que definir explicitamente um <see cref="T:System.Reflection.Binder" /> objeto pode ser necessário para chamar com êxito as sobrecargas do método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <summary>Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos especificada.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não-públicos (ou seja, membros private e protected) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de chamada podem ser usados para indicar a ação a tomar com o membro:  
  
-   `CreateInstance`para chamar um construtor. `name`é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod`para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField`Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField`Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty`Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty`Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será chamado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos de `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos associador.  
  
 Depois que o método for selecionado, ele é invocado. Acessibilidade é verificada nesse ponto. A pesquisa pode controlar qual conjunto de métodos são pesquisadas com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método o <xref:System.Reflection.Binder> classe é responsável para selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 Restrições de acesso são ignoradas por código totalmente confiável. ou seja, privadas construtores, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública denominado F na classe C e F é um `String`, você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Se F é um `String[]`, você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 qual inicializar o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Isso alterará a cadeia de caracteres "z" na matriz de F contém a cadeia de caracteres "b".  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DispID = # #]". Por exemplo, se o DispID de MyComMethod é 3, você pode especificar a cadeia de caracteres "[DispID = 3]", em vez de "MyComMethod". Chamar um membro DISPID é mais rápido do que pesquisar por nome do membro. Em cenários de agregação complexos, o DispID às vezes é a única maneira de invocar o membro desejado.  
  
> [!NOTE]
>  Começando por [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele. (Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
   
  
## Examples  
 O exemplo a seguir usa `InvokeMember` para acessar membros de um tipo.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />Não há <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />não é válido <see cref="T:System.Reflection.BindingFlags" /> atributo.  
  
 -ou-  
  
 <paramref name="invokeAttr" />não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetField" /> e <see langword="SetField" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
 -ou-  
  
 Este método é chamado em um objeto COM, e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
 -ou-  
  
 Uma das matrizes de parâmetros nomeados contém uma cadeia de caracteres <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
 -ou-  
  
 O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.NotSupportedException">No momento, o .NET Compact Framework não dá suporte a esse método.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
 -ou-  
  
 Uma cadeia de caracteres vazia ("") para chamar o membro padrão.  
  
 -ou-  
  
 Para <see langword="IDispatch" /> membros, uma cadeia de caracteres que representa o DispID, por exemplo "[DispID = 3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser uma da <see langword="BindingFlags" /> como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de consulta for omitido, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> são usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que definir explicitamente um <see cref="T:System.Reflection.Binder" /> objeto pode ser necessário para chamar com êxito as sobrecargas do método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <param name="culture">O objeto que representa a localidade de globalização para usar, que pode ser necessário para conversões específicas de localidade, como converter um numérico <see cref="T:System.String" /> para um <see cref="T:System.Double" />.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
        <summary>Invoca o membro especificado, usando as restrições de associação especificadas e fazendo a correspondência da lista de argumentos e cultura especificadas.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o associador padrão não processe <xref:System.Globalization.CultureInfo> (o parâmetro `culture` ), é possível usar a classe abstrata <xref:System.Reflection.Binder?displayProperty=nameWithType> para gravar um associador personalizado que processa `culture`.  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de chamada podem ser usados para indicar a ação a tomar com o membro:  
  
-   `CreateInstance`para chamar um construtor. `name`é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod`para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField`Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField`Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty`Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty`Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será chamado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos de `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos associador.  
  
 Depois que o método for selecionado, ele é invocado. Acessibilidade é verificada nesse ponto. A pesquisa pode controlar qual conjunto de métodos são pesquisadas com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método o <xref:System.Reflection.Binder> classe é responsável para selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 Restrições de acesso são ignoradas por código totalmente confiável. ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocadas pela reflexão sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública denominado F na classe C e F é um `String` você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Se F é um `String[]`, você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 qual inicializar o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Isso alterará a cadeia de caracteres "z" na matriz de F contém a cadeia de caracteres "b".  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DispID = # #]". Por exemplo, se o DispID de MyComMethod é 3, você pode especificar a cadeia de caracteres "[DispID = 3]", em vez de "MyComMethod". Chamar um membro DISPID é mais rápido do que pesquisar por nome do membro. Em cenários de agregação complexos, o DispID às vezes é a única maneira de invocar o membro desejado.  
  
> [!NOTE]
>  Começando por [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele. (Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />Não há <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="invokeAttr" />não é válido <see cref="T:System.Reflection.BindingFlags" /> atributo.  
  
 -ou-  
  
 <paramref name="invokeAttr" />não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetField" /> e <see langword="SetField" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
 -ou-  
  
 Este método é chamado em um objeto COM, e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
 -ou-  
  
 Uma das matrizes de parâmetros nomeados contém uma cadeia de caracteres <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
 -ou-  
  
 O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres que contém o nome do construtor, método, propriedade ou membro de campo a serem invocados.  
  
 -ou-  
  
 Uma cadeia de caracteres vazia ("") para chamar o membro padrão.  
  
 -ou-  
  
 Para <see langword="IDispatch" /> membros, uma cadeia de caracteres que representa o DispID, por exemplo "[DispID = 3]".</param>
        <param name="invokeAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada. O acesso pode ser uma da <see langword="BindingFlags" /> como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />e assim por diante. O tipo de pesquisa não precisa ser especificado. Se o tipo de consulta for omitido, <see langword="BindingFlags.Public" />  |  <see langword="BindingFlags.Instance" />  |  <see langword="BindingFlags.Static" /> são usados.</param>
        <param name="binder">Um objeto que define um conjunto de propriedades e habilita a associação, que pode envolver seleção de um método sobrecarregado, coerção de tipos de argumento e invocação de um membro por meio da reflexão.  
  
 -ou-  
  
 Uma referência nula (Nothing no Visual Basic), para usar o <see cref="P:System.Type.DefaultBinder" />. Observe que definir explicitamente um <see cref="T:System.Reflection.Binder" /> objeto pode ser necessário para chamar com êxito as sobrecargas do método com argumentos de variável.</param>
        <param name="target">O objeto no qual invocar o membro especificado.</param>
        <param name="args">Uma matriz que contém os argumentos que serão passados para o membro a ser invocado.</param>
        <param name="modifiers">Uma matriz de <see cref="T:System.Reflection.ParameterModifier" /> objetos que representam os atributos associados com o elemento correspondente no <c>args</c> matriz. Os atributos associados ao parâmetro são armazenados na assinatura do membro.  
  
 O associador padrão processa esse parâmetro somente ao chamar um componente COM.</param>
        <param name="culture">O <see cref="T:System.Globalization.CultureInfo" /> objeto que representa a localidade de globalização para usar, que pode ser necessário para conversões específicas de localidade, como ao converter uma cadeia de caracteres numérica para um duplo.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic) para usar o <see cref="T:System.Globalization.CultureInfo" /> do thread atual.</param>
        <param name="namedParameters">Uma matriz que contém os nomes dos parâmetros para o qual os valores de <c>args</c> matriz são passados.</param>
        <summary>Quando substituído em uma classe derivada, invoca o membro especificado usando as restrições de associação especificadas e correspondendo a cultura, modificadores e lista de argumentos especificados.</summary>
        <returns>Um objeto que representa o valor retornado do membro invocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember`chama um membro de construtor ou método, obtém ou define uma propriedade de membro, obtém ou define um membro de campo de dados, ou obtém ou define um elemento de um membro da matriz.  
  
> [!NOTE]
>  Não é possível usar <xref:System.Type.InvokeMember%2A> para invocar um método genérico.  
  
 Quando você invoca um `IDispatch` membro, você pode especificar o DispID em vez do nome de membro, usando o formato de cadeia de caracteres "[DispID = # #]". Por exemplo, se o DispID de MyComMethod é 3, você pode especificar a cadeia de caracteres "[DispID = 3]", em vez de "MyComMethod". Chamar um membro DISPID é mais rápido do que pesquisar por nome do membro. Em cenários de agregação complexos, o DispID às vezes é a única maneira de invocar o membro desejado.  
  
 Embora o associador padrão não processar <xref:System.Reflection.ParameterModifier> ou <xref:System.Globalization.CultureInfo> (o `modifiers` e `culture` parâmetros), você pode usar o resumo <xref:System.Reflection.Binder?displayProperty=nameWithType> classe para gravar um associador personalizado que processam `modifiers` e `culture`. `ParameterModifier` só é usado durante a chamada por meio da interoperabilidade COM e apenas parâmetros passados por referência são identificados.  
  
 Cada parâmetro de `namedParameters` matriz obtém o valor do elemento correspondente na `args` matriz. Se o comprimento de `args` é maior que o comprimento de `namedParameters`, os valores de argumento restantes são passados na ordem.  
  
 O `namedParameters` matriz pode ser usada para alterar a ordem dos argumentos em uma matriz de entrada. Por exemplo, considerando o método `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` no Visual Basic) e a matriz de entrada `{ 42, "x" }`, a matriz de entrada pode ser passada inalterada para `args` se a matriz `{ "b", "a" }` é fornecido para `namedParameters`.  
  
 Os seguintes sinalizadores de filtro <xref:System.Reflection.BindingFlags> podem ser usados para definir quais membros devem ser incluídos na pesquisa:  
  
-   Especifique `BindingFlags.Public` para incluir membros públicos na pesquisa.  
  
-   Especifique `BindingFlags.NonPublic` para incluir membros não públicos (ou seja, membros particulares, internos e protegidos) na pesquisa.  
  
-   Especifique `BindingFlags.FlattenHierarchy` para incluir membros estáticos da hierarquia.  
  
 Os seguintes sinalizadores de modificador <xref:System.Reflection.BindingFlags> podem ser usados para alterar como a pesquisa funciona:  
  
-   `BindingFlags.IgnoreCase` para ignorar o caso de `name`.  
  
-   `BindingFlags.DeclaredOnly` para procurar apenas os membros declarados no <xref:System.Type>, e não os membros que foram simplesmente herdados.  
  
 O seguinte <xref:System.Reflection.BindingFlags> sinalizadores de chamada podem ser usados para indicar a ação a tomar com o membro:  
  
-   `CreateInstance`para chamar um construtor. `name`é ignorado. Não é válido com outros sinalizadores de invocação.  
  
-   `InvokeMethod`para invocar um método, mas não um construtor ou um inicializador de tipo. Não é válido com `SetField` ou `SetProperty`. Se `InvokeMethod` é especificado por si só, `BindingFlags.Public`, `BindingFlags.Instance`, e `BindingFlags.Static` são incluídos automaticamente.  
  
-   `GetField`Para obter o valor de um campo. Não é válido com `SetField`.  
  
-   `SetField`Para definir o valor de um campo. Não é válido com `GetField`.  
  
-   `GetProperty`Para obter uma propriedade. Não é válido com `SetProperty`.  
  
-   `SetProperty`Para definir uma propriedade. Não é válido com `GetProperty`.  
  
 Consulte <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obter mais informações.  
  
 Um método será chamado se ambas as seguintes condições forem verdadeiras:  
  
-   O número de parâmetros na declaração de método é igual ao número de argumentos de `args` matriz (a menos que os argumentos padrão são definidos no membro e `BindingFlags.OptionalParamBinding` for especificado).  
  
-   O tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`e assim por diante). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos associador.  
  
 Depois que o método for selecionado, ele é invocado. Acessibilidade é verificada nesse ponto. A pesquisa pode controlar qual conjunto de métodos são pesquisadas com base no atributo acessibilidade associado com o método. O <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método o <xref:System.Reflection.Binder> classe é responsável para selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
 `InvokeMember`pode ser usado para invocar os métodos com parâmetros que têm valores padrão. Para vincular a esses métodos, reflexão requer <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> seja especificado. Para um parâmetro que tem um valor padrão, você pode fornecer um valor diferente, ou fornecer <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> para usar o valor padrão.  
  
 Por exemplo, considere um método como Meumetodo (int, x, y float = 2.0). Para invocar esse método com somente o primeiro argumento MyMethod(4), passe um dos sinalizadores de associação acima e passar dois argumentos, ou seja, 4 para o primeiro argumento e `Missing.Value` para o segundo argumento. A menos que você use `Missing.Value`, você não pode omitir os parâmetros opcionais com o `Invoke` método. Se você deve fazer isso, use `InvokeMember` em vez disso.  
  
 Restrições de acesso são ignoradas por código totalmente confiável. ou seja, privadas construtores, métodos, campos e propriedades podem ser acessadas e invocadas por meio de <xref:System.Reflection> sempre que o código é totalmente confiável.  
  
 Você pode usar `Type.InvokeMember` para definir um campo para um valor específico, especificando <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>. Por exemplo, se você quiser definir um campo de instância pública denominado F na classe C e F é um `String`, você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Se F é um `String[]`, você pode usar o código, como:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 qual inicializar o campo F para essa nova matriz. Você também pode usar `Type.InvokeMember` para definir uma posição em uma matriz, fornecendo o índice do valor e, em seguida, o próximo valor usando código como o seguinte:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Isso alterará a cadeia de caracteres "z" na matriz de F contém a cadeia de caracteres "b".  
  
> [!NOTE]
>  Começando por [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele. (Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="invokeAttr" />Não há <see langword="CreateInstance" /> e <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="args" /> e <paramref name="modifiers" /> não têm o mesmo tamanho.  
  
 -ou-  
  
 <paramref name="invokeAttr" />não é válido <see cref="T:System.Reflection.BindingFlags" /> atributo.  
  
 -ou-  
  
 <paramref name="invokeAttr" />não contém um dos seguintes sinalizadores de associação: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="CreateInstance" /> combinado com <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetField" /> e <see langword="SetField" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="GetProperty" /> e <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="InvokeMethod" /> combinado com <see langword="SetField" /> ou <see langword="SetProperty" />.  
  
 -ou-  
  
 <paramref name="invokeAttr" />contém <see langword="SetField" /> e <paramref name="args" /> tem mais de um elemento.  
  
 -ou-  
  
 A matriz de parâmetros nomeada é maior que a matriz de argumentos.  
  
 -ou-  
  
 Este método é chamado em um objeto COM, e um dos seguintes sinalizadores de associação não foi passado: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, ou <see langword="BindingFlags.PutRefDispProperty" />.  
  
 -ou-  
  
 Uma das matrizes de parâmetros nomeados contém uma cadeia de caracteres <see langword="null" />.</exception>
        <exception cref="T:System.MethodAccessException">O membro especificado é um inicializador de classe.</exception>
        <exception cref="T:System.MissingFieldException">Não é possível encontrar o campo nem a propriedade.</exception>
        <exception cref="T:System.MissingMethodException">Não é possível encontrar nenhum método que corresponde aos argumentos em <paramref name="args" />.  
  
 -ou-  
  
 Não foi possível encontrar nenhum membro com os nomes de argumentos fornecidos em <paramref name="namedParameters" />.  
  
 -ou-  
  
 O atual objeto <see cref="T:System.Type" /> representa um tipo que contém os parâmetros de tipo aberto, ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />.</exception>
        <exception cref="T:System.Reflection.TargetException">O membro especificado não pode ser invocado no <paramref name="target" />.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mais de um método corresponde aos critérios de associação.</exception>
        <exception cref="T:System.InvalidOperationException">O método representado pelo <paramref name="name" /> tem um ou mais parâmetros de tipo genérico não especificados. Ou seja, a propriedade <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> do método retorna <see langword="true" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">para acessar membros não públicos independentemente do conjunto de concessões. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é abstrato e deve ser substituído.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for abstrato; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsAbstract%2A> propriedade retorna `true` nos seguintes casos:  
  
-   O tipo atual é abstrato; ou seja, ele não pode ser instanciado, mas só pode servir como a classe base para classes derivadas. No c#, as classes abstratas são marcadas com o [abstrata](~/docs/csharp/language-reference/keywords/abstract.md) palavra-chave; no Visual Basic, eles são marcados com o [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) palavra-chave.  
  
-   O tipo atual é uma interface.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Type> objetos que representam os seguintes tipos: contém tipo retorna `true` se o objeto especificado for `abstract`; caso contrário, retornará `false`.  
  
-   `AbstractClass`, uma classe abstrata (uma classe marcada como `abstract` em c# e `MustInherit` no Visual Basic).  
  
-   `DerivedClass`, uma classe que herda de `AbstractClass`.  
  
-   `SingleClass`, uma classe não-herdável. Ele é definido como `sealed` em c# e `NotInheritable` no Visual Basic.  
  
-   `ITypeInfo`, uma interface.  
  
-   `ImplementingClass`, uma classe que implementa o `ITypeInfo` interface.  
  
 O método retorna `true` apenas para `AbstractClass`, a classe abstrata, e `ITypeInfo`, a interface.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AnsiClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Se o atual <xref:System.Type> representa um tipo genérico, essa propriedade se refere à definição de tipo genérico do qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir obtém as informações de campo e verifica o `AnsiClass` atributo.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo é uma matriz.</summary>
        <value>
          <see langword="true" /> se o tipo atual for uma matriz; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsArray%2A> propriedade retorna `false` para o <xref:System.Array> classe. Ele também retorna `false` se a instância atual for um <xref:System.Type> objeto que representa um tipo de coleção ou uma interface projetado para trabalhar com coleções, como <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Para verificar uma matriz, use um código como:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Se o tipo atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Type.IsArray%2A> propriedade.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.IsArray" /> propriedade e determina se o <see cref="T:System.Type" /> é uma matriz.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Type" /> é uma matriz; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma instância do <xref:System.Array> classe deve retornar `false` porque ele é um objeto, não uma matriz.  
  
   
  
## Examples  
 O exemplo a seguir substitui o `IsArrayImpl` método o `MyTypeDelegator` classe verifica se uma variável é uma matriz e exibe o resultado.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">O tipo a ser comparado com o tipo atual.</param>
        <summary>Determina se uma instância de um tipo especificado pode ser atribuída a uma instância do tipo atual.</summary>
        <returns>
          <see langword="true" />Se qualquer uma das condições a seguir for verdadeira:  
  
-   <paramref name="c" />e a instância atual representam o mesmo tipo.  
  
-   <paramref name="c" />é derivado direta ou indiretamente da instância atual. <paramref name="c" /> será derivado diretamente da instância atual se herdar da instância atual; <paramref name="c" /> será derivado indiretamente da instância atual se herdar de uma sucessão de uma ou mais classes que herdam da instância atual.  
  
-   A instância atual é uma interface implementada por <paramref name="c" />.  
  
-   <paramref name="c" /> é um parâmetro de tipo genérico, e a instância atual representa uma das restrições de <paramref name="c" />.  
  
     No exemplo a seguir, a instância atual é um objeto <see cref="T:System.Type" /> que representa a classe <see cref="T:System.IO.Stream" />. <c>GenericWithConstraint</c> é um tipo genérico cujo parâmetro de tipo genérico deve ser do tipo <see cref="T:System.IO.Stream" />. Passar o parâmetro de tipo genérico para o <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indica que uma instância do parâmetro de tipo genérico pode ser atribuída a um objeto <see cref="T:System.IO.Stream" />.  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <paramref name="c" />representa um valor de tipo e representa a instância atual <c>Nullable&lt;c&gt; </c> (<c>Nullable (Of c)</c> no Visual Basic).  
  
 <see langword="false" /> se nenhuma dessas condições for verdadeira, ou se <paramref name="c" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsAssignableFrom%2A> método pode ser usado para determinar se uma instância de `c` pode ser atribuído a uma instância do tipo atual, o método é mais útil quando você está tratando objetos cujos tipos não são conhecidos no tempo de design e permite a atribuição condicional, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Esse método, portanto, garante que uma linha de código como o seguinte será executado em tempo de execução sem gerar uma <xref:System.InvalidCastException> exceção ou uma exceção semelhante:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Este método pode ser substituído por uma classe derivada.  
  
> [!NOTE]
>  Uma definição de tipo genérico não é atribuível de um tipo construído fechado. Ou seja, você não pode atribuir o tipo construído fechado `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) para uma variável do tipo `MyGenericList<T>`.  
  
 Se o `c` parâmetro é do tipo <xref:System.Reflection.Emit.TypeBuilder>, o resultado é baseado no tipo que deve ser criada. O exemplo de código a seguir demonstra isso usando um tipo interno chamado `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `IsAssignableFrom` usando o método definido classes, matrizes de inteiro e genéricos.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="AutoClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> seleciona os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são apresentados automaticamente pelo common language runtime.</summary>
        <value>
          <see langword="true" />Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos em memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar o <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo com o <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> valor de enumeração para o tipo, para permitir que o tempo de execução determinar o modo apropriado para dispor de classe.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo`MyGenericType<T>.`  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do tipo e exibe o <xref:System.Type.IsAutoLayout%2A> propriedade.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aprovado por referência.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter o tipo real, cancelar o tipo passado por referência e, em seguida, chamar <xref:System.Type.GetElementType%2A> nesse tipo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso de `IsByRef` propriedade para verificar se um tipo especificado é passado por referência. O exemplo define a classe `MyTypeDelegator`, que substitui o `HasElementTypeImpl` método. Verifica se a classe principal para o `HasElementType` propriedade e exibe o elemento de tipo.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.IsByRef" /> propriedade e determina se o <see cref="T:System.Type" /> é passada por referência.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for aprovado por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é uma classe ou um delegado; ou seja, não um tipo de valor ou interface.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for uma classe; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna `true` para classes, bem como delegados. Ele retorna `false` para tipos de valor (para estruturas e enumerações) mesmo se eles são demarcados.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade sempre retorna `true`. Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna `true` se a definição de tipo genérico é uma definição de classe; ou seja, ele não define uma interface ou um tipo de valor.  
  
> [!NOTE]
>  Essa propriedade retorna `true` para `Type` instâncias que representam o <xref:System.Enum> e <xref:System.ValueType> classes. Essas duas classes são os tipos de base para enumerações e tipos de valor, respectivamente, mas não são tipos de valor próprios ou enumerações. Para obter mais informações, consulte o <xref:System.Type.IsValueType%2A> e <xref:System.Type.IsEnum%2A> propriedades.  
  
 O <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valor de enumeração distingue uma declaração de tipo de classe ou interface. No entanto, as classes e tipos de valor são marcados com o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> atributo. Se você recuperar o valor de propriedade de atributos de um tipo e o uso de <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valor para determinar se um tipo é uma classe em vez de um tipo de valor, você também deve chamar o <xref:System.Type.IsValueType%2A> propriedade. O exemplo para o <xref:System.Reflection.TypeAttributes> enumeração contém informações adicionais, bem como anexample.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um tipo e indica se o tipo é uma classe.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um objeto COM.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna `false` para COM interfaces porque eles não são objetos. Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.  
  
 Você também pode carregar uma classe COM e obter um `Type` objeto para a classe COM usando o [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int`> (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.IsCOMObject" /> propriedade e determina se o <see cref="T:System.Type" /> é um objeto COM.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um objeto COM; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna `false` para COM interfaces porque eles não são objetos. Interfaces COM podem ser implementadas por objetos do Microsoft .NET Framework.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído. Você pode criar instâncias de um tipo genérico construído.</summary>
        <value>
          <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um tipo genérico construído teve tipos explícitos fornecidos para todos os seus parâmetros de tipo genérico. Ele também é chamado como um tipo genérico fechado.  
  
 Quando essa propriedade é `true`, você pode criar instâncias do tipo atual; quando ele for `false`, não é possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> pode ser hospedado em um contexto; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um contexto intercepta chamadas para os membros de classe e impõe políticas que são aplicadas à classe, como sincronização. Para obter mais informações sobre os contextos de comunicação remota, consulte <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades da <xref:System.Type> classe. Ele verifica se o tipo de dado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa o <see cref="P:System.Type.IsContextful" /> propriedade e determina se o <see cref="T:System.Type" /> pode ser hospedado em um contexto.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Type" /> pode ser hospedado em um contexto; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
 Um contexto intercepta chamadas para os membros de classe e imponha políticas que são aplicadas à classe, como sincronização.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso de `IsContextfulImpl` método.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma enumeração.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> atual representar uma enumeração; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna `true` para uma enumeração, mas não para o <xref:System.Enum> digite em si.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `IsEnum` propriedade.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser testado.</param>
        <summary>Retorna um valor que indica se o valor especificado existe no tipo de enumeração atual.</summary>
        <returns>
          <see langword="true" />Se o valor especificado for um membro do tipo de enumeração atual; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O tipo atual não é uma enumeração.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> é de um tipo que não pode ser o tipo subjacente de uma enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">A equivalência do tipo de COM é testado em relação ao tipo atual.</param>
        <summary>Determina se dois tipos COM têm a mesma identidade e são elegíveis para equivalência de tipo.</summary>
        <returns>
          <see langword="true" />Se os tipos COM forem equivalentes; Caso contrário, <see langword="false" />. Esse método também retornará <see langword="false" />, se for um tipo for um assembly que é carregado para execução e o outro está em um assembly que é carregado no contexto de somente reflexão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a inserção de informações de tipo para tipos COM diretamente para assemblies gerenciados, em vez de exigir os assemblies gerenciados obter informações de tipo para tipos COM de assemblies de interoperabilidade dá suporte a common language runtime. Como as informações de tipo inserido incluem somente os tipos e os membros que são realmente usados por um assembly gerenciado, dois assemblies gerenciados podem ter exibições muito diferentes do mesmo tipo COM. Cada assembly gerenciado tem um objeto <xref:System.Type> diferente para representar sua exibição do tipo COM. O Common Language Runtime dá suporte à equivalência de tipo entre essas exibições diferentes para interfaces, estruturas, enumerações e representantes.  
  
 Equivalência de tipo significa que um objeto COM que é passado de um assembly gerenciado para outro pode ser convertido no tipo gerenciado apropriado no assembly receptor. O <xref:System.Type.IsEquivalentTo%2A> método permite que um assembly determinar se um objeto COM obtido de outro assembly tem a mesma identidade COM um dos tipos de interoperabilidade do primeiro assembly próprio inserido e, portanto, pode ser convertido em tipo.  
  
 Para obter mais informações, consulte [equivalência de tipo e tipos de interoperabilidade inserido](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são dispostos em deslocamentos explicitamente especificados.</summary>
        <value>
          <see langword="true" />Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos em memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar o <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo com o <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que os deslocamentos no qual os campos Início for especificados explicitamente.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um tipo e exibe o valor da sua <xref:System.Type.IsExplicitLayout%2A> propriedade. Ele usa o `MySystemTime` classe, que também está no código de exemplo para <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa um parâmetro de tipo na definição de um tipo ou método genérico.</summary>
        <value>
          <see langword="true" /> se o objeto <see cref="T:System.Type" /> representar um parâmetro de tipo de uma definição de tipo genérico ou de método genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>objetos que representam os parâmetros de tipo genérico podem ser obtidos chamando o <xref:System.Type.GetGenericArguments%2A> método de um <xref:System.Type> objeto que representa uma definição de tipo genérico, ou o <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método de um <xref:System.Reflection.MethodInfo> objeto que representa uma definição de método genérico.  
  
-   Para um tipo genérico ou definição de método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `true` para cada elemento da matriz resultante.  
  
-   Para um tipo construído fechado ou método, o <xref:System.Type.IsGenericParameter%2A> propriedade retorna `false` para cada elemento da matriz retornada pelo <xref:System.Type.GetGenericArguments%2A> método.  
  
-   Para um tipo construído aberto ou método, alguns elementos da matriz podem ser tipos específicos e outros podem ser parâmetros de tipo. <xref:System.Type.IsGenericParameter%2A>Retorna `false` para os tipos e `true` para os parâmetros de tipo. O exemplo de código para o <xref:System.Type.ContainsGenericParameters%2A> propriedade demonstra uma classe genérica com uma mistura de tipos e parâmetros de tipo.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.IsGenericParameter%2A> propriedade para testar os parâmetros de tipo genérico em um tipo genérico.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é um tipo genérico.</summary>
        <value>
          <see langword="true" />Se o tipo atual é um tipo genérico; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Type.IsGenericType%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo genérico. Use o <xref:System.Type.ContainsGenericParameters%2A> propriedade para determinar se um <xref:System.Type> objeto representa um tipo construído aberto ou um tipo construído fechado.  
  
> [!NOTE]
>  O <xref:System.Type.IsGenericType%2A> propriedade retorna `false` se o tipo de imediato não é genérico. Por exemplo, uma matriz cujos elementos são do tipo `A<int>` (`A(Of Integer)` no Visual Basic) é um tipo genérico, não em si.  
  
 A tabela a seguir resume as condições invariáveis para termos comuns usados em reflexão genérico.  
  
|Termo|Constante|  
|----------|---------------|  
|definição de tipo genérico|A propriedade <xref:System.Type.IsGenericTypeDefinition%2A> é `true`.<br /><br /> Define um tipo genérico. Um tipo construído é criado chamando o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> do objeto que representa uma definição de tipo genérico e especificando uma matriz de argumentos de tipo.<br /><br /> <xref:System.Type.MakeGenericType%2A>pode ser chamado apenas em definições de tipo genérico.<br /><br /> Qualquer definição de tipo genérico é um tipo genérico (o <xref:System.Type.IsGenericType%2A> é de propriedade `true`), mas o contrário não é válido.|  
|tipo genérico|A propriedade <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> Pode ser uma definição de tipo genérico, um tipo construído aberto ou um tipo construído fechado.<br /><br /> Observe que uma matriz de tipo cujo tipo de elemento é genérico é um tipo genérico, não em si. O mesmo é verdadeiro para um <xref:System.Type> objeto que representa um ponteiro para um tipo genérico.|  
|Abra o tipo construído|A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.<br /><br /> Os exemplos são um tipo genérico que tem não atribuídos a parâmetros de tipo, um tipo que está aninhado em uma definição de tipo genérico ou em um tipo construído aberto ou um tipo genérico que tem um argumento de tipo para o qual o <xref:System.Type.ContainsGenericParameters%2A> é de propriedade `true`.<br /><br /> Não é possível criar uma instância de um tipo construído aberto.<br /><br /> Observe que tipos construídos abertos não genéricos. Por exemplo, uma matriz cujo tipo de elemento é uma definição de tipo genérico não é genérica e um ponteiro para um tipo construído aberto não é genérico.|  
|tipo construído fechado|A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `false`.<br /><br /> Quando examinada recursivamente, o tipo não tem nenhum parâmetro genérico não atribuído.|  
|parâmetro de tipo genérico|A propriedade <xref:System.Type.IsGenericParameter%2A> é `true`.<br /><br /> A propriedade <xref:System.Type.ContainsGenericParameters%2A> é `true`.<br /><br /> Em uma definição de tipo genérico, um espaço reservado para um tipo que será atribuído mais tarde.|  
|argumento de tipo genérico|Pode ser qualquer tipo, incluindo um parâmetro de tipo genérico.<br /><br /> Argumentos de tipo são especificados como uma matriz de <xref:System.Type> objetos passados para o <xref:System.Type.MakeGenericType%2A> método durante a criação de um tipo genérico construído. Se as instâncias do tipo resultante devem ser criados, o <xref:System.Type.ContainsGenericParameters%2A> propriedade deve ser `false` para todos os argumentos de tipo.|  
  
 O exemplo de código e a tabela a seguir ilustram algumas dessas condições e invariáveis. O `Derived` classe é de particular interesse porque seu tipo base é um tipo construído com uma mistura de tipos e parâmetros de tipo na sua lista de argumentos de tipo.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 A tabela a seguir exemplos que usam e criar as classes `Base`, `Derived`, e `G`. Quando o código C++ e c# é o mesmo, apenas uma entrada é mostrada.  
  
|Exemplo|Invariáveis|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `true`.|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Para este tipo:<br /><br /> <xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `true`.|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Para o tipo da variável `d`:<br /><br /> <xref:System.Type.IsGenericType%2A>é `false` porque `d` é uma matriz.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> é `false`.|  
|`T`, `U`, e `V` (everywhere aparecem)|<xref:System.Type.IsGenericParameter%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericType%2A>é `false` porque não há nenhuma maneira de restringir um parâmetro de tipo para tipos genéricos.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>é `true` porque `T`, `U`, e `V` são parâmetros de tipo genérico. Isso não significa nada sobre os argumentos de tipo que são atribuídos a eles mais tarde.|  
|O tipo de campo`F`|<xref:System.Type.IsGenericType%2A> é `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>é `false` porque um tipo foi atribuído a para o parâmetro de tipo de `G`. Observe que isso é equivalente a ter chamado o <xref:System.Type.MakeGenericType%2A> método.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>é `true` porque o tipo de campo `F` tem um argumento de tipo que é um tipo construído aberto. O tipo construído é aberto como seu argumento de tipo (ou seja, `Base`) é uma definição de tipo genérico. Isso ilustra a natureza recursiva do <xref:System.Type.IsGenericType%2A> propriedade.|  
|A classe aninhada`Nested`|<xref:System.Type.IsGenericType%2A>é `true`, mesmo que o `Nested` classe não tem nenhum parâmetro de tipo genérico de seu próprio, porque ele está aninhado em um tipo genérico.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> é `true`. Ou seja, você pode chamar o <xref:System.Type.MakeGenericType%2A> método e fornecer o parâmetro de tipo do tipo delimitador, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>é `true` porque o tipo de circunscrição, `Derived`, tem parâmetros de tipo genérico. Isso ilustra a natureza recursiva do <xref:System.Type.ContainsGenericParameters%2A> propriedade.|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor da <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, e <xref:System.Type.ContainsGenericParameters%2A> propriedades para os tipos descritos na seção comentários. Para obter explicações sobre os valores de propriedade, consulte a tabela a seguir em comentários.  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> atual representa uma definição de tipo genérico, da qual outros tipos genéricos podem ser construídos.</summary>
        <value>
          <see langword="true" /> se o objeto <see cref="T:System.Type" /> representar uma definição de tipo genérico, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma definição de tipo genérico é um modelo do qual os outros tipos podem ser criados. Por exemplo, da definição de tipo genérico `G<T>` (expresso na sintaxe do c#; `G(Of T)` no Visual Basic ou `generic <typename T> ref class G` em C++) você pode criar e instanciar o tipo `G<int>` (`G(Of Integer)` no Visual Basic), chamando o <xref:System.Type.MakeGenericType%2A> método com uma lista de argumento genérico que contém o <xref:System.Int32> tipo. Dado um <xref:System.Type> construída de objeto que representa este tipo, o <xref:System.Type.GetGenericTypeDefinition%2A> método obtém a definição de tipo genérico volta novamente.  
  
 Use o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade para determinar se você pode criar novos tipos do tipo atual. Se o <xref:System.Type.IsGenericTypeDefinition%2A> propriedade retorna `true`, você pode chamar o <xref:System.Type.MakeGenericType%2A> método para criar novos tipos genéricos.  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 O exemplo a seguir exibe informações sobre um tipo, incluindo se ele é uma definição de tipo genérico ou não. Informações são exibidas para um tipo construído, sua definição de tipo genérico e um tipo comum.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> tem um <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> atributo aplicado, indicando que ele foi importado de uma biblioteca de tipos COM.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> tem um <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o atual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade é determinado pelo`MyGenericType<T>.`  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto a ser comparado com o tipo atual.</param>
        <summary>Determina se o objeto especificado é uma instância do <see cref="T:System.Type" /> atual.</summary>
        <returns>
          <see langword="true" /> se o <see langword="Type" /> atual estiver na hierarquia de herança do objeto representado pelo <paramref name="o" /> ou se o <see langword="Type" /> atual for uma interface implementada por <paramref name="o" />. <see langword="false" /> se nenhuma dessas condições for verdadeira, se <paramref name="o" /> for <see langword="null" /> ou se o <see langword="Type" /> atual for um tipo genérico aberto (ou seja, <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" />).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
> [!NOTE]
>  Um tipo construído não é uma instância de sua definição de tipo genérico. Ou seja, `MyGenericList<int>` (`MyGenericList(Of Integer)` no Visual Basic) não é uma instância de `MyGenericList<T>` (`MyGenericList(Of T)` no Visual Basic).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do método `IsInstanceOfType`.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é uma interface, ou seja, não é uma classe ou um tipo de valor.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> é uma interface; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue uma declaração de tipo como classe, interface ou tipo de valor.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma interface, verifica o tipo de interface e indica se uma classe tem a `IsInterface` conjunto de propriedades.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os campos do tipo atual são apresentados em sequência, na ordem em que eles foram definidos ou emitidos nos metadados.</summary>
        <value>
          <see langword="true" />Se o <see cref="P:System.Type.Attributes" /> propriedade do tipo atual inclui <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida como uma conveniência. Como alternativa, você pode usar o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valor de enumeração para selecionar os atributos de tipo de layout e, em seguida, teste se <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> está definido. O <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType>, e <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> valores de enumeração indicam a maneira como os campos do tipo são dispostos em memória.  
  
 Para tipos dinâmicos, você pode especificar <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> quando você cria o tipo. No código, aplicar o <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo com o <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> valor de enumeração para o tipo, para especificar que o layout é sequencial.  
  
> [!NOTE]
>  Não é possível usar o <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar se o <xref:System.Runtime.InteropServices.StructLayoutAttribute> foi aplicado a um tipo.  
  
 Para obter mais informações, consulte a seção 9.1.2 da especificação para a documentação de infra-estrutura de linguagem comum (CLI), "Partição II: metadados definição e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de uma classe para o qual o <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> valor de enumeração no <xref:System.Runtime.InteropServices.StructLayoutAttribute> classe foi definida, verifica o <xref:System.Type.IsLayoutSequential%2A> propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é empacotado por referência.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> empacotado por referência; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra o `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades da <xref:System.Type> classe. Ele verifica se o tipo de dado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa o <see cref="P:System.Type.IsMarshalByRef" /> propriedade e determina se o <see cref="T:System.Type" /> é empacotado por referência.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Type" /> empacotado por referência; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pode ser substituído por uma classe derivada.  
  
   
  
## Examples  
 O exemplo a seguir determina se o tipo em questão é empacotado por referência e exibe o resultado.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto atual <see cref="T:System.Type" /> representa um tipo cuja definição está aninhada dentro da definição de outro tipo.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> está aninhado dentro de outro tipo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsNested%2A> propriedade retorna `true` para todos os tipos, independentemente de visibilidade aninhados. Para testar o aninhamento e visibilidade ao mesmo tempo, use as propriedades relacionadas <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, ou <xref:System.Type.IsNestedPublic%2A>.  
  
> [!NOTE]
>  O <xref:System.Reflection.TypeAttributes.VisibilityMask> membro de enumeração seleciona os atributos de visibilidade de um tipo.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é visível somente dentro de seu próprio assembly e aninhadas.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> aninhados e visíveis somente dentro de seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhadas e visíveis somente para classes que pertencem ao seu próprio família e seu próprio assembly.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> aninhados e visível somente para classes que pertencem ao seu próprio família e seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
> [!NOTE]
>  As linguagens c# e Visual Basic não incluem a semântica que permitem que você defina um tipo aninhado que é visível somente aos tipos protegidos em seu próprio assembly. `protected internal`visibilidade em c# e `Protected Friend` visibilidade no Visual Basic define um tipo aninhado que é visível para tipos protegidos e tipos no mesmo assembly.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos do mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é visível somente dentro de seu próprio família e aninhadas.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> aninhados e visíveis somente dentro de seu próprio família; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos de exato mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é visível somente para classes que pertencem a uma família de seu próprio ou seu próprio assembly e aninhadas.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> aninhados e visível somente para classes que pertencem à família de seu próprio ou seu próprio assembly; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a visibilidade de um tipo é `protected internal` em c# ou `Protected Friend` no Visual Basic, o <xref:System.Type.IsNestedFamORAssem%2A> propriedade retorna `true`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
 Um <xref:System.Type> família do objeto é definida como todos os objetos de exato mesmo <xref:System.Type> e de seus subtipos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é aninhados e declarado particular.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> é aninhados e declarado particular; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se uma classe é aninhada e declarado como pública.</summary>
        <value>
          <see langword="true" />Se a classe é declarado e aninhado público; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `false`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe externa com um número de classes aninhadas que têm vários tipos de visibilidade. Em seguida, recupera o valor de um número de visibilidade relacionadas <xref:System.Type> propriedades para o tipo de pai e cada um de seus tipos aninhados.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> não está declarado como público.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> não está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use essa propriedade com tipos aninhados; Use o <xref:System.Type.IsNestedPublic%2A> propriedade em vez disso.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `false`.  
  
   
  
## Examples  
 Este exemplo usesthe `IsNotPublic` para alterar a visibilidade do tipo.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir demonstra o motivo pelo qual você não pode usar `IsPublic` e `IsNotPublic` para classes aninhadas.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Para classes aninhadas, ignore os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas para os resultados de `IsNestedPublic` e `IsNestedPrivate`. A saída de reflexão para este fragmento de código seria a seguinte:  
  
|Classe|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|Um|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|FALSE|FALSE|TRUE|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um ponteiro.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso de `IsPointer` propriedade.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa o <see cref="P:System.Type.IsPointer" /> propriedade e determina se o <see cref="T:System.Type" /> é um ponteiro.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um ponteiro; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um dos tipos primitivos.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos primitivos são <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
 Caso o <xref:System.Type> atual representa um tipo genérico ou um parâmetro de tipo na definição de um tipo genérico ou um método genérico esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, e <xref:System.Type.IsPrimitive%2A> propriedades da <xref:System.Type> classe. Ele verifica se o tipo de dado pode ser hospedado no contexto, se ele pode ser empacotado por referência, e se o tipo é um tipo de dados primitivo.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, implementa a propriedade <see cref="P:System.Type.IsPrimitive" /> e determina se o <see cref="T:System.Type" /> é um dos tipos primitivos.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um dos tipos primitivos; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos primitivos são <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, e <xref:System.Single>.  
  
   
  
## Examples  
 O exemplo a seguir determina se o tipo fornecido é um tipo primitivo e exibe o resultado.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado como público.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> está declarado como público e não é um tipo aninhado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use com tipos aninhados; Use <xref:System.Type.IsNestedPublic%2A> em vez disso.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo de um tipo genérico, essa propriedade retornará `true`.  
  
 <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> seleciona os atributos de visibilidade.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de `MyTestClass`, verifica o `IsPublic` propriedade e exibe o resultado.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Para classes aninhadas, ignore os resultados de `IsPublic` e `IsNotPublic` e preste atenção apenas para os resultados de <xref:System.Type.IsNestedPublic%2A> e <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> está declarado como sealed.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Type" /> é declarado lacrado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo de um tipo genérico, esta propriedade sempre retorna `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de um `sealed` classe procura o `IsSealed` propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é crítico de segurança ou segurança-crítico para segurança no nível de confiança atual e, portanto, pode realizar operações críticas.</summary>
        <value>
          <see langword="true" />Se o tipo atual é crítico de segurança ou segurança-crítico para segurança no nível de confiança atual; <see langword="false" /> se é transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam. As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é safe-crítico de segurança no nível de confiança atual; ou seja, se ele pode realizar operações críticas e pode ser acessado pelo código de transparência.</summary>
        <value>
          <see langword="true" />Se o tipo atual é safe-crítico de segurança no nível de confiança atual; <see langword="false" /> se ele é crítico de segurança ou transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam. As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Segurança crítica|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é transparente no nível de confiança atual e, portanto, não é possível realizar operações críticas.</summary>
        <value>
          <see langword="true" />Se o tipo é transparente de segurança no nível de confiança atual; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade retorna `true`, o <xref:System.Type.IsSecurityCritical%2A> e <xref:System.Type.IsSecuritySafeCritical%2A> propriedades retorno `false`.  
  
 O <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, e <xref:System.Type.IsSecurityTransparent%2A> o nível de transparência do tipo em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam. Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
> [!IMPORTANT]
>  Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly. Se o assembly for carregado em um domínio de aplicativo parcialmente confiável (por exemplo, em um domínio de aplicativo em área restrita), o tempo de execução irá ignorar as anotações de segurança do assembly. O assembly e todos os tipos são tratados como transparentes. O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho). Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável. É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é serializável.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for serializável; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância de `MyTestClass` classe, define o atributo [Serializable] e verifica o `IsSerializable` propriedade `true` ou `false`.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo tem um nome que exige tratamento especial.</summary>
        <value>
          <see langword="true" /> se o tipo tiver um nome que exige tratamento especial; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes que começam com ou contenham um caractere de sublinhado (_), acessadores de propriedade e métodos de sobrecarga de operador são exemplos de tipos que podem exigir tratamento especial por alguns compiladores.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">O tipo a ser comparado com o tipo atual.</param>
        <summary>Determina se o <see cref="T:System.Type" /> atual deriva do <see cref="T:System.Type" /> especificado.</summary>
        <returns>
          <see langword="true" /> se o <see langword="Type" /> atual derivar de <paramref name="c" />; caso contrário, <see langword="false" />. Esse método também retorna <see langword="false" /> se <paramref name="c" /> e o <see langword="Type" /> atual forem iguais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode chamar o <xref:System.Type.IsSubclassOf%2A> método para determinar a qualquer um dos seguintes:  
  
-   Se uma classe derivada de outro.  
  
-   Se um tipo derivado de <xref:System.ValueType>. No entanto, o <xref:System.Type.IsValueType%2A> é uma maneira mais eficiente para determinar se um tipo é um tipo de valor.  
  
-   Se um tipo derivado de <xref:System.Enum>. No entanto, o <xref:System.Type.IsEnum%2A> é uma maneira mais eficiente para determinar se um tipo é uma enumeração.  
  
-   Se um tipo é um delegado, ou seja, se ele é derivado do <xref:System.Delegate> ou <xref:System.MulticastDelegate>.  
  
 O <xref:System.Type.IsSubclassOf%2A> método não pode ser usado para determinar se uma interface derivada de outra interface, ou se uma classe implementa uma interface. Use o <xref:System.Type.IsAssignableFrom%2A> método para essa finalidade, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, deriva de sua restrição de classe ou de <xref:System.Object?displayProperty=nameWithType> se nenhuma restrição de classe.  
  
> [!NOTE]
>  Exceto quando usado com interfaces, <xref:System.Type.IsSubclassOf%2A> é o oposto de <xref:System.Type.IsAssignableFrom%2A>. Ou seja, se `t1.IsSubclassOf(t2)` é `true`, em seguida, `t2.IsAssignableFrom(t1)` também é `true`.  
  
 Este método pode ser substituído por uma classe derivada.  
  
   
  
## Examples  
 O exemplo a seguir cria uma classe denominada `Class1` e uma classe derivada chamada `DerivedC1`. Ele chama o <xref:System.Type.IsSubclassOf%2A> método para mostrar que `DerivedC1` é uma subclasse de `Class1`.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="c" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> está selecionado para o <see cref="T:System.Type" />.</summary>
        <value>
          <see langword="true" /> se o atributo de formato da cadeia de caracteres <see langword="UnicodeClass" /> estiver selecionado para o <see cref="T:System.Type" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.TypeAttributes.StringFormatMask> é usado para selecionar os atributos de formato de cadeia de caracteres. Os atributos de formato de cadeia de caracteres melhorar a interoperabilidade, definindo como cadeias de caracteres devem ser interpretadas.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Type" /> é um tipo de valor.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tipos de valor são tipos que são representados como sequências de bits; tipos de valor não são classes ou interfaces. Tipos de valor são denominados "estruturas" em algumas linguagens de programação. Enumerações são um caso especial de tipos de valor.  
  
 Essa propriedade retorna `false` para o <xref:System.ValueType> classe porque <xref:System.ValueType> não é um tipo de valor. É a classe base para todos os tipos de valor e, portanto, qualquer tipo de valor pode ser atribuído a ele. Isso não seria possível se <xref:System.ValueType> próprio era de um tipo de valor. Tipos de valor são boxed quando eles forem atribuídos a um campo do tipo <xref:System.ValueType>.  
  
 Essa propriedade retorna `true` para enumerações, mas não para o <xref:System.Enum> digite em si. Para obter um exemplo que demonstra esse comportamento, consulte <xref:System.Type.IsEnum%2A>.  
  
 Esta propriedade é somente para leitura.  
  
   
  
## Examples  
 O exemplo a seguir cria uma variável do tipo `MyEnum`, verifica o `IsValueType` propriedade e exibe o resultado.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementa o <see cref="P:System.Type.IsValueType" /> propriedade e determina se o <see cref="T:System.Type" /> é um tipo de valor; ou seja, não uma classe ou uma interface.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Type" /> for um tipo de valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é fornecido para permitir a implementação de sistemas do tipo alternativo. Ele não é geralmente usado no código do aplicativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se <see cref="T:System.Type" /> pode ser acessado pelo código fora do assembly.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Type" /> atual é um tipo público ou um tipo público aninhado, de modo que todos os tipos de delimitadores são públicos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade para determinar se um tipo é parte da interface pública de um componente de assembly.  
  
   
  
## Examples  
 O exemplo de código a seguir testa duas classes, somente um deles é visível fora do assembly.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira de gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.  
  
 **Observação** o common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseadas em zero) e matrizes multidimensionais. Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional acontece ter apenas uma dimensão. Essa sobrecarga de método só pode ser usada para criar tipos de vetor e é a única maneira de criar um tipo de vetor. Use o <xref:System.Type.MakeArrayType%28System.Int32%29> sobrecarga do método para criar tipos de matriz multidimensional.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
 -ou-  
  
 O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">O número de dimensões da matriz. Esse número deve ser menor ou igual a 32.</param>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa uma matriz do tipo atual, com o número especificado de dimensões.</summary>
        <returns>Um objeto que representa uma matriz do tipo atual, com o número especificado de dimensões.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeArrayType%2A> método fornece uma maneira de gerar tipos de matriz cujos tipos de elemento são calculados em tempo de execução.  
  
> [!NOTE]
>  O common language runtime faz uma distinção entre os vetores (ou seja, matrizes unidimensionais que sempre são baseadas em zero) e matrizes multidimensionais. Um vetor, que sempre tem apenas uma dimensão, não é o mesmo que uma matriz multidimensional acontece ter apenas uma dimensão. Você não pode usar essa sobrecarga de método para criar um tipo de vetor. Se `rank` for 1, essa sobrecarga de método retorna um tipo de matriz multidimensional que ocorre ter uma dimensão. Use o <xref:System.Type.MakeArrayType> sobrecarga do método para criar tipos de vetor.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" /> é inválido. Por exemplo, 0 ou negativo.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
 -ou-  
  
 O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.  
  
 -ou-  
  
 <paramref name="rank" />é maior do que 32.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</summary>
        <returns>Um objeto <see cref="T:System.Type" /> que representa o tipo atual quando passado como um parâmetro <see langword="ref" /> (parâmetro <see langword="ByRef" /> no Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeByRefType%2A> método fornece uma maneira de gerar `ref` tipos (`ByRef` no Visual Basic) para o parâmetro de lista.  
  
 Usando a sintaxe de linguagem intermediária da Microsoft (MSIL), se o atual <xref:System.Type> objeto <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32&`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
 -ou-  
  
 O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Uma matriz de tipos a serem substituídos pelos parâmetros de tipo do tipo genérico atual.</param>
        <summary>Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de tipo genérico atual e retorna um objeto <see cref="T:System.Type" /> que representa o tipo construído resultante.</summary>
        <returns>Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakeGenericType%2A> método permite que você escreva código que atribui tipos específicos para os parâmetros de tipo de uma definição de tipo genérico, criando assim uma <xref:System.Type> objeto que representa um determinado tipo construído. Você pode usar isso <xref:System.Type> objeto para criar instâncias de tempo de execução do tipo construído.  
  
 Tipos construídos com <xref:System.Type.MakeGenericType%2A> pode ser aberto, ou seja, alguns de seus argumentos de tipo podem ser parâmetros de tipo de delimitador tipos ou métodos genéricos. Você pode usar esses tipos construídos abertos quando você emite conjuntos dinâmicos. Por exemplo, considere as classes `Base` e `Derived` no código a seguir.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Para gerar `Derived` em um assembly dinâmico, é necessário construir seu tipo base. Para fazer isso, chame o <xref:System.Type.MakeGenericType%2A> método em um <xref:System.Type> que representa a classe de objeto `Base`, usando os argumentos de tipo genérico <xref:System.Int32> e o parâmetro de tipo `V` de `Derived`. Como os parâmetros de tipo genérico e tipos são representados por <xref:System.Type> objetos, uma matriz que contém ambos pode ser passada para o <xref:System.Type.MakeGenericType%2A> método.  
  
> [!NOTE]
>  Um tipo construído como `Base<int, V>` é útil ao emitir código, mas você não pode chamar o <xref:System.Type.MakeGenericType%2A> método neste tipo porque ele não é uma definição de tipo genérico. Para criar um tipo construído fechado que pode ser instanciado, primeiro chame o <xref:System.Type.GetGenericTypeDefinition%2A> método para obter um <xref:System.Type> representa a definição de tipo genérico do objeto e, em seguida, chamar <xref:System.Type.MakeGenericType%2A> com os argumentos de tipo desejado.  
  
 O <xref:System.Type> objeto retornado por <xref:System.Type.MakeGenericType%2A> é igual a <xref:System.Type> obtida chamando o <xref:System.Object.GetType%2A> método resultante construído tipo, ou o <xref:System.Object.GetType%2A> construída de método de qualquer tipo que foi criado no mesmo genérico usando os mesmos argumentos de tipo de definição de tipo.  
  
> [!NOTE]
>  Uma matriz de tipos genéricos não em si for um tipo genérico. Não é possível chamar <xref:System.Type.MakeGenericType%2A> em uma matriz de tipo como `C<T>[]` (`Dim ac() As C(Of T)` no Visual Basic). Para construir um tipo genérico fechado de `C<T>[]`, chame <xref:System.Type.GetElementType%2A> para obter a definição de tipo genérico `C<T>`; chame <xref:System.Type.MakeGenericType%2A> na definição de tipo genérico para criar o tipo construído; e, finalmente, chamar o <xref:System.Type.MakeArrayType%2A> método no tipo construído para criar o tipo de matriz. O mesmo é verdadeiro para tipos de ponteiro e `ref` tipos (`ByRef` no Visual Basic).  
  
 Para obter uma lista das condições invariáveis para termos usados na reflexão genérica, consulte os comentários da propriedade <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Tipos aninhados  
 Se um tipo genérico é definido usando c#, C++ ou Visual Basic, seus tipos aninhados são todos genéricos. Isso é verdadeiro mesmo se os tipos aninhados não possuem nenhum parâmetro de tipo de seus próprios, porque todos os três idiomas incluam parâmetros de tipo de inclusão nas listas de parâmetro de tipo de tipos aninhados. Considere as seguintes classes:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 A lista de parâmetro de tipo de classe aninhada `Inner` tem dois parâmetros de tipo, `T` e `U`, o primeiro deles é o parâmetro de tipo de sua classe de delimitador. Da mesma forma, a lista de parâmetro de tipo de classe aninhada `Innermost1` tem três parâmetros de tipo, `T`, `U`, e `V`, com `T` e `U` provenientes de suas classes de delimitadores. A classe aninhada `Innermost2` tem dois parâmetros de tipo, `T` e `U`, que vêm de suas classes de delimitadores.  
  
 Se a lista de parâmetros do tipo delimitador tem mais de um parâmetro de tipo, todos os parâmetros de tipo em ordem serão incluídos na lista de parâmetros de tipo do tipo aninhado.  
  
 Para construir um tipo genérico da definição de tipo genérico para um tipo aninhado, chame o <xref:System.Type.MakeGenericType%2A> com a matriz formado pela concatenação as matrizes de argumento de tipo de todos os tipos de circunscrição, começando com o tipo genérico externo e termina com a matriz de argumento de tipo de aninhada de tipo de método em si, se ele tem parâmetros de tipo de seu próprio. Para criar uma instância de `Innermost1`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém três tipos, a ser atribuído a T, U e V. Para criar uma instância de `Innermost2`, chame o <xref:System.Type.MakeGenericType%2A> método com uma matriz que contém dois tipos, a ser atribuído a T e U.  
  
 Os idiomas propagam os parâmetros de tipo de inclusão dessa maneira, você pode usar os parâmetros de tipo de um tipo de delimitador para definir campos de tipos aninhados. Caso contrário, os parâmetros de tipo não seria no escopo dentro de corpos de tipos aninhados. É possível definir tipos aninhados sem propagar os parâmetros de tipo de inclusão, emitindo código em assemblies dinâmicos ou usando o [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Considere o seguinte código para o MSIL assembler:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 Neste exemplo, não é possível definir um campo do tipo `T` ou `U` na classe `Innermost`, porque esses parâmetros de tipo não estão no escopo. O código a seguir assembler define classes aninhadas que se comportam da forma que faria se definida em C++, Visual Basic e c#:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar as classes aninhadas definidas nas linguagens de alto nível e observar esse esquema de nomenclatura.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.MakeGenericType%2A> método para criar um tipo construído da definição de tipo genérico para o <xref:System.Collections.Generic.Dictionary%602> tipo. Representa o tipo construído um <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos com chaves de cadeia de caracteres.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não representa uma definição de tipo genérica. Ou seja, <see cref="P:System.Type.IsGenericTypeDefinition" /> retorna <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> é <see langword="null" />.  
  
 -ou-  
  
 Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos em <paramref name="typeArguments" /> não é igual ao número de parâmetros de tipo na definição de tipo genérico atual.  
  
 -ou-  
  
 Nenhum elemento do <paramref name="typeArguments" /> satisfaz as restrições especificadas para o parâmetro de tipo correspondente do tipo genérico atual.  
  
 -ou-  
  
 <paramref name="typeArguments" />contém um elemento que é um tipo de ponteiro (<see cref="P:System.Type.IsPointer" /> retorna <see langword="true" />), um tipo por referência (<see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />), ou <see cref="T:System.Void" />.</exception>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base. As classes derivadas devem fornecer uma implementação.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa um ponteiro para o tipo atual.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa um ponteiro para o tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Type.MakePointerType%2A> método fornece uma maneira de gerar tipos de ponteiro para listas de parâmetros.  
  
 Usando a sintaxe de linguagem intermediária da Microsoft (MSIL), se o atual <xref:System.Type> objeto <xref:System.Int32>, esse método retorna um <xref:System.Type> objeto representando `Int32*`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria a matriz, `ref` (`ByRef` no Visual Basic) e os tipos de ponteiro para a classe `Test`.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
        <exception cref="T:System.TypeLoadException">O tipo atual é <see cref="T:System.TypedReference" />.  
  
 -ou-  
  
 O tipo atual é um tipo <see langword="ByRef" />. Ou seja, <see cref="P:System.Type.IsByRef" /> retorna <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</summary>
        <value>Um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um tipo ou um tipo aninhado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade substitui <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Portanto, quando você examinar um conjunto de <xref:System.Reflection.MemberInfo> objetos — por exemplo, a matriz retornada por <xref:System.Type.GetMembers%2A>— o <xref:System.Reflection.MemberInfo.MemberType%2A> propriedade retorna <xref:System.Reflection.MemberTypes?displayProperty=nameWithType> quando um determinado membro é um tipo aninhado.  
  
 Caso o <xref:System.Type> atual represente um tipo genérico construído, esta propriedade aplica-se à definição de tipo genérico a partir da qual o tipo foi construído. Por exemplo, se o <xref:System.Type> atual representar `MyGenericType<int>` (`MyGenericType(Of Integer)` no Visual Basic), o valor dessa propriedade será determinado por `MyGenericType<T>`.  
  
 Caso o <xref:System.Type> atual represente um parâmetro de tipo na definição de um tipo genérico ou um método genérico, esta propriedade sempre retorna <xref:System.Reflection.MemberTypes?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o `MemberType` campo como um parâmetro para o `GetMember` método:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa um valor ausente nas informações <see cref="T:System.Type" />. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o `Missing` campo para invocação por meio de reflexão para obter o valor padrão de um parâmetro. Se o `Missing` campo é passado para um valor de parâmetro e não há nenhum valor padrão para esse parâmetro, um <xref:System.ArgumentException> é gerada.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso do `Missing` campo para invocar um método com argumentos padrão.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Esse código gera a seguinte saída:  
  
 um = 10 b = 55.3 c = 12  
  
 um = 10 b = 1.3 c = 1  
  
 um = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo (a DLL) no qual o <see cref="T:System.Type" /> atual está definido.</summary>
        <value>O módulo no qual o <see cref="T:System.Type" /> atual está definido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o atual <xref:System.Type> representa um tipo genérico construído, essa propriedade retorna o módulo no qual a definição de tipo genérico foi definida. Por exemplo, se você criar uma instância de `MyGenericStack<int>`, o <xref:System.Type.Module%2A> propriedade para o tipo construído retorna o módulo no qual `MyGenericStack<T>` está definido.  
  
 Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o assembly que contém o tipo genérico que define `T`.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e `Module` propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o namespace do <see cref="T:System.Type" />.</summary>
        <value>O namespace do <see cref="T:System.Type" />; <see langword="null" /> se a instância atual não tiver nenhum namespace ou representar um parâmetro genérico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um namespace é um lógico tempo de design nomenclatura conveniência, usado principalmente para definir o escopo em um aplicativo e organizar as classes e outros tipos em uma única estrutura hierárquica. Do ponto de vista do tempo de execução, não há nenhum namespace.  
  
 Se o atual <xref:System.Type> representa o tipo de um genérico construído, essa propriedade retorna o namespace que contém a definição de tipo genérico. Da mesma forma, se o atual <xref:System.Type> representa um parâmetro genérico `T`, essa propriedade retorna o namespace que contém a definição de tipo genérico que define `T`.  
  
 Se o atual <xref:System.Type> objeto representa um parâmetro genérico, essa propriedade retornará `null`.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do `Namespace` e <xref:System.Type.Module%2A> propriedades e o <xref:System.Type.ToString%2A> método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois objetos <see cref="T:System.Type" /> são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois <see cref="T:System.Type" /> objetos não são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto de classe que foi usado para obter esse membro.</summary>
        <value>O objeto <see langword="Type" /> por meio do qual este objeto <see cref="T:System.Type" /> foi obtido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Type> objetos, o valor dessa propriedade é sempre o mesmo que o valor da <xref:System.Type.DeclaringType%2A> propriedade.  
  
   
  
## Examples  
 Este exemplo exibe o tipo refletido de uma classe aninhada.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O nome qualificado pelo assembly do <see cref="T:System.Type" /> a ser obtido.</param>
        <param name="throwIfNotFound">
          <see langword="true" />para lançar uma <see cref="T:System.TypeLoadException" /> se o tipo não pode ser encontrado; <see langword="false" /> para retornar <see langword="null" /> se o tipo não pode ser encontrado. A especificação de <see langword="false" /> também suprime algumas condições de exceção, mas não todas. Consulte a seção Exceções.</param>
        <param name="ignoreCase">
          <see langword="true" />para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>; <see langword="false" /> para realizar uma pesquisa diferencia maiusculas de minúsculas para <c>typeName</c>.</param>
        <summary>Obtém o <see cref="T:System.Type" /> com o nome especificado, especificando se deverá realizar uma pesquisa que diferencia maiúsculas de minúsculas e se deverá gerar uma exceção se o tipo não for encontrado. O tipo é carregado para reflexão apenas, não para execução.</summary>
        <returns>O tipo com o nome especificado, se for encontrado; caso contrário, <see langword="null" />. Caso o tipo não seja encontrado, o parâmetro <paramref name="throwIfNotFound" /> especifica se <see langword="null" /> é retornado ou uma exceção é lançada. Em alguns casos, uma exceção é lançada independentemente do valor de <paramref name="throwIfNotFound" />. Consulte a seção Exceções.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o assembly que contém o tipo já não estiver carregado no contexto exclusivo de reflexão, usando o <xref:System.Type.ReflectionOnlyGetType%2A> método é equivalente a primeiro ao carregar o assembly para reflexão, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método e, em seguida, carregar o tipo chamando o assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método. Para obter informações sobre nomes de assembly qualificado, consulte o <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propriedade. Para obter detalhes adicionais sobre como especificar nomes de tipo, consulte o <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método.  
  
 Se o assembly já foi carregado para execução, outra cópia é carregada no contexto exclusivo de reflexão.  
  
 O `throwIfNotFound` parâmetro especifica o que acontece quando o tipo não for localizado e também suprime determinadas outras condições de exceção, conforme descrito na seção de exceções. Algumas exceções são geradas, independentemente do valor de `throwIfNotFound`. Por exemplo, se o assembly não é válido, um <xref:System.BadImageFormatException> é acionada mesmo se `throwIfNotFound` é `false`.  
  
 Para obter mais informações sobre como usar o contexto exclusivo de reflexão, consulte [como: carregar Assemblies no contexto de only](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Um inicializador de classe é invocado e lança uma exceção.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwIfNotFound" /> é <see langword="true" /> e o tipo não foi encontrado.  
  
 -ou-  
  
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> contém caracteres inválidos como, por exemplo, uma guia inserida.  
  
 -ou-  
  
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="throwIfNotFound" /> é <see langword="true" /> e <paramref name="typeName" /> representa um tipo de matriz com um tamanho inválido.  
  
 -ou-  
  
 <paramref name="typeName" />representa uma matriz de <see cref="T:System.TypedReference" /> objetos.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" />não inclui o nome do assembly.  
  
 -ou-  
  
 <paramref name="throwIfNotFound" />é <see langword="true" /> e <paramref name="typeName" /> contém sintaxe inválida; por exemplo, "MyType [, *,]".  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tenha um tipo de ponteiro, um tipo <see langword="ByRef" /> ou <see cref="T:System.Void" /> como um dos argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico que tem um número incorreto de argumentos de tipo.  
  
 -ou-  
  
 <paramref name="typeName" /> representa um tipo genérico, e um dos argumentos de tipo não atende às restrições do parâmetro de tipo correspondente.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="throwIfNotFound" /> é <see langword="true" /> e o assembly ou uma de suas dependências não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly ou uma de suas dependências foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly ou uma de suas dependências não é válido.  
  
 -ou-  
  
 O assembly foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve o layout do tipo atual.</summary>
        <value>Obtém um <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que descreve os recursos de layout bruto do tipo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute>não é retornado pelo <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método. Em vez disso, use essa propriedade para obtê-lo.  
  
   
  
## Examples  
 Primeiro, o exemplo de código a seguir define uma classe, uma estrutura e uma estrutura com atributos de layout especial (as estruturas são aninhadas dentro da classe). O exemplo usa o <xref:System.Type.StructLayoutAttribute%2A> propriedade para obter um <xref:System.Runtime.InteropServices.StructLayoutAttribute> para cada tipo e exibe as propriedades dos atributos.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O método chamado não é suportado na classe base.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma <see langword="String" /> que representa o nome da <see langword="Type" /> atual.</summary>
        <returns>Uma <see cref="T:System.String" /> que representa o nome da <see cref="T:System.Type" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna o namespace de tempo de execução de linguagem comum totalmente qualificado e o nome para todos os tipos primitivos. Por exemplo, a c# instrução, `(long)0.Type().ToString()` retorna "System. Int64" em vez de simplesmente "Int64".  
  
 Se o atual <xref:System.Type> representa um tipo genérico, o tipo e seus argumentos de tipo são qualificados por namespace e tipo aninhado, mas não pelo assembly. Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, esse método retorna o nome não qualificado do parâmetro de tipo.  
  
   
  
## Examples  
 Este exemplo a seguir demonstra um uso do <xref:System.Type.Namespace%2A> e <xref:System.Type.Module%2A> propriedades e o `ToString` método <xref:System.Type>.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 O exemplo a seguir compara as cadeias de caracteres retornadas pelo <xref:System.Type.ToString%2A> método e o `Name`, <xref:System.Type.FullName%2A>, e <xref:System.Type.AssemblyQualifiedName%2A> propriedades.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador do <see cref="T:System.Type" /> atual.</summary>
        <value>O identificador do <see cref="T:System.Type" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle`encapsula um ponteiro para uma estrutura de dados interna que representa o tipo. Esse identificador é exclusivo durante o tempo de vida do processo. O identificador é válido somente no domínio do aplicativo no qual ele foi obtido.  
  
   
  
## Examples  
 O exemplo a seguir retorna o identificador do tipo correspondente e transmite o identificador para um método que obtém o tipo do identificador e o exibe.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">No momento, o .NET Compact Framework não dá suporte a essa propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o inicializador para o tipo.</summary>
        <value>Um objeto que contém o nome do construtor da classe para o <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicializadores de classe também estão disponíveis por meio de <xref:System.Type.FindMembers%2A> método, ou por meio de sobrecargas do <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, e <xref:System.Type.GetConstructors%2A> métodos que usam <xref:System.Reflection.BindingFlags> como um parâmetro.  
  
 Se o atual <xref:System.Type> representa um parâmetro de tipo na definição de um tipo genérico ou método genérico, essa propriedade retornará `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica o tipo fornecido pelo Common Language Runtime que representa esse tipo.</summary>
        <value>O tipo de sistema subjacente para o <see cref="T:System.Type" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
