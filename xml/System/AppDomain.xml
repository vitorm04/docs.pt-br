<Type Name="AppDomain" FullName="System.AppDomain">
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um domínio de aplicativo, que é um ambiente isolado em que os aplicativos são executados. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domínios de aplicativo, que são representados por <xref:System.AppDomain> objetos, ajuda a fornecer limites, descarregamento, segurança e isolamento para código gerenciado em execução.  
  
-   Use domínios de aplicativo para isolar as tarefas que podem colocar um processo. Se o estado do <xref:System.AppDomain> que está executando uma tarefa torna-se instável, a <xref:System.AppDomain> pode ser descarregado sem afetar o processo. Isso é importante quando um processo deve ser executado por longos períodos sem reiniciar. Você também pode usar domínios de aplicativo para isolar as tarefas que não devem compartilhar dados.  
  
-   Se um assembly é carregado no domínio de aplicativo padrão, ele não pode ser descarregado da memória enquanto o processo está em execução. No entanto, se você abrir um segundo domínio de aplicativo para carregar e executar o assembly, o assembly é descarregado quando o domínio de aplicativo é descarregado. Use essa técnica para minimizar o conjunto de trabalho de processos de execução demorada que usam ocasionalmente DLLs grandes.  
  
 Vários domínios de aplicativo podem executar em um único processo; No entanto, não há uma correlação entre domínios de aplicativo e segmentos. Vários threads podem pertencer a um único domínio de aplicativo e, enquanto um determinado thread não está limitado a um único domínio de aplicativo, a qualquer momento determinado, um thread é executado em um único domínio de aplicativo.  
  
 Domínios de aplicativo são criados usando o <xref:System.AppDomain.CreateDomain%2A> método. <xref:System.AppDomain>instâncias são usadas para carregar e executar assemblies (<xref:System.Reflection.Assembly>). Quando um <xref:System.AppDomain> é não mais em uso, ele pode ser descarregado.  
  
 O <xref:System.AppDomain> classe implementa um conjunto de eventos que habilitam aplicativos para responder quando um assembly é carregado, quando um domínio de aplicativo será descarregado, ou quando uma exceção sem tratamento.  
  
 Para obter mais informações sobre como usar domínios de aplicativo, consulte [domínios de aplicativo](~/docs/framework/app-domains/application-domains.md).  
  
 Essa classe implementa o <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, e <xref:System.Security.IEvidenceFactory> interfaces.  
  
 Você nunca deve criar um wrapper remoto para um <xref:System.AppDomain> objeto. Isso foi possível publicar uma referência remota ao <xref:System.AppDomain>, expor métodos, como <xref:System.AppDomain.CreateInstance%2A> para acesso remoto e efetivamente destruição de segurança de acesso de código para que <xref:System.AppDomain>. Mal-intencionado clientes conectando-se para a remota <xref:System.AppDomain> poderia obter acesso a qualquer recurso de <xref:System.AppDomain> tem acesso ao. Não criar wrappers remota para qualquer tipo que estende <xref:System.MarshalByRefObject> e que implementa os métodos que podem ser usados por clientes mal-intencionado para ignorar o sistema de segurança.  
  
> [!CAUTION]
>  O valor padrão para o <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> é de propriedade `false`. Essa configuração não é segura para serviços. Para impedir que serviços baixando código parcialmente confiável, defina essa propriedade como `true`.  
  
   
  
## Examples  
 Este exemplo mostra como criar um novo <xref:System.AppDomain>, criar uma instância de um tipo em que novos <xref:System.AppDomain>e se comunicar com o objeto do tipo. Além disso, este exemplo mostra como descarregar o <xref:System.AppDomain> fazendo com que o objeto a ser coletado como lixo.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o contexto de ativação para o domínio do aplicativo atual.</summary>
        <value>Um objeto que representa o contexto de ativação para o domínio de aplicativo atual ou <see langword="null" />, se o domínio não tiver contexto de ativação.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome do diretório a ser anexo ao caminho privado.</param>
        <summary>Anexa o nome do diretório especificado à lista de caminhos privado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O uso dessa propriedade não é recomendável, pois ele pode alterar o caminho de sondagem para assemblies depois que já foram carregados. Use a propriedade <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> em seu lugar.  
  
 O caminho particular ou caminho de pesquisa relativo é o caminho relativo para o diretório base onde o resolvedor de assembly sondas de assemblies privados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a identidade do aplicativo no domínio do aplicativo.</summary>
        <value>Um objeto que identifica o aplicativo no domínio do aplicativo.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações que descrevem as permissões concedidas a um aplicativo e se o aplicativo tem um nível de confiança que permite que ele seja executado.</summary>
        <value>Um objeto que encapsula informações de permissão e de relação de confiança do aplicativo no domínio do aplicativo.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O assembly exibe nome, no formato fornecido pelo <see cref="P:System.Reflection.Assembly.FullName" /> propriedade.</param>
        <summary>Retorna o nome para exibição do assembly depois que a diretiva foi aplicada.</summary>
        <returns>Uma cadeia de caracteres que contém o assembly de nome de exibição depois que a diretiva foi aplicada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.AppDomain.ApplyPolicy%2A> leva um assembly de nome de exibição e retorna o nome de exibição de pós política de. Isso é útil se você precisar carregar um assembly usando a política, porque o contexto exclusivo de reflexão não se aplica a política.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um assembly é carregado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.AssemblyLoadEventHandler> delegar para esse evento indica que o assembly foi carregado.  
  
 Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.AssemblyLoad> evento.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a resolução de um assembly falha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É responsabilidade do <xref:System.ResolveEventHandler> para esse evento retornar o assembly que é especificado pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade, ou para retornar null se o assembly não é reconhecido. O assembly deve ser carregado em um contexto de execução; Se ele é carregado no contexto exclusivo de reflexão, a carga que causou este evento a ser gerado falhará.  
  
 Para obter diretrizes sobre o uso desse evento, consulte [Resolvendo carregamentos de Assembly](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade retorna o assembly que pediu a carga de assembly não pôde ser resolvida. Por exemplo, o carregador pode ser não é possível carregar uma dependência do solicitante assembly porque o assembly solicitante e sua dependência não estão no caminho de investigação. Saber a identidade do solicitante assembly pode ser úteis na localização de dependência ou identificar a versão correta, se houver mais de uma versão da dependência. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o <xref:System.ResolveEventHandler> é gerado para todos os assemblies, incluindo módulos de recursos. Em versões anteriores, o evento não foi gerado para módulos de recursos. Se o sistema operacional está localizado, o manipulador pode ser chamado várias vezes: uma vez para cada cultura na cadeia de fallback.  
  
 Para esse evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade retorna o nome do assembly, antes da política é aplicada.  
  
> [!IMPORTANT]
>  Se mais de um manipulador de eventos é registrado para esse evento, o evento handlersarecalled na ordem até que um manipulador de eventos retorna um valor que não é `null`. Manipuladores de eventos subsequentes serão ignorados.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o diretório base usado pelo resolvedor de assembly para investigar assemblies.</summary>
        <value>O diretório base usado pelo resolvedor de assembly para investigar assemblies.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade corresponde do <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> propriedade. Ele também pode ser recuperado usando o <xref:System.AppDomain.GetData%2A> método com a cadeia de caracteres "APPBASE".  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo domínio de aplicativo, especificando um diretório base a ser usado ao procurar por assemblies para carregar no domínio. O exemplo usa o <xref:System.AppDomain.BaseDirectory%2A> propriedade para obter o caminho de diretório base para exibição no console.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar as informações no caminho em si, incluindo se, o caminho está no formato "file://" ou \\\UNC\dir ou "c:\\". Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine o caminho que especifica o local dos assemblies privados para a cadeia de caracteres vazia ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho particular é um caminho relativo para o diretório base do que o common language runtime pesquisa para localizar assemblies privados.  
  
 Para obter mais informações, consulte <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.AppDomain.ClearPrivatePath%2A> método para remover todas as entradas da lista de caminhos privadas para pesquisar quando os assemblies são carregados.  
  
 Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine a lista de diretórios que contêm assemblies de cópia de sombra para a cadeia de caracteres vazia ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho de cópia de sombra é uma lista de diretórios onde a sombra copiados assemblies são armazenados.  
  
 Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> e [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de um arquivo que contém um assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome do tipo solicitado.</param>
        <summary>Cria uma nova instância de um tipo COM especificado. Parâmetros especificam o nome de um arquivo que contém um assembly que contém o tipo e o nome do tipo.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.  
  
 O valor de retorno deve para ser desencapsulamento para acessar o objeto real.  
  
 Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">O tipo não pode ser carregado.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público sem parâmetros foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />é uma classe abstrata.  
  
 -ou-  
  
 Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">O objeto COM que está sendo referenciado é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de um arquivo que contém um assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome do tipo solicitado.</param>
        <param name="hashValue">Representa o valor do código hash computado.</param>
        <param name="hashAlgorithm">Representa o algoritmo de hash usado pelo manifesto do assembly.</param>
        <summary>Cria uma nova instância de um tipo COM especificado. Parâmetros especificam o nome de um arquivo que contém um assembly que contém o tipo e o nome do tipo.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar objetos remotamente sem a necessidade de carregar o tipo localmente.  
  
 O valor de retorno deve para ser desencapsulamento para acessar o objeto real.  
  
 Um <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo com um valor de `true` deve ser aplicado explicitamente ou por padrão para o tipo de COM para esse método para criar uma instância desse tipo; caso contrário, <xref:System.TypeLoadException> é gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">O tipo não pode ser carregado.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público sem parâmetros foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" />é uma classe abstrata.  
  
 -ou-  
  
 Este membro foi invocado com um mecanismo de associação tardia.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> é a cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">O objeto COM que está sendo referenciado é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio.</param>
        <summary>Cria um novo domínio de aplicativo com o nome especificado.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `friendlyName` parâmetro destina-se para identificar o domínio de uma maneira que seja significativa para os usuários. Essa cadeia de caracteres deve ser adequada para exibição nas interfaces do usuário.  
  
 Essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.  
  
   
  
## Examples  
 O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio. Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio. Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidência que estabelece a identidade do código executado no domínio do aplicativo. Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</param>
        <summary>Cria um novo domínio do aplicativo com o nome especificado usando a evidência fornecida.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.  
  
 Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.  
  
> [!IMPORTANT]
>  Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita. Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo. Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.  
  
   
  
## Examples  
 O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio. Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio. Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidência que estabelece a identidade do código executado no domínio do aplicativo. Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</param>
        <param name="info">Um objeto que contém informações de inicialização do domínio do aplicativo.</param>
        <summary>Cria um novo domínio do aplicativo usando o nome, evidência e informações de instalação do domínio do aplicativo especificados.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `info` não é fornecido, essa sobrecarga de método usa o <xref:System.AppDomainSetup> informações do domínio de aplicativo padrão.  
  
 Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.  
  
> [!IMPORTANT]
>  Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita. Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo. Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.  
  
   
  
## Examples  
 O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio. Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio. Para obter mais informações, consulte a descrição de <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidência que estabelece a identidade do código executado no domínio do aplicativo. Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</param>
        <param name="info">Um objeto que contém informações de inicialização do domínio do aplicativo.</param>
        <param name="grantSet">Um conjunto de permissões padrão concedido a todos os assemblies carregados no novo domínio do aplicativo que não tem concessões específicas.</param>
        <param name="fullTrustAssemblies">Uma matriz de nomes fortes que representa os assemblies a serem considerados totalmente confiáveis no novo domínio do aplicativo.</param>
        <summary>Cria um novo domínio do aplicativo usando o nome, evidência, informações de configuração do domínio do aplicativo, conjunto de permissões padrão e a matriz de assemblies totalmente confiáveis especificados.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve definir o <xref:System.AppDomainSetup.ApplicationBase%2A> propriedade o <xref:System.AppDomainSetup> objeto que você fornecer para `info`. Caso contrário, uma exceção será gerada.  
  
 Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.  
  
 As informações fornecidas para `grantSet` e `fullTrustAssemblies` é usado para criar um <xref:System.Security.Policy.ApplicationTrust> objeto para o novo domínio de aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O domínio do aplicativo é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.AppDomainSetup.ApplicationBase" /> não está definida no objeto <see cref="T:System.AppDomainSetup" /> fornecido para <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de criar e manipular um domínio de aplicativo. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio. Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio. Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidência que estabelece a identidade do código executado no domínio do aplicativo. Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</param>
        <param name="appBasePath">O diretório base usado pelo resolvedor de assembly para investigar assemblies. Para obter mais informações, consulte <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">O caminho relativo ao diretório base em que o resolvedor do assembly deve investigar assemblies particulares. Para obter mais informações, consulte <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Se for <see langword="true" />, uma cópia de sombra de um assembly é carregada nesse domínio do aplicativo.</param>
        <summary>Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, o caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregada no domínio de aplicativo.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.  
  
 Para obter mais informações sobre a cópia de sombra, consulte <xref:System.AppDomain.ShadowCopyFiles%2A> e [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita. Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo. Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.  
  
   
  
## Examples  
 O exemplo a seguir demonstra, em geral, como criar um domínio usando uma das sobrecargas de <xref:System.AppDomain.CreateDomain%2A>.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">O nome amigável do domínio. Este nome amigável pode ser exibido nas interfaces do usuário para identificar o domínio. Para obter mais informações, consulte <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Evidência que estabelece a identidade do código executado no domínio do aplicativo. Passe <see langword="null" /> para usar a evidência do domínio de aplicativo atual.</param>
        <param name="appBasePath">O diretório base usado pelo resolvedor de assembly para investigar assemblies. Para obter mais informações, consulte <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">O caminho relativo ao diretório base em que o resolvedor do assembly deve investigar assemblies particulares. Para obter mais informações, consulte <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" /> para carregar uma cópia de sombra de um assembly no domínio de aplicativo.</param>
        <param name="adInit">Um delegado <see cref="T:System.AppDomainInitializer" /> que representa um método de retorno de chamada a ser invocado quando o novo objeto <see cref="T:System.AppDomain" /> for inicializado.</param>
        <param name="adInitArgs">Uma matriz de argumentos de cadeia de caracteres a serem passados para o retorno de chamada representado por <c>adInit</c>, quando o novo <see cref="T:System.AppDomain" /> objeto é inicializado.</param>
        <summary>Cria um novo domínio de aplicativo com o nome especificado, usando a evidência, o caminho base do aplicativo, o caminho de pesquisa relativo e um parâmetro que especifica se uma cópia de sombra de um assembly deve ser carregada no domínio de aplicativo. Especifica um método de retorno de chamada invocado quando o domínio de aplicativo é inicializado e uma matriz de argumentos de cadeia de caracteres para passar o método de retorno de chamada.</summary>
        <returns>O domínio de aplicativo recém-criado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método representado pela `adInit` é executado no contexto do domínio do aplicativo recém-criado.  
  
 Se `securityInfo` não for fornecido, a evidência do domínio de aplicativo atual será usada.  
  
 Para obter mais informações sobre a cópia de sombra, consulte <xref:System.AppDomain.ShadowCopyFiles%2A> e [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Não use essa sobrecarga de método para criar domínios de aplicativo em área restrita. Começando pelo [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], a evidência que é fornecida para `securityInfo` não afeta mais o conjunto de concessões do domínio do aplicativo. Use a sobrecarga do método <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> para criar domínios de aplicativo em área restrita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <summary>Cria uma nova instância do tipo especificado definido no assembly especificado.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o construtor padrão para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.  
  
 Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino. Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar. O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no assembly especificado. Um parâmetro especifica uma matriz de atributos de ativação.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o construtor padrão para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.  
  
 Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino. Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar. O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no assembly especificado. Os parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, informações específicas da cultura usadas para interpretar argumentos e atributos de ativação opcionais.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.  
  
 Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino. Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar. O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityAttributes">Informações usadas para autorizar a criação de <c>typeName</c>.</param>
        <summary>Cria uma nova instância do tipo especificado definido no assembly especificado. Parâmetros especificam um associador, sinalizadores de associação, argumentos de construtor, usado para interpretar os argumentos, atributos de ativação e autorização para criar o tipo de informações de cultura específica.</summary>
        <returns>Um objeto que é um wrapper para a nova instância especificada por <paramref name="typeName" />. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`.  
  
 Uma tentativa de chamar <xref:System.AppDomain.CreateInstance%2A> em um domínio de aplicativo de destino que não seja o domínio de aplicativo atual resultará em uma carga bem-sucedida do assembly no domínio de aplicativo de destino. Como um <xref:System.Reflection.Assembly> não é <xref:System.MarshalByRefObject>, quando esse método tenta retornar o <xref:System.Reflection.Assembly> do assembly carregado para o domínio de aplicativo atual, o Common Language Runtime tentará carregar o assembly no domínio do aplicativo atual e a carga poderá falhar. O assembly carregado no domínio de aplicativo atual pode ser diferente do assembly que foi carregado primeiro caso as configurações de caminho dos dois domínios de aplicativo sejam diferentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.  
  
 -ou-  
  
 <paramref name="securityAttributes" /> não é <see langword="null" />. Quando a política de CAS legada não estiver habilitada, <paramref name="securityAttributes" /> deve ser<see langword="null." /></exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <summary>Cria uma nova instância do tipo especificado. Parâmetros especificam o assembly no qual o tipo é definido e o nome do tipo.</summary>
        <returns>Uma instância do objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método chama o construtor padrão para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`. Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.  
  
> [!NOTE]
>  Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual. Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente. Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo. Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra a maneira mais simples para executar código em outro domínio de aplicativo. O exemplo define uma classe denominada `Worker` que herda de <xref:System.MarshalByRefObject>. O `Worker` classe define um método que exibe o nome do domínio do aplicativo no qual ele está em execução. O exemplo cria instâncias de `Worker` no domínio de aplicativo padrão e em um novo domínio de aplicativo.  
  
> [!NOTE]
>  O assembly que contém `Worker` devem ser carregados em ambos os domínios de aplicativo, mas ele pode carregar outros assemblies que existem somente no novo domínio de aplicativo.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">a capacidade de ler o arquivo que contém o manifesto do assembly, ou se você estiver criando um tipo de um módulo que não seja o arquivo de manifesto. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado. Parâmetros especificam o assembly no qual o tipo, o nome do tipo e uma matriz de atributos de ativação são definidos.</summary>
        <returns>Uma instância do objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método chama o construtor padrão para `typeName`.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`. Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.  
  
> [!NOTE]
>  Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual. Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente. Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo. Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Um objeto específico da cultura usado para controlar a coerção de tipos. Se <c>cultura</c> é <see langword="null" />, o <see langword="CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo indicado definido no assembly especificado, determinando se a diferenciação entre maiúsculas e minúsculas é ignorada no nome do tipo; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação.</summary>
        <returns>Uma instância do objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`. Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.  
  
> [!NOTE]
>  Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual. Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente. Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo. Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de `ignoreCase` parâmetro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de chamar código não gerenciado durante a criação de uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> usando reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Um objeto específico da cultura usado para controlar a coerção de tipos. Se <c>cultura</c> é <see langword="null" />, o <see langword="CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityAttributes">Informações usadas para autorizar a criação de <c>typeName</c>.</param>
        <summary>Cria uma nova instância do tipo especificado. Os parâmetros especificam o nome do tipo e como ele é encontrado e criado.</summary>
        <returns>Uma instância do objeto especificado por <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstance%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Consulte <xref:System.Reflection.AssemblyName> para o formato de `assemblyName`. Consulte a propriedade <xref:System.Type.FullName%2A?displayProperty=nameWithType> do formato de `typeName`.  
  
> [!NOTE]
>  Caso você faça uma chamada Early Bound para um método `M` de um objeto do tipo `T1` que foi retornado por <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> e esse método faça uma chamada Early Bound para um método de um objeto do tipo `T2` em um assembly `C` diferente do assembly atual ou do assembly que contém `T1`, o assembly `C` é carregado no domínio de aplicativo atual. Este carregamento ocorre mesmo se a chamada Early Bound para `T1.M()` tiver sido feita no corpo de um <xref:System.Reflection.Emit.DynamicMethod> ou em outro código gerado dinamicamente. Caso o domínio atual seja o domínio padrão, o assembly `C` não pode ser descarregado até o término do processo. Caso o domínio atual tente carregar posteriormente o assembly `C`, o carregamento pode falhar.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de `ignoreCase` parâmetro.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ou <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão para chamar esse construtor.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">a capacidade de invocar operações em todos os membros do tipo. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> método.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor padrão para `typeName` é invocado.  
  
 Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino. No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada. Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos. Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.  
  
-   Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.  
  
-   Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga do método para criar uma instância de um objeto em um domínio de aplicativo de destino e chamar seus métodos.  
  
 O exemplo define o `MarshallableExample` classe, que pode ser empacotado nos limites do domínio de aplicativo. O exemplo cria um caminho para o assembly em execução no momento, cria um domínio de aplicativo de destino e usa o <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga do método para carregar o assembly de exemplo para o domínio de aplicativo de destino e criar uma instância de `MarshallableExample`.  
  
> [!NOTE]
>  O caminho é absoluto neste exemplo, mas um caminho relativo, também pode funcionar como o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> método é usado para carregar o assembly.  
  
 Após o desencapsulamento o identificador de objeto, o exemplo demonstra três maneiras de usar um objeto em um domínio de aplicativo de destino:  
  
-   Invocando um método com associação tardia, usando a reflexão. Isso requer informações de tipo, que faz com que o assembly a ser carregado no domínio de aplicativo do chamador. (Neste exemplo, ele já está carregado.)  
  
-   Converter o objeto para uma interface conhecida para o chamador e o receptor. Se a interface está definida no assembly de chamada ou em um terceiro assembly referenciado pelo chamador e o receptor, o assembly de chamada não foi carregado para o domínio de aplicativo do chamador.  
  
-   Usando o objeto diretamente ao seu tipo é conhecido pelo chamador. O assembly deve ser carregado no domínio de aplicativo do chamador.  
  
 Outra maneira de evitar carregar o assembly de chamada para o domínio de aplicativo do chamador é para o chamador derivar o <xref:System.MarshalByRefObject> classe e para definir um método que pode ser executado no domínio de aplicativo de destino. Esse método pode usar reflexão para examinar um conjunto de destino, porque o assembly de destino já foi carregado para o domínio de aplicativo de destino. Consulte o exemplo para o <xref:System.AppDomain.DynamicDirectory%2A> propriedade.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">Não foi encontrado nenhum construtor público sem parâmetros.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> método.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor padrão para `typeName` é invocado.  
  
 Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino. No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada. Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos. Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.  
  
-   Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.  
  
-   Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> método.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino. No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada. Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos. Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.  
  
-   Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.  
  
-   Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome, inclusive o caminho, de um arquivo que contém um assembly que define o tipo solicitado. O assembly for carregado usando o <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> método.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityAttributes">Informações usadas para autorizar a criação de <c>typeName</c>.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>Um objeto que é um wrapper para a nova instância ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado. O valor de retorno precisa ser desencapsulado para acessar o objeto real.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Quando o método <xref:System.AppDomain.CreateInstanceFrom%2A> é usado para criar uma instância em um domínio de aplicativo de destino, outro que não seja o domínio de aplicativo do qual a chamada é feita, o assembly é carregado no domínio de aplicativo de destino. No entanto, caso a instância seja desencapsulada no domínio do aplicativo de chamada, o uso da instância desencapsulada de determinadas formas pode fazer o assembly ser carregado no domínio do aplicativo de chamada. Por exemplo, depois da instância ser desencapsulada, as informações de tipo poderão ser solicitadas, para chamar a associação tardia dos métodos. Quando o assembly é carregado no domínio de aplicativo de chamada, podem ocorrer exceções.  
  
-   Caso outra versão do mesmo assembly tenha sido carregada anteriormente no domínio do aplicativo de chamada ou caso o caminho de carregamento do domínio de aplicativo de chamada seja diferente do domínio do aplicativo de destino, exceções como <xref:System.MissingMethodException> podem ocorrer.  
  
-   Caso o domínio do aplicativo de chamada faça chamadas Early Bound para o tipo de instância, <xref:System.InvalidCastException> pode ser lançado quando uma tentativa é feita para converter a instância.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.  
  
 -ou-  
  
 <paramref name="securityAttributes" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="securityAttributes" /> deve ser <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NullReferenceException">Esta instância é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método chama o construtor padrão para `typeName`.  
  
 Para obter mais informações, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Não foi encontrado nenhum construtor público sem parâmetros.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, incluindo o namespace, mas não o assembly (consulte o <see cref="P:System.Type.FullName" /> propriedade).</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação pelo cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Este método chama o construtor padrão para `typeName`.  
  
 Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Não foi encontrado nenhum construtor público sem parâmetros.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado, especificando se o caso do nome do tipo é ignorado; os atributos de associação e o associador que são usados para selecionar o tipo a ser criado; os argumentos do construtor; a cultura; e os atributos de ativação.</summary>
        <returns>O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyName" />foi compilado com uma versão posterior do common language runtime que a versão que está sendo carregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de arquivo e o caminho do assembly que define o tipo solicitado.</param>
        <param name="typeName">O nome totalmente qualificado do tipo solicitado, inclusive o namespace, mas não o assembly, como retornado pela propriedade <see cref="P:System.Type.FullName" />.</param>
        <param name="ignoreCase">Um valor booliano especificando se é necessário executar uma pesquisa que diferencie maiúsculas de minúsculas ou não.</param>
        <param name="bindingAttr">Uma combinação de zero ou mais sinalizadores de bit que afetam a pesquisa para o <c>typeName</c> construtor. Se <c>bindingAttr</c> for zero, uma pesquisa diferencia maiusculas de minúsculas para construtores públicos será conduzida.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see cref="T:System.Reflection.MemberInfo" /> por meio da reflexão. Se <c>associador</c> é null, o associador padrão é usado.</param>
        <param name="args">Os argumentos a serem passados para o construtor. Esta matriz de argumentos deve corresponder em número, ordem e digitar os parâmetros do construtor a ser invocado. Se o construtor padrão é preferencial, <c>args</c> deve ser uma matriz vazia ou null.</param>
        <param name="culture">Informações específicas de cultura que governam a coerção de <c>args</c> para os tipos formais declarados para o <c>typeName</c> construtor. Se <c>cultura</c> é <see langword="null" />, o <see cref="T:System.Globalization.CultureInfo" /> para o segmento atual é usado.</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  
  
 Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <param name="securityAttributes">Informações usadas para autorizar a criação de <c>typeName</c>.</param>
        <summary>Cria uma nova instância do tipo especificado definido no arquivo de assembly especificado.</summary>
        <returns>O objeto solicitado ou <see langword="null" /> caso <paramref name="typeName" /> não seja encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este é um método prático que combina <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre esse método, consulte o método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O chamador não pode fornecer atributos de ativação para um objeto que não seja herdado de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> não foi encontrado em <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor público correspondente foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem permissão suficiente para chamar esse construtor.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">para a capacidade de ler o arquivo que contém o manifesto do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o domínio de aplicativo atual do <see cref="T:System.Threading.Thread" /> atual.</summary>
        <value>O domínio do aplicativo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria um novo domínio de aplicativo. O <xref:System.AppDomain.CurrentDomain%2A> propriedade é usada para obter um <xref:System.AppDomain> objeto que representa o domínio de aplicativo atual. O <xref:System.AppDomain.FriendlyName%2A> propriedade fornece o nome de domínio de aplicativo atual é exibido na linha de comando.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo de acesso para o assembly dinâmico.</param>
        <summary>Define um assembly dinâmico com o nome e o modo de acesso especificados.</summary>
        <returns>Um assembly dinâmico com o nome e o modo de acesso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo de acesso para o assembly dinâmico.</param>
        <param name="assemblyAttributes">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</param>
        <summary>Define um assembly dinâmico com o nome especificado, o modo de acesso e os atributos personalizados.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado. Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.  
  
 Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga do método.  
  
 Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar um assembly dinâmico que tem o <xref:System.Security.SecurityTransparentAttribute>. O atributo deve ser especificado como um elemento de uma matriz de <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos.  
  
 A primeira etapa na criação de <xref:System.Reflection.Emit.CustomAttributeBuilder> é obter um construtor para o atributo. O construtor não tem parâmetros, portanto, o <xref:System.Type.GetConstructor%2A> método for chamado com uma matriz vazia de <xref:System.Type> objetos para representar os tipos dos parâmetros. A segunda etapa é passar resultante <xref:System.Reflection.ConstructorInfo> objeto para o construtor para o <xref:System.Reflection.Emit.CustomAttributeBuilder> classe, junto com uma matriz vazia do tipo <xref:System.Object> para representar os argumentos.  
  
 Resultante <xref:System.Reflection.Emit.CustomAttributeBuilder> é então passado para o <xref:System.AppDomain.DefineDynamicAssembly%2A> método como o único elemento de uma matriz.  
  
 O exemplo de código define um módulo e um tipo no novo assembly dinâmico e, em seguida, exibe os atributos do assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="evidence">A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso e a evidência.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico. O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas. Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo. Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.  
  
 Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.DefineDynamicAssembly%2A> método e o <xref:System.AppDomain.AssemblyResolve> evento.  
  
 Primeiro, o exemplo de código tenta criar uma instância de `MyDynamicType` chamando o <xref:System.AppDomain.CreateInstance%2A> método com um nome de assembly inválido e captura a exceção resultante.  
  
 O exemplo de código, em seguida, adiciona um manipulador de eventos para o <xref:System.AppDomain.AssemblyResolve> eventos e novamente tenta criar uma instância de`MyDynamicType`. Durante a chamada para <xref:System.AppDomain.CreateInstance%2A>, o <xref:System.AppDomain.AssemblyResolve> é gerado para o assembly inválido. O manipulador de eventos cria um assembly dinâmico que contém um tipo denominado `MyDynamicType`, fornece o tipo de um construtor sem parâmetros e retorna o novo assembly dinâmico. A chamada para <xref:System.AppDomain.CreateInstance%2A> for concluída com êxito e o construtor para `MyDynamicType` exibe uma mensagem no console do.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly será salvo. Se <c>dir</c> é <see langword="null" />, o diretório padrão é o diretório atual.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso e o diretório de armazenamento.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo de acesso para o assembly dinâmico.</param>
        <param name="assemblyAttributes">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</param>
        <param name="securityContextSource">A origem do contexto de segurança.</param>
        <summary>Define um assembly dinâmico com o nome especificado, o modo de acesso e os atributos personalizados e usando a origem especificada para o seu contexto de segurança.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado. Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.  
  
 Esse método deve ser usado apenas para definir um assembly dinâmico no domínio do aplicativo atual. Para obter mais informações sobre essa restrição, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga do método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="securityContextSource" /> não era um dos valores de enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly será salvo. Se <c>dir</c> é <see langword="null" />, o diretório padrão é o diretório atual.</param>
        <param name="evidence">A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento e evidência.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico. O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas. Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo. Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.  
  
 Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso e a solicitações de permissão.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória. Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo em disco, use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence> objeto.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte o <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga do método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly dinâmico será salvo. Se <c>dir</c> é <see langword="null" />, o diretório atual é usado.</param>
        <param name="isSynchronized">
          <see langword="true" />para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <see langword="false" />.</param>
        <param name="assemblyAttributes">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento e opção de sincronização.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado. Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.  
  
 Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro é concluído.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="evidence">A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, evidência e solicitações de permissão.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
 Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico. O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas. Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo. Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.  
  
 Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly será salvo. Se <c>dir</c> é <see langword="null" />, o diretório padrão é o diretório atual.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, o diretório de armazenamento e a solicitações de permissão.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` não são usados, a menos que o assembly dinâmico foi salvo e recarregado na memória. Para especificar as solicitações de permissão para um assembly temporário que nunca é salvo em disco, use uma sobrecarga de <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica a evidência como solicitado bem como permissões e fornecer um <xref:System.Security.Policy.Evidence> objeto.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável usar uma sobrecarga do método <xref:System.AppDomain.DefineDynamicAssembly%2A> que especifica evidência e permissões, fornecer a evidência que você deseja que o assembly dinâmico tenha e incluir <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly será salvo. Se <c>dir</c> é <see langword="null" />, o diretório padrão é o diretório atual.</param>
        <param name="evidence">A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento, evidência e solicitações de permissão.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
 Apenas chamadores totalmente confiáveis podem fornecer `evidence` ao definir um <xref:System.Reflection.Assembly> dinâmico. O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas. Os chamadores parcialmente confiáveis devem fornecer um `evidence`nulo. Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.  
  
 Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.  
  
 Este método só deve ser usado para definir um assembly dinâmico no domínio de aplicativo atual. Para obter mais informações, consulte a sobrecarga de método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly dinâmico será salvo. Se <c>dir</c> é <see langword="null" />, o diretório padrão é o diretório atual.</param>
        <param name="evidence">A evidência fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <param name="isSynchronized">
          <see langword="true" />para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <see langword="false" />.</param>
        <summary>Define um assembly dinâmico usando o nome especificado, o modo de acesso, diretório de armazenamento, evidência, solicitações de permissão e opção de sincronização.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As solicitações de permissão especificadas para `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` são usados somente se `evidence` também for fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.  
  
> [!NOTE]
>  Durante o desenvolvimento de código que emite assemblies dinâmicos, é recomendável que você inclua <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> em `refusedPermissions`. A inclusão de <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> no parâmetro de `refusedPermissions` garante que o MSIL seja verificado. Uma limitação dessa técnica é que ela também faz <xref:System.Security.SecurityException> ser lançado quando usado com código que demanda confiança total.  
  
 Somente os chamadores totalmente confiáveis podem fornecer seu evidência ao definir um dinâmico <xref:System.Reflection.Assembly>. O tempo de execução mapeará <xref:System.Security.Policy.Evidence> pela política de segurança para determinar as permissões concedidas. Parcialmente confiável chamadores devem fornecer `null` para o `evidence` parâmetro. Caso `evidence` seja `null`, o tempo de execução copia os conjuntos de permissões, ou seja, os conjuntos de concessões e negações, do <xref:System.Reflection.Assembly> do chamador para o <xref:System.Reflection.Assembly> dinâmico definido e marca a política como resolvida.  
  
 Se o <xref:System.Reflection.Assembly> dinâmico for salvo em disco, os carregamentos subsequentes obterão concessões com base em políticas associadas ao local no qual o <xref:System.Reflection.Assembly> foi salvo.  
  
 Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que outra seja concluída.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o método <xref:System.AppDomain.DefineDynamicAssembly%2A> e o evento <xref:System.AppDomain.AssemblyResolve>.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">A identidade exclusiva do assembly dinâmico.</param>
        <param name="access">O modo no qual o assembly dinâmico será acessado.</param>
        <param name="dir">O nome do diretório onde o assembly dinâmico será salvo. Se <c>dir</c> é <see langword="null" />, o diretório atual é usado.</param>
        <param name="evidence">A evidência que é fornecida para o assembly dinâmico. A evidência é usada inalterada como o conjunto final de evidências usado na resolução da política.</param>
        <param name="requiredPermissions">A solicitação de permissões obrigatória.</param>
        <param name="optionalPermissions">A solicitação de permissões opcional.</param>
        <param name="refusedPermissions">A solicitação de permissões recusada.</param>
        <param name="isSynchronized">
          <see langword="true" />para sincronizar a criação de módulos, tipos e membros no assembly dinâmico; Caso contrário, <see langword="false" />.</param>
        <param name="assemblyAttributes">Uma lista de atributos enumeráveis a serem aplicados ao assembly ou <see langword="null" /> caso não haja nenhum atributo.</param>
        <summary>Define um assembly dinâmico com o nome especificado, o modo de acesso, diretório de armazenamento, evidência, solicitações de permissão, opção de sincronização e atributos personalizados.</summary>
        <returns>Um assembly dinâmico com o nome e os recursos especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta sobrecarga de método para especificar atributos que não funcionam corretamente, senão aplicados quando um assembly dinâmico é criado. Por exemplo, os atributos de segurança como <xref:System.Security.SecurityTransparentAttribute> e <xref:System.Security.SecurityCriticalAttribute> não funcionam corretamente caso sejam adicionados após um assembly dinâmico ser criado.  
  
 As solicitações de permissão especificadas para o `requiredPermissions`, `optionalPermissions`, e `refusedPermissions` parâmetros são usados somente se o `evidence` parâmetro também é fornecido, ou se o assembly dinâmico for salvo e recarregado na memória.  
  
> [!NOTE]
>  Ao desenvolver o código que emite assemblies dinâmicos, recomendamos que você inclua o <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> sinalizador no `refusedPermissions` parâmetro. A inclusão do sinalizador garante que a Microsoft intermediate language (MSIL) será verificado. Essa técnica detectará a geração não intencional de código não verificado, o que, normalmente, é muito difícil de detectar. Uma limitação dessa técnica é que ele também faz com que <xref:System.Security.SecurityException> seja gerada quando é usado com o código que exige confiança total.  
  
 Somente os chamadores totalmente confiáveis podem fornecer evidências ao definir um dinâmico <xref:System.Reflection.Assembly>. O tempo de execução mapeia o <xref:System.Security.Policy.Evidence> por meio da política de segurança para determinar as permissões concedidas. Parcialmente confiável chamadores devem fornecer `null` para o `evidence` parâmetro. Se `evidence` é `null`, o tempo de execução copia os conjuntos de permissões (isto é, a concessão atual e negar conjuntos) do assembly do chamador para o assembly dinâmico que está sendo definido e marca a política como resolvido.  
  
 Se o assembly dinâmico é salvo em disco, subsequente cargas receberá concessões com base nas políticas que estão associadas com o local onde o assembly dinâmico foi salvo.  
  
 Se `isSynchronized` é `true`, os seguintes métodos de resultante <xref:System.Reflection.Emit.AssemblyBuilder> serão sincronizados: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, e <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Se dois desses métodos são chamados em threads diferentes, um será bloqueado até que o outro é concluído.  
  
 Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade <see langword="Name" /> de <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 A propriedade <see langword="Name" /> de <paramref name="name" /> começa com espaço em branco ou contém uma barra ou uma barra invertida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Um delegado que especifica um método a ser chamado.</param>
        <summary>Executa o código em outro domínio de aplicativo que é identificado pelo delegado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate`pode especificar um marshal-por-valor, <xref:System.MarshalByRefObject>, ou <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um estático <xref:System.AppDomain.DoCallBack%2A> método.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.AppDomain.DoCallBack%2A> método por valor.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.AppDomain.DoCallBack%2A> método por referência.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o Gerenciador de domínio que foi fornecido pelo host quando o domínio do aplicativo foi inicializado.</summary>
        <value>Um objeto que representa o gerenciador de domínio fornecido pelo host quando o domínio do aplicativo foi inicializado ou <see langword="null" /> se nenhum gerenciador de domínio foi fornecido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um host não gerenciado do common language runtime (CLR) pode fornecer um Gerenciador de domínio. O Gerenciador de domínio pode participar de inicializar o novo domínio de aplicativo e fornece outros gerentes, como um <xref:System.Security.HostSecurityManager>, que participam de operações do domínio do aplicativo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um <see cref="T:System.AppDomain" /> está prestes a ser descarregado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.EventHandler> delegar para esse evento pode executar as atividades de encerramento antes que o domínio de aplicativo seja descarregado.  
  
 Cada domínio de aplicativo que precisa executar o processamento quando ela é descarregada deve registrar um manipulador de eventos para esse evento. Um manipulador de eventos compartilhado não deve ser usado porque o <xref:System.EventHandler> delegado não identifica o domínio que está sendo descarregado.  
  
> [!NOTE]
>  Esse evento é gerado nunca no domínio de aplicativo padrão.  
  
 Não faça suposições sobre o thread em que o evento é gerado em. O evento pode ser gerado em um thread diferente daquela que chamou o <xref:System.AppDomain.Unload%2A> método.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o diretório que usa o resolvedor de assembly para sondar assemblies criados dinamicamente.</summary>
        <value>O diretório que usa o resolvedor de assembly para sondar assemblies criados dinamicamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para definir o diretório dinâmico, atribua um caminho de diretório base para o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade o <xref:System.AppDomainSetup> objeto que será usado para criar o novo domínio de aplicativo. O caminho do diretório base atribuído à propriedade é modificado pela adição de um subdiretório, cujo nome simple é o código hash da cadeia de caracteres que você atribui ao <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriedade, portanto, o formato do diretório base é *caminho original*\\*o código hash*. O diretório dinâmico é uma subpasta desta pasta base. O nome simple é o valor da <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propriedade, portanto, seu formato é *caminho original*\\*o código hash*\\*nome do aplicativo*.  
  
   
  
## Examples  
 O exemplo a seguir cria um domínio de aplicativo com um diretório para assemblies dinâmicos, emite um assembly dinâmico e armazena-o no diretório dinâmico e, em seguida, carrega o assembly para o novo domínio de aplicativo e utiliza.  
  
 O exemplo cria um <xref:System.AppDomainSetup> objeto e define seu <xref:System.AppDomainSetup.ApplicationName%2A> propriedade como "Exemplo" e seu <xref:System.AppDomainSetup.DynamicBase%2A> propriedade como "C:\DynamicAssemblyDir". O exemplo, em seguida, exibe o <xref:System.AppDomainSetup.DynamicBase%2A> propriedade, para mostrar que o código hash do nome do aplicativo foi acrescentado como uma subpasta do caminho que foi atribuído originalmente.  
  
> [!NOTE]
>  O diretório base neste exemplo destina-se a estar fora do caminho de investigação para o aplicativo de exemplo. Certifique-se de compilar o exemplo em um local diferente. Exclua o diretório base e todos os seus subdiretórios cada vez que você executar o exemplo.  
  
 O exemplo cria um novo domínio de aplicativo, usando o <xref:System.AppDomainSetup> objeto. O exemplo usa o <xref:System.AppDomain.DynamicDirectory%2A> propriedade para recuperar o nome do diretório, para que ele possa criar o diretório. (O exemplo pode ser tão facilmente criar o diretório com antecedência concatenando o caminho original, o código hash do nome do aplicativo e o nome do aplicativo.)  
  
 O exemplo tem uma `GenerateDynamicAssembly` método que emite um assembly chamado `DynamicHelloWorld.dll` e os armazena no diretório dinâmico do novo domínio de aplicativo. O assembly dinâmico contém um tipo, `HelloWorld`, que tem um método estático (`Shared` método no Visual Basic) denominada `HelloFromAD`. Chamar esse método exibe o nome do domínio do aplicativo.  
  
 O `Example` classe derivada de <xref:System.MarshalByRefObject>, portanto, o exemplo pode criar uma instância da classe no novo domínio de aplicativo e chamada seu `Test` método. O `Test` método carrega o assembly dinâmico por seu nome de exibição e chama estático `HelloFromAD` método.  
  
 Você pode mostrar que o diretório dinâmico é pesquisado após os caminhos de probing normais, escrevendo código para um assembly chamado `DynamicHelloWorld.dll` e compilá-lo no mesmo diretório que este exemplo. O assembly deve ter uma classe denominada `HelloWorld` com um método estático denominado `HelloFromAD`. Esse método não precisam ter a mesma funcionalidade que o exemplo; ele simplesmente pode exibir uma cadeia de caracteres para o console. O assembly deve ter também um <xref:System.Reflection.AssemblyVersionAttribute> atributo que define a versão como 1.0.0.0. Quando você executa o exemplo, o assembly compilado no diretório atual foi encontrado para que o diretório dinâmico é pesquisado.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a <see cref="T:System.Security.Policy.Evidence" /> associada a esse domínio de aplicativo.</summary>
        <value>A evidência associada a esse domínio de aplicativo.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <summary>Executa o assembly contido no arquivo especificado.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
 Para criar o <xref:System.AppDomain> para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Executa o assembly contido no arquivo especificado, usando a evidência especificada.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 O <xref:System.AppDomain.ExecuteAssembly%2A> método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <param name="args">Os argumentos para o ponto de entrada do assembly.</param>
        <summary>Executa o assembly contido no arquivo especificado usando argumentos especificados.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <param name="assemblySecurity">A evidência fornecida para o assembly.</param>
        <param name="args">Os argumentos para o ponto de entrada do assembly.</param>
        <summary>Executa o assembly contido no arquivo especificado, usando a evidência e os argumentos especificados.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <param name="args">Os argumentos para o ponto de entrada do assembly.</param>
        <param name="hashValue">Representa o valor do código hash computado.</param>
        <param name="hashAlgorithm">Representa o algoritmo de hash usado pelo manifesto do assembly.</param>
        <summary>Executa o assembly contido no arquivo especificado, usando os argumentos especificados, o valor de hash e o algoritmo de hash.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome do arquivo que contém o assembly a ser executado.</param>
        <param name="assemblySecurity">A evidência fornecida para o assembly.</param>
        <param name="args">Os argumentos para o ponto de entrada do assembly.</param>
        <param name="hashValue">Representa o valor do código hash computado.</param>
        <param name="hashAlgorithm">Representa o algoritmo de hash usado pelo manifesto do assembly.</param>
        <summary>Executa o assembly contido no arquivo especificado, usando a evidência especificada, a argumentos, o valor de hash e o algoritmo de hash.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Este método carrega assemblies usando o método <xref:System.Reflection.Assembly.LoadFile%2A>. Também é possível executar assemblies usando o método <xref:System.AppDomain.ExecuteAssemblyByName%2A>, que carrega assemblies usando o método <xref:System.Reflection.Assembly.Load%2A>.  
  
   
  
## Examples  
 Exemplo de asseguintes demonstra como usar uma das sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> em dois domínios diferentes.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Executa um assembly fornecido seu nome de exibição.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 Para criar o <xref:System.AppDomain> para carregar e executar, use o <xref:System.AppDomain.CreateDomain%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Um <see cref="T:System.Reflection.AssemblyName" /> objeto que representa o nome do assembly.</param>
        <param name="args">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Executa o assembly devido a um <see cref="T:System.Reflection.AssemblyName" />, usando os argumentos especificados.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Executa um assembly fornecido seu nome de exibição, usando a evidência especificada.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 O <xref:System.AppDomain.ExecuteAssemblyByName%2A> método não cria um novo processo ou o domínio de aplicativo e o método de ponto de entrada não for executado em um novo thread.  
  
> [!NOTE]
>  Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidência fornecida pelo carregador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Executa o assembly fornecido seu nome de exibição, usando os argumentos especificados.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyName" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Um <see cref="T:System.Reflection.AssemblyName" /> objeto que representa o nome do assembly.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <param name="args">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Executa o assembly devido a um <see cref="T:System.Reflection.AssemblyName" />, usando a evidência especificada e os argumentos.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
> [!NOTE]
>  Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidência fornecida pelo carregador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <param name="args">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Executa o assembly fornecido seu nome de exibição, usando a evidência especificada e os argumentos.</summary>
        <returns>O valor retornado pelo ponto de entrada do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.AppDomain.ExecuteAssemblyByName%2A> fornece funcionalidade semelhante ao método <xref:System.AppDomain.ExecuteAssembly%2A>, mas especifica o assembly por nome para exibição ou <xref:System.Reflection.AssemblyName> em vez de pelo local do arquivo. Por isso, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carrega assemblies com o método <xref:System.Reflection.Assembly.Load%2A> em vez do método <xref:System.Reflection.Assembly.LoadFile%2A>.  
  
 O assembly começa a ser executado no ponto de entrada especificado no cabeçalho do .NET Framework.  
  
 Este método não cria um novo processo ou um domínio de aplicativo e não executa o método de ponto de entrada em um novo thread.  
  
> [!NOTE]
>  Quando você usa o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.AppDomain.ExecuteAssemblyByName%2A> método substituir partes de evidência fornecida pelo carregador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O assembly especificado por <paramref name="assemblyName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly especificado por <paramref name="assemblyName" /> foi encontrado, mas não foi possível carregá-lo.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly especificado por <paramref name="assemblyName" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyName" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="assemblySecurity" /> deve ser <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">O assembly especificado não tem ponto de entrada.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, para acesso às informações no próprio caminho e para redirecionar um nome para exibição para um caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">para acesso a um site, quando um nome para exibição é redirecionado para uma URL.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">para executar um aplicativo de console. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma exceção é lançada no código gerenciado, antes que o tempo de execução procure na pilha de chamadas um manipulador de exceção no domínio do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é apenas uma notificação. O evento não lidar com a exceção ou afetar de qualquer forma de tratamento de exceção subsequente. Depois que o evento foi gerado e manipuladores de eventos tiveram sido chamados, o common language runtime (CLR) começa a procurar por um manipulador para a exceção. <xref:System.AppDomain.FirstChanceException>fornece o domínio de aplicativo com a primeira oportunidade de examinar qualquer exceção gerenciada.  
  
 O evento pode ser tratado por domínio de aplicativo. Se um thread passa por vários domínios de aplicativo durante a execução de uma chamada, o evento é gerado em cada domínio de aplicativo que registrou um manipulador de eventos, antes do CLR começa a procurar por um manipulador de exceção correspondente no domínio de aplicativo. Depois que o evento foi tratado, uma pesquisa é feita para um manipulador de exceção correspondente no domínio de aplicativo. Se nenhum for encontrado, o evento é gerado no próximo domínio de aplicativo.  
  
 Você deve tratar todas as exceções que ocorrem no manipulador para o <xref:System.AppDomain.FirstChanceException> evento. Caso contrário, <xref:System.AppDomain.FirstChanceException> é gerado recursivamente. Isso pode resultar em um estouro de pilha e o encerramento do aplicativo. É recomendável que você implemente os manipuladores de eventos para esse evento como regiões de execução restrita (CERs), para evitar exceções relacionadas à infraestrutura, como o estouro de pilha ou falta de memória que afetam a máquina virtual enquanto a notificação de exceção está sendo processada.  
  
 Esse evento não é gerado para exceções que indicam corrupção do estado do processo, como violações de acesso, a menos que o manipulador de eventos é crítico de segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.  
  
 O common language runtime suspende anulações de thread enquanto este evento de notificação está sendo tratado.  
  
   
  
## Examples  
 O exemplo a seguir cria uma série de domínios de aplicativo chamada `AD0` por meio de `AD3`, com um `Worker` objeto em cada domínio de aplicativo. Cada `Worker` objeto tem uma referência para o `Worker` do objeto no próximo domínio de aplicativo, exceto para o `Worker` no último domínio do aplicativo. O <xref:System.AppDomain.FirstChanceException> evento é tratado em todos os domínios de aplicativo, exceto `AD1`.  
  
> [!NOTE]
>  Além de exemplo, que demonstra as notificações de exceção de primeira chance em vários domínios de aplicativo, você pode encontrar os casos de uso simples no [como: receber notificações de exceção de primeira Chance](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Quando os domínios de aplicativo tiveram sido criados, o domínio de aplicativo padrão chama o `TestException` método para o primeiro domínio de aplicativo. Cada `Worker` objeto chama o `TestException` método para o próximo domínio de aplicativo, até o último `Worker` lança uma exceção que é tratada ou não tratada. Portanto, o thread atual passa por todos os domínios de aplicativo, e `TestException` é adicionada à pilha em cada domínio de aplicativo.  
  
 Quando a última `Worker` objeto lida com a exceção, o <xref:System.AppDomain.FirstChanceException> é gerado apenas no último domínio do aplicativo. Os outros domínios de aplicativo nunca obtém a oportunidade de lidar com a exceção, para que o evento não será gerado.  
  
 Quando a última `Worker` objeto não lida com a exceção, o <xref:System.AppDomain.FirstChanceException> é gerado em cada domínio de aplicativo que tem um manipulador de eventos. Após cada manipulador de eventos, a pilha continua desenrolar até que a exceção é capturada por domínio de aplicativo padrão.  
  
> [!NOTE]
>  Para ver como a exibição de pilha aumenta à medida que o evento é gerado mais próximo e mais próximo domínio de aplicativo padrão, altere `e.Exception.Message` para `e.Exception` no `FirstChanceHandler` manipuladores de eventos. Observe que, quando `TestException` é chamado nos limites do domínio de aplicativo, ele aparece duas vezes: uma vez para o proxy e outra para o stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome amigável desse domínio do aplicativo.</summary>
        <value>O nome amigável desse domínio do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome amigável do domínio de aplicativo padrão é o nome do arquivo do processo do executável. Por exemplo, se o executável usado para iniciar o processo é `"c:\MyAppDirectory\MyAssembly.exe"`, o nome amigável do domínio de aplicativo padrão é `"MyAssembly.exe"`.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.AppDomain.FriendlyName%2A> propriedade para obter o nome amigável do domínio de aplicativo atual. Para o domínio de aplicativo padrão, o nome amigável é o nome do arquivo executável do aplicativo. O exemplo de código também exibe informações adicionais sobre o domínio de aplicativo.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os assemblies que foram carregados no contexto de execução desse domínio de aplicativo.</summary>
        <returns>Uma matriz de assemblies nesse domínio do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.AppDomain.GetAssemblies%2A> método para obter uma lista de todos os assemblies que tiverem sido carregados no domínio do aplicativo. Os assemblies são exibidos no console.  
  
 Para executar este exemplo de código, você precisa criar um assembly nomeado `CustomLibrary.dll`, ou alterar o nome do assembly que é passado para o <xref:System.AppDomain.GetAssemblies%2A> método.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o identificador atual de thread.</summary>
        <returns>Um inteiro com sinal de 32 bits que é o identificador do thread atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propriedade, que é estável, mesmo quando o .NET Framework é hospedado por um ambiente que oferece suporte a fibras (ou seja, leve threads).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome de uma propriedade de domínio de aplicativo predefinida ou o nome de uma propriedade de domínio de aplicativo que você definiu.</param>
        <summary>Obtém o valor armazenado no domínio atual do aplicativo para o nome especificado.</summary>
        <returns>O valor da propriedade <paramref name="name" /> ou <see langword="null" /> se a propriedade não existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para recuperar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância do <xref:System.AppDomain>. Observe que a comparação de `name` com o nome de pares chave-valor diferencia maiusculas de minúsculas.  
  
 O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Você pode inspecionar os valores com o <xref:System.AppDomain.GetData%2A> método, ou equivalente <xref:System.AppDomainSetup> propriedades.  
  
 Você pode inserir ou modificar seus próprios pares de dados de nome definido pelo usuário com o <xref:System.AppDomain.SetData%2A> método e inspecionar os valores com o <xref:System.AppDomain.GetData%2A> método.  
  
 A tabela a seguir descreve o `name` de cada entrada do sistema e correspondente predefinidos <xref:System.AppDomainSetup> propriedade.  
  
|Valor de 'name'|Propriedade|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(nenhuma propriedade)<br /><br /> "APP_LAUNCH_URL" representa a URL solicitada originalmente pelo usuário, antes de qualquer redirecionamento. Ele está disponível somente quando o aplicativo foi iniciado com um navegador como o Internet Explorer. Nem todos os navegadores fornecem esse valor.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(nenhuma propriedade)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" ou uma cadeia de caracteres específica do aplicativo|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(nenhuma propriedade)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" não é uma entrada de sistema e seu valor pode ser definido ao chamar o <xref:System.AppDomain.SetData%2A> método.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 O exemplo a seguir cria um novo domínio de aplicativo, define um valor fornecido pelo sistema para o domínio e adiciona um novo par de valor para o domínio. O exemplo demonstra como usar o <xref:System.AppDomain.GetData%2A> método para recuperar os dados desses pares de valor e exibi-los para o console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar as informações no caminho em si, se a propriedade se aplica a um caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o tipo da instância atual.</summary>
        <returns>O tipo da instância atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um inteiro que identifica exclusivamente o domínio de aplicativo dentro do processo.</summary>
        <value>Um inteiro que identifica o domínio do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria um segundo domínio de aplicativo e exibe informações sobre o domínio padrão e o novo domínio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece o <see cref="T:System.AppDomain" /> um tempo de vida infinito, impedindo que uma concessão que está sendo criado.</summary>
        <returns>Sempre <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A opção de compatibilidade para testar.</param>
        <summary>Obtém um valor anulável booliano que indica se todos os comutadores compatibilidade são definidos e nesse caso, se a opção de compatibilidade especificada está definida.</summary>
        <returns>Uma referência nula (<see langword="Nothing" /> no Visual Basic) se nenhuma opção de compatibilidade for definida; caso contrário, um valor booliano que indica se a compatibilidade do comutador que é especificado pelo <paramref name="value" /> está definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método testa se a opção de compatibilidade especificado tiver sido definida para o domínio de aplicativo atual. Comutadores de compatibilidade normalmente restaura um comportamento (como as cadeias de caracteres de forma são classificadas) que foi alterado entre as versões do .NET Framework.  Eles são definidos chamando o <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> método antes de criar um domínio de aplicativo.  
  
 A tabela a seguir fornece exemplos de comutadores de compatibilidade que podem ser definidas para restaurar o comportamento de versões anteriores do .NET Framework.  
  
|Alternar|Significado|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Código de segurança de acesso (ACS) para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada neste domínio de aplicativo. Consulte [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Cadeia de caracteres de classificação padrão para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] são habilitados neste domínio de aplicativo. O sucesso requer o arquivo sort00001000.dll para ser instalado. Consulte [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Cadeia de caracteres de classificação padrão para o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e Unicode 5.0 são habilitados neste domínio de aplicativo. O sucesso requer sort00060101.dll para ser instalado.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan>formatação de comportamento para o [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada neste domínio de aplicativo.  Consulte [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) e a seção "Restaurando herdado TimeSpan formatação" o <xref:System.TimeSpan> tópico.|  
|"UseRandomizedStringHashAlgorithm"|O tempo de execução calcula os códigos de hash para cadeias de caracteres em um por cada domínio de aplicativo em vez de usar um único algoritmo de hash que gera um código hash consistente entre domínios de aplicativo. Consulte [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se o domínio de aplicativo é o domínio de aplicativo padrão para o processo.</summary>
        <returns>
          <see langword="true" />Se o atual <see cref="T:System.AppDomain" /> objeto representa o domínio de aplicativo padrão para o processo; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada processo gerenciado tem um domínio de aplicativo padrão. Início da execução do domínio padrão.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um segundo domínio de aplicativo e exibe informações sobre o domínio padrão e o novo domínio.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se este domínio de aplicativo está descarregando e os objetos que ele contém finalizados pelo common language runtime.</summary>
        <returns>
          <see langword="true" />Se esse domínio de aplicativo é descarregar e o common language runtime iniciou invocar finalizadores; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método de finalização de um objeto fornece a oportunidade de executar quaisquer operações de limpeza necessária antes que o objeto é coletado como lixo. Após a finalização, o objeto é acessível, mas em um estado inválido e, portanto, inutilizável. Eventualmente, a coleta de lixo é concluída e recupera o objeto.  
  
 Método de finalização de um objeto é chamado em uma das seguintes situações: durante a coleta de lixo, quando o common language runtime está sendo desligado, ou quando o domínio de aplicativo que contém o objeto é descarregado. O <xref:System.AppDomain.IsFinalizingForUnload%2A> método `true` somente no último caso; ele não retorna `true` se finalização resulta da coleta de lixo de rotina ou do desligamento do CLR.  
  
> [!NOTE]
>  Para determinar se a finalização é devido ao desligamento do CLR, use o <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> propriedade. Ele retorna `true` se finalização é devido a um domínio de aplicativo que está sendo descarregado ou ao CLR que está sendo desligado.  
  
 Durante a execução em seu método de finalização durante descarregamento do domínio, você talvez queira acessar outro objeto que é referenciado por um campo estático e tem um método de finalização. No entanto, não é possível confiável porque o objeto acessado pode já ter foi finalizado.  
  
> [!NOTE]
>  Uma exceção a essa regra é o <xref:System.Console> classe, que contém campos estáticos que fazem referência a objetos de fluxo, mas é implementada especialmente para você sempre pode gravar no console do sistema, mesmo durante o desligamento de descarregar ou sistema de domínio.  
  
 Use esse método no método de finalização de um objeto para determinar se o domínio de aplicativo que contém o objeto está descarregando. Se esse for o caso, você não pode acessar com segurança qualquer objeto que tem um método de finalização e é referenciado por um campo estático.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os assemblies carregados no domínio de aplicativo atual são executados com confiança total.</summary>
        <value>
          <see langword="true" /> se os assemblies carregados no domínio de aplicativo atual forem executados com confiança total; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método sempre retorna `true` para o domínio de aplicativo padrão de um aplicativo que é executado na área de trabalho. Ele retorna `false` para um domínio de aplicativo na área restrita foi criado usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga do método, a menos que as permissões que são concedidas ao domínio do aplicativo são equivalentes a confiança total.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.IsFullyTrusted%2A> propriedade e o <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> propriedade com domínios de aplicativo totalmente confiável quanto o parcialmente confiável. O domínio de aplicativo totalmente confiável é o domínio de aplicativo padrão para o aplicativo. O domínio de aplicativo parcialmente confiável é criado usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga do método.  
  
 O exemplo usa um `Worker` classe que deriva de <xref:System.MarshalByRefObject>, portanto, ele pode ser empacotado nos limites do domínio de aplicativo. O exemplo cria um `Worker` objeto no domínio de aplicativo padrão. Depois, ele chama o `TestIsFullyTrusted` método para exibir o valor da propriedade para o domínio de aplicativo em dois assemblies são carregados no domínio de aplicativo: mscorlib, que faz parte do .NET Framework e o assembly de exemplo. O domínio de aplicativo é totalmente confiável, para que os dois assemblies forem totalmente confiáveis.  
  
 O exemplo cria outro `Worker` objeto em um domínio de aplicativo na área restrita e, novamente, chamadas de `TestIsFullyTrusted` método. Mscorlib sempre é confiável, mesmo em um domínio de aplicativo parcialmente confiável, mas o assembly de exemplo é parcialmente confiável.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o domínio de aplicativo atual tem um conjunto de permissões concedido a todos os assemblies que são carregados no domínio do aplicativo.</summary>
        <value>
          <see langword="true" /> se o domínio de aplicativo atual tiver um conjunto de permissões homogêneo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna `true` para domínios de aplicativo na área restrita que foram criados usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga do método. Domínios de aplicativo na área restrita têm um homogêneo conjunto de permissões; Isto é, o mesmo conjunto de permissões é concedido a todos os assemblies parcialmente confiáveis que são carregados no domínio do aplicativo. Opcionalmente, um domínio de aplicativo na área restrita tem uma lista de assemblies de nomes fortes que são isentos essa permissão definida e, em vez disso, é executado com confiança total.  
  
 Totalmente confiáveis pode usar o código de <xref:System.AppDomain.PermissionSet%2A> propriedade para determinar o conjunto de concessão homogêneo de um domínio de aplicativo na área restrita.  
  
 Essa propriedade também retorna `true` para o domínio de aplicativo padrão de um aplicativo de área de trabalho, porque o domínio de aplicativo concede confiança total para todos os assemblies.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <summary>Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.  
  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de carregar um assembly bruto.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">O objeto que descreve o assembly a ser carregado.</param>
        <summary>Carrega um <see cref="T:System.Reflection.Assembly" /> dado seu <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Se uma versão do assembly solicitado já está carregada, esse método retorna o assembly carregado, mesmo se for solicitada uma versão diferente.  
  
 Fornecendo um nome de assembly parcial para `assemblyRef` não é recomendado. (Um nome parcial omite um ou mais da cultura, versão ou token de chave pública. Para sobrecargas que têm uma cadeia de caracteres em vez de um <xref:System.Reflection.AssemblyName> objeto, "MyAssembly, Version = 1.0.0.0" é um exemplo de um nome parcial e "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" é um exemplo de um nome completo.) Usar nomes parciais tem um efeito negativo no desempenho. Além disso, um nome de assembly parcial pode carregar um assembly do cache de assembly global somente se houver uma cópia exata do assembly no diretório base do aplicativo (<xref:System.AppDomain.BaseDirectory%2A> ou <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Se o atual <xref:System.AppDomain> objeto representa o domínio de aplicativo `A`e o <xref:System.AppDomain.Load%2A> método é chamado de domínio de aplicativo `B`, o assembly é carregado em ambos os domínios de aplicativo. Por exemplo, o código a seguir carrega `MyAssembly` no novo domínio de aplicativo `ChildDomain` e também no domínio de aplicativo onde o código é executado:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 O assembly é carregado em ambos os domínios porque <xref:System.Reflection.Assembly> não deriva de <xref:System.MarshalByRefObject>e, portanto, o valor de retorno de <xref:System.AppDomain.Load%2A> método não pode ser empacotado. Em vez disso, o common language runtime tenta carregar o assembly no domínio de aplicativo de chamada. Os assemblies que são carregados nos domínios do duas aplicativo podem ser diferentes se as configurações de caminho para os domínios de dois aplicativo são diferentes.  
  
> [!NOTE]
>  Se o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriedade estiver definida, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade). Se o arquivo não for encontrado, o <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade é usada para pesquisar o assembly. Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly. Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Carrega um <see cref="T:System.Reflection.Assembly" /> de acordo com seu nome de exibição.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> é <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para a capacidade de acessar o local do conjunto caso o assembly não seja local.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <param name="rawSymbolStore">Uma matriz do tipo <see langword="byte" /> que contém os bytes brutos que representa os símbolos para o assembly.</param>
        <summary>Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido. Os bytes brutos que representa os símbolos para o <see cref="T:System.Reflection.Assembly" /> também são carregados.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.  
  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de carregar um assembly bruto.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">O objeto que descreve o assembly a ser carregado.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Carrega um <see cref="T:System.Reflection.Assembly" /> dado seu <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> é <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">O nome para exibição do assembly. Consulte <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Carrega um <see cref="T:System.Reflection.Assembly" /> de acordo com seu nome de exibição.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> é <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz do tipo <see langword="byte" /> que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <param name="rawSymbolStore">Uma matriz do tipo <see langword="byte" /> que contém os bytes brutos que representa os símbolos para o assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <summary>Carrega o <see cref="T:System.Reflection.Assembly" /> com uma imagem baseada em formato COFF, contendo um <see cref="T:System.Reflection.Assembly" /> emitido. Os bytes brutos que representa os símbolos para o <see cref="T:System.Reflection.Assembly" /> também são carregados.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança do domínio do aplicativo.  
  
 Este método só deve ser usado para carregar um assembly no domínio de aplicativo atual. Este método é fornecido como uma praticidade para chamadores de interoperabilidade que não possam chamar o método estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>. Para carregar assemblies em outros domínios de aplicativo, use um método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Para informações comuns a todas as sobrecargas desse método, consulte a sobrecarga do método <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso de carregar um assembly bruto.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> não é <see langword="null" />. Quando a política CAS herdada não está habilitada, <paramref name="securityEvidence" /> deve ser <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">para ler um caminho que não está no formato "file://" ou "\\\UNC\dir\\" ou "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o monitoramento de CPU e memória de domínios de aplicativo está habilitado para o processo atual. Depois que o monitoramento é habilitado para um processo, ele não pode ser desabilitado.</summary>
        <value>
          <see langword="true" /> se o monitoramento está habilitado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso `static` propriedade (`Shared` propriedade no Visual Basic) controla a CPU e memória de monitoramento de todos os domínios de aplicativo no processo.  
  
 Se você tentar definir essa propriedade como `false`, um <xref:System.ArgumentException> exceção for lançada, mesmo se o valor atual da propriedade é `false`.  
  
 Depois que o monitoramento estiver habilitado, você pode usar o <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, e <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> propriedades para monitorar o uso de CPU e memória de domínios de aplicativos individuais da instância.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O processo atual tentou atribuir o valor <see langword="false" /> a esta propriedade.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de bytes que sobreviveram à última coleta e que são conhecidos por serem referenciados pelo domínio do aplicativo atual.</summary>
        <value>O número de bytes sobreviventes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As estatísticas são atualizadas com cada coleta de lixo. No entanto, eles não têm garantia sejam precisos somente após um completo, bloqueio de uma coleção. ou seja, uma coleção que inclui todas as gerações e que interrompe o aplicativo durante a coleta ocorre. Por exemplo, o <xref:System.GC.Collect?displayProperty=nameWithType> sobrecarga do método executa um completo, bloqueio de coleta. (Coleção simultânea ocorre em segundo plano e não bloqueia o aplicativo.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o total de bytes que sobreviveram da última coleção para todos os domínios de aplicativo no processo.</summary>
        <value>O número total de bytes restantes para o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de um conjunto completo, bloqueio, esse número representará o número de bytes contido em tempo real em heaps gerenciados. Ele deve ser o próximo o número relatado pelo <xref:System.GC.GetTotalMemory%2A> método. Depois de uma coleção efêmera, esse número representará o número de bytes que estão retidas ao vivo em gerações efêmeras.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho total, em bytes, de todas as alocações de memória que foram feitas pelo domínio do aplicativo desde que ele foi criado, sem subtrair a memória que foi coletada.</summary>
        <value>O tamanho total de todas as alocações de memória.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo total do processador usado por todos os threads durante a execução no domínio do aplicativo atual, desde o início do processo.</summary>
        <value>Tempo total do processador para o domínio do aplicativo atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tempo total que é relatado para um domínio de aplicativo inclui o tempo gasto em cada thread no processo de execução no domínio de aplicativo.  
  
 Um thread que chamam o código não gerenciado ainda está associado com um domínio de aplicativo e o tempo do processador gasto na execução que de código não gerenciado é relatado para o domínio de aplicativo em que a chamada foi feita.  
  
 Quando um thread está bloqueado ou suspenso, ele não consome tempo do processador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see langword="static" /> (<see langword="Shared" /> no Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> é definida como <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o conjunto de permissões de um domínio de aplicativo em área restrita.</summary>
        <value>O conjunto de permissões de um domínio de aplicativo em área restrita.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domínios de aplicativo no modo seguro que foram criados usando o <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga de método tem um homogêneo conjunto de permissões; isto é, o mesmo conjunto de permissões é concedido a todos os assemblies parcialmente confiáveis que são carregados no domínio do aplicativo. Opcionalmente, um domínio de aplicativo na área restrita tem uma lista de assemblies de nomes fortes que são isentos essa permissão definida e, em vez disso, é executado com confiança total.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o processo pai do domínio de aplicativo padrão é encerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.EventHandler> para esse evento pode executar atividades de término, como fechar arquivos, liberação de armazenamento e assim por diante, antes do término do processo.  
  
 Começando com o .NET Framework versão 2.0, esse evento é gerado em cada domínio de aplicativo que registra um manipulador de eventos.  
  
> [!NOTE]
>  Tempo total de execução de todos os <xref:System.AppDomain.ProcessExit> manipuladores de eventos é limitado, assim como o tempo de execução total de todos os finalizadores é limitado no encerramento do processo. O padrão é dois segundos. Um host não gerenciado pode alterar esse tempo de execução chamando o [ICLRPolicyManager](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) método com o [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valor de enumeração.  
  
 Nas versões do .NET Framework 1.0 e 1.1, esse evento é gerado apenas no domínio de aplicativo padrão e somente se um manipulador de eventos é registrado no domínio de aplicativo padrão.  
  
 Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a resolução de um assembly falha no contexto somente para reflexão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No contexto exclusivo de reflexão, dependências não são resolvidas automaticamente. Eles devem ser pré-carregados ou retornados pelo manipulador para este evento. Esse evento é gerado quando um assembly tem uma dependência que já não foi carregada no contexto exclusivo de reflexão. A dependência ausente é especificada pelo <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade. O <xref:System.ResolveEventHandler> para esse evento deve retornar um assembly que satisfaz a dependência. O assembly que é retornado deve ser carregado no contexto exclusivo de reflexão.  
  
> [!IMPORTANT]
>  Esse evento é gerado apenas para dependências ausentes do assembly que você está carregando no contexto de somente reflexão (por exemplo, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> método). Ele não será gerado se o assembly que você está carregando não pode ser encontrado.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade retorna o assembly que pediu a carga de assembly não pôde ser resolvida. Saber a identidade do solicitante assembly pode ser útil para identificar a versão correta da dependência, se houver mais de uma versão. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para esse evento, o <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propriedade retorna o nome do assembly, antes da política é aplicada.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os assemblies que tiverem sido carregados no contexto exclusivo de reflexão do domínio do aplicativo.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.Assembly" /> objetos que representam os assemblies carregados no contexto de somente reflexão do domínio do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna os assemblies que tiverem sido carregados no contexto exclusivo de reflexão. Para obter os módulos que foram carregados para execução, use o <xref:System.AppDomain.GetAssemblies%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir carrega o assembly System. dll no contexto de execução e, em seguida, no contexto exclusivo de reflexão. O <xref:System.AppDomain.GetAssemblies%2A> e <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> métodos são usados para exibir os assemblies carregados em cada contexto.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Uma operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho no diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</summary>
        <value>O caminho no diretório base em que o resolvedor do assembly deve investigar assemblies particulares.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblies privados são implantados na mesma estrutura de diretório do aplicativo. Se o caminho especificado o <xref:System.AppDomain.RelativeSearchPath%2A> propriedade não está sob <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, ele será ignorado.  
  
 Essa propriedade retorna o valor definido usando <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso às informações de caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a resolução de um recurso falha devido ao recurso não ser um recurso vinculado ou inserido válido no assembly.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ResolveEventHandler> para esse evento pode tentar localizar o assembly que contém o recurso e retorná-la.  
  
> [!IMPORTANT]
>  Esse evento não será gerado se a resolução falhar porque o arquivo não pode ser encontrado para um recurso vinculado válido. Ele é gerado se um fluxo de recurso de manifesto não pode ser encontrado, mas não será gerado se uma chave de recurso individual não pode ser encontrada.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade contém o assembly que o recurso solicitado. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">O nível de política de segurança.</param>
        <summary>Estabelece o nível de política de segurança para esse domínio de aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método antes de um assembly é carregado para o <xref:System.AppDomain> em ordem para a política de segurança para ter efeito.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.AppDomain.SetAppDomainPolicy%2A> método para definir o nível de política de segurança de um domínio de aplicativo.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">O nível de política de segurança já foi definido.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho totalmente qualificado para o local da cópia de sombra.</param>
        <summary>Estabelece o caminho de diretório especificado como o local onde os assemblies são feitas cópias de sombra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho do cache será ignorado se o <xref:System.AppDomainSetup.ApplicationName%2A> propriedade não está definida. Consulte a propriedade <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">O nome de uma propriedade de domínio de aplicativo definida pelo usuário a ser criada ou alterada.</param>
        <param name="data">O valor da propriedade.</param>
        <summary>Atribui o valor especificado para a propriedade de domínio do aplicativo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para inserir uma entrada ou modificar o valor de uma entrada em um cache interno de pares de nome de dados que descrevem as propriedades desta instância do <xref:System.AppDomain>.  
  
 O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Não é possível inserir ou modificar as entradas de sistema com esse método. Uma chamada de método que tenta modificar uma entrada de sistema não tem nenhum efeito; o método não lançará uma exceção. Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A> método, ou equivalente <xref:System.AppDomainSetup> propriedades descritas <xref:System.AppDomain.GetData%2A>.  
  
 Você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar padrões de expressão regular pela fonte de "REGEX_DEFAULT_MATCH_TIMEOUT" como o valor da `name` argumento e uma <xref:System.TimeSpan> valor que representa o intervalo de tempo limite como o valor da `data` argumento. Você também pode inserir ou modificar seus próprios pares de dados de nome definido pelo usuário com esse método e inspecionar os valores com o <xref:System.AppDomain.GetData%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> método para criar um novo par de valor. O exemplo usa o <xref:System.AppDomain.GetData%2A> método para recuperar o valor e o exibe no console.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">O nome de uma propriedade de domínio de aplicativo definida pelo usuário a ser criada ou alterada.</param>
        <param name="data">O valor da propriedade.</param>
        <param name="permission">A permissão a demanda do chamador quando a propriedade é recuperada.</param>
        <summary>Atribui o valor especificado para a propriedade de domínio de aplicativo especificado, com uma permissão especificada a demanda do chamador quando a propriedade é recuperada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para inserir ou modificar suas próprias entradas definidas pelo usuário em um cache interno de pares de nome/dados que descrevem as propriedades do domínio do aplicativo. Quando você insere uma entrada, você pode especificar uma demanda de permissão para impor quando a entrada é recuperada. Além disso, você pode chamar esse método para definir o valor do intervalo de tempo limite padrão para avaliar padrões de expressão regular pela fonte de "REGEX_DEFAULT_MATCH_TIMEOUT" como o valor da `name` argumento e uma <xref:System.TimeSpan> valor que representa o intervalo de tempo limite como o valor da `data` argumento.  
  
 Você não pode usar esse método para atribuir uma exigência de segurança para uma cadeia de caracteres de propriedade definidos pelo sistema.  
  
 O cache contém entradas de sistema predefinidos que são inseridas quando o domínio de aplicativo é criado automaticamente. Não é possível inserir ou modificar as entradas de sistema com esse método. Uma chamada de método que tenta modificar uma entrada de sistema não tem nenhum efeito; o método não lançará uma exceção. Você pode inspecionar os valores das entradas de sistema com o <xref:System.AppDomain.GetData%2A> método ou o equivalente <xref:System.AppDomainSetup> propriedades descritas na seção comentários para o <xref:System.AppDomain.GetData%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" />Especifica uma cadeia de caracteres de propriedade definida pelo sistema e <paramref name="permission" /> não é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho totalmente qualificado que é o diretório base para subpastas onde assemblies dinâmicos são armazenados.</param>
        <summary>Estabelece o caminho de diretório especificado como o diretório base para subdiretórios onde os arquivos gerados dinamicamente são armazenados e acessados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método define o <xref:System.AppDomainSetup.DynamicBase%2A> propriedade interno <xref:System.AppDomainSetup> associado a esta instância.  
  
   
  
## Examples  
 Este método agora está obsoleto e não deve ser usado no novo desenvolvimento. O exemplo a seguir mostra como usar a alternativa não obsoleta, o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade. Para obter uma explicação desse exemplo, consulte o <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propriedade ou o <xref:System.AppDomain.DynamicDirectory%2A> propriedade.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Um dos valores <see cref="T:System.Security.Principal.PrincipalPolicy" /> que especifica o tipo do objeto de entidade de segurança a ser anexado aos threads.</param>
        <summary>Especifica como objetos de identidade e de entidade de segurança devem ser anexados a um thread se a thread tenta se associar a uma entidade de segurança durante a execução nesse domínio do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir esse valor só será eficaz se você defini-lo antes de usar o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propriedade. Por exemplo, se você definir <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para uma determinada entidade (por exemplo, uma entidade de segurança genérica) e, em seguida, use o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para definir o <xref:System.Security.Principal.PrincipalPolicy> para <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, o principal atual permanecerá a entidade de segurança genérica.  
  
   
  
## Examples  
 O exemplo a seguir mostra o efeito em threads de usar o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para alterar a política de entidade de segurança do domínio do aplicativo. Ele também mostra o efeito de usar o <xref:System.AppDomain.SetThreadPrincipal%2A> método para alterar a entidade que está disponível para anexar a threads no domínio do aplicativo.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de manipular o objeto principal. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ativa a cópia de sombra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Uma lista de nomes de diretórios, onde cada nome é separado por ponto e vírgula.</param>
        <summary>Estabelece o caminho de diretório especificado como o local da cópia de sombra de assemblies.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, uma cópia de sombra inclui todos os assemblies localizados por meio de sondagem. O <xref:System.AppDomain.SetShadowCopyPath%2A> método restringe a cópia de sombra para os assemblies nos diretórios especificados pelo `path`.  
  
 O <xref:System.AppDomain.SetShadowCopyPath%2A> método não especificar diretórios adicionais a serem pesquisadas para assemblies. Assemblies a serem copiados de sombra devem já estar localizados no caminho de pesquisa, por exemplo em <xref:System.AppDomain.BaseDirectory%2A>. O <xref:System.AppDomain.SetShadowCopyPath%2A> método especifica quais caminhos de pesquisa são qualificados para ser sombra copiado.  
  
 Esse método define o <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propriedade interno <xref:System.AppDomainSetup> associado a esta instância.  
  
 Para obter mais informações sobre a cópia de sombra, consulte [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Este método agora está obsoleto e não deve ser usado no novo desenvolvimento.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">O objeto de entidade de segurança a ser anexado aos threads.</param>
        <summary>Define o objeto de entidade de segurança padrão a ser anexado aos threads se eles tentam se associar a uma entidade de segurança durante a execução nesse domínio de aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra o efeito de usar o <xref:System.AppDomain.SetThreadPrincipal%2A> método para alterar a entidade que está disponível para anexar a threads que estão em execução no domínio do aplicativo. Ele também mostra o efeito em threads de usar o <xref:System.AppDomain.SetPrincipalPolicy%2A> método para alterar a política de entidade de segurança do domínio do aplicativo.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">A entidade de segurança do thread já foi definida.</exception>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a capacidade de manipular o objeto principal. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as informações de configuração do domínio do aplicativo para essa instância.</summary>
        <value>As informações de inicialização do domínio do aplicativo.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma indicação se o domínio do aplicativo é configurado para arquivos de cópia de sombra.</summary>
        <value>
          <see langword="true" /> se o domínio do aplicativo for configurado para arquivos de cópia de sombra; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> e [cópia de sombra de Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">A operação é tentada em um domínio de aplicativo descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Recebe um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma representação de cadeia de caracteres que inclui o nome amigável do domínio do aplicativo e as políticas de contexto.</summary>
        <returns>Uma cadeia de caracteres é formada pela concatenação da cadeia de caracteres literal “Nome:”, o nome amigável do domínio do aplicativo e as representações de cadeia de caracteres das políticas de contexto ou a cadeia de caracteres “Não há políticas sem contexto”.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir exibe o valor de retorno de <xref:System.AppDomain.ToString%2A> método.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">O domínio de aplicativo representado pelo <see cref="T:System.AppDomain" /> atual foi descarregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a resolução de um tipo falha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.AppDomain.TypeResolve> evento ocorre quando o common language runtime não é possível determinar o assembly que pode criar o tipo solicitado. Isso pode ocorrer se o tipo é definido em um assembly dinâmico, ou o tipo não está definido em um assembly dinâmico, mas o tempo de execução não sabe qual assembly o tipo é definido no. A segunda situação pode ocorrer quando <xref:System.Type.GetType%2A?displayProperty=nameWithType> é chamado com um nome de tipo que não está qualificado com o nome do assembly.  
  
 O <xref:System.ResolveEventHandler> para esse evento pode tentar localizar e criar o tipo.  
  
 No entanto, o <xref:System.AppDomain.TypeResolve> evento não ocorrerá se o tempo de execução sabe que não é possível encontrar um tipo em determinados assemblies. Por exemplo, esse evento não ocorre se o tipo não é encontrado em um conjunto estático porque o tempo de execução sabe tipos não podem ser adicionados dinamicamente para assemblies estáticos.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propriedade contém o assembly que o tipo solicitado. Para obter mais informações, consulte <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.TypeResolve> evento.  
  
 Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma exceção não é capturada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento fornece notificação de exceções não capturadas. Ele permite que o aplicativo registrar informações sobre a exceção antes do manipulador padrão do sistema relata a exceção para o usuário e encerra o aplicativo. Se houver informações suficientes sobre o estado do aplicativo, outras ações podem ser realizadas — como salvar dados de programa para recuperação posterior. Tenha cuidado, porque os dados de programa podem se tornar corrompidos quando são as exceções não tratadas.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, opções de depuração e encerramento de aplicativo são relatados para o usuário antes que esse evento é gerado, em vez de depois.  
  
 Esse evento pode ser tratado em qualquer domínio de aplicativo. No entanto, o evento não será necessariamente gerado no domínio do aplicativo onde ocorreu a exceção. Uma exceção é sem tratamento somente se a pilha inteira para o thread foi organizada sem encontrar um manipulador de exceção aplicável, portanto, é o primeiro lugar em que o evento pode ser gerado no domínio do aplicativo em que o thread foi originado.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, esse evento ocorre somente para o domínio de aplicativo padrão que é criado pelo sistema quando um aplicativo é iniciado. Se um aplicativo cria domínios de aplicativo adicionais, especificar um delegado para esse evento nesses domínios de aplicativos não tem nenhum efeito.  
  
 Se o <xref:System.AppDomain.UnhandledException> evento é tratado no domínio de aplicativo padrão, ele é gerado existe para qualquer exceção sem tratamento em qualquer thread, independentemente de qual domínio de aplicativo o thread iniciado no. Se o thread foi iniciado em um domínio de aplicativo que tem um manipulador de eventos <xref:System.AppDomain.UnhandledException>, o evento é gerado no domínio de aplicativo. Se o domínio de aplicativo não é o domínio de aplicativo padrão, e também há um manipulador de eventos no domínio de aplicativo padrão, o evento é gerado em ambos os domínios de aplicativo.  
  
 Por exemplo, suponha que um thread é iniciado no domínio de aplicativo "IA1", chama um método no domínio de aplicativo "AD2" e a partir daí chama um método no domínio de aplicativo "AD3", onde ele lança uma exceção. O primeiro domínio de aplicativo no qual o <xref:System.AppDomain.UnhandledException> pode ser gerado é "IA1". Se o domínio de aplicativo não é o domínio de aplicativo padrão, o evento também pode ser gerado no domínio de aplicativo padrão.  
  
> [!NOTE]
>  O common language runtime suspende anulações de thread enquanto manipuladores de eventos para o <xref:System.AppDomain.UnhandledException> evento estão em execução.  
  
 Se o manipulador de eventos tem um <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo com os sinalizadores apropriados, o manipulador de eventos é tratado como uma região de execução restrita.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], esse evento não é gerado para exceções que corromper o estado do processo, como o estouro de pilha ou violações de acesso, a menos que o manipulador de eventos é crítico de segurança e tem o <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.  
  
 Nas versões do .NET Framework 1.0 e 1.1, uma exceção não tratada ocorre em um thread que não seja o thread principal do aplicativo é capturada pelo tempo de execução e, portanto, não faz com que o aplicativo seja finalizado. Portanto, é possível que o <xref:System.AppDomain.UnhandledException> evento ser gerado sem encerramento do aplicativo. Iniciando com o .NET Framework versão 2.0, esta barreira de exceções sem tratamento em threads de filho foi removida, porque o efeito cumulativo de tais falhas silenciosas incluído degradação de desempenho, dados corrompidos e travamentos, que eram difíceis de depurar. Para obter mais informações, incluindo uma lista de casos em que não encerra o tempo de execução, consulte [exceções em Threads gerenciados](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Para registrar um manipulador de eventos para esse evento, você deve ter as permissões necessárias, ou um <xref:System.Security.SecurityException> é lançado.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Outros eventos para exceções não identificadas  
 Para determinados modelos de aplicativo, o <xref:System.AppDomain.UnhandledException> evento pode ser impedido por outros eventos se a exceção não tratada ocorrer no thread principal do aplicativo.  
  
 Em aplicativos que usam Windows Forms, exceções não tratadas na causa do thread principal do aplicativo a <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> evento ser gerado. Se esse evento é lida, o comportamento padrão é que a exceção não tratada não encerra o aplicativo, embora o aplicativo for deixado em um estado desconhecido. Nesse caso, o <xref:System.AppDomain.UnhandledException> não é gerado. Esse comportamento pode ser alterado usando o arquivo de configuração de aplicativo ou usando o <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> método para alterar o modo para <xref:System.Windows.Forms.UnhandledExceptionMode?displayProperty=nameWithType> antes do <xref:System.Windows.Forms.Application.ThreadException> manipulador de eventos é conectado. Isso se aplica somente ao thread principal do aplicativo. O <xref:System.AppDomain.UnhandledException> é gerado para exceções sem tratamento lançadas em outros threads.  
  
 A partir do Microsoft Visual Studio 2005, a estrutura de aplicativo do Visual Basic fornece outro evento de exceções sem tratamento no thread principal do aplicativo. Consulte o <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> evento. Esse evento possui um objeto de argumentos de evento com o mesmo nome que o objeto de argumentos de evento usado pelo <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, mas com propriedades diferentes. Em particular, esse objeto de argumentos de evento tem um <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> propriedade que permite que o aplicativo continue em execução, ignorando a exceção não tratada (e sair do aplicativo em um estado desconhecido). Nesse caso, o <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> não é gerado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.AppDomain.UnhandledException> evento. Define um manipulador de eventos, `MyHandler`, que é invocado sempre que é gerada uma exceção sem tratamento no domínio de aplicativo padrão. Em seguida, gera duas exceções. A primeira é tratada por um **try/catch** bloco. O segundo é sem tratamento e invoca o `MyHandle` rotina antes do encerramento do aplicativo.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Um domínio de aplicativo a ser descarregado.</param>
        <summary>Descarrega o domínio de aplicativo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No .NET Framework versão 2.0 há um thread dedicado para o descarregamento de domínios de aplicativo. Isso melhora a confiabilidade, especialmente quando o .NET Framework está hospedado. Quando um thread chama <xref:System.AppDomain.Unload%2A>, o domínio de destino está marcado para descarregar. O thread dedicado tenta descarregar o domínio, e todos os threads no domínio serão anulados. Se um thread não cancelar, por exemplo, porque ele está executando o código não gerenciado, ou porque ele está sendo executado um `finally` bloco, em seguida, após um período de tempo um <xref:System.CannotUnloadAppDomainException> é lançada no thread que originalmente chamado <xref:System.AppDomain.Unload%2A>. Se o thread que não puderam ser anulado eventualmente termina, o domínio de destino não é descarregado. Portanto, no .NET Framework versão 2.0 `domain` não é garantido para descarregar, porque pode não ser possível encerrar threads em execução.  
  
> [!NOTE]
>  Em alguns casos, chamando <xref:System.AppDomain.Unload%2A> faz com que um imediata <xref:System.CannotUnloadAppDomainException>, por exemplo se for chamado em um finalizador.  
  
 Os threads nos `domain` são encerradas usando o <xref:System.Threading.Thread.Abort%2A> método, que gera um <xref:System.Threading.ThreadAbortException> no thread. Embora o thread deve encerrar imediatamente, ele poderá continuar em execução por um período imprevisível em um `finally` cláusula.  
  
## <a name="version-compatibility"></a>Compatibilidade de versões  
 No .NET Framework versão 1.0 e 1.1 se o thread que chama <xref:System.AppDomain.Unload%2A> está sendo executado no `domain`, outro thread é iniciado para realizar a operação. Se `domain` não pode ser descarregado, um <xref:System.CannotUnloadAppDomainException> é lançada nesse thread, não no thread original que chamou <xref:System.AppDomain.Unload%2A>. No entanto, se o thread que chama <xref:System.AppDomain.Unload%2A> está em execução fora `domain`, thread recebe a exceção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como descarregar um domínio de aplicativo.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> é <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          Não foi possível descarregar <paramref name="domain" />.</exception>
        <exception cref="T:System.Exception">Ocorreu um erro durante o processo de descarregamento.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para adicionar um manipulador de eventos para esse evento. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
