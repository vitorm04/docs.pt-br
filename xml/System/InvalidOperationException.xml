<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A exceção que é gerada quando uma chamada de método é inválida para o estado atual do objeto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException>é usado em casos quando a falha para chamar um método é causada por razões diferentes de argumentos inválidos. Normalmente, ela é gerada quando o estado de um objeto não oferece suporte para a chamada do método. Por exemplo, um <xref:System.InvalidOperationException> exceção é lançada por métodos, como:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>Se os objetos de uma coleção são modificados depois que o enumerador é criado. Para obter mais informações, consulte [alterando uma coleção enquanto ele](#Iterating).  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>Se o conjunto de recursos está fechado antes da chamada do método é feita.  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, se um ou mais objetos a serem adicionados resultaria em um documento XML estruturado incorretamente.  
  
-   Um método que tenta manipular a interface do usuário do thread de interface do usuário ou por um thread que não é o principal.  
  
> [!IMPORTANT]
>  Porque o <xref:System.InvalidOperationException> exceção pode ser lançada em uma ampla variedade de circunstâncias, é importante ler a mensagem de exceção retornada pelo <xref:System.Exception.Message%2A> propriedade.  
  
 Nesta seção:  
  
 [Algumas causas comuns de exceções InvalidOperationException](#Causes)   
 [Atualizando um thread de interface do usuário de um thread sem interface do usuário](#UI)  
 [Alterando uma coleção enquanto ele](#Iterating)  
 [A classificação de uma matriz ou coleção cujos objetos não podem ser comparados.](#Sorting)  
 [Convertendo um Nullable&lt;T&gt; que é nula para seu tipo subjacente](#Nullable)   
 [Chamando um método Enumerable em uma coleção vazia](#Empty)  
 [Chamando Enumerable ou LastOrDefault em uma sequência de sem um elemento](#Single)  
 [Acesso de campo dinâmico entre domínios de aplicativo](#Emit)  
[Gerar uma exceção InvalidOperationException](#Throwing)  
[Informações diversas](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>Algumas causas comuns de exceções InvalidOperationException  
 As seções a seguir mostram como algumas casos em que <xref:System.InvalidOperationException> exceção será lançada em um aplicativo. Como tratar o problema depende a situação específica. Mais comumente, no entanto, a exceção resulta de erro do desenvolvedor e o <xref:System.InvalidOperationException> exceção pode ser prevista e evitada.  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>Atualizando um thread de interface do usuário de um thread sem interface do usuário  
 Geralmente, threads de trabalho são usados para realizar algum trabalho em segundo plano que envolve a coleta de dados a ser exibido na interface do usuário do aplicativo. No entanto. a maioria das estruturas de aplicativo de GUI (interface gráfica do usuário) para o .NET Framework, como formulários do Windows e Windows Presentation Foundation (WPF) permitem acessar objetos de interface gráfica do usuário somente do thread que cria e gerencia a interface do usuário (o thread principal ou interface de usuário). Um <xref:System.InvalidOperationException> é gerada quando você tentar acessar um elemento de interface do usuário de um thread que não seja o thread de interface do usuário.  O texto da mensagem de exceção é mostrado na tabela a seguir.  
  
|Tipo de Aplicativo|Mensagem|  
|----------------------|-------------|  
|Aplicativo do WPF|**O thread de chamada não pode acessar este objeto porque ele pertence um thread diferente.**|  
|Aplicativo UWP|**O aplicativo chamado uma interface que foi o marshaling de um thread diferente.**|  
|Aplicativo do Windows Forms|**Operação entre threads inválida: controle 'TextBox1' acessado de um thread que não seja o thread foi criado.**|  
  
 Estruturas de interface do usuário para o .NET Framework implementam um *dispatcher* padrão que inclui um método para verificar se uma chamada para um membro de um elemento de interface do usuário está sendo executada no thread da interface do usuário e outros métodos para agendar a chamada no thread da interface do usuário:  
  
-   Em aplicativos WPF, chame o <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> método para determinar se um método está sendo executado em um thread sem interface do usuário. Ele retorna `true` se o método está em execução no thread da interface do usuário e `false` caso contrário. Chame um das sobrecargas do <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> método para agendar a chamada no thread da interface do usuário.  
  
-   Em aplicativos UWP, chame o [CoreDispatcher.HasThreadAccess](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.core.coredispatcher.hasthreadaccess.aspx) método para determinar se um método está sendo executado em um thread sem interface do usuário. Chamar o [CoreDispatcher.RunAsync](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.core.coredispatcher.runasync.aspx) método para executar um delegado que atualiza o thread de interface do usuário. Use o comando  
  
-   Em aplicativos de formulários do Windows, use o <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> propriedade para determinar se um método está sendo executado em um thread sem interface do usuário. Chame um das sobrecargas do <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> método para executar um delegado que atualiza o thread de interface do usuário.  
  
 Os exemplos a seguir ilustram o <xref:System.InvalidOperationException> exceção que é lançada quando você tentar atualizar um elemento de interface do usuário de um thread que não seja o thread que criou.  Cada exemplo requer que você crie dois controles:  
  
-   Um controle de caixa de texto denominado `textBox1`.  Em um aplicativo de formulários do Windows, você deve definir seu <xref:System.Windows.Forms.TextBox.Multiline%2A> propriedade `true`.  
  
-   Um controle de botão chamado `threadExampleBtn`. O exemplo fornece um manipulador, `ThreadsExampleBtn_Click`, para o botão `Click` eventos.  
  
 Em cada caso, o `threadExampleBtn_Click` chamadas de manipulador de eventos de `DoSomeWork` método duas vezes. A primeira chamada é executado de forma síncrona e será bem-sucedida. Mas a segunda chamada, pois ele executa de forma assíncrona em um pool de threads, tenta atualizar a interface do usuário de um thread sem interface do usuário. Isso resulta em um <xref:System.InvalidOperationException> exceção.  
  
 Aplicativos WPF e UWP  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 A versão seguinte do `DoSomeWork` método elimina a exceção em um aplicativo do WPF.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 A versão seguinte do `DoSomeWork` método elimina a exceção em um aplicativo UWP.  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Aplicativos do Windows Forms  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 A versão seguinte do `DoSomeWork` método elimina a exceção em um aplicativo do Windows Forms.  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>Alterando uma coleção enquanto ele  
 O `foreach` instrução em c# ou `For Each` instrução no Visual Basic é usada para iterar os membros de uma coleção e para ler ou modificar seus elementos individuais. No entanto, ele não pode ser usado para adicionar ou remover itens da coleção. Fazer isso gera um <xref:System.InvalidOperationException> exceção com uma mensagem que é semelhante a "**a coleção foi modificada; operação de enumeração não pode ser executada. **"  
  
 O exemplo a seguir itera que uma coleção de inteiros tenta adicionar o quadrado de cada inteiro à coleção. O exemplo gera um <xref:System.InvalidOperationException> com a primeira chamada para o <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 Você pode eliminar a exceção em uma das duas maneiras, dependendo de sua lógica de aplicativo:  
  
-   Se elementos devem ser adicionados à coleção durante a iteração a ela, você pode iterá-lo usando o índice de `for` instrução, em vez de `foreach` ou `For Each`. O exemplo a seguir usa a instrução adicionar a raiz dos números na coleção à coleção.  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     Observe que você deve estabelecer o número de iterações antes da iteração usando um contador de loop que será encerrado appropraitely loop, por iteração para trás, a coleção de `Count` - 1 para 0, ou, como o exemplo faz, atribuindo o número de elementos na matriz para uma variável e usá-lo para estabelecer o limite superior do loop. Caso contrário, se um elemento é adicionado à coleção em cada iteração, resulta um loop infinito.  
  
-   Se não for necessário adicionar elementos à coleção durante a iteração a ela, você pode armazenar os elementos a serem adicionados em uma coleção temporária que você adicionar ao iterar a coleção foi concluída.  O exemplo a seguir usa essa abordagem para adicionar a raiz dos números em uma coleção para um conjunto temporário e, em seguida, combinar as coleções em um único objeto de matriz.  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>A classificação de uma matriz ou coleção cujos objetos não podem ser comparados.  
 Uso geral de classificação métodos, como o <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> método ou o <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> método, geralmente exigem que pelo menos um dos objetos a serem classificados implementar o <xref:System.IComparable%601> ou <xref:System.IComparable> interface. Se não, a coleção ou matriz não pode ser classificado, e o método gera uma <xref:System.InvalidOperationException> exceção. O exemplo a seguir define uma `Person` classe armazena dois `Person` objetos em um genérico <xref:System.Collections.Generic.List%601> objeto e tentativas para classificá-los. Como a saída mostra o exemplo, a chamada para o <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> método lança um <xref:System.InvalidOperationException>.  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 Você pode eliminar a exceção em qualquer uma das três maneiras:  
  
-   Se você pode ter o tipo que você está tentando classificar (ou seja, se você controlar o código-fonte), você pode modificá-lo para implementar o <xref:System.IComparable%601> ou <xref:System.IComparable> interface. Isso exige que você implemente o <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> ou <xref:System.IComparable.CompareTo%2A> método. Adicionar uma implementação de interface para um tipo existente não é uma alteração significativa.  
  
     O exemplo a seguir usa essa abordagem para fornecer uma <xref:System.IComparable%601> implementação para o `Person` classe. Você ainda poderá chamar o método de classificação geral da matriz ou de coleção e, como mostra a saída do exemplo, a coleção classifica com êxito.  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   Se você não pode modificar o código-fonte para o tipo que você está tentando classificar, você pode definir uma classe de classificação de finalidade especial que implementa o <xref:System.Collections.Generic.IComparer%601> interface.  Você pode chamar uma sobrecarga de `Sort` método inclui um <xref:System.Collections.Generic.IComparer%601> parâmetro. Essa abordagem é especialmente útil se você deseja desenvolver uma classe de classificação especializada que pode classificar os objetos com base em vários critérios.  
  
     O exemplo a seguir usa a abordagem ao desenvolver um personalizado `PersonComparer` classe que é usada para classificar `Person` coleções.  Em seguida, passar uma instância dessa classe para o <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> método.  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   Se você não pode modificar o código-fonte para o tipo está tentando classificar, você pode criar um <xref:System.Comparison%601> delegado para realizar a classificação. É a assinatura do delegado  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     O exemplo a seguir usa a abordagem, definindo um `PersonComparison` método que corresponde a <xref:System.Comparison%601> assinatura do delegado.  Em seguida, passar esse delegado para o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> método.  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>Convertendo um Nullable\<T > que é nula para seu tipo subjacente  
 Tentativa de converter um <xref:System.Nullable%601> valor que é `null` para seu tipo subjacente lança um <xref:System.InvalidOperationException> exceção e exibe a mensagem de erro "**objeto nulo deve ter um valor.**  
  
 O exemplo a seguir gera um <xref:System.InvalidOperationException> exceção quando ele tenta iterar uma matriz que inclui um `Nullable(Of Integer)` valor.  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 Para evitar a exceção:  
  
-   Use o <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> propriedade para selecionar apenas os elementos que não são `null`.  
  
-   Chame um do <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> sobrecargas para fornecer um valor padrão para um `null` valor.  
  
 O exemplo a seguir faz isso para evitar o <xref:System.InvalidOperationException> exceção.  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>Chamando um método Enumerable em uma coleção vazia  
 O <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, e <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> métodos executam operações em uma sequência e retornar um único resultado.   Algumas sobrecargas dos métodos a seguir geram um <xref:System.InvalidOperationException> exceção quando a sequência for vazia, enquanto outras sobrecargas retornam `null`. O <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> método também lançará um <xref:System.InvalidOperationException> exceção quando a sequência contém mais de um elemento.  
  
> [!NOTE]
>  A maioria dos métodos que lançam uma <xref:System.InvalidOperationException> exceção são sobrecargas. Certifique-se de que você entender o comportamento da sobrecarga que você escolher.  
  
 A tabela a seguir lista as mensagens de exceção do <xref:System.InvalidOperationException> objetos de exceção gerados por chamadas para alguns <xref:System.Linq.Enumerable?displayProperty=nameWithType> métodos.  
  
|Método|Mensagem|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**Sequência não contém elementos**|  
|`First`|**A sequência não contém nenhum elemento correspondente**|  
|`Single` <br /> `SingleOrDefault`|**A sequência contém mais de um elemento de correspondência**|  
  
 Como eliminar ou lidar com a exceção depende suposições do seu aplicativo e o método particular chamado.  
  
-   Quando você deliberadamente chama um dos seguintes métodos sem verificar se há uma sequência vazia, você supondo que a sequência não está vazia e uma sequência vazia é uma ocorrência inesperada. Nesse caso, capturando ou relançamento a exceção é apropriado.  
  
-   Se a falha para verificar se há uma sequência vazia foi acidental, você pode chamar uma das sobrecargas do <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> sobrecarga para determinar se uma sequência contém elementos.  
  
    > [!TIP]
    >  Chamar o <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> método antes de gerar uma sequência pode melhorar o desempenho se os dados a serem processados podem conter um grande número de elementos ou se a operação que gera a sequência é cara.  
  
-   Se você já chamou um método como <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, ou <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, você pode substituir um método alternativo, como <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, ou <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, que retorna um valor padrão em vez de um membro da sequência.  
  
 Os exemplos fornecem detalhes adicionais.  
  
 O exemplo a seguir usa o <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> método para calcular a média de uma sequência cujos valores são maiores que 4. Desde que nenhum valor da matriz original excede 4, valores não é incluído na sequência e o método gera uma <xref:System.InvalidOperationException> exceção.  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 A exceção pode ser eliminada chamando o <xref:System.Linq.Enumerable.Any%2A> método para determinar se a sequência contém elementos antes de chamar o método que processa a sequência, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 O <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> método retorna o primeiro item em uma sequência ou o primeiro elemento em uma sequência que satisfazem uma condição especificada. Se a sequência está vazia e, portanto, não tem um elemento primeiro, ele gerará uma <xref:System.InvalidOperationException> exceção.  
  
 No exemplo a seguir, o <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> método lança um <xref:System.InvalidOperationException> exceção porque a matriz de dbQueryResults não contém um elemento maior que 4.  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 Você pode chamar o <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> em vez do <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> para retornar uma especificado ou o valor padrão. Se o método não localizar um elemento primeiro na sequência, ele retorna o valor padrão para esse tipo de dados.  O valor padrão é `null` para um tipo de referência, zero para um tipo de dados numérico e <xref:System.DateTime.MinValue?displayProperty=nameWithType> para o <xref:System.DateTime> tipo.  
  
> [!NOTE]
>  Interpretar o valor retornado pelo <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> método geralmente é complicado pelo fato de que o valor padrão do tipo pode ser um valor válido na sequência. Nesse caso, é uma chamada a <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> método para determinar se a sequência tem membros válidos antes de chamar o <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> método.  
  
 A exemplo a seguir chama o <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> método para impedir que o <xref:System.InvalidOperationException> exceção lançada no exemplo anterior.  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>Chamando Enumerable ou LastOrDefault em uma sequência de sem um elemento  
 O <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> método retorna o único elemento de uma sequência ou o único elemento de uma sequência que atende a uma condição especificada.    Se não há nenhum elemento na sequência, ou se houver mais de um elemento, o método gera uma <xref:System.InvalidOperationException> exceção.  
  
 Você pode usar o <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> método para retornar um valor padrão em vez de gerar uma exceção quando a sequência não contém elementos. No entanto, o <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> método ainda gera um <xref:System.InvalidOperationException> exceção quando a sequência contém mais de um elemento.  
  
 A tabela a seguir lista as mensagens de exceção do <xref:System.InvalidOperationException> objetos de exceção gerados por chamadas para o <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> e <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> métodos.  
  
|Método|Mensagem|  
|------------|-------------|  
|`Single`|**A sequência não contém nenhum elemento correspondente**|  
|`Single` <br /> `SingleOrDefault`|**A sequência contém mais de um elemento de correspondência**|  
  
 No exemplo a seguir, a chamada para o <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> método lança um <xref:System.InvalidOperationException> exceção porque a sequência não tem um elemento maior que 4.  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 O exemplo a seguir tenta impedir que o <xref:System.InvalidOperationException> exceção gerada quando uma sequência é vazia em vez disso, chamando o <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> método. No entanto, como essa sequência retorna vários elementos cujo valor é maior que 2, ele também gera um <xref:System.InvalidOperationException> exceção.  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 Chamar o <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> método pressupõe que uma sequência ou a sequência que atenda aos critérios especificados contém somente um elemento.  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>pressupõe uma sequência com zero ou um resultado, mas não mais. Se esse pressuposto é um deliberada de sua parte, e essas condições não forem atendidas, relançamento ou capturando resultante <xref:System.InvalidOperationException> é apropriado. Caso contrário, ou se você espera que as condições inválidas ocorrerá com alguma frequência, considere o uso de algum outro <xref:System.Linq.Enumerable> método, como <xref:System.Linq.Enumerable.FirstOrDefault%2A> ou <xref:System.Linq.Enumerable.Where%2A>.  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>Acesso de campo dinâmico entre domínios de aplicativo  
 O <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft instrução intermediate language (MSIL) gera um <xref:System.InvalidOperationException> exceção se o objeto que contém o campo cujo endereço que você está tentando recuperar não está dentro do domínio de aplicativo no qual o código está em execução. O endereço de um campo só pode ser acessado do domínio de aplicativo no qual ele reside.  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>Gerar uma exceção InvalidOperationException  
 Você deve lançar uma <xref:System.InvalidOperationException> exceção somente quando o estado de seu objeto por alguma razão não dá suporte a uma chamada de método em particular. Ou seja, a chamada do método é válida em algumas circunstâncias ou contextos, mas não é válida em outros.  
  
 Se a falha da chamada de método é devido a argumentos inválidos, em seguida, <xref:System.ArgumentException> ou uma de suas classes derivadas, <xref:System.ArgumentNullException> ou <xref:System.ArgumentOutOfRangeException>, deverá ser lançada em vez disso.  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>Informações diversas  
 <xref:System.InvalidOperationException>usa o HRESULT COR_E_INVALIDOPERATION, que tem o valor 0x80131509.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.InvalidOperationException>, consulte o <xref:System.InvalidOperationException.%23ctor%2A> construtores.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.InvalidOperationException" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa o <xref:System.Exception.Message%2A> propriedade da nova instância para uma mensagem fornecida pelo sistema que descreve o erro, como "a operação solicitada não pode ser executada." Esta mensagem leva em conta a cultura do sistema atual.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.InvalidOperationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Uma referência nula (`Nothing` no Visual Basic).|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro localizada.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem que descreve o erro.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.InvalidOperationException" /> com uma mensagem de erro especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a propriedade <xref:System.Exception.Message%2A?displayProperty=nameWithType> da nova exceção usando-se o parâmetro `message`. O conteúdo de `message` deve ser compreendido por humanos. O chamador desse construtor é necessário para garantir que essa cadeia de caracteres tenha sido localizada para a cultura do sistema atual.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.InvalidOperationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|Uma referência nula (`Nothing` no Visual Basic).|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto que mantém os dados de objeto serializados.</param>
        <param name="context">As informações contextuais sobre a origem ou o destino.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.InvalidOperationException" /> com dados serializados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado durante a desserialização para reconstituir o objeto de exceção transmitido por um fluxo. Para obter mais informações, consulte [XML e serialização SOAP](~/docs/standard/serialization/xml-and-soap-serialization.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A mensagem de erro que explica a razão da exceção.</param>
        <param name="innerException">A exceção que é a causa da exceção atual. Se o <c>innerException</c> parâmetro não é uma referência nula (<see langword="Nothing" /> no Visual Basic), a exceção atual é gerada em um <see langword="catch" /> bloco que manipula a exceção interna.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.InvalidOperationException" /> com uma mensagem de erro especificada e uma referência à exceção interna que é a causa da exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma exceção que é lançada como um resultado direto de uma exceção anterior deve incluir uma referência para a exceção anterior na propriedade <xref:System.Exception.InnerException%2A>. A propriedade <xref:System.Exception.InnerException%2A> retorna o mesmo valor que é passado para o construtor ou uma referência nula (`Nothing` no Visual Basic) caso a propriedade <xref:System.Exception.InnerException%2A> não forneça o valor de exceção interna para o construtor.  
  
 A tabela a seguir mostra os valores de propriedade iniciais para uma instância de <xref:System.InvalidOperationException>.  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|A referência de exceção interna.|  
|<xref:System.Exception.Message%2A>|A cadeia de caracteres da mensagem de erro.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
