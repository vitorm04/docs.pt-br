<Type Name="Convert" FullName="System.Convert">
  <TypeSignature Language="C#" Value="public static class Convert" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Convert extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Convert" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Converte um tipo de dados base em outro tipo de dados base.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos estáticos do <xref:System.Convert> classe são usados principalmente para oferecer suporte a conversão de e para os tipos de dados base no .NET Framework. Os tipos de base com suporte são <xref:System.Boolean>, <xref:System.Char>, <xref:System.SByte>, <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>, <xref:System.Single>, <xref:System.Double>, <xref:System.Decimal>, <xref:System.DateTime> e <xref:System.String>. Além disso, a <xref:System.Convert> classe inclui métodos para dar suporte a outros tipos de conversões.  
  
 Este tópico é composto pelas seguintes seções:  
  
 [Conversões para e de tipos Base](#Base)   
 [Números decimais não](#NonDecimal)   
 [Conversões de tipos de Base de objetos personalizados](#Custom)   
 [Informações de formatação específica da cultura](#Culture)   
 [A codificação Base64](#Base64)   
 [Outras conversões comuns](#Other)  
  
<a name="Base"></a>   
## <a name="conversions-to-and-from-base-types"></a>Conversões em e de tipos de base  
 Existe um método de conversão para converter cada tipo base para todos os outros tipos de base. No entanto, a chamada real para um método de conversão específica pode produzir um dos cinco resultados, dependendo do valor de tipo de base em tempo de execução e o tipo de base de destino. Esses cinco resultados são:  
  
-   Nenhuma conversão. Isso ocorre quando é feita uma tentativa de converter de um tipo para si mesmo (por exemplo, chamando <xref:System.Convert.ToInt32%28System.Int32%29?displayProperty=nameWithType> com um argumento de tipo <xref:System.Int32>). Nesse caso, o método simplesmente retorna uma instância do tipo original.  
  
-   Um <xref:System.InvalidCastException>. Isso ocorre quando não há suporte para uma determinada conversão. Um <xref:System.InvalidCastException> é lançada para as conversões a seguir:  
  
    -   Conversões de <xref:System.Char> para <xref:System.Boolean>, <xref:System.Single>, <xref:System.Double>, <xref:System.Decimal>, ou <xref:System.DateTime>.  
  
    -   Conversões de <xref:System.Boolean>, <xref:System.Single>, <xref:System.Double>, <xref:System.Decimal>, ou <xref:System.DateTime> para <xref:System.Char>.  
  
    -   Conversões de <xref:System.DateTime> para qualquer outro tipo de exceção <xref:System.String>.  
  
    -   Conversões de qualquer outro tipo, exceto <xref:System.String>, <xref:System.DateTime>.  
  
-   Um <xref:System.FormatException>. Isso ocorre quando a tentativa de converter um valor de cadeia de caracteres em qualquer outro tipo de base falhar porque a cadeia de caracteres não está no formato correto. A exceção é lançada para as conversões a seguir:  
  
    -   Uma cadeia de caracteres a ser convertido em um <xref:System.Boolean> valor não é igual a <xref:System.Boolean.TrueString?displayProperty=nameWithType> ou <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
    -   Uma cadeia de caracteres a ser convertido em um <xref:System.Char> valor consiste em vários caracteres.  
  
    -   Uma cadeia de caracteres a ser convertido em qualquer tipo numérico não é reconhecida como um número válido.  
  
    -   Uma cadeia de caracteres a ser convertido em um <xref:System.DateTime> não é reconhecido como uma data válida e um valor de tempo.  
  
-   Uma conversão bem-sucedida. Para conversões entre dois tipos de base diferentes não listados nos resultados anteriores, todas as conversões ampliadoras, bem como todas as conversões de estreitamento não resultar em perda de dados serão bem-sucedida e o método retornará um valor do tipo de base de destino.  
  
-   Um <xref:System.OverflowException>. Isso ocorre quando uma restrição resultados de conversão em uma perda de dados. Por exemplo, tentando converter um <xref:System.Int32> instância cujo valor é 10000 para um <xref:System.Byte> tipo lança uma <xref:System.OverflowException> porque 10000 está fora do intervalo da <xref:System.Byte> tipo de dados.  
  
 Uma exceção não será lançada se a conversão de um tipo numérico resulta em perda de precisão (ou seja, a perda de alguns dígitos menos significantes). No entanto, uma exceção será lançada se o resultado for maior do que pode ser representado pelo tipo de valor de retorno do método de conversão específica.  
  
 Por exemplo, quando um <xref:System.Double> é convertido em um <xref:System.Single>, pode ocorrer perda de precisão, mas nenhuma exceção é lançada. No entanto, se a magnitude do <xref:System.Double> é muito grande para ser representado por um <xref:System.Single>, é gerada uma exceção de estouro.  
  
<a name="NonDecimal"></a>   
## <a name="non-decimal-numbers"></a>Números decimais não  
 O <xref:System.Convert> classe inclui métodos estáticos que você pode chamar para converter valores integrais para representações de cadeia de caracteres não-decimal e converter cadeias de caracteres que números decimais não representam valores inteiros. Cada um desses métodos de conversão inclui um `base` argumento que permite que você especifique o número de sistema; binário (base 2), octal (base 8) e hexadecimal (base 16), bem como decimal (base 10). Há um conjunto de métodos para converter cada um dos tipos integrais primitivo compatível com CLS para uma cadeia de caracteres e outra para converter uma cadeia de caracteres para cada um dos tipos primitivos integrais:  
  
-   <xref:System.Convert.ToString%28System.Byte%2CSystem.Int32%29>e <xref:System.Convert.ToByte%28System.String%2CSystem.Int32%29>, para converter um valor de bytes em uma cadeia de caracteres em uma base especificada.  
  
-   <xref:System.Convert.ToString%28System.Int16%2CSystem.Int32%29>e <xref:System.Convert.ToInt16%28System.String%2CSystem.Int32%29>, para converter um inteiro assinado de 16 bits em uma cadeia de caracteres em uma base especificada.  
  
-   <xref:System.Convert.ToString%28System.Int32%2CSystem.Int32%29>e <xref:System.Convert.ToInt32%28System.String%2CSystem.Int32%29>, para converter um inteiro assinado de 32 bits em uma cadeia de caracteres em uma base especificada.  
  
-   <xref:System.Convert.ToString%28System.Int64%2CSystem.Int32%29>e <xref:System.Convert.ToInt64%28System.String%2CSystem.Int32%29>, para converter um inteiro assinado de 64 bits em uma cadeia de caracteres em uma base especificada.  
  
-   <xref:System.Convert.ToSByte%28System.String%2CSystem.Int32%29>, para converter a representação de cadeia de caracteres de um valor de byte em um formato especificado em um byte assinado.  
  
-   <xref:System.Convert.ToUInt16%28System.String%2CSystem.Int32%29>, para converter a representação de cadeia de caracteres de um número inteiro em um formato especificado em um inteiro de 16 bits sem sinal.  
  
-   <xref:System.Convert.ToUInt32%28System.String%2CSystem.Int32%29>, para converter a representação de cadeia de caracteres de um número inteiro em um formato especificado em um inteiro de 32 bits sem sinal.  
  
-   <xref:System.Convert.ToUInt64%28System.String%2CSystem.Int32%29>, para converter a representação de cadeia de caracteres de um número inteiro em um formato especificado em um inteiro não assinado de 64 bits.  
  
 O exemplo a seguir converte o valor de <xref:System.Int16.MaxValue?displayProperty=nameWithType> em uma cadeia de caracteres em todos os formatos numéricos com suporte. Em seguida, converte o valor de cadeia de caracteres de volta para um <xref:System.Int16> valor.  
  
 [!code-cpp[System.Convert#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert/CPP/NonDecimal1.cpp#2)]
 [!code-csharp[System.Convert#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert/CS/NonDecimal1.cs#2)]
 [!code-vb[System.Convert#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert/VB/NonDecimal1.vb#2)]  
  
<a name="Custom"></a>   
## <a name="conversions-from-custom-objects-to-base-types"></a>Conversões de objetos personalizados em tipos de base  
 Além de oferecer suporte a conversões entre os tipos de base, o <xref:System.Convert> método dá suporte à conversão de qualquer tipo personalizado para qualquer tipo de base. Para fazer isso, o tipo personalizado deve implementar o <xref:System.IConvertible> interface, que define métodos para converter o tipo de implementação para cada um dos tipos base. Conversões que não são suportados por um determinado tipo devem lançar um <xref:System.InvalidCastException>.  
  
 Quando o <xref:System.Convert.ChangeType%2A> método é passado um tipo personalizado como o primeiro parâmetro, ou quando o `Convert.To` *tipo* método (como <xref:System.Convert.ToInt32%28System.Object%29?displayProperty=nameWithType> ou <xref:System.Convert.ToDouble%28System.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> é chamado e passado a uma instância de um tipo personalizado como o primeiro parâmetro, o <xref:System.Convert> método, por sua vez, chama o tipo personalizado <xref:System.IConvertible> implementação para executar a conversão. Para obter mais informações, consulte [conversão de tipo do .NET Framework](~/docs/standard/base-types/type-conversion.md).  
  
<a name="Culture"></a>   
## <a name="culture-specific-formatting-information"></a>Informações de formatação específicas de cultura  
 Todos os métodos de conversão de tipo de base e o <xref:System.Convert.ChangeType%2A> método incluir sobrecargas que têm um parâmetro do tipo <xref:System.IFormatProvider>. Por exemplo, o <xref:System.Convert.ToBoolean%2A?displayProperty=nameWithType> método tem duas sobrecargas a seguir:  
  
-   <xref:System.Convert.ToBoolean%28System.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType>  
  
-   <xref:System.Convert.ToBoolean%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>  
  
 O <xref:System.IFormatProvider> parâmetro pode fornecer informações de formatação específica da cultura para ajudar o processo de conversão. No entanto, ele será ignorado pela maioria dos métodos de conversão de tipo base. Ele é usado apenas pelos seguintes métodos de conversão de tipo base. Se um `null` <xref:System.IFormatProvider> argumento é passado para esses métodos, o <xref:System.Globalization.CultureInfo> objeto que representa a cultura do thread atual é usado.  
  
-   Por métodos que convertem um valor para um tipo numérico. O <xref:System.IFormatProvider> parâmetro é usado, a sobrecarga que tem parâmetros de tipo <xref:System.String> e <xref:System.IFormatProvider>. Ele também é usado, a sobrecarga que tem parâmetros de tipo <xref:System.Object> e <xref:System.IFormatProvider> se o objeto do tempo de execução tipo é um <xref:System.String>.  
  
-   Por métodos que convertem um valor em uma data e hora. O <xref:System.IFormatProvider> parâmetro é usado, a sobrecarga que tem parâmetros de tipo <xref:System.String> e <xref:System.IFormatProvider>. Ele também é usado, a sobrecarga que tem parâmetros de tipo <xref:System.Object> e <xref:System.IFormatProvider> se o objeto do tempo de execução tipo é um <xref:System.String>.  
  
-   Pelo <xref:System.Convert.ToString%2A?displayProperty=nameWithType> sobrecargas que incluem um <xref:System.IFormatProvider> parâmetro e se converter um valor numérico em uma cadeia de caracteres ou um <xref:System.DateTime> valor em uma cadeia de caracteres.  
  
 No entanto, qualquer tipo definido pelo usuário que implementa <xref:System.IConvertible> podem fazer uso do <xref:System.IFormatProvider> parâmetro.  
  
<a name="Base64"></a>   
## <a name="base64-encoding"></a>A codificação Base64  
 A codificação Base64 converte dados binários em uma cadeia de caracteres. Expressada como dígitos de base 64 de dados podem ser facilmente transmitidos em canais de dados que podem transmitir apenas caracteres de 7 bits. O <xref:System.Convert> classe inclui os seguintes métodos para dar suporte a codificação base64: um conjunto de métodos suporte converter uma matriz de bytes para e de um <xref:System.String> ou de e para uma matriz de caracteres Unicode que consiste em caracteres de dígitos de base 64.  
  
-   <xref:System.Convert.ToBase64String%2A>, que converte uma matriz de bytes em uma cadeia de caracteres codificada em base64.  
  
-   <xref:System.Convert.ToBase64CharArray%2A>, que converte uma matriz de bytes em uma matriz de caracteres codificada em base64.  
  
-   <xref:System.Convert.FromBase64String%2A>, que converte uma cadeia de caracteres codificada em base64 para uma matriz de bytes.  
  
-   <xref:System.Convert.FromBase64CharArray%2A>, que converte uma matriz de caracteres codificada em base64 para uma matriz de bytes.  
  
<a name="Other"></a>   
## <a name="other-common-conversions"></a>Outras conversões comuns  
 Você pode usar outras classes no .NET Framework para executar algumas conversões que não são suportados por um dos métodos estáticos de <xref:System.Convert> classe.  Elas incluem:  
  
 Conversão em matrizes de bytes  
 O <xref:System.BitConverter> classe fornece métodos que convertem os primitivos numéricos (incluindo <xref:System.Boolean>) de matrizes de bytes e bytes matrizes de volta para tipos de dados primitivos.  
  
 Codificação de caracteres e de decodificação  
 O <xref:System.Text.Encoding> classe e suas classes derivadas (como <xref:System.Text.UnicodeEncoding> e <xref:System.Text.UTF8Encoding>) fornecem métodos para codificar uma matriz de caracteres ou uma cadeia de caracteres (ou seja, convertê-las em uma matriz de bytes em uma codificação específica) e decodificar uma matriz de bytes codificados (ou seja, converter uma matriz de bytes para caracteres Unicode codificados UTF16. Para obter mais informações, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md)  
  
   
  
## Examples  
 O exemplo a seguir demonstra alguns dos métodos de conversão de <xref:System.Convert> classe, incluindo <xref:System.Convert.ToInt32%2A>, <xref:System.Convert.ToBoolean%2A>, e <xref:System.Convert.ToString%2A>.  
  
 [!code-cpp[System.Convert#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert/CPP/converter.cpp#1)]
 [!code-csharp[System.Convert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert/CS/converter.cs#1)]
 [!code-vb[System.Convert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert/VB/converter.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public static object ChangeType (object value, Type conversionType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ChangeType(object value, class System.Type conversionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ChangeType(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="conversionType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="conversionType">O tipo de objeto a ser retornado.</param>
        <summary>Retorna um objeto do tipo especificado e cujo valor é equivalente ao objeto especificado.</summary>
        <returns>Um objeto cujo tipo é <paramref name="conversionType" /> e cujo valor é equivalente a <paramref name="value" />.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), se <paramref name="value" /> for <see langword="null" /> e <paramref name="conversionType" /> não for um tipo de valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Convert.ChangeType%2A>é um método de conversão para fins gerais que converte o objeto especificado pelo `value` para `conversionType`. O `value` parâmetro pode ser um objeto de qualquer tipo, e `conversionType` também pode ser um <xref:System.Type> objeto que representa qualquer tipo de base ou personalizado. Para que a conversão seja bem-sucedida, `value` deve implementar a interface <xref:System.IConvertible>, porque o método simplesmente encapsula uma chamada para um método <xref:System.IConvertible> apropriado. O método requer conversão de `value` para `conversionType` suporte.  
  
 Esse método usa a cultura do thread atual para a conversão.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Convert.ChangeType%2A>.  
  
 [!code-cpp[convertchangetype#1](~/samples/snippets/cpp/VS_Snippets_CLR/convertchangetype/CPP/convertchangetype.cpp#1)]
 [!code-csharp[convertchangetype#1](~/samples/snippets/csharp/VS_Snippets_CLR/convertchangetype/CS/convertchangetype.cs#1)]
 [!code-vb[convertchangetype#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/convertchangetype/VB/convertchangetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" /> e <paramref name="conversionType" /> é um tipo de valor.  
  
 -ou-  
  
 <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato reconhecido pelo <paramref name="conversionType" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que está fora do intervalo de <paramref name="conversionType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="conversionType" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>O <see cref="M:System.Convert.ChangeType(System.Object,System.Type)" /> método pode converter um valor de enumeração em outro tipo. No entanto, ele não é possível converter o outro tipo para um valor de enumeração, mesmo se o tipo de origem é o tipo subjacente da enumeração. Para converter um tipo em um valor de enumeração, use um operador de conversão (em c#) ou uma função de conversão (no Visual Basic). O exemplo a seguir ilustra a conversão para e de um <c>continente</c> valor de enumeração.  
  
 [!code-csharp[System.Convert.ChangeType#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype_enum2.cs#5)]
 [!code-vb[System.Convert.ChangeType#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype_enum2.vb#5)]  
  
 O <see cref="M:System.Convert.ChangeType(System.Object,System.Type)" /> método pode converter um tipo anulável em outro tipo. No entanto, ele não é possível converter o outro tipo para um valor de um tipo anulável, mesmo se <paramref name="conversionType" /> é o tipo subjacente do <see cref="T:System.Nullable`1" />. Para executar a conversão, você pode usar um operador de conversão (em c#) ou uma função de conversão (no Visual Basic). O exemplo a seguir ilustra a conversão para e de um tipo anulável.  
  
 [!code-csharp[System.Convert.ChangeType#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype_nullable.cs#7)]
 [!code-vb[System.Convert.ChangeType#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype_nullable.vb#7)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public static object ChangeType (object value, TypeCode typeCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ChangeType(object value, valuetype System.TypeCode typeCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ChangeType(System.Object,System.TypeCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="typeCode" Type="System.TypeCode" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="typeCode">O tipo de objeto a ser retornado.</param>
        <summary>Retorna um objeto do tipo especificado, cujo valor é equivalente ao objeto especificado.</summary>
        <returns>Um objeto cujo tipo subjacente é <paramref name="typeCode" /> e cujo valor é equivalente a <paramref name="value" />.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), se <paramref name="value" /> for <see langword="null" /> e <paramref name="typeCode" /> for <see cref="F:System.TypeCode.Empty" />, <see cref="F:System.TypeCode.String" /> ou <see cref="F:System.TypeCode.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%29>é um método de conversão para fins gerais que converte o objeto especificado pelo `value` para um tipo predefinido especificado pelo `typeCode`. O `value` parâmetro pode ser um objeto de qualquer tipo. Para que a conversão seja bem-sucedida, `value` deve implementar a interface <xref:System.IConvertible>, porque o método simplesmente encapsula uma chamada para um método <xref:System.IConvertible> apropriado. O método também requer conversão de `value` para `typeCode` suporte.  
  
 O <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%29> método não oferece suporte para a conversão de `value` para um tipo personalizado. Para executar tal conversão, chamar o <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%29> método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar o <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%29> método para alterar um <xref:System.Object> para o tipo especificado pelo <xref:System.TypeCode> parâmetro, se possível.  
  
 [!code-cpp[System.Convert.ChangeType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.convert.changetype/cpp/changetype_01.cpp#2)]
 [!code-csharp[System.Convert.ChangeType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype01.cs#2)]
 [!code-vb[System.Convert.ChangeType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype01.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" /> e <paramref name="typeCode" /> especifica um tipo de valor.  
  
 -ou-  
  
 <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato reconhecido pelo tipo <paramref name="typeCode" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que está fora do intervalo do tipo <paramref name="typeCode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeCode" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public static object ChangeType (object value, Type conversionType, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ChangeType(object value, class System.Type conversionType, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="conversionType" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="conversionType">O tipo de objeto a ser retornado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Retorna um objeto do tipo especificado, cujo valor é equivalente ao objeto especificado. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Um objeto cujo tipo é <paramref name="conversionType" /> e cujo valor é equivalente a <paramref name="value" />.  
  
 -ou-  
  
 <paramref name="value" />, se o <see cref="T:System.Type" /> de <paramref name="value" /> e <paramref name="conversionType" /> forem iguais.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), se <paramref name="value" /> for <see langword="null" /> e <paramref name="conversionType" /> não for um tipo de valor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Convert.ChangeType%2A>é um método de conversão para fins gerais que converte o objeto especificado pelo `value` para `conversionType`. O `value` parâmetro pode ser um objeto de qualquer tipo, e `conversionType` também pode ser um <xref:System.Type> objeto que representa qualquer tipo de base ou personalizado. Para que a conversão seja bem-sucedida, `value` deve implementar a interface <xref:System.IConvertible>, porque o método simplesmente encapsula uma chamada para um método <xref:System.IConvertible> apropriado. O método requer conversão de `value` para `conversionType` suporte.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação que fornece informações de formatação para a conversão. Se e como esse parâmetro é usado depende subjacente <xref:System.IConvertible> implementação. Se `value` é um tipo de dados base, `provider` é usado apenas para as conversões a seguir:  
  
-   Conversão de um número em uma cadeia de caracteres ou de uma cadeia de caracteres para um número. `provider`deve ser um <xref:System.Globalization.CultureInfo> objeto, um <xref:System.Globalization.NumberFormatInfo> objeto ou um personalizado <xref:System.IFormatProvider> implementação que retorna um <xref:System.Globalization.NumberFormatInfo> objeto. No entanto, como o <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29> método realiza a conversão usando o especificador de formato padrão "G", o `provider` parâmetro não tem nenhum efeito se `value` ou o tipo de destino é um inteiro não assinado. Se `provider` é `null`, o <xref:System.Globalization.CultureInfo> objeto que representa a cultura do thread atual é usado.  
  
-   Conversão de um <xref:System.DateTime> valor de uma cadeia de caracteres, ou uma cadeia de caracteres para um <xref:System.DateTime> valor. `provider`deve ser um <xref:System.Globalization.CultureInfo> ou <xref:System.Globalization.DateTimeFormatInfo> objeto. Se `provider` é `null`, o <xref:System.Globalization.CultureInfo> objeto que representa a cultura do thread atual é usado.  
  
 Se `value` é um tipo definido pelo aplicativo, seu <xref:System.IConvertible> implementação pode usar o `provider` parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Temperature` classe que implementa o <xref:System.IConvertible> interface.  
  
 [!code-cpp[System.Convert.ChangeType#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.convert.changetype/cpp/changetype03.cpp#3)]
 [!code-csharp[System.Convert.ChangeType#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype03.cs#3)]
 [!code-vb[System.Convert.ChangeType#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype03.vb#3)]  
  
 O exemplo a seguir cria uma instância do `Temperature` classe e chama o <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> método para convertê-lo para os tipos numéricos básicos com suporte pelo .NET Framework e para um <xref:System.String>. Ele ilustra que o <xref:System.Convert.ChangeType%2A> método ajusta uma chamada para o tipo de origem <xref:System.IConvertible> implementação.  
  
 [!code-cpp[System.Convert.ChangeType#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.convert.changetype/cpp/changetype03.cpp#4)]
 [!code-csharp[System.Convert.ChangeType#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype03.cs#4)]
 [!code-vb[System.Convert.ChangeType#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype03.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" /> e <paramref name="conversionType" /> é um tipo de valor.  
  
 -ou-  
  
 <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato para <paramref name="conversionType" /> reconhecido pelo <paramref name="provider" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que está fora do intervalo de <paramref name="conversionType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="conversionType" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage">
          <para>O <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)" /> método pode converter um valor de enumeração em outro tipo. No entanto, ele não é possível converter o outro tipo para um valor de enumeração, mesmo se o tipo de origem é o tipo subjacente da enumeração. Para converter um tipo em um valor de enumeração, use um operador de conversão (em c#) ou uma função de conversão (no Visual Basic). O exemplo a seguir ilustra a conversão para e de um <c>continente</c> valor de enumeração.  
  
 [!code-csharp[System.Convert.ChangeType#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype_enum2.cs#5)]
 [!code-vb[System.Convert.ChangeType#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype_enum2.vb#5)]  
  
 O <see cref="M:System.Convert.ChangeType(System.Object,System.Type,System.IFormatProvider)" /> método pode converter um tipo anulável em outro tipo. No entanto, ele não é possível converter o outro tipo para um valor de um tipo anulável, mesmo se <paramref name="conversionType" /> é o tipo subjacente do <see cref="T:System.Nullable`1" />. Para executar a conversão, você pode usar um operador de conversão (em c#) ou uma função de conversão (no Visual Basic). O exemplo a seguir ilustra a conversão para e de um tipo anulável.  
  
 [!code-csharp[System.Convert.ChangeType#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype_nullable_1.cs#8)]
 [!code-vb[System.Convert.ChangeType#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype_nullable_1.vb#8)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public static object ChangeType (object value, TypeCode typeCode, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ChangeType(object value, valuetype System.TypeCode typeCode, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ChangeType(System.Object,System.TypeCode,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="typeCode" Type="System.TypeCode" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="typeCode">O tipo de objeto a ser retornado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Retorna um objeto do tipo especificado, cujo valor é equivalente ao objeto especificado. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Um objeto cujo tipo subjacente é <paramref name="typeCode" /> e cujo valor é equivalente a <paramref name="value" />.  
  
 -ou-  
  
 Uma referência nula (<see langword="Nothing" /> no Visual Basic), se <paramref name="value" /> for <see langword="null" /> e <paramref name="typeCode" /> for <see cref="F:System.TypeCode.Empty" />, <see cref="F:System.TypeCode.String" /> ou <see cref="F:System.TypeCode.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29>é um método de conversão para fins gerais que converte o objeto especificado pelo `value` para um tipo predefinido especificado pelo `typeCode`. O `value` parâmetro pode ser um objeto de qualquer tipo. Para que a conversão seja bem-sucedida, `value` deve implementar a interface <xref:System.IConvertible>, porque o método simplesmente encapsula uma chamada para um método <xref:System.IConvertible> apropriado. O método também requer conversão de `value` para `typeCode` suporte.  
  
 O <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29> método não oferece suporte para a conversão de `value` para um tipo personalizado. Para executar tal conversão, chamar o <xref:System.Convert.ChangeType%28System.Object%2CSystem.Type%2CSystem.IFormatProvider%29> método.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação que fornece informações de formatação para a conversão. Se e como esse parâmetro é usado depende subjacente <xref:System.IConvertible> implementação. Se `value` é um tipo de dados base, `provider` é usado apenas para as conversões a seguir. Se um `null` <xref:System.IFormatProvider> argumento é passado para esses métodos, o <xref:System.Globalization.CultureInfo> objeto que representa a cultura do thread atual é usado.  
  
-   Conversão de um número em uma cadeia de caracteres ou de uma cadeia de caracteres para um número. `provider`deve ser um <xref:System.Globalization.CultureInfo> objeto, um <xref:System.Globalization.NumberFormatInfo> objeto ou um personalizado <xref:System.IFormatProvider> implementação que retorna um <xref:System.Globalization.NumberFormatInfo> objeto. No entanto, como o <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29> método realiza a conversão usando o especificador de formato padrão "G", o `provider` parâmetro não tem nenhum efeito se `value` ou o tipo de destino é um inteiro não assinado.  
  
-   Conversão de um <xref:System.DateTime> valor de uma cadeia de caracteres, ou uma cadeia de caracteres para um <xref:System.DateTime> valor. `provider`deve ser um <xref:System.Globalization.CultureInfo> ou <xref:System.Globalization.DateTimeFormatInfo> objeto.  
  
 Se `value` é um tipo definido pelo aplicativo, seu <xref:System.IConvertible> implementação pode usar o `provider` parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir define um provedor de formato personalizado chamado `InterceptProvider` que indica quando seu <xref:System.IFormatProvider.GetFormat%2A> é chamado de método e retorna um <xref:System.Globalization.NumberFormatInfo> para a cultura fr-FR e um <xref:System.Globalization.DateTimeFormatInfo> objeto para a cultura en-US. Este provedor de formato é usado em todas as chamadas para o <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29> método. O exemplo cria uma matriz com um <xref:System.Double> e um <xref:System.DateTime> valor e faz chamadas repetidas para <xref:System.Convert.ChangeType%28System.Object%2CSystem.TypeCode%2CSystem.IFormatProvider%29> com cada valor e cada membro de <xref:System.TypeCode> enumeração. O exemplo ilustra quando o método usa o <xref:System.IFormatProvider> parâmetro e também ilustra o uso do `provider` parâmetro para executar formatação sensíveis à cultura.  
  
 [!code-cpp[System.Convert.ChangeType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.convert.changetype/cpp/changetype00.cpp#1)]
 [!code-csharp[System.Convert.ChangeType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.changetype/cs/changetype00.cs#1)]
 [!code-vb[System.Convert.ChangeType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.changetype/vb/changetype00.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" /> e <paramref name="typeCode" /> especifica um tipo de valor.  
  
 -ou-  
  
 <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato para o tipo <paramref name="typeCode" /> reconhecido pelo <paramref name="provider" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que está fora do intervalo do tipo <paramref name="typeCode" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeCode" /> é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DBNull">
      <MemberSignature Language="C#" Value="public static readonly object DBNull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object DBNull" />
      <MemberSignature Language="DocId" Value="F:System.Convert.DBNull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uma constante que representa uma coluna de banco de dados sem dados, ou seja, um banco de dados nulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Convert.DBNull> campo é equivalente à <xref:System.DBNull.Value?displayProperty=nameWithType>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Convert.DBNull#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.dbnull/cs/dbnull1.cs#1)]
 [!code-vb[System.Convert.DBNull#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.dbnull/vb/dbnull1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromBase64CharArray">
      <MemberSignature Language="C#" Value="public static byte[] FromBase64CharArray (char[] inArray, int offset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] FromBase64CharArray(char[] inArray, int32 offset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.FromBase64CharArray(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Char[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de caracteres Unicode.</param>
        <param name="offset">Uma posição no <c>inArray</c>.</param>
        <param name="length">O número de elementos em <c>inArray</c> para converter.</param>
        <summary>Converte um subconjunto de uma matriz de caracteres Unicode que codifica dados binários como dígitos de base 64 em uma matriz de inteiros sem sinal de 8 bits equivalente. Os parâmetros especificam o subconjunto na matriz de entrada e o número de elementos a serem convertidos.</summary>
        <returns>Uma matriz de inteiros sem sinal de 8 bits equivalentes aos elementos <paramref name="length" /> na posição <paramref name="offset" /> em <paramref name="inArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `inArray`é composto de dígitos de base 64, caracteres de espaço em branco e caracteres de preenchimento à direita. Os dígitos de base 64 em ordem crescente de zero são os caracteres maiusculos "A" a "Z", caracteres em minúsculas "a" a "z", numerais "0" para "9" e os símbolos "+" e "/".  
  
 Os caracteres de espaço em branco e os nomes de Unicode e os pontos de código hexadecimal, são guia (CARACTERE de tabulação, U + 0009), nova linha (alimentação de linha, U + 000A), retorno de carro (retorno de CARRO, U + 000d) e espaço em branco (espaço, U + 0020). Um número arbitrário de espaço em branco pode aparecer em `inArray` porque todos os caracteres de espaço em branco são ignorados.  
  
 O caractere sem valor, "=", é usado no preenchimento à direita. O fim do `inArray` pode consistir em zero, um ou dois caracteres de preenchimento.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.FromBase64CharArray%2A> método foi projetado para processar uma matriz de caractere único que contém todos os dados a ser decodificado. Para decodificar dados de caracteres de base 64 de um fluxo, use o <xref:System.Security.Cryptography.FromBase64Transform?displayProperty=nameWithType> classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Convert.FromBase64CharArray%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para decodificar dados UUencoded (base-64) e salve-o como saída binária.  
  
 [!code-cpp[System.Convert UUEncodeDecode functions#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/CPP/class1.cpp#3)]
 [!code-csharp[System.Convert UUEncodeDecode functions#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/CS/class1.cs#3)]
 [!code-vb[System.Convert UUEncodeDecode functions#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/VB/class1.vb#3)]  
  
 O exemplo a seguir demonstra o <xref:System.Convert.ToBase64CharArray%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%2CSystem.Base64FormattingOptions%29> e <xref:System.Convert.FromBase64CharArray%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> métodos. A entrada é dividida em grupos de três bytes (24 bits) cada. Consequentemente, cada grupo consiste em quatro números de 6 bits em que cada número varia de 0 a 63 decimal. Neste exemplo, existem 85 grupos de 3 bytes com um byte restante. O primeiro grupo consiste nos valores hexadecimais 00, 01 e 02, que produzem quatro valores de 6 bits iguais a 0, 0, 4 e 2 decimais. Os quatro valores correspondem aos dígitos de base 64, "A", "A", "E" e "C", no início da saída.  
  
 Caso um número integral de grupos de 3 bytes não exista, os bytes restantes são preenchidos efetivamente com zero para formar um grupo completo. Neste exemplo, o valor do último byte é FF hexadecimal. Os primeiros 6 bits são iguais ao decimal 63, que corresponde ao dígito de base 64 "/" no final da saída, e os 2 próximos bits são preenchidos com zeros para produzir o decimal 48, que corresponde ao dígito de base 64, "w". Os dois últimos valores de 6 bits estão sendo preenchidos e correspondem ao caractere de preenchimento sem valor, "=".  
  
 [!code-cpp[convert.tobase64chararray#1](~/samples/snippets/cpp/VS_Snippets_CLR/convert.tobase64chararray/CPP/tb64ca.cpp#1)]
 [!code-csharp[convert.tobase64chararray#1](~/samples/snippets/csharp/VS_Snippets_CLR/convert.tobase64chararray/CS/tb64ca.cs#1)]
 [!code-vb[convert.tobase64chararray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/convert.tobase64chararray/VB/tb64ca.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="length" /> é menor que 0.  
  
 -ou-  
  
 A soma de <paramref name="offset" /> e <paramref name="length" /> indica uma posição que não está dentro do <paramref name="inArray" />.</exception>
        <exception cref="T:System.FormatException">O comprimento de <paramref name="inArray" />, ignorando caracteres de espaço em branco, não é zero ou um múltiplo de 4.  
  
 -ou-  
  
 O formato de <paramref name="inArray" /> é inválido. <paramref name="inArray" /> contém um caractere que não é de base 64, mais de dois caracteres de preenchimento ou um caractere que não é um espaço em branco entre os caracteres de preenchimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromBase64String">
      <MemberSignature Language="C#" Value="public static byte[] FromBase64String (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] FromBase64String(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.FromBase64String(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres a ser convertida.</param>
        <summary>Converte a cadeia de caracteres especificada, o que codifica dados binários, como dígitos de base 64, em uma matriz equivalente de inteiros sem sinais de 8 bits.</summary>
        <returns>Uma matriz de inteiros sem sinais de 8 bits equivalente a <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s`é composto de dígitos de base 64, caracteres de espaço em branco e caracteres de preenchimento à direita. Os dígitos de base 64 em ordem crescente de zero são os caracteres maiusculos "A" a "Z", caracteres em minúsculas "a" a "z", numerais "0" para "9" e os símbolos "+" e "/".  
  
 Os caracteres de espaço em branco e os nomes de Unicode e os pontos de código hexadecimal, são guia (CARACTERE de tabulação, U + 0009), nova linha (alimentação de linha, U + 000A), retorno de carro (retorno de CARRO, U + 000d) e espaço em branco (espaço, U + 0020). Um número arbitrário de espaço em branco pode aparecer em `s` porque todos os caracteres de espaço em branco são ignorados.  
  
 O caractere sem valor, "=", é usado no preenchimento à direita. O fim do `s` pode consistir em zero, um ou dois caracteres de preenchimento.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.FromBase64String%2A> método foi projetado para processar uma única cadeia de caracteres que contém todos os dados a ser decodificado. Para decodificar dados de caracteres de base 64 de um fluxo, use o <xref:System.Security.Cryptography.FromBase64Transform?displayProperty=nameWithType> classe.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Convert.ToBase64String%28System.Byte%5B%5D%29> método para converter uma matriz de bytes em uma cadeia de caracteres UUencoded (base-64) e, em seguida, chama o <xref:System.Convert.FromBase64String%28System.String%29> método para restaurar a matriz de bytes original.  
  
 [!code-csharp[System.Convert.ToBase64String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert.ToBase64String/cs/ToBase64String2.cs#1)]
 [!code-vb[System.Convert.ToBase64String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert.ToBase64String/vb/ToBase64String2.vb#1)]  
  
 Este é um exemplo mais complexo que cria uma matriz de elementos de 20 de inteiros de 32 bits. Ele usa o <xref:System.BitConverter.GetBytes%28System.Int32%29?displayProperty=nameWithType> método para converter cada elemento em uma matriz de bytes que ele armazena na posição apropriada em um buffer ao chamar o <xref:System.Array.Copy%28System.Array%2CSystem.Int32%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método. Esse buffer é passado para o <xref:System.Convert.ToBase64String%28System.Byte%5B%5D%29> método para criar uma cadeia de caracteres UUencoded (base-64).  Depois, ele chama o <xref:System.Convert.FromBase64String%28System.String%29> método decodificar a cadeia de caracteres UUencoded e chama o <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> método para converter cada conjunto de quatro bytes (o tamanho de um inteiro de 32 bits) para um número inteiro. A saída do exemplo mostra que a matriz original foi restaurada com êxito.  
  
 [!code-csharp[System.Convert.ToBase64String#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert.ToBase64String/cs/ToBase64String.cs#2)]
 [!code-vb[System.Convert.ToBase64String#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert.ToBase64String/vb/ToBase64String.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">O comprimento de <paramref name="s" />, ignorando caracteres de espaço em branco, não é zero ou um múltiplo de 4.  
  
 -ou-  
  
 O formato de <paramref name="s" /> é inválido. <paramref name="s" /> contém um caractere que não é de base 64, mais de dois caracteres de preenchimento ou um caractere que não é um espaço em branco entre os caracteres de preenchimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.GetTypeCode(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para o objeto especificado.</summary>
        <returns>O <see cref="T:System.TypeCode" /> de <paramref name="value" /> ou <see cref="F:System.TypeCode.Empty" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDBNull">
      <MemberSignature Language="C#" Value="public static bool IsDBNull (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDBNull(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.IsDBNull(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto.</param>
        <summary>Retorna uma indicação de que se o objeto especificado é do tipo <see cref="T:System.DBNull" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for do tipo <see cref="T:System.DBNull" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Convert.IsDBNull%2A> método testes se o `value` parâmetro for igual ao <xref:System.DBNull?displayProperty=nameWithType>. É equivalente ao seguinte código:  
  
 [!code-csharp[System.Convert.IsDBNull#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.IsDBNull/cs/Form1.cs#1)]
 [!code-vb[System.Convert.IsDBNull#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.IsDBNull/vb/Form1.vb#1)]  
  
> [!NOTE]
>  <xref:System.DBNull?displayProperty=nameWithType>é usado para indicar um valor que está ausente. Não é equivalente a `null` ou <xref:System.String.Empty?displayProperty=nameWithType>. Portanto, código, como `Convert.IsDBNull(null)` em c# ou `Convert.IsDBNull(Nothing)` no Visual Basic retorna`false`.  
  
   
  
## Examples  
 O exemplo a seguir usa uma <xref:System.Data.SqlClient.SqlDataReader> objeto para recuperar dados de pesquisa de um banco de dados. Ele atribui valores de campo de cada linha em uma matriz e, em seguida, passa cada elemento da matriz de <xref:System.Convert.IsDBNull%2A> método. Se o método retornar `true`, o exemplo atribui a cadeia de caracteres "NA" para o elemento da matriz. A matriz é adicionada para o <xref:System.Windows.Forms.DataGridView.Rows%2A> coleção de um <xref:System.Windows.Forms.DataGridView?displayProperty=nameWithType> controle.  
  
 [!code-csharp[System.Convert.IsDBNull#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.IsDBNull/cs/Form1.cs#2)]
 [!code-vb[System.Convert.IsDBNull#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.IsDBNull/vb/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBase64CharArray">
      <MemberSignature Language="C#" Value="public static int ToBase64CharArray (byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToBase64CharArray(unsigned int8[] inArray, int32 offsetIn, int32 length, char[] outArray, int32 offsetOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
        <Parameter Name="offsetIn" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="outArray" Type="System.Char[]" />
        <Parameter Name="offsetOut" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de entrada com inteiros sem sinal de 8 bits.</param>
        <param name="offsetIn">Uma posição no <c>inArray</c>.</param>
        <param name="length">O número de elementos de <c>inArray</c> para converter.</param>
        <param name="outArray">Uma matriz de saída de caracteres Unicode.</param>
        <param name="offsetOut">Uma posição no <c>outArray</c>.</param>
        <summary>Converte um subconjunto de uma matriz de inteiros não assinados de 8 bits em um subconjunto equivalente de uma matriz de caracteres Unicode codificada com dígitos com base em 64. Os parâmetros especificam os subconjuntos como deslocamentos nas matrizes de entrada e saída, e o número de elementos na matriz de entrada a serem convertidos.</summary>
        <returns>Um inteiro com sinal de 32 bits que contém o número de bytes em <paramref name="outArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O subconjunto de `length` elementos de `inArray` começando na posição `offsetIn`, são executadas como um valor numérico e convertido em um subconjunto de elementos em `outArray` começando na posição `offsetOut`. O valor de retorno indica o número de elementos convertidos em `outArray`. O subconjunto de `outArray` consiste em dígitos de base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere sem valor, "=", é usado no preenchimento à direita.  
  
 Os parâmetros `offset` e `length` são números assinados de 32 bits. O `offsetIn` e `offsetOut` parâmetros são as posições de matriz com base em zero.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64CharArray%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para criar uma matriz de caracteres de base 64 de um fluxo de bytes, use o <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType> classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Convert.ToBase64CharArray%2A> método UUencode (codificação em base 64) um fluxo binário, em seguida, salve a codificação para um arquivo.  
  
 [!code-cpp[System.Convert UUEncodeDecode functions#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/CPP/class1.cpp#2)]
 [!code-csharp[System.Convert UUEncodeDecode functions#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/CS/class1.cs#2)]
 [!code-vb[System.Convert UUEncodeDecode functions#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert UUEncodeDecode functions/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> ou <paramref name="outArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offsetIn" />, <paramref name="offsetOut" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 A soma de <paramref name="offsetIn" /> e <paramref name="length" /> é maior que o tamanho de <paramref name="inArray" />.  
  
 -ou-  
  
 <paramref name="offsetOut" /> mais o número de elementos a serem retornados é maior que o comprimento de <paramref name="outArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBase64CharArray">
      <MemberSignature Language="C#" Value="public static int ToBase64CharArray (byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, Base64FormattingOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToBase64CharArray(unsigned int8[] inArray, int32 offsetIn, int32 length, char[] outArray, int32 offsetOut, valuetype System.Base64FormattingOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Base64FormattingOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
        <Parameter Name="offsetIn" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="outArray" Type="System.Char[]" />
        <Parameter Name="offsetOut" Type="System.Int32" />
        <Parameter Name="options" Type="System.Base64FormattingOptions" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de entrada com inteiros sem sinal de 8 bits.</param>
        <param name="offsetIn">Uma posição no <c>inArray</c>.</param>
        <param name="length">O número de elementos de <c>inArray</c> para converter.</param>
        <param name="outArray">Uma matriz de saída de caracteres Unicode.</param>
        <param name="offsetOut">Uma posição no <c>outArray</c>.</param>
        <param name="options">
          <see cref="F:System.Base64FormattingOptions.InsertLineBreaks" /> para inserir uma quebra de linha a cada 76 caracteres, ou <see cref="F:System.Base64FormattingOptions.None" /> para não inserir quebras de linha.</param>
        <summary>Converte um subconjunto de uma matriz de inteiros não assinados de 8 bits em um subconjunto equivalente de uma matriz de caracteres Unicode codificada com dígitos com base em 64. Parâmetros especificam os subconjuntos como deslocamentos nas matrizes de entrada e saída, o número de elementos na matriz de entrada a serem convertidos e se as quebras de linha são inseridas na matriz de saída.</summary>
        <returns>Um inteiro com sinal de 32 bits que contém o número de bytes em <paramref name="outArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O subconjunto de `length` elementos do `inArray` parâmetro começando na posição `offsetIn`, são executadas como um valor numérico e convertido em um subconjunto de elementos no `outArray` começando na posição de parâmetro `offsetOut`. O valor de retorno indica o número de elementos convertidos em `outArray`. O subconjunto de `outArray` consiste em dígitos de base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere de valor "=" é usado para à direita de preenchimento.  
  
 Os parâmetros `offset` e `length` são números assinados de 32 bits. O `offsetIn` e `offsetOut` parâmetros são as posições de matriz com base em zero.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64CharArray%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para criar uma matriz de caracteres de base 64 de um fluxo de bytes, use o <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType> classe.  
  
 Se o `options` parâmetro está definido como <xref:System.Base64FormattingOptions.InsertLineBreaks> e a saída da conversão é maior do que 76 caracteres, uma quebra de linha é inserida cada 76 caracteres. Uma quebra de linha é definida como um caractere de retorno de carro (U + 000d) seguido por uma linha de feed de caractere (U + 000A). Para obter mais informações, consulte RFC 2045, "Multipurpose Internet Mail Extensions", em [http://www.rfc-editor.org/](http://www.rfc-editor.org/).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Convert.ToBase64CharArray%2A> método. A entrada é dividida em grupos de três bytes (24 bits) cada. Consequentemente, cada grupo consiste em quatro números de 6 bits em que cada número varia de 0 a 63 decimal. Neste exemplo, existem 85 grupos de 3 bytes com um byte restante. O primeiro grupo consiste nos valores hexadecimais 00, 01 e 02, que produzem quatro valores de 6 bits iguais a 0, 0, 4 e 2 decimais. Os quatro valores correspondem aos dígitos de base 64 "A", "A", "E" e "C" no início da saída.  
  
 Caso um número integral de grupos de 3 bytes não exista, os bytes restantes são preenchidos efetivamente com zero para formar um grupo completo. Neste exemplo, o valor do último byte é FF hexadecimal. Os primeiros 6 bits são iguais ao decimal 63, que corresponde ao dígito de base 64 "/" no final da saída, e os 2 próximos bits são preenchidos com zeros para produzir o decimal 48, que corresponde ao dígito de base 64, "w". Os dois últimos valores de 6 bits estão sendo preenchidos e correspondem ao caractere de preenchimento sem valor, "=".  
  
 [!code-cpp[convert.tobase64chararray#1](~/samples/snippets/cpp/VS_Snippets_CLR/convert.tobase64chararray/CPP/tb64ca.cpp#1)]
 [!code-csharp[convert.tobase64chararray#1](~/samples/snippets/csharp/VS_Snippets_CLR/convert.tobase64chararray/CS/tb64ca.cs#1)]
 [!code-vb[convert.tobase64chararray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/convert.tobase64chararray/VB/tb64ca.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> ou <paramref name="outArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offsetIn" />, <paramref name="offsetOut" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 A soma de <paramref name="offsetIn" /> e <paramref name="length" /> é maior que o tamanho de <paramref name="inArray" />.  
  
 -ou-  
  
 <paramref name="offsetOut" /> mais o número de elementos a serem retornados é maior que o comprimento de <paramref name="outArray" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um valor <see cref="T:System.Base64FormattingOptions" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBase64String">
      <MemberSignature Language="C#" Value="public static string ToBase64String (byte[] inArray);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToBase64String(unsigned int8[] inArray) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64String(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de inteiros não assinados de 8 bits.</param>
        <summary>Converte uma matriz de inteiros sem sinal de 8 bits na representação de cadeia de caracteres equivalente codificada com dígitos de base 64.</summary>
        <returns>A representação de cadeia de caracteres, em base 64, do conteúdo de <paramref name="inArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos de `inArray` são criados como um valor numérico e convertido em uma representação de cadeia de caracteres codificada com dígitos de base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere sem valor, "=", é usado no preenchimento à direita.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64String%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para codificar dados a partir de um fluxo, use a classe <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType>.  
  
 Em geral, o <xref:System.Convert.ToBase64String%2A> método não é usado para a viagem um UUEncoded (codificados na base 64) cadeia de caracteres.  Ou seja, se você decodificar uma cadeia de caracteres chamando o <xref:System.Convert.FromBase64String%2A> método, codificar, em seguida, a matriz de bytes retornado ao chamar o <xref:System.Convert.ToBase64String%2A> método, a cadeia de caracteres resultante não serão necessariamente idêntica à cadeia de caracteres original. A cadeia de caracteres será viagem somente se a cadeia de caracteres original for uma cadeia codificada de base 64 válida.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Convert.ToBase64String%28System.Byte%5B%5D%29> método para converter uma matriz de bytes em uma cadeia de caracteres UUencoded (base-64) e, em seguida, chama o <xref:System.Convert.FromBase64String%28System.String%29> método para restaurar a matriz de bytes original.  
  
 [!code-csharp[System.Convert.ToBase64String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert.ToBase64String/cs/ToBase64String2.cs#1)]
 [!code-vb[System.Convert.ToBase64String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert.ToBase64String/vb/ToBase64String2.vb#1)]  
  
 Este é um exemplo mais complexo que cria uma matriz de elementos de 20 de inteiros de 32 bits. Ele usa o <xref:System.BitConverter.GetBytes%28System.Int32%29?displayProperty=nameWithType> método para converter cada elemento em uma matriz de bytes que ele armazena na posição apropriada em um buffer ao chamar o <xref:System.Array.Copy%28System.Array%2CSystem.Int32%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método. Esse buffer é passado para o <xref:System.Convert.ToBase64String%28System.Byte%5B%5D%29> método para criar uma cadeia de caracteres UUencoded (base-64).  Depois, ele chama o <xref:System.Convert.FromBase64String%28System.String%29> método decodificar a cadeia de caracteres UUencoded e chama o <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> método para converter cada conjunto de quatro bytes (o tamanho de um inteiro de 32 bits) para um número inteiro. A saída do exemplo mostra que a matriz original foi restaurada com êxito.  
  
 [!code-csharp[System.Convert.ToBase64String#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert.ToBase64String/cs/ToBase64String.cs#2)]
 [!code-vb[System.Convert.ToBase64String#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert.ToBase64String/vb/ToBase64String.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBase64String">
      <MemberSignature Language="C#" Value="public static string ToBase64String (byte[] inArray, Base64FormattingOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToBase64String(unsigned int8[] inArray, valuetype System.Base64FormattingOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64String(System.Byte[],System.Base64FormattingOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
        <Parameter Name="options" Type="System.Base64FormattingOptions" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de inteiros não assinados de 8 bits.</param>
        <param name="options">
          <see cref="F:System.Base64FormattingOptions.InsertLineBreaks" /> para inserir uma quebra de linha a cada 76 caracteres, ou <see cref="F:System.Base64FormattingOptions.None" /> para não inserir quebras de linha.</param>
        <summary>Converte uma matriz de inteiros sem sinal de 8 bits na representação de cadeia de caracteres equivalente codificada com dígitos de base 64. Um parâmetro especifica se deseja inserir quebras de linha no valor retornado.</summary>
        <returns>A representação de cadeia de caracteres em base 64 dos elementos em <paramref name="inArray" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos do `inArray` parâmetro são executadas como um valor numérico e convertido em uma representação de cadeia de caracteres em base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere de valor "=" é usado para à direita de preenchimento.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64String%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para codificar dados a partir de um fluxo, use a classe <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType>.  
  
 Se o `options` parâmetro está definido como <xref:System.Base64FormattingOptions.InsertLineBreaks> e a saída da conversão é maior do que 76 caracteres, uma quebra de linha é inserida cada 76 caracteres. Uma quebra de linha é definida como um caractere de retorno de carro (U + 000d) seguido por uma linha de feed de caractere (U + 000A). Como quebras de linha são consideradas caracteres de espaço em branco em uma codificação de base 64, elas serão ignoradas quando a conversão de base 64 codificados cadeia de caracteres para uma matriz de bytes. As quebras de linha são simplesmente convenientes ao exibir a cadeia de caracteres codificada para um controle ou um dispositivo, como uma janela do console. Para obter mais informações, consulte RFC 2045, "Multipurpose Internet Mail Extensions", em [http://www.rfc-editor.org/](http://www.rfc-editor.org/).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Convert.ToBase64String%28System.Byte%5B%5D%2CSystem.Base64FormattingOptions%29?displayProperty=nameWithType> com um <xref:System.Base64FormattingOptions?displayProperty=nameWithType> argumento para inserir a linha de quebra na cadeia de caracteres que é produzida por uma matriz de elemento de 100 bytes de codificação.  
  
 [!code-csharp[System.Convert.ToBase64String#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Convert.ToBase64String/cs/ToBase64String3.cs#3)]
 [!code-vb[System.Convert.ToBase64String#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Convert.ToBase64String/vb/ToBase64String3.vb#3)]  
  
 Como a saída mostra o exemplo, o <xref:System.Convert.FromBase64String%2A?displayProperty=nameWithType> terá êxito na restauração de matriz de bytes original; os caracteres de quebra de linha são ignorados durante a conversão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um valor <see cref="T:System.Base64FormattingOptions" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBase64String">
      <MemberSignature Language="C#" Value="public static string ToBase64String (byte[] inArray, int offset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToBase64String(unsigned int8[] inArray, int32 offset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64String(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de inteiros não assinados de 8 bits.</param>
        <param name="offset">Um deslocamento em <c>inArray</c>.</param>
        <param name="length">O número de elementos de <c>inArray</c> para converter.</param>
        <summary>Converte um subconjunto de uma matriz de inteiros sem sinal de 8 bits na representação de cadeia de caracteres equivalente codificada com dígitos de base 64. Parâmetros especificam o subconjunto como um deslocamento na matriz de entrada e o número de elementos na matriz a converter.</summary>
        <returns>A representação de cadeia de caracteres em base 64 de elementos <paramref name="length" /> de <paramref name="inArray" />, começando na posição <paramref name="offset" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos de `inArray` são criados como um valor numérico e convertido em uma representação de cadeia de caracteres em base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere sem valor, "=", é usado no preenchimento à direita.  
  
 Os parâmetros `offset` e `length` são números assinados de 32 bits. O `offset` parâmetro é baseado em zero.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64String%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para codificar dados a partir de um fluxo, use a classe <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 A soma de <paramref name="offset" /> e <paramref name="length" /> é maior que o tamanho de <paramref name="inArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBase64String">
      <MemberSignature Language="C#" Value="public static string ToBase64String (byte[] inArray, int offset, int length, Base64FormattingOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToBase64String(unsigned int8[] inArray, int32 offset, int32 length, valuetype System.Base64FormattingOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBase64String(System.Byte[],System.Int32,System.Int32,System.Base64FormattingOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inArray" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="options" Type="System.Base64FormattingOptions" />
      </Parameters>
      <Docs>
        <param name="inArray">Uma matriz de inteiros não assinados de 8 bits.</param>
        <param name="offset">Um deslocamento em <c>inArray</c>.</param>
        <param name="length">O número de elementos de <c>inArray</c> para converter.</param>
        <param name="options">
          <see cref="F:System.Base64FormattingOptions.InsertLineBreaks" /> para inserir uma quebra de linha a cada 76 caracteres, ou <see cref="F:System.Base64FormattingOptions.None" /> para não inserir quebras de linha.</param>
        <summary>Converte um subconjunto de uma matriz de inteiros sem sinal de 8 bits na representação de cadeia de caracteres equivalente codificada com dígitos de base 64. Parâmetros especificam o subconjunto como um deslocamento da matriz de entrada, o número de elementos na matriz para converter e se deve ou não inserir quebras de linha no valor retornado.</summary>
        <returns>A representação de cadeia de caracteres em base 64 de elementos <paramref name="length" /> de <paramref name="inArray" />, começando na posição <paramref name="offset" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos do `inArray` parâmetro são executadas como um valor numérico e convertido em uma representação de cadeia de caracteres em base 64.  
  
 Os dígitos de base 64 em ordem crescente a partir de zero são os caracteres maiúsculos de "A" a "Z", os caracteres minúsculos de "a" a "z", os numerais de "0" a "9" e os símbolos "+" e "/". O caractere de valor "=" é usado para à direita de preenchimento.  
  
 Os parâmetros `offset` e `length` são números assinados de 32 bits. O `offset` parâmetro é baseado em zero.  
  
> [!IMPORTANT]
>  O <xref:System.Convert.ToBase64String%2A> método foi projetado para processar uma matriz de byte único que contém todos os dados a ser decodificado. Para codificar dados a partir de um fluxo, use a classe <xref:System.Security.Cryptography.ToBase64Transform?displayProperty=nameWithType>.  
  
 Se o `options` parâmetro está definido como <xref:System.Base64FormattingOptions.InsertLineBreaks> e a saída da conversão é maior do que 76 caracteres, uma quebra de linha é inserida cada 76 caracteres. Uma quebra de linha é definida como um caractere de retorno de carro (U + 000d) seguido por uma linha de feed de caractere (U + 000A). Para obter mais informações, consulte RFC 2045, "Multipurpose Internet Mail Extensions", em [http://www.rfc-editor.org/](http://www.rfc-editor.org/).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Convert.ToBase64String%2A> método. A entrada é dividida em grupos de três bytes (24 bits) cada. Consequentemente, cada grupo consiste em quatro números de 6 bits em que cada número varia de 0 a 63 decimal. Neste exemplo, existem 85 grupos de 3 bytes com um byte restante. O primeiro grupo consiste nos valores hexadecimais 00, 01 e 02, que produzem quatro valores de 6 bits iguais a 0, 0, 4 e 2 decimais. Os quatro valores correspondem aos dígitos de base 64 "A", "A", "E" e "C" no início da saída.  
  
 Caso um número integral de grupos de 3 bytes não exista, os bytes restantes são preenchidos efetivamente com zero para formar um grupo completo. Neste exemplo, o valor do último byte é FF hexadecimal. Os primeiros 6 bits são iguais ao decimal 63, que corresponde ao dígito de base 64 "/" no final da saída, e os 2 próximos bits são preenchidos com zeros para produzir o decimal 48, que corresponde ao dígito de base 64, "w". Os dois últimos valores de 6 bits estão sendo preenchidos e correspondem ao caractere de preenchimento sem valor, "=".  
  
 [!code-cpp[convert.tobase64string#1](~/samples/snippets/cpp/VS_Snippets_CLR/convert.tobase64string/CPP/tb64s.cpp#1)]
 [!code-csharp[convert.tobase64string#1](~/samples/snippets/csharp/VS_Snippets_CLR/convert.tobase64string/CS/tb64s.cs#1)]
 [!code-vb[convert.tobase64string#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/convert.tobase64string/VB/tb64s.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="length" /> é negativo.  
  
 -ou-  
  
 A soma de <paramref name="offset" /> e <paramref name="length" /> é maior que o tamanho de <paramref name="inArray" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="options" /> não é um valor <see cref="T:System.Base64FormattingOptions" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser retornado.</param>
        <summary>Retorna o valor booliano especificado. Nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Byte> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#12)]
 [!code-csharp[System.Convert.ToBoolean#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#12)]
 [!code-vb[System.Convert.ToBoolean#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra que uma tentativa de converter um <xref:System.DateTime> valor para um tipo Boolean gera <xref:System.InvalidCastException>.  
  
 [!code-cpp[System.Convert Snippets#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#20)]
 [!code-csharp[System.Convert Snippets#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#20)]
 [!code-vb[System.Convert Snippets#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Decimal> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#2)]
 [!code-csharp[System.Convert.ToBoolean#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#2)]
 [!code-vb[System.Convert.ToBoolean#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um valor booleano para um <xref:System.Double> e um <xref:System.Double> para um valor booliano.  
  
 [!code-cpp[System.Convert Snippets#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#1)]
 [!code-csharp[System.Convert Snippets#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#1)]
 [!code-vb[System.Convert Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int16> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#3)]
 [!code-csharp[System.Convert.ToBoolean#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#3)]
 [!code-vb[System.Convert.ToBoolean#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado para um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int32> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#4)]
 [!code-csharp[System.Convert.ToBoolean#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#4)]
 [!code-vb[System.Convert.ToBoolean#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int64> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#5)]
 [!code-csharp[System.Convert.ToBoolean#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#5)]
 [!code-vb[System.Convert.ToBoolean#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor de um objeto especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> ou <see langword="false" />, que reflete o valor retornado ao invocar o método <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /> para o tipo subjacente de <paramref name="value" />. Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de valores de objeto para <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#11)]
 [!code-csharp[System.Convert.ToBoolean#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#11)]
 [!code-vb[System.Convert.ToBoolean#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> é uma cadeia de caracteres que não é igual a <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte para a conversão de <paramref name="value" /> em um <see cref="T:System.Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 8 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.SByte> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#6)]
 [!code-csharp[System.Convert.ToBoolean#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#6)]
 [!code-vb[System.Convert.ToBoolean#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Single> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#7)]
 [!code-csharp[System.Convert.ToBoolean#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#7)]
 [!code-vb[System.Convert.ToBoolean#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o valor de <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um valor lógico para seu equivalente booliano.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for igual a <see cref="F:System.Boolean.TrueString" />, ou <see langword="false" /> se <paramref name="value" /> for igual a <see cref="F:System.Boolean.FalseString" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma conversão bem-sucedida ocorra, o `value` parâmetro deve ser igual a <xref:System.Boolean.TrueString?displayProperty=nameWithType>, uma constante cujo valor é `True`, <xref:System.Boolean.FalseString?displayProperty=nameWithType>, uma constante cujo valor é `False`, ou deve ser `null`. Comparando `value` com <xref:System.Boolean?displayProperty=nameWithType> e <xref:System.Boolean?displayProperty=nameWithType>, o método ignora maiusculas espaço em branco, bem como à esquerda e à direita.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Boolean.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> método para converter cadeias de caracteres de vários valores booleanos.  
  
 [!code-cpp[System.Convert.ToBoolean#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean1.cpp#1)]
 [!code-csharp[System.Convert.ToBoolean#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/ToBoolean1.cs#1)]
 [!code-vb[System.Convert.ToBoolean#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/ToBoolean1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é igual a <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.UInt16> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#8)]
 [!code-csharp[System.Convert.ToBoolean#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#8)]
 [!code-vb[System.Convert.ToBoolean#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int32> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#9)]
 [!code-csharp[System.Convert.ToBoolean#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#9)]
 [!code-vb[System.Convert.ToBoolean#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado como um valor booliano equivalente.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.UInt64> valores <xref:System.Boolean> valores.  
  
 [!code-cpp[System.Convert.ToBoolean#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cpp/toboolean2.cpp#10)]
 [!code-csharp[System.Convert.ToBoolean#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToBoolean/cs/toboolean2.cs#10)]
 [!code-vb[System.Convert.ToBoolean#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToBoolean/vb/toboolean2.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um valor booliano equivalente, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>
          <see langword="true" /> ou <see langword="false" />, que reflete o valor retornado ao invocar o método <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" /> para o tipo subjacente de <paramref name="value" />. Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Os tipos base ignorar o `provider` parâmetro; no entanto, o parâmetro pode ser usado se `value` é um tipo definido pelo usuário que implementa o <xref:System.IConvertible> interface.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o <xref:System.Convert.ToBoolean%28System.Object%2CSystem.IFormatProvider%29> método. Este método retorna `true` se qualquer um dos valores de matriz não descartado for diferente de zero. O <xref:System.IFormatProvider> objeto determina como os elementos são descartados para este cálculo.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> é uma cadeia de caracteres que não é igual a <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte para a conversão de <paramref name="value" /> em um <see cref="T:System.Boolean" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToBoolean">
      <MemberSignature Language="C#" Value="public static bool ToBoolean (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ToBoolean(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToBoolean(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o valor de <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura. Este parâmetro é ignorado.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um valor lógico para seu equivalente booliano, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for igual a <see cref="F:System.Boolean.TrueString" />, ou <see langword="false" /> se <paramref name="value" /> for igual a <see cref="F:System.Boolean.FalseString" /> ou <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Boolean.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é igual a <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado no inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir ilustra a conversão de <xref:System.Boolean> para <xref:System.Byte> valores.  
  
 [!code-cpp[System.Convert.ToByte#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.convert.tobyte/cpp/tobyte1.cpp#1)]
 [!code-csharp[System.Convert.ToByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#1)]
 [!code-vb[System.Convert.ToByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser retornado.</param>
        <summary>Retorna o inteiro sem sinal de 8 bits especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado no inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna um valor de byte sem sinal que representa o código numérico do <xref:System.Char> objeto passado para ele. No .NET Framework, um <xref:System.Char> objeto é um valor de 16 bits. Isso significa que o método é adequado para retornar os códigos numéricos dos caracteres no intervalo de caracteres ASCII ou nos intervalos Unicode C0 controles e Latim básico e controles de C1 e complementam Latin-1, U + 0000 a U + 00FF.  
  
   
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Char> valores <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#2)]
 [!code-vb[System.Convert.ToByte#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número a ser convertido.</param>
        <summary>Converte o valor de número decimal especificado para um inteiro não assinado de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O exemplo a seguir converte um <xref:System.Byte> valor para um <xref:System.Decimal> e um <xref:System.Decimal> valor para um <xref:System.Byte>.  
  
 [!code-cpp[System.Convert Snippets#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#18)]
 [!code-csharp[System.Convert Snippets#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#18)]
 [!code-vb[System.Convert Snippets#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Byte> valor para um <xref:System.Double> e um <xref:System.Double> valor para um <xref:System.Byte>.  
  
 [!code-cpp[System.Convert Snippets#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#2)]
 [!code-csharp[System.Convert Snippets#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#2)]
 [!code-vb[System.Convert Snippets#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int16> valores <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#3)]
 [!code-vb[System.Convert.ToByte#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int32> valores <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#4)]
 [!code-vb[System.Convert.ToByte#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.Int64> valores <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#5)]
 [!code-vb[System.Convert.ToByte#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado para um inteiro sem sinal de 8 bits.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />, ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToByte%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Convert.ToByte%28System.Object%29> método para converter uma matriz de objetos para <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#6)]
 [!code-vb[System.Convert.ToByte#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          O <paramref name="value" /> não está no formato de propriedade para um valor <see cref="T:System.Byte" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte à conversão do <paramref name="value" /> para o tipo <see cref="T:System.Byte" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do número inteiro com sinal de 8 bits especificado em um número inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de <xref:System.SByte> valores <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#7)]
 [!code-vb[System.Convert.ToByte#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão simples.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Single> valor para um <xref:System.Byte>.  
  
 [!code-cpp[System.Convert Snippets#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#19)]
 [!code-csharp[System.Convert Snippets#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#19)]
 [!code-vb[System.Convert Snippets#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />, ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToByte%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Byte.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Byte.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de cadeia de caracteres e tenta converter cada cadeia de caracteres para um <xref:System.Byte>.  Observe que, embora uma `null` cadeia de caracteres analisa a zero, <xref:System.String.Empty?displayProperty=nameWithType> lança um <xref:System.FormatException>. Além disso, observe que enquanto espaços à direita e analisam com êxito, formatação de símbolos, como símbolos de moeda, separadores de grupo ou separadores decimais, não.  
  
 [!code-csharp[System.Convert.ToByte#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/ToByte5.cs#15)]
 [!code-vb[System.Convert.ToByte#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte5.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros de 16 bits sem sinal para <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#8)]
 [!code-vb[System.Convert.ToByte#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros sem sinal para <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#9)]
 [!code-vb[System.Convert.ToByte#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros longos não assinados para <xref:System.Byte> valores.  
  
 [!code-csharp[System.Convert.ToByte#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte1.cs#10)]
 [!code-vb[System.Convert.ToByte#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro sem sinal de 8 bits, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />, ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `ByteString` classe que implementa o <xref:System.IConvertible> interface. A classe armazena a representação de cadeia de caracteres de um valor de byte junto com um campo de entrada, para que ele possa representar os dois valores de byte assinados e não assinados.  
  
 [!code-csharp[System.Convert.ToByte#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte3.cs#12)]
 [!code-vb[System.Convert.ToByte#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte3.vb#12)]  
  
 O exemplo a seguir cria várias `ByteString` objetos e chama o <xref:System.Convert.ToByte%28System.Object%2CSystem.IFormatProvider%29> método convertê-las em valores de byte. Ele ilustra que o <xref:System.Convert.ToByte%28System.Object%2CSystem.IFormatProvider%29> método ajusta uma chamada para o <xref:System.IConvertible.ToByte%2A?displayProperty=nameWithType> método do objeto a ser convertido.  
  
 [!code-csharp[System.Convert.ToByte#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte3.cs#13)]
 [!code-vb[System.Convert.ToByte#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte3.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          O <paramref name="value" /> não está no formato de propriedade para um valor <see cref="T:System.Byte" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte à conversão do <paramref name="value" /> para o tipo <see cref="T:System.Byte" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro sem sinal de 8 bits equivalente, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um inteiro não assinado de 8 bits equivalente a <paramref name="value" />, ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Byte.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir cria um personalizado <xref:System.Globalization.NumberFormatInfo> objeto que define o sinal positivo como "pos" e o sinal negativo como "neg", ele usa em chamadas para o <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29> método. Depois, ele chama o <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29> método repetidamente para converter cada elemento em uma matriz de cadeia de caracteres para um <xref:System.Byte> valor.  
  
 [!code-csharp[System.Convert.ToByte#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte4.cs#14)]
 [!code-vb[System.Convert.ToByte#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte4.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToByte">
      <MemberSignature Language="C#" Value="public static byte ToByte (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ToByte(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToByte(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada em um inteiro sem sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 8 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque o <xref:System.Byte> tipo de dados oferece suporte a valores não assinados, o <xref:System.Convert.ToByte%28System.String%2CSystem.Int32%29> método pressupõe que `value` é expressado usando a representação binária não assinada. Em outras palavras, todos os oito bits são usados para representar o valor numérico, e um pouco de entrada está ausente. Como resultado, é possível gravar o código no qual um byte assinado valor que está fora do intervalo de <xref:System.Byte> tipo de dados é convertido em um <xref:System.Byte> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.SByte.MinValue> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToByte%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x80 converte a 128".  
  
 [!code-csharp[System.Convert.BaseConversion#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#3)]
 [!code-vb[System.Convert.BaseConversion#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#3)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método ou operador está usando a representação numérica apropriada para interpretar um valor específico. O exemplo a seguir ilustra uma técnica para garantir que o método não usar inadequadamente representação binária não assinado quando ele converte uma representação de cadeia de caracteres hexadecimal para uma <xref:System.Byte> valor. O exemplo determina se um valor representa um inteiro assinado ou não assinado enquanto converte esse valor na representação da cadeia de caracteres. Quando o exemplo converte o valor de volta para um <xref:System.Byte> valor, ele verifica se o valor original era um inteiro com sinal. Se o modo e se o bit de ordem alta é definido (que indica que o valor é negativo e que ele usa dois é o complemento, em vez de representação binária sem sinal), o método gera uma exceção.  
  
 [!code-csharp[System.Convert.BaseConversion#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#4)]
 [!code-vb[System.Convert.BaseConversion#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#4)]  
  
   
  
## Examples  
 Como alternativa, o exemplo a seguir tenta interpretar uma matriz de cadeias de caracteres como a representação de valores binários, octais, decimais e hexadecimais.  
  
 [!code-csharp[System.Convert.ToByte#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tobyte/cs/tobyte2.cs#11)]
 [!code-vb[System.Convert.ToByte#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tobyte/vb/tobyte2.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número sem sinal de base 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.Byte.MinValue" /> ou maior que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado em seu caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de bytes sem sinal para <xref:System.Char> valores.  
  
 [!code-csharp[System.Convert.ToChar#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#1)]
 [!code-vb[System.Convert.ToChar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser retornado.</param>
        <summary>Retorna o valor do caractere Unicode especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter um <xref:System.Decimal> para <xref:System.Char>e gera <xref:System.InvalidCastException> em caso de falha.  
  
 [!code-cpp[System.Convert Snippets#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#17)]
 [!code-csharp[System.Convert Snippets#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#17)]
 [!code-vb[System.Convert Snippets#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em seu caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros de 16 bits com sinal para <xref:System.Char> valores.  
  
 [!code-csharp[System.Convert.ToChar#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#2)]
 [!code-vb[System.Convert.ToChar#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em seu caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros com sinal para <xref:System.Char> valores.  
  
 [!code-csharp[System.Convert.ToChar#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#3)]
 [!code-vb[System.Convert.ToChar#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" /> ou maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em seu caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter um inteiro longo para um <xref:System.Char>e gera um <xref:System.OverflowException> em caso de falha.  
  
 [!code-cpp[System.Convert Snippets#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#8)]
 [!code-csharp[System.Convert Snippets#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#8)]
 [!code-vb[System.Convert Snippets#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" /> ou maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <summary>Converte o valor do objeto especificado em um caractere Unicode.</summary>
        <returns>Um caractere Unicode equivalente ao valor ou <see cref="F:System.Char.MinValue" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToChar%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um <xref:System.Char> valor.  
  
 [!code-csharp[System.Convert.ToChar#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#9)]
 [!code-vb[System.Convert.ToChar#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é uma cadeia de caracteres nula.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte para a conversão de <paramref name="value" /> em um <see cref="T:System.Char" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" /> ou maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 8 bits especificado no caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de bytes assinados para <xref:System.Char> valores.  
  
 [!code-csharp[System.Convert.ToChar#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#4)]
 [!code-vb[System.Convert.ToChar#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres de tamanho 1.</param>
        <summary>Converte o primeiro caractere de uma cadeia de caracteres especificada em um caractere Unicode.</summary>
        <returns>Um caractere Unicode que é equivalente ao primeiro e único caractere em <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`deve ser uma cadeia de caracteres que contém um único caractere.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Char.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de cadeia de caracteres para um <xref:System.Char> valor.  
  
 [!code-csharp[System.Convert.ToChar#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#5)]
 [!code-vb[System.Convert.ToChar#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">O tamanho de <paramref name="value" /> não é 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado no caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits sem sinal para um <xref:System.Char> valor.  
  
 [!code-csharp[System.Convert.ToChar#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#6)]
 [!code-vb[System.Convert.ToChar#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado no caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal a uma <xref:System.Char> valor.  
  
 [!code-csharp[System.Convert.ToChar#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#7)]
 [!code-vb[System.Convert.ToChar#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado para o caractere Unicode equivalente.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal de tempo para um <xref:System.Char> valor.  
  
 [!code-csharp[System.Convert.ToChar#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tochar/cs/tochar1.cs#8)]
 [!code-vb[System.Convert.ToChar#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tochar/vb/tochar1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado para o caractere Unicode equivalente usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um caractere Unicode equivalente a <paramref name="value" /> ou <see cref="F:System.Char.MinValue" />, se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToChar%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o `ToChar` método. Este método retorna um caractere cujo Unicode valor é a média da matriz de <xref:System.Double> valores, usando o objeto que implementa <xref:System.IFormatProvider> para determinar como calcular a média.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é uma cadeia de caracteres nula.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 Não há suporte para a conversão de <paramref name="value" /> em um <see cref="T:System.Char" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que <see cref="F:System.Char.MinValue" /> ou maior que <see cref="F:System.Char.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToChar">
      <MemberSignature Language="C#" Value="public static char ToChar (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char ToChar(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToChar(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres de tamanho 1 ou <see langword="null" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura. Este parâmetro é ignorado.</param>
        <summary>Converte o primeiro caractere da cadeia de caracteres especificada em um caractere Unicode, usando informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um caractere Unicode que é equivalente ao primeiro e único caractere em <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value`deve ser uma cadeia de caracteres que contém um único caractere.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Char.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte uma representação de cadeia de caracteres de um <xref:System.Char> valor com o `ToChar` método, usando um <xref:System.IFormatProvider> objeto que exibe o tipo do provedor de formato para o qual ele é chamado. O exemplo mostra que o provedor de formato não é referenciado.  
  
 [!code-cpp[System.Convert.ToNonNum_String#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToNonNum_String/CPP/stringnonnum.cpp#2)]
 [!code-csharp[System.Convert.ToNonNum_String#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToNonNum_String/CS/stringnonnum.cs#2)]
 [!code-vb[System.Convert.ToNonNum_String#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToNonNum_String/VB/stringnonnum.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">O tamanho de <paramref name="value" /> não é 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">Um valor de data e hora.</param>
        <summary>Retorna o objeto <see cref="T:System.DateTime" /> especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor de ponto flutuante de precisão dupla para converter.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>A data e hora equivalentes do valor de <paramref name="value" /> ou a data e hora equivalentes de <see cref="F:System.DateTime.MinValue" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para a conversão seja bem-sucedida, o tipo de tempo de execução do `value` parâmetro deve ser um <xref:System.DateTime> ou um <xref:System.String>, ou `value` devem ser `null`. Caso contrário, o método gera uma <xref:System.InvalidCastException>. Além disso, se `value` é uma cadeia de caracteres, ele deve conter uma representação válida de um valor de data e hora da cultura atual ou um <xref:System.FormatException> é gerada.  
  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToDateTime%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Convert.ToDateTime%28System.Object%29> método com uma variedade de <xref:System.Object> variáveis.  
  
 [!code-csharp[System.Convert.ToDateTime#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDateTime/cs/ToDateTime1.cs#1)]
 [!code-vb[System.Convert.ToDateTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDateTime/vb/ToDateTime1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um valor de data e hora válido.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor do ponto flutuante de precisão simples a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A representação de cadeia de caracteres de uma data e hora.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de uma data e hora em um valor de data e hora equivalente.</summary>
        <returns>A data e hora equivalentes do valor de <paramref name="value" /> ou a data e hora equivalentes de <see cref="F:System.DateTime.MinValue" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, o valor de retorno é o resultado de chamar o <xref:System.DateTime.Parse%2A?displayProperty=nameWithType> método no `value` usando as informações de formatação em um <xref:System.Globalization.DateTimeFormatInfo> objeto que é inicializado para a cultura atual. O `value` argumento deve conter a representação de uma data e hora em um dos formatos descritos no <xref:System.Globalization.DateTimeFormatInfo> tópico. Se `value` for `null`, o método retornará <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 Esse método tenta analisar `value` completamente e evitar que seja um <xref:System.FormatException>. Ele conclui ausente mês, dia e informações do ano com a data atual. Se `value` contém apenas uma data e nenhuma hora, esse método assume um tempo de meia-noite. Qualquer interna, à esquerda ou caracteres de espaço em branco nos `value` são ignorados.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Convert.ToDateTime%2A> método para converter diversas representações de cadeia de caracteres de data e hora para <xref:System.DateTime> valores.  
  
 [!code-csharp[System.Convert.ToDateTime#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDateTime/cs/ToDateTime2.cs#2)]
 [!code-vb[System.Convert.ToDateTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDateTime/vb/ToDateTime2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é uma cadeia de caracteres de data e hora formatada corretamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um objeto <see cref="T:System.DateTime" />, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A data e hora equivalentes do valor de <paramref name="value" /> ou a data e hora equivalentes de <see cref="F:System.DateTime.MinValue" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToDateTime%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` é um <xref:System.String> que representa uma data, `provider` pode fornecer informações específicas de cultura sobre a notação usada para representar essa data. `provider`está envolvido na conversão de `value` se o tipo de tempo de execução de `value` é um <xref:System.String>, ou se `value` é um usuário definido pelo tipo cujo <xref:System.IConvertible.ToDateTime%2A?displayProperty=nameWithType> implementação faz uso de `provider`. Se o tipo de tempo de execução de `value` é <xref:System.String> e `provider` é `null`, o <xref:System.Globalization.CultureInfo> objeto que representa a cultura do thread atual é usado.  
  
   
  
## Examples  
 O exemplo a seguir define um provedor de formato personalizado, `CustomProvider`, cujo <xref:System.IFormatProvider.GetFormat%2A> método gera uma mensagem para o console que ele foi chamado e, em seguida, retorna o <xref:System.Globalization.DateTimeFormatInfo> objeto de cultura cujo nome foi passado como um parâmetro à sua classe construtor. Cada uma dessas `CustomProvider` objetos é usado para converter os elementos em uma matriz de objetos para valores de data e hora. A saída indica que o `CustomProvider` objeto é usado na conversão apenas quando o tipo do `value` parâmetro é um <xref:System.String>.  
  
 [!code-csharp[System.Convert.ToDateTime#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDateTime/cs/todatetime4.cs#4)]
 [!code-vb[System.Convert.ToDateTime#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDateTime/vb/todatetime4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um valor de data e hora válido.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDateTime">
      <MemberSignature Language="C#" Value="public static DateTime ToDateTime (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime ToDateTime(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDateTime(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém uma data e hora a ser convertida.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em uma data e hora equivalentes, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A data e hora equivalentes do valor de <paramref name="value" /> ou a data e hora equivalentes de <see cref="F:System.DateTime.MinValue" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.DateTime.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.DateTimeFormatInfo>. O objeto <xref:System.Globalization.DateTimeFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.DateTimeFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.DateTime.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de valores de data com o `ToDateTime` método, usando um <xref:System.IFormatProvider> objeto.  
  
 [!code-csharp[System.Convert.ToDateTime#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDateTime/cs/ToDateTime3.cs#3)]
 [!code-vb[System.Convert.ToDateTime#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDateTime/vb/ToDateTime3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é uma cadeia de caracteres de data e hora formatada corretamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o número decimal equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir ilustra a conversão de <xref:System.Boolean> para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#1)]
 [!code-vb[System.Convert.ToDecimal2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o número decimal equivalente.</summary>
        <returns>O número decimal é equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Byte> valor para um <xref:System.Decimal> valor.  
  
 [!code-cpp[System.Convert Snippets#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#18)]
 [!code-csharp[System.Convert Snippets#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#18)]
 [!code-vb[System.Convert Snippets#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter um <xref:System.Char> valor <xref:System.Decimal>e gera <xref:System.InvalidCastException> em caso de falha.  
  
 [!code-cpp[System.Convert Snippets#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#17)]
 [!code-csharp[System.Convert Snippets#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#17)]
 [!code-vb[System.Convert Snippets#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um número decimal.</param>
        <summary>Retorna o número decimal especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de dupla precisão para um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal> valor retornado por este método conterá um máximo de 15 dígitos significativos. Se o `value` parâmetro contém mais de 15 dígitos significativos, ele será arredondado usando arredondamento mais próximo. O exemplo a seguir ilustra como o <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> método usa arredondamento mais próximos de retorno de uma <xref:System.Decimal> valor com 15 dígitos significativos.  
  
 [!code-csharp[System.Convert.ToDecimal#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDecimal/cs/ToDecimal1.cs#2)]
 [!code-vb[System.Convert.ToDecimal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDecimal/vb/ToDecimal1.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Double> valor para um <xref:System.Decimal> valor.  
  
 [!code-cpp[System.Convert Snippets#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#5)]
 [!code-csharp[System.Convert Snippets#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#5)]
 [!code-vb[System.Convert Snippets#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado em um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros com sinal de 16 bits para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#2)]
 [!code-vb[System.Convert.ToDecimal2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros com sinal para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#3)]
 [!code-vb[System.Convert.ToDecimal2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Int64> valor para um <xref:System.Decimal> valor.  
  
 [!code-cpp[System.Convert Snippets#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#10)]
 [!code-csharp[System.Convert Snippets#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#10)]
 [!code-vb[System.Convert Snippets#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" /> ou 0 (zero) se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToDecimal%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Convert.ToDecimal2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#4)]
 [!code-vb[System.Convert.ToDecimal2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 8 bits especificado no número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes assinados para uma <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Convert.ToDecimal2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#5)]
 [!code-vb[System.Convert.ToDecimal2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples para um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Decimal> valor retornado por este método conterá um máximo de sete dígitos significativos. Se o `value` parâmetro contém mais de sete dígitos, ele será arredondado usando arredondamento mais próximo. O exemplo a seguir ilustra como o <xref:System.Convert.ToDecimal%28System.Single%29> método usa arredondamento mais próximos de retorno de uma <xref:System.Decimal> valor com sete dígitos significativos.  
  
 [!code-csharp[System.Convert.ToDecimal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToDecimal/cs/ToDecimal1.cs#1)]
 [!code-vb[System.Convert.ToDecimal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToDecimal/vb/ToDecimal1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores para um <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Convert.ToDecimal2#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#6)]
 [!code-vb[System.Convert.ToDecimal2#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Decimal.MaxValue" /> ou menor que <see cref="F:System.Decimal.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número para um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToDecimal%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Decimal.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Decimal.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `ToDecimal`. Tenta converter um <xref:System.String> para um <xref:System.Decimal>e gera as exceções possíveis que podem surgir durante a conversão.  
  
 [!code-cpp[System.Convert Snippets#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#15)]
 [!code-csharp[System.Convert Snippets#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#15)]
 [!code-vb[System.Convert Snippets#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para um número decimal equivalente.</summary>
        <returns>O número decimal é equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros de 16 bits sem sinal para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#7)]
 [!code-vb[System.Convert.ToDecimal2#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros sem sinal para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#8)]
 [!code-vb[System.Convert.ToDecimal2#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado para um número decimal equivalente.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma matriz de inteiros longos não assinados para <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Convert.ToDecimal2#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal1.cs#9)]
 [!code-vb[System.Convert.ToDecimal2#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um número decimal equivalente, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um número decimal equivalente a <paramref name="value" /> ou 0 (zero) se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToDecimal%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Temperature` classe que implementa o <xref:System.IConvertible> interface.  
  
 [!code-csharp[System.Convert.ToDecimal2#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal2.cs#10)]
 [!code-vb[System.Convert.ToDecimal2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal2.vb#10)]  
  
 O exemplo a seguir mostra que quando um `Temperature` objeto é passado como um parâmetro para o <xref:System.Convert.ToDecimal%28System.Object%2CSystem.IFormatProvider%29> método, o <xref:System.IConvertible.ToDecimal%2A?displayProperty=nameWithType> implementação o `Temperature` classe é chamada para executar a conversão.  
  
 [!code-csharp[System.Convert.ToDecimal2#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal2.cs#11)]
 [!code-vb[System.Convert.ToDecimal2#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal2.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal ToDecimal(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDecimal(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um número decimal equivalente, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um número decimal equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.Decimal.Parse%2A?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Decimal.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter uma matriz de cadeias de caracteres para <xref:System.Decimal> valores usando <xref:System.Globalization.NumberFormatInfo> objetos que representam duas culturas diferentes.  
  
 [!code-csharp[System.Convert.ToDecimal2#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todecimal2/cs/todecimal3.cs#12)]
 [!code-vb[System.Convert.ToDecimal2#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todecimal2/vb/todecimal3.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado no número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Boolean> valor para um <xref:System.Double> valor.  
  
 [!code-cpp[System.Convert Snippets#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#1)]
 [!code-csharp[System.Convert Snippets#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#1)]
 [!code-vb[System.Convert Snippets#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Byte> valor para um <xref:System.Double> valor.  
  
 [!code-cpp[System.Convert Snippets#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#2)]
 [!code-csharp[System.Convert Snippets#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#2)]
 [!code-vb[System.Convert Snippets#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Decimal> valor para um <xref:System.Double> valor.  
  
 [!code-cpp[System.Convert Snippets#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#5)]
 [!code-csharp[System.Convert Snippets#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#5)]
 [!code-vb[System.Convert Snippets#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser retornado.</param>
        <summary>Retorna o número de ponto flutuante de precisão dupla especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros com sinal de 16 bits para uma <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#1)]
 [!code-vb[System.Convert.ToDouble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal especificado de 32 bits em um número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Int32> valor para um <xref:System.Double> valor.  
  
 [!code-cpp[System.Convert Snippets#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#3)]
 [!code-csharp[System.Convert Snippets#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#3)]
 [!code-vb[System.Convert Snippets#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros longos assinados para uma <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#2)]
 [!code-vb[System.Convert.ToDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" /> ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToDouble%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada valor em uma matriz de objeto para um <xref:System.Double>.  
  
 [!code-csharp[System.Convert.ToDouble#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#3)]
 [!code-vb[System.Convert.ToDouble#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Double" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>O inteiro assinado de 8 bits que é equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.SByte> valores para um <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#4)]
 [!code-vb[System.Convert.ToDouble#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um <xref:System.Single> valor para um <xref:System.Double> valor.  
  
 [!code-cpp[System.Convert Snippets#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#6)]
 [!code-csharp[System.Convert Snippets#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#6)]
 [!code-vb[System.Convert Snippets#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToDouble%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de cadeias de caracteres numéricas para um <xref:System.Double>. Saída de exemplo é de um sistema cuja cultura atual é en-US.  
  
 [!code-csharp[System.Convert.ToDouble#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/example8.cs#8)]
 [!code-vb[System.Convert.ToDouble#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/example8.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.UInt16> valores para um <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#5)]
 [!code-vb[System.Convert.ToDouble#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.UInt32> valores para um <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#6)]
 [!code-vb[System.Convert.ToDouble#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.UInt64> valores para um <xref:System.Double> valor.  
  
 [!code-csharp[System.Convert.ToDouble#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.todouble/cs/todouble1.cs#7)]
 [!code-vb[System.Convert.ToDouble#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.todouble/vb/todouble1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um número de ponto flutuante de precisão dupla, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um número de ponto flutuante de precisão dupla equivalente a <paramref name="value" /> ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToDouble%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o `ToDouble` método. Este método retorna uma média da matriz de valores <xref:System.Double>, usando o objeto que implementa <xref:System.IFormatProvider> para determinar como calcular a média.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Double" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDouble">
      <MemberSignature Language="C#" Value="public static double ToDouble (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 ToDouble(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToDouble(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação da cadeia de caracteres especificada de um número em um número de ponto flutuante de precisão dupla equivalente, usando as informações de formatação específicas da cultura.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.Double.Parse%2A?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Double.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de <xref:System.Double> valores com o `ToDouble` método, usando um <xref:System.IFormatProvider> objeto.  
  
 [!code-csharp[System.Convert.ToReals_String#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToReals_String/CS/todouble.cs#2)]
 [!code-vb[System.Convert.ToReals_String#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToReals_String/VB/todouble.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado no inteiro com sinal de 16 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte os valores booleanos `true` e `false` para <xref:System.Int16> valores.  
  
 [!code-csharp[System.Convert.ToInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#1)]
 [!code-vb[System.Convert.ToInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o equivalente inteiro assinado de 16 bits.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Byte> valores para um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#2)]
 [!code-vb[System.Convert.ToInt16#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado no inteiro com sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Char> valores para um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#3)]
 [!code-vb[System.Convert.ToInt16#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado em um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores para um inteiro assinado de 16 bits. O exemplo ilustra que qualquer parte fracionária de um <xref:System.Decimal> valor será arredondado ao executar a conversão.  
  
 [!code-csharp[System.Convert.ToInt16#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#4)]
 [!code-vb[System.Convert.ToInt16#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Double> valores para um inteiro assinado de 16 bits. O exemplo ilustra que qualquer parte fracionária de um <xref:System.Double> valor é arredondado antes de executar a conversão.  
  
 [!code-csharp[System.Convert.ToInt16#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#5)]
 [!code-vb[System.Convert.ToInt16#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado 16-bit para retornar.</param>
        <summary>Retorna o inteiro de assinado de 16 bits especificado; Nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>O inteiro com sinal de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#6)]
 [!code-vb[System.Convert.ToInt16#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 64 bits especificado em um inteiro assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#7)]
 [!code-vb[System.Convert.ToInt16#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro assinado de 16 bits.</summary>
        <returns>Um inteiro com sinal de 16 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToInt16%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#8)]
 [!code-vb[System.Convert.ToInt16#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Int16" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o equivalente inteiro assinado de 16 bits.</summary>
        <returns>Um inteiro com sinal de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes assinados para um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#9)]
 [!code-vb[System.Convert.ToInt16#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores para um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#10)]
 [!code-vb[System.Convert.ToInt16#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 16 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToInt16%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Int16.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int16.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de inteiros de 16 bits com o `ToInt16` método, usando a formatação padrão.  
  
 [!code-cpp[System.Convert.ToSInts_String#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CPP/toint16.cpp#3)]
 [!code-csharp[System.Convert.ToSInts_String#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CS/toint16.cs#3)]
 [!code-vb[System.Convert.ToSInts_String#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToSInts_String/VB/toint16.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado no inteiro com sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros de 16 bits sem sinal em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#11)]
 [!code-vb[System.Convert.ToInt16#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um inteiro assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros sem sinal em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#12)]
 [!code-vb[System.Convert.ToInt16#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos sem sinal em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_1.cs#13)]
 [!code-vb[System.Convert.ToInt16#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro com sinal de 16 bits, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um inteiro com sinal de 16 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o `ToInt16` método. Este método retorna uma média da matriz de valores <xref:System.Double>, usando o objeto que implementa <xref:System.IFormatProvider> para determinar como calcular a média.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato apropriado para um tipo <see cref="T:System.Int16" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 16 bits equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>Um inteiro com sinal de 16 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int16.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de inteiros de 16 bits com o `ToInt16` método, usando um <xref:System.IFormatProvider> objeto.  
  
 [!code-cpp[System.Convert.ToSInts_String#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CPP/toint16.cpp#3)]
 [!code-csharp[System.Convert.ToSInts_String#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CS/toint16.cs#3)]
 [!code-vb[System.Convert.ToSInts_String#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToSInts_String/VB/toint16.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt16">
      <MemberSignature Language="C#" Value="public static short ToInt16 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ToInt16(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt16(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada para um inteiro com sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 16 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque não é compatível com o sinal negativo não base 10 representações de numéricas, o <xref:System.Convert.ToInt16%28System.String%2CSystem.Int32%29> método pressupõe que os números negativos usam representação de complemento de dois. Em outras palavras, o método sempre interpreta o bit de ordem mais alta binário de um inteiro (15 bits) como o bit de sinal. Como resultado, é possível gravar o código no qual um 10 de base não número que está fora do intervalo de <xref:System.Int16> tipo de dados é convertido em um <xref:System.Int16> valor sem o método lançar uma exceção. A seguir incrementa exemplo <xref:System.Int16?displayProperty=nameWithType> por um, converte o número resultante em sua representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToInt16%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x8000 converte -32768."  
  
 [!code-csharp[System.Convert.BaseConversion#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#5)]
 [!code-vb[System.Convert.BaseConversion#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#5)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método está usando a representação numérica apropriada para interpretar um valor específico. Como mostra o exemplo a seguir, você pode garantir que os identificadores de método estoura adequadamente primeiro recuperando o sinal do valor numérico antes de convertê-la em sua representação de cadeia de caracteres hexadecimal. Lançar uma exceção se o valor original era positivo, mas a conversão de volta para um número inteiro produz um valor negativo.  
  
 [!code-csharp[System.Convert.BaseConversion#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#6)]
 [!code-vb[System.Convert.BaseConversion#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#6)]  
  
   
  
## Examples  
 O exemplo a seguir tenta interpretar a cada elemento em uma matriz de cadeia de caracteres como uma cadeia de caracteres hexadecimal e para convertê-los em um inteiro assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToInt16#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint16/cs/toint16_2.cs#14)]
 [!code-vb[System.Convert.ToInt16#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint16/vb/toint16_2.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int16.MinValue" /> ou maior que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o inteiro com sinal de 32 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte a <xref:System.Boolean> valores `true` e `false` para números inteiros.  
  
 [!code-csharp[System.Convert.ToInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#1)]
 [!code-vb[System.Convert.ToInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em um inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#2)]
 [!code-vb[System.Convert.ToInt32#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado no inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Convert.ToInt32%28System.Char%29> método retorna um inteiro assinado de 32 bits que representa a unidade de código codificado em UTF-16 do `value` argumento. Se `value` não é um substituto baixo ou um substituto alto, esse valor de retorno também representa o ponto de código Unicode do valor.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Char> valores para um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#3)]
 [!code-vb[System.Convert.ToInt32#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores para um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#4)]
 [!code-vb[System.Convert.ToInt32#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" /> ou menor que <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Double> valores aninteger.  
  
 [!code-csharp[System.Convert.ToInt32#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#5)]
 [!code-vb[System.Convert.ToInt32#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" /> ou menor que <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em um valor com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros com sinal de 16 bits em um inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#6)]
 [!code-vb[System.Convert.ToInt32#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a ser retornado.</param>
        <summary>Retorna o inteiro com sinal de 32 bits especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#7)]
 [!code-vb[System.Convert.ToInt32#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" /> ou menor que <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado para um inteiro com sinal de 32 bits.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />, ou zero, se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se`value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToInt32%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#8)]
 [!code-vb[System.Convert.ToInt32#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 8 bits especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes assinados para um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#9)]
 [!code-vb[System.Convert.ToInt32#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um número inteiro com sinal de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores para um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#10)]
 [!code-vb[System.Convert.ToInt32#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" /> ou menor que <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToInt32%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Int32.Parse%28System.String%29?displayProperty=nameWithType> método.`value` são interpretados usando as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de cadeia de caracteres numéricos em um número inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#11)]
 [!code-vb[System.Convert.ToInt32#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado no inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits sem sinal em um inteiro.  
  
 [!code-csharp[System.Convert.ToInt32#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#12)]
 [!code-vb[System.Convert.ToInt32#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros sem sinal em um inteiro com sinal.  
  
 [!code-csharp[System.Convert.ToInt32#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#13)]
 [!code-vb[System.Convert.ToInt32#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos sem sinal em um inteiro com sinal.  
  
 [!code-csharp[System.Convert.ToInt32#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_1.cs#14)]
 [!code-vb[System.Convert.ToInt32#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro com sinal de 32 bits, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToInt32%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o `ToInt32` método. Este método retorna uma média da matriz de valores <xref:System.Double>, usando o objeto que implementa <xref:System.IFormatProvider> para determinar como calcular a média.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 32 bits equivalente, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.Int32.Parse%2A?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int32.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define um objeto <xref:System.Globalization.NumberFormatInfo> personalizado que reconhece a cadeia de caracteres "pos" como o sinal positivo e a cadeia de caracteres "neg" como o sinal negativo. Em seguida, ele tenta converter cada elemento de uma matriz de cadeia de caracteres numérica em um inteiro usando esse provedor e o provedor <xref:System.Globalization.NumberFormatInfo> para a cultura invariável.  
  
 [!code-csharp[System.Convert.ToInt32#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint32/cs/toint32_2.cs#15)]
 [!code-vb[System.Convert.ToInt32#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint32/vb/toint32_2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public static int ToInt32 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ToInt32(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt32(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada para um inteiro com sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque não é compatível com o sinal negativo não base 10 representações de numéricas, o <xref:System.Convert.ToInt32%28System.String%2CSystem.Int32%29> método pressupõe que os números negativos usam representação de complemento de dois. Em outras palavras, o método sempre interpreta o bit de ordem mais alta binário de um inteiro (31 bits) como o bit de sinal. Como resultado, é possível gravar o código no qual um 10 de base não número que está fora do intervalo de <xref:System.Int32> tipo de dados é convertido em um <xref:System.Int32> valor sem o método lançar uma exceção. A seguir incrementa exemplo <xref:System.Int32?displayProperty=nameWithType> por um, converte o número resultante em sua representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToInt32%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x80000000 converte -2147483648."  
  
 [!code-cpp[System.Convert.BaseConversion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cpp/toint_str_int32.cpp#1)]
 [!code-csharp[System.Convert.BaseConversion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#1)]
 [!code-vb[System.Convert.BaseConversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#1)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método está usando a representação numérica apropriada para interpretar um valor específico. Como mostra o exemplo a seguir, você pode garantir que os identificadores de método estoura adequadamente primeiro recuperando o sinal do valor numérico antes de convertê-la em sua representação de cadeia de caracteres hexadecimal. Lançar uma exceção se o valor original era positivo, mas a conversão de volta para um número inteiro produz um valor negativo.  
  
 [!code-cpp[System.Convert.BaseConversion#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cpp/toint_str_int32.cpp#2)]
 [!code-csharp[System.Convert.BaseConversion#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#2)]
 [!code-vb[System.Convert.BaseConversion#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int32.MinValue" /> ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte a <xref:System.Boolean> valores `true` e `false` para inteiros longos.  
  
 [!code-csharp[System.Convert.ToInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#1)]
 [!code-vb[System.Convert.ToInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#2)]
 [!code-vb[System.Convert.ToInt64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em um <xref:System.Char> matriz para um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#3)]
 [!code-vb[System.Convert.ToInt64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado em um inteiro com sinal de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores como um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#4)]
 [!code-vb[System.Convert.ToInt64#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int64.MaxValue" /> ou menor que <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro com sinal de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Double> valores como um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#5)]
 [!code-vb[System.Convert.ToInt64#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int64.MaxValue" /> ou menor que <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado em um inteiro assinado de 64 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#6)]
 [!code-vb[System.Convert.ToInt64#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro assinado de 32 bits especificado em um inteiro assinado de 64 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro com sinal de 64 bits.</param>
        <summary>Retorna o inteiro com sinal de 64 bits especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#7)]
 [!code-vb[System.Convert.ToInt64#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro com sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` não é `null`, este método envolve uma chamada para o <xref:System.IConvertible.ToInt64%2A?displayProperty=nameWithType> implementação do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objetos em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#8)]
 [!code-vb[System.Convert.ToInt64#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de byte assinado para um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#9)]
 [!code-vb[System.Convert.ToInt64#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um número inteiro com sinal de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro com sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores como um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#10)]
 [!code-vb[System.Convert.ToInt64#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int64.MaxValue" /> ou menor que <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro assinado de 64 bits equivalente ao número em <paramref name="value" />, ou 0 (zero) caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToInt64%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Int64.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int64.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de cadeias de caracteres numéricas em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#11)]
 [!code-vb[System.Convert.ToInt64#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para o equivalente inteiro assinado de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits sem sinal em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#12)]
 [!code-vb[System.Convert.ToInt64#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um inteiro assinado de 64 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#13)]
 [!code-vb[System.Convert.ToInt64#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro com sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos sem sinal em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_1.cs#14)]
 [!code-vb[System.Convert.ToInt64#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro com sinal de 64 bits, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToInt64%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe que implementa <xref:System.IConvertible> e uma classe que implementa <xref:System.IFormatProvider>. Os objetos da classe que implementa a propriedade <xref:System.IConvertible> têm uma matriz de valores <xref:System.Double>. Um objeto de cada classe é passado para o `ToInt64` método. Este método retorna uma média da matriz de valores <xref:System.Double>, usando o objeto que implementa <xref:System.IFormatProvider> para determinar como calcular a média.  
  
 [!code-cpp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CPP/objectifp.cpp#1)]
 [!code-csharp[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/CS/objectifp.cs#1)]
 [!code-vb[System.Convert.ToXXX_Object_IFP#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToXXX_Object_IFP/VB/objectifp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 64 bits equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>Um inteiro assinado de 64 bits equivalente ao número em <paramref name="value" />, ou 0 (zero) caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.Int64.Parse%2A?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de `IFormatProvider` que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto `NumberFormatInfo` fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, `NumberFormatInfo` da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Int64.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define um objeto <xref:System.Globalization.NumberFormatInfo> personalizado que reconhece a cadeia de caracteres "pos" como o sinal positivo e a cadeia de caracteres "neg" como o sinal negativo. Em seguida, ele tenta converter cada elemento de uma matriz de cadeia de caracteres numérica em um inteiro usando esse provedor e o provedor <xref:System.Globalization.NumberFormatInfo> para a cultura invariável.  
  
 [!code-csharp[System.Convert.ToInt64#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_3.cs#16)]
 [!code-vb[System.Convert.ToInt64#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_3.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public static long ToInt64 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ToInt64(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToInt64(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada para um inteiro com sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro assinado de 64 bits equivalente ao número em <paramref name="value" />, ou 0 (zero) caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque não é compatível com o sinal negativo não base 10 representações de numéricas, o <xref:System.Convert.ToInt64%28System.String%2CSystem.Int32%29> método pressupõe que os números negativos usam representação de complemento de dois. Em outras palavras, o método sempre interpreta o bit de ordem mais alta binário de um inteiro longo (bit 63) como o bit de sinal. Como resultado, é possível gravar o código no qual um 10 de base não número que está fora do intervalo de <xref:System.Int64> tipo de dados é convertido em um <xref:System.Int64> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.UInt64.MaxValue> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToInt64%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0xFFFFFFFFFFFFFFFF converte como -1".  
  
 [!code-csharp[System.Convert.BaseConversion#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#7)]
 [!code-vb[System.Convert.BaseConversion#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#7)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método está usando a representação numérica apropriada para interpretar um valor específico. Como mostra o exemplo a seguir, você pode garantir que os identificadores de método estoura adequadamente primeiro determinando se um valor representa um não assinados ou um tipo assinado ao convertê-lo em sua representação de cadeia de caracteres hexadecimal. Lançar uma exceção se o valor original era um tipo não assinado, mas a conversão de volta para um número inteiro gera um valor de bit cujo logon está em.  
  
 [!code-csharp[System.Convert.BaseConversion#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#8)]
 [!code-vb[System.Convert.BaseConversion#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#8)]  
  
 O exemplo a seguir tenta interpretar a cada elemento em uma matriz de cadeia de caracteres como uma cadeia de caracteres hexadecimal e convertê-lo em um inteiro longo.  
  
 [!code-csharp[System.Convert.ToInt64#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.toint64/cs/toint64_2.cs#15)]
 [!code-vb[System.Convert.ToInt64#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.toint64/vb/toint64_2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.Int64.MinValue" /> ou maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o inteiro com sinal de 8 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte os valores booleanos `true` e `false` para assinado valores de byte.  
  
 [!code-csharp[System.Convert.ToSByte#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#1)]
 [!code-vb[System.Convert.ToSByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado no inteiro com sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de bytes em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#2)]
 [!code-vb[System.Convert.ToSByte#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado no inteiro com sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Char> valores para um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#3)]
 [!code-vb[System.Convert.ToSByte#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor de número decimal especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o inteiro mais próximo de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores para um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#4)]
 [!code-vb[System.Convert.ToSByte#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número especificado de ponto flutuante de precisão dupla em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o inteiro mais próximo de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Double> valores para um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#5)]
 [!code-vb[System.Convert.ToSByte#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado para o equivalente inteiro assinado de 8 bits.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros com sinal de 16 bits em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#6)]
 [!code-vb[System.Convert.ToSByte#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro assinado de 32 bits especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros com sinal de um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#7)]
 [!code-vb[System.Convert.ToSByte#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 64 bits especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#8)]
 [!code-vb[System.Convert.ToSByte#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro assinado de 8 bits.</summary>
        <returns>Um inteiro de 8 bits assinado que é equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToSByte%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#9)]
 [!code-vb[System.Convert.ToSByte#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 8 bits para retornar.</param>
        <summary>Retorna o inteiro de assinado de 8 bits especificado; Nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o inteiro mais próximo de 8 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores para um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#9)]
 [!code-vb[System.Convert.ToSByte#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro com sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 8 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se o valor for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToSByte%28System.String%29> método é equivalente à passagem `value` para o <xref:System.SByte.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.SByte.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de <xref:System.SByte> valores com o `ToSByte` método, usando a formatação padrão.  
  
 [!code-cpp[System.Convert.ToSInts_String#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CPP/tosbyte.cpp#4)]
 [!code-csharp[System.Convert.ToSInts_String#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CS/tosbyte.cs#4)]
 [!code-vb[System.Convert.ToSInts_String#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToSInts_String/VB/tosbyte.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para o equivalente inteiro assinado de 8 bits.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros de 16 bits sem sinal em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#11)]
 [!code-vb[System.Convert.ToSByte#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#12)]
 [!code-vb[System.Convert.ToSByte#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro assinado de 8 bits equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um byte assinado.  
  
 [!code-csharp[System.Convert.ToSByte#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte1.cs#13)]
 [!code-vb[System.Convert.ToSByte#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro assinado de 8 bits, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro de 8 bits assinado que é equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define um `ByteString` classe que armazena ambos assinados e bytes como cadeias de caracteres hexadecimais junto com um campo que indica o sinal do byte. A classe `ByteString` implementa a interface <xref:System.IConvertible>. Seu <xref:System.IConvertible.ToSByte%2A?displayProperty=nameWithType> chamadas de método de <xref:System.SByte.Parse%28System.String%2CSystem.IFormatProvider%29> método para executar a conversão. Se ele falhar, ele gerará um <xref:System.OverflowException>.  
  
 [!code-csharp[System.Convert.ToSByte#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte2.cs#14)]
 [!code-vb[System.Convert.ToSByte#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte2.vb#14)]  
  
 A exemplo a seguir mostra como o <xref:System.IConvertible.ToSByte%2A?displayProperty=nameWithType> implementação o `ByteString` classe é chamada pelo <xref:System.Convert.ToSByte%28System.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Convert.ToSByte#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte2.cs#15)]
 [!code-vb[System.Convert.ToSByte#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um equivalente de 8 bits assinado inteiro, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.SByte.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir converte representações de cadeia de caracteres de <xref:System.SByte> valores com o `ToSByte` método, usando um <xref:System.IFormatProvider> objeto.  
  
 [!code-cpp[System.Convert.ToSInts_String#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CPP/tosbyte.cpp#4)]
 [!code-csharp[System.Convert.ToSInts_String#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToSInts_String/CS/tosbyte.cs#4)]
 [!code-vb[System.Convert.ToSInts_String#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToSInts_String/VB/tosbyte.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSByte">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 ToSByte(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSByte(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada para um inteiro com sinal de 8 bits equivalente.</summary>
        <returns>Um inteiro com sinal de 8 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque não é compatível com o sinal negativo não base 10 representações de numéricas, o <xref:System.Convert.ToSByte%28System.String%2CSystem.Int32%29> método pressupõe que os números negativos usam representação de complemento de dois. Em outras palavras, o método sempre interpreta o bit de ordem superior de um byte (7 bits) como o bit de sinal. Como resultado, é possível gravar o código no qual um 10 de base não número que está fora do intervalo de <xref:System.SByte> tipo de dados é convertido em um <xref:System.SByte> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.Byte.MaxValue> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToSByte%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0xff converte como -1".  
  
 [!code-csharp[System.Convert.BaseConversion#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#9)]
 [!code-vb[System.Convert.BaseConversion#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#9)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método está usando a representação numérica apropriada para interpretar um valor específico. Como mostra o exemplo a seguir, você pode garantir que os identificadores de método estoura adequadamente primeiro determinando se um valor representa um não assinados ou um tipo assinado ao convertê-lo em sua representação de cadeia de caracteres hexadecimal. Lançar uma exceção se o valor original era um tipo não assinado, mas a conversão de volta para um byte assinado gera um valor de bit cujo logon está em.  
  
 [!code-csharp[System.Convert.BaseConversion#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#10)]
 [!code-vb[System.Convert.BaseConversion#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#10)]  
  
   
  
## Examples  
 O exemplo a seguir tenta interpretar os elementos em uma matriz de cadeia de caracteres como binary, octal e a representação hexadecimal de valores numéricos para convertê-los em bytes sem sinal.  
  
 [!code-csharp[System.Convert.ToSByte#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosbyte/cs/tosbyte3.cs#16)]
 [!code-vb[System.Convert.ToSByte#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosbyte/vb/tosbyte3.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado no número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte os valores booleanos `true` e `false` para <xref:System.Single> valores.  
  
 [!code-csharp[System.Convert.ToSingle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#1)]
 [!code-vb[System.Convert.ToSingle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado no número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de valores de byte para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#2)]
 [!code-vb[System.Convert.ToSingle#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado para um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.  
  
 <paramref name="value" /> é arredondado usando o arredondamento mais próximo. Por exemplo, quando arredondado para duas casas decimais, o valor 2.345 torna-se 2.34 e 2.355 torna-se o valor 2.36.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Decimal> valores para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#3)]
 [!code-vb[System.Convert.ToSingle#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.  
  
 <paramref name="value" /> é arredondado usando o arredondamento mais próximo. Por exemplo, quando arredondado para duas casas decimais, o valor 2.345 torna-se 2.34 e 2.355 torna-se o valor 2.36.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Double> valores para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#4)]
 [!code-vb[System.Convert.ToSingle#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado para um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits a uma <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#5)]
 [!code-vb[System.Convert.ToSingle#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro assinado de 32 bits especificado para um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros para uma <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#6)]
 [!code-vb[System.Convert.ToSingle#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 64 bits especificado para um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros longos para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#7)]
 [!code-vb[System.Convert.ToSingle#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número de ponto flutuante de precisão simples que é equivalente a <paramref name="value" /> ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToSingle%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objeto para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#8)]
 [!code-vb[System.Convert.ToSingle#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um inteiro assinado de 8 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de byte assinado para uma <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#9)]
 [!code-vb[System.Convert.ToSingle#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser retornado.</param>
        <summary>Retorna o número de ponto flutuante de precisão simples especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples que é equivalente ao número em <paramref name="value" /> ou 0 (zero) se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToSingle%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Single.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de cadeias de caracteres numéricas para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#10)]
 [!code-vb[System.Convert.ToSingle#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para o número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits sem sinal para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#11)]
 [!code-vb[System.Convert.ToSingle#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado em um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal a uma <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#12)]
 [!code-vb[System.Convert.ToSingle#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado para um número de ponto flutuante de precisão simples equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão simples equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal de tempo para um <xref:System.Single> valor.  
  
 [!code-csharp[System.Convert.ToSingle#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle1.cs#13)]
 [!code-vb[System.Convert.ToSingle#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um número de ponto flutuante de precisão simples, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um número de ponto flutuante de precisão simples que é equivalente a <paramref name="value" /> ou zero se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToSingle%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Temperature` classe que implementa o <xref:System.IConvertible> interface. Sua implementação do <xref:System.IConvertible.ToSingle%2A?displayProperty=nameWithType> método retorna o valor interno de uma particular <xref:System.Single> variável que representa a temperatura.  
  
 [!code-csharp[System.Convert.ToSingle#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle2.cs#14)]
 [!code-vb[System.Convert.ToSingle#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle2.vb#14)]  
  
 O exemplo a seguir ilustra como uma chamada para o <xref:System.Convert.ToSingle%28System.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método, por sua vez, chama o <xref:System.IConvertible.ToSingle%2A?displayProperty=nameWithType> implementação o `Temperature` classe.  
  
 [!code-csharp[System.Convert.ToSingle#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle2.cs#15)]
 [!code-vb[System.Convert.ToSingle#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa <see cref="T:System.IConvertible" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSingle">
      <MemberSignature Language="C#" Value="public static float ToSingle (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ToSingle(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToSingle(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres de um número especificada em um número de ponto flutuante de precisão simples equivalente, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>Um número de ponto flutuante de precisão simples que é equivalente ao número em <paramref name="value" /> ou 0 (zero) se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.Single.Parse%2A?displayProperty=nameWithType> método `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.Single.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.IFormatProvider> objetos que representam as culturas en-US e fr-FR ao converter os elementos em uma matriz de cadeias de caracteres numéricas para <xref:System.Single> valores.  
  
 [!code-csharp[System.Convert.ToSingle#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tosingle/cs/tosingle3.cs#16)]
 [!code-vb[System.Convert.ToSingle#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tosingle/vb/tosingle3.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.Single.MinValue" /> ou maior que <see cref="F:System.Single.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>. Ele retorna <xref:System.Boolean.TrueString?displayProperty=nameWithType> para `true` valores e <xref:System.Boolean.FalseString?displayProperty=nameWithType> para `false` valores.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a conversão de um <xref:System.Boolean> para um <xref:System.String>usando `ToString`. Ele também ilustra a cadeia de caracteres retornada pela conversão é igual a <xref:System.Boolean.TrueString?displayProperty=nameWithType> ou <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Convert.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString/cs/ToString_Bool1.cs#1)]
 [!code-vb[System.Convert.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString/vb/ToString_Bool1.vb#1)]  
 [!code-fsharp[System.Convert.ToString#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.Convert.ToString/fs/ToString_Bool1.fs#1)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Byte.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada valor em uma <xref:System.Byte> matriz como uma cadeia de caracteres.  
  
 [!code-csharp[System.Convert.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString/cs/ToString.Byte1.cs#3)]
 [!code-vb[System.Convert.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString/vb/ToString.Byte1.vb#3)]
 [!code-fsharp[System.Convert.ToString#3](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.Convert.ToString/fs/ToString_Byte1.fs#3)]
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Char.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Char> para um <xref:System.String>.  
  
 [!code-cpp[System.Convert Snippets#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#14)]
 [!code-csharp[System.Convert Snippets#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#14)]
 [!code-vb[System.Convert Snippets#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>Converte o valor do <see cref="T:System.DateTime" /> especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.DateTime.ToString?displayProperty=nameWithType>. Ele usa as convenções de formatação da cultura atual e o especificador de formato "G" para converter um <xref:System.DateTime> valor em sua representação de cadeia de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de um <xref:System.DateTime> valor para um <xref:System.String> valor.  
  
 [!code-csharp[System.Convert.ToString2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#1)]
 [!code-vb[System.Convert.ToString2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor do número decimal especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Decimal.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Decimal> para um <xref:System.String>.  
  
 [!code-cpp[System.Convert Snippets#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#15)]
 [!code-csharp[System.Convert Snippets#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#15)]
 [!code-vb[System.Convert Snippets#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Double.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Double> para um <xref:System.String>.  
  
 [!code-cpp[System.Convert Snippets#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert Snippets/CPP/system.convert snippet.cpp#7)]
 [!code-csharp[System.Convert Snippets#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert Snippets/CS/system.convert snippet.cs#7)]
 [!code-vb[System.Convert Snippets#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert Snippets/VB/system.convert snippet.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int16.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#2)]
 [!code-vb[System.Convert.ToString2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int32.ToString?displayProperty=nameWithType>. Formata `value` usando as convenções de formatação da cultura do thread atual.  
  
   
  
## Examples  
 O exemplo a seguir compara o <xref:System.Convert.ToString%28System.Int32%29> método com o <xref:System.Convert.ToString%28System.UInt16%2CSystem.IFormatProvider%29> método. Define um personalizado <xref:System.Globalization.NumberFormatInfo> objeto que usa a sequência "menos" para representar o sinal negativo. Ele converte cada elemento em uma matriz de inteiros em sua representação de cadeia de caracteres equivalente usando (as convenções de formatação da cultura atual) a formatação padrão e o provedor de formato personalizado.  
  
 [!code-csharp[System.Convert.ToString2#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring7.cs#27)]
 [!code-vb[System.Convert.ToString2#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring7.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int64.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros longos em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring6.cs#28)]
 [!code-vb[System.Convert.ToString2#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring6.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que fornece o valor a ser convertido ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação de cadeia de caracteres de <paramref name="value" />, ou <see cref="F:System.String.Empty" /> se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para converter `value` em sua representação de cadeia de caracteres, o método tentará chamar o <xref:System.IConvertible.ToString%2A?displayProperty=nameWithType> implementação de `value`. Se `value` não implementa o <xref:System.IConvertible> o método de interface, tentará chamar o <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação de `value`. Se o valor não implementa o <xref:System.IFormattable> interface, as chamadas de método de `ToString` método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de objeto em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#3)]
 [!code-vb[System.Convert.ToString2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.SByte.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de byte assinado em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#4)]
 [!code-vb[System.Convert.ToString2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Single.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Single> valores em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#5)]
 [!code-vb[System.Convert.ToString2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser retornada.</param>
        <summary>Retorna a instância de cadeia de caracteres especificada; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir passa uma cadeia de caracteres para o <xref:System.Convert.ToString%28System.String%29> método e chama o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método para confirmar que o método retorna a cadeia de caracteres original. O exemplo também chama o <xref:System.String.IsInterned%2A?displayProperty=nameWithType> método para garantir que as duas cadeias de caracteres não são idênticas, porque a cadeia de caracteres original é definidos como internos.  
  
 [!code-csharp[System.Convert.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString/cs/tostring_string1.cs#2)]
 [!code-vb[System.Convert.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString/vb/tostring_string1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado em uma representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt16.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de valores inteiros de 16 bits sem sinal em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#6)]
 [!code-vb[System.Convert.ToString2#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt32.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#7)]
 [!code-vb[System.Convert.ToString2#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt64.ToString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiro longo não assinado em sua representação de cadeia de caracteres equivalente.  
  
 [!code-csharp[System.Convert.ToString2#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring1.cs#8)]
 [!code-vb[System.Convert.ToString2#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (bool value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(bool value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Boolean,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <param name="provider">Uma instância de um objeto. Este parâmetro é ignorado.</param>
        <summary>Converte o valor booliano especificado na representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>. Ele retorna <xref:System.Boolean.TrueString?displayProperty=nameWithType> para `true` valores e <xref:System.Boolean.FalseString?displayProperty=nameWithType> para `false` valores.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Boolean> valor para um <xref:System.String> com o `ToString` método, usando um <xref:System.IFormatProvider> objeto que exibe o tipo do provedor de formato para o qual ele é chamado. O exemplo mostra que o <xref:System.IFormatProvider> objeto não é referenciado.  
  
 [!code-cpp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CPP/nonnumeric.cpp#2)]
 [!code-csharp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CS/nonnumeric.cs#2)]
 [!code-vb[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/VB/nonnumeric.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (byte value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int8 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Byte,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado em sua representação de cadeia de caracteres equivalente, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Byte.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes não assinado em sua representação de cadeia de caracteres equivalente usando as convenções de formatação das culturas en-US e fr-FR. Porque o especificador "G" por padrão gera somente dígitos decimais na representação de cadeia de caracteres do valor de um byte, o `provider` parâmetro não afeta a formatação da cadeia de caracteres retornada.  
  
 [!code-csharp[System.Convert.ToString2#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#16)]
 [!code-vb[System.Convert.ToString2#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (byte value, int toBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int8 value, int32 toBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Byte,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="toBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <param name="toBase">A base do valor de retorno, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte o valor de um inteiro sem sinal de 8 bits em sua representação de cadeia de caracteres equivalente de uma base especificada.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" /> na base <paramref name="toBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `toBase` não é igual a 10, a cadeia de caracteres que é retornado pelo <xref:System.Convert.ToString%28System.Byte%2CSystem.Int32%29?displayProperty=nameWithType> método representa `value` por sua magnitude somente. Se o método é chamado para criar uma cadeia de caracteres que posteriormente será convertida para um número, um método correspondente que assume uma representação numérica somente magnitude deve ser chamado para executar a conversão. Esses métodos incluem <xref:System.Convert.ToByte%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> ou <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em suas representações de cadeia de caracteres binária, hexadecimal, decimal e hexadecimal equivalente.  
  
 [!code-csharp[System.Convert.ToString2#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring2.cs#9)]
 [!code-vb[System.Convert.ToString2#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring2.vb#9)]
 [!code-fsharp[System.Convert.ToString2#9](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.convert.tostring2/fs/tostring2.fs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="toBase" /> não é 2, 8, 10 ou 16.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (char value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(char value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Char,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura. Este parâmetro é ignorado.</param>
        <summary>Converte o valor do caractere Unicode especificado em sua representação de cadeia de caracteres equivalente, usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Char.ToString?displayProperty=nameWithType>. O `provider` parâmetro é ignorado.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.Char> valor para um <xref:System.String> com o `ToString` método, usando um <xref:System.IFormatProvider> objeto que exibe o tipo do provedor de formato para o qual ele é chamado. O exemplo mostra que o <xref:System.IFormatProvider> objeto não é referenciado.  
  
 [!code-cpp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CPP/nonnumeric.cpp#2)]
 [!code-csharp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CS/nonnumeric.cs#2)]
 [!code-vb[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/VB/nonnumeric.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (DateTime value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(valuetype System.DateTime value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.DateTime,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do <see cref="T:System.DateTime" /> especificado na representação de cadeia de caracteres equivalente usando as informações de formatação específicas da cultura determinadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.DateTime.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte um <xref:System.DateTime> valor em sua representação de cadeia de caracteres equivalente em oito culturas diferentes.  
  
 [!code-csharp[System.Convert.ToString2#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#13)]
 [!code-vb[System.Convert.ToString2#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (decimal value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(valuetype System.Decimal value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Decimal,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do número decimal especificado na representação de cadeia de caracteres equivalente usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Decimal> valores em sua representação de cadeia de caracteres equivalente em quatro culturas diferentes.  
  
 [!code-csharp[System.Convert.ToString2#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#14)]
 [!code-vb[System.Convert.ToString2#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (double value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(float64 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Double,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em sua representação de cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao<xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Double> valores em sua representação de cadeia de caracteres equivalente em quatro culturas diferentes.  
  
 [!code-csharp[System.Convert.ToString2#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#15)]
 [!code-vb[System.Convert.ToString2#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (short value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int16 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int16,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado em sua representação de cadeia de caracteres equivalente usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.Int16%2CSystem.IFormatProvider%29> método para converter cada elemento em uma matriz de inteiros de 16 bits em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável, bem como o objeto <xref:System.Globalization.NumberFormatInfo> personalizado.  
  
 [!code-csharp[System.Convert.ToString2#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#19)]
 [!code-vb[System.Convert.ToString2#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#19)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (short value, int toBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int16 value, int32 toBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int16,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="toBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <param name="toBase">A base do valor de retorno, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte o valor de um inteiro com sinal de 16 bits em sua representação de cadeia de caracteres equivalente em uma base especificada.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" /> na base <paramref name="toBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for positivo e `toBase` é 2, 8 ou 16, a cadeia de caracteres retornada usa representação de entrada e magnitude. Se `value` é negativo e `toBase` é 2, 8 ou 16, a cadeia de caracteres retornada usa representação de complemento de dois. Isso significa que o bit de ordem alta do byte de ordem superior (15 bits) é interpretado como o bit de sinal. Se o <xref:System.Convert.ToString%28System.Int16%2CSystem.Int32%29> método é chamado para criar uma cadeia de caracteres que posteriormente será convertida para um número, um método correspondente que assume uma representação numérica semelhante deve ser chamado para executar a conversão. Esses métodos incluem <xref:System.Convert.ToInt16%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> e <xref:System.Int16.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros com sinal de 16 bits em suas representações de cadeia de caracteres binária, octal, decimal e hexadecimal equivalente.  
  
 [!code-csharp[System.Convert.ToString2#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring2.cs#10)]
 [!code-vb[System.Convert.ToString2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring2.vb#10)]
 [!code-fsharp[System.Convert.ToString2#10](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.convert.tostring2/fs/tostring2.fs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="toBase" /> não é 2, 8, 10 ou 16.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (int value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int32 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int32,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em sua representação de cadeia de caracteres equivalente usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.Int32%2CSystem.IFormatProvider%29> método para converter cada elemento em uma matriz de inteiros em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável, bem como o objeto <xref:System.Globalization.NumberFormatInfo> personalizado.  
  
 [!code-csharp[System.Convert.ToString2#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#20)]
 [!code-vb[System.Convert.ToString2#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#20)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (int value, int toBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int32 value, int32 toBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="toBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <param name="toBase">A base do valor de retorno, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte o valor de um inteiro com sinal de 32 bits na representação de cadeia de caracteres equivalente a ele em uma base especificada.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" /> na base <paramref name="toBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for positivo e `toBase` é 2, 8 ou 16, a cadeia de caracteres retornada usa representação de entrada e magnitude. Se `value` é negativo e `toBase` é 2, 8 ou 16, a cadeia de caracteres retornada usa representação de complemento de dois. Isso significa que o bit de ordem alta do byte de ordem mais alta (31 bits) é interpretado como o bit de sinal. Se o <xref:System.Convert.ToString%28System.Int32%2CSystem.Int32%29> método é chamado para criar uma cadeia de caracteres que posteriormente será convertida para um número, um método correspondente que assume uma representação numérica semelhante deve ser chamado para executar a conversão. Esses métodos incluem <xref:System.Convert.ToInt32%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> e <xref:System.Int32.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros em suas representações de cadeia de caracteres binária, hexadecimal, decimal e hexadecimal equivalente.  
  
 [!code-csharp[System.Convert.ToString2#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring2.cs#11)]
 [!code-vb[System.Convert.ToString2#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring2.vb#11)]
 [!code-fsharp[System.Convert.ToString2#11](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.convert.tostring2/fs/tostring2.fs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="toBase" /> não é 2, 8, 10 ou 16.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (long value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int64 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int64,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado na representação de cadeia de caracteres equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.Int64%2CSystem.IFormatProvider%29> método para converter cada elemento em uma matriz de inteiros longos em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável, bem como o objeto <xref:System.Globalization.NumberFormatInfo> personalizado.  
  
 [!code-csharp[System.Convert.ToString2#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#21)]
 [!code-vb[System.Convert.ToString2#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (long value, int toBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int64 value, int32 toBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Int64,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="toBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <param name="toBase">A base do valor de retorno, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte o valor de um inteiro com sinal de 64 bits na representação de cadeia de caracteres equivalente a ele em uma base especificada.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" /> na base <paramref name="toBase" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for positivo e `toBase` não for 10, a cadeia de caracteres retornada usa representação de entrada e magnitude. Se `value` é negativo e `toBase` não for 10, a cadeia de caracteres retornada usa representação de complemento de dois. Isso significa que o bit de ordem alta do byte de ordem mais alta (bit 63) é interpretado como o bit de sinal. Se o <xref:System.Convert.ToString%28System.Int64%2CSystem.Int32%29> método é chamado para criar uma cadeia de caracteres que posteriormente será convertida para um número, um método correspondente que assume uma representação numérica semelhante deve ser chamado para executar a conversão. Esses métodos incluem <xref:System.Convert.ToInt64%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> e <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros longos em suas representações de cadeia de caracteres binária, hexadecimal, decimal e hexadecimal equivalente.  
  
 [!code-csharp[System.Convert.ToString2#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring2.cs#12)]
 [!code-vb[System.Convert.ToString2#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring2.vb#12)]  
 [!code-fsharp[System.Convert.ToString2#12](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.convert.tostring2/fs/tostring2.fs#12)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="toBase" /> não é 2, 8, 10 ou 16.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que fornece o valor a ser convertido ou <see langword="null" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado na representação de cadeia de caracteres equivalente usando as informações de formatação específicas da cultura especificadas.</summary>
        <returns>A representação de cadeia de caracteres de <paramref name="value" />, ou <see cref="F:System.String.Empty" /> se <paramref name="value" /> for um objeto cujo valor é <see langword="null" />. Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `value` parâmetro implementa o <xref:System.IConvertible> interface, as chamadas de método de <xref:System.IConvertible.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> implementação de `value`. Caso contrário, se o `value` parâmetro implementa o <xref:System.IFormattable> interface, as chamadas de método seu <xref:System.IFormattable.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> implementação. Se `value` implementa nenhuma interface, as chamadas de método de `value` do parâmetro `ToString()` método e o `provider` parâmetro é ignorado.  
  
 O `provider` parâmetro é usado se o `value` parâmetro implementa o <xref:System.IConvertible> ou <xref:System.IFormattable> interface. O uso mais comum dos `provider` parâmetro é para especificar informações específicas de cultura usadas na conversão de `value`. Por exemplo, se o `value` parâmetro é um número decimal negativo, o `provider` parâmetro pode fornecer informações específicas de cultura sobre a notação usada para o separador decimal e o sinal negativo. O segundo exemplo na próxima seção ilustra um provedor de formato que não fornece informações de formatação sensíveis à cultura.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Temperature` classe que substitui o <xref:System.Object.ToString%2A?displayProperty=nameWithType> método mas não implementa o <xref:System.IConvertible> interface. O exemplo ilustra como chamadas para o <xref:System.Convert.ToString%28System.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método, por sua vez, chamar o `Temperature.ToString` método.  
  
 [!code-csharp[System.Convert.ToString2#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring5.cs#26)]
 [!code-vb[System.Convert.ToString2#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring5.vb#26)]  
  
 O exemplo a seguir define uma `Temperature` classe que implementa o <xref:System.IFormattable> interface mas não implementa o <xref:System.IConvertible> interface. Seu <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação representa o `Temperature` valor em Celsius, Fahrenheit ou Kelvin, dependendo da cadeia de formato. O exemplo também define um `TemperatureProvider` classe que implementa <xref:System.IFormatProvider> e fornece uma cadeia de caracteres de formato gerado aleatoriamente que é usada pelo <xref:System.IFormattable> implementação o `Temperature` classe.  
  
 [!code-csharp[System.Convert.ToString2#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring_obj30.cs#30)]
 [!code-vb[System.Convert.ToString2#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring_obj30.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (sbyte value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(int8 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.SByte,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado em sua representação de cadeia de caracteres equivalente, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.SByte%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método para converter cada elemento na matriz de byte assinado em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável, bem como o objeto <xref:System.Globalization.NumberFormatInfo> personalizado.  
  
 [!code-csharp[System.Convert.ToString2#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#17)]
 [!code-vb[System.Convert.ToString2#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (float value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(float32 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.Single,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples em sua representação de cadeia de caracteres equivalente, usando as informações de formatação específicas da cultura.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.Single.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Single> valores em sua representação de cadeia de caracteres equivalente em quatro culturas diferentes.  
  
 [!code-csharp[System.Convert.ToString2#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#18)]
 [!code-vb[System.Convert.ToString2#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser retornada.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura. Este parâmetro é ignorado.</param>
        <summary>Retorna a instância de cadeia de caracteres especificada; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 A exemplo a seguir chama o `ToString` método com um <xref:System.String> parâmetro. O método retorna o inalterado <xref:System.String> sem fazer referência a <xref:System.IFormatProvider> objeto.  
  
 [!code-cpp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CPP/nonnumeric.cpp#2)]
 [!code-csharp[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/CS/nonnumeric.cs#2)]
 [!code-vb[System.Convert.ToString.IFormatProvider#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.ToString.IFormatProvider/VB/nonnumeric.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (ushort value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int16 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt16,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado na representação de cadeia de caracteres equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.UInt16%2CSystem.IFormatProvider%29> método para converter um valor inteiro não assinado de 16 bits em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável e personalizado <xref:System.Globalization.NumberFormatInfo> objeto. A saída indica que essas informações de formatação não são usadas, porque, por padrão o especificador de formato "G" não tem um sinal positivo com valores positivos.  
  
 [!code-csharp[System.Convert.ToString2#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#22)]
 [!code-vb[System.Convert.ToString2#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (uint value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int32 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt32,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado na representação de cadeia de caracteres equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.UInt32%2CSystem.IFormatProvider%29> método para converter um valor inteiro não assinado em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável e personalizado <xref:System.Globalization.NumberFormatInfo> objeto. A saída indica que essas informações de formatação não são usadas, porque, por padrão o especificador de formato "G" não tem um sinal positivo com valores positivos.  
  
 [!code-csharp[System.Convert.ToString2#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#23)]
 [!code-vb[System.Convert.ToString2#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public static string ToString (ulong value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString(unsigned int64 value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToString(System.UInt64,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado na representação de cadeia de caracteres equivalente, usando as informações de formatação específicas à cultura especificadas.</summary>
        <returns>A representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação é idêntica ao <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir define uma classe <xref:System.Globalization.NumberFormatInfo> personalizada que define o sinal de subtração como a cadeia de caracteres "~" e o sinal de adição como a cadeia de caracteres "!". Depois, ele chama o <xref:System.Convert.ToString%28System.UInt64%2CSystem.IFormatProvider%29> método para converter um valor inteiro longo não assinado em sua representação de cadeia de caracteres equivalente. A conversão usa a cultura invariável e personalizado <xref:System.Globalization.NumberFormatInfo> objeto. A saída indica que essas informações de formatação não são usadas, porque, por padrão o especificador de formato "G" não tem um sinal positivo com valores positivos.  
  
 [!code-csharp[System.Convert.ToString2#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.tostring2/cs/tostring3.cs#24)]
 [!code-vb[System.Convert.ToString2#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.tostring2/vb/tostring3.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o inteiro sem sinal de 16 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte os valores booleanos `true` e `false` para inteiros de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#1)]
 [!code-vb[System.Convert.ToUInt16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o equivalente inteiro sem sinal de 16 bits.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#2)]
 [!code-vb[System.Convert.ToUInt16#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado para o equivalente inteiro sem sinal de 16 bits.</summary>
        <returns>O inteiro sem sinal de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de caracteres em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#3)]
 [!code-vb[System.Convert.ToUInt16#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor de número decimal especificado para um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Decimal> valores para um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#4)]
 [!code-vb[System.Convert.ToUInt16#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro sem sinal de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.Double> valores para um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#5)]
 [!code-vb[System.Convert.ToUInt16#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 16 bits especificado no inteiro sem sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros de 16 bits em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#6)]
 [!code-vb[System.Convert.ToUInt16#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro assinado de 32 bits especificado para um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#7)]
 [!code-vb[System.Convert.ToUInt16#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 64 bits especificado para um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros longos em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#8)]
 [!code-vb[System.Convert.ToUInt16#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro não assinado de 16 bits.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt16%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objetos em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#9)]
 [!code-vb[System.Convert.ToUInt16#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o equivalente inteiro sem sinal de 16 bits.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de byte assinado para um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#10)]
 [!code-vb[System.Convert.ToUInt16#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 16 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de <xref:System.String> valores para um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#11)]
 [!code-vb[System.Convert.ToUInt16#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro sem sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToUInt16%28System.String%29> método é equivalente à passagem `value` para o <xref:System.UInt16.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt16.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de cadeia de caracteres numéricos em um inteiro não assinado de 16 bits.  
  
 [!code-csharp[System.Convert.ToUInt16#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#12)]
 [!code-vb[System.Convert.ToUInt16#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Inteiro sem sinal de 16 bits para retornar.</param>
        <summary>Retorna o inteiro de não assinado de 16 bits especificado; Nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado para um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros sem sinal em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#13)]
 [!code-vb[System.Convert.ToUInt16#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado para um inteiro não assinado de 16 bits equivalente.</summary>
        <returns>Um inteiro não assinado de 16 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos sem sinal em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_1.cs#14)]
 [!code-vb[System.Convert.ToUInt16#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro sem sinal de 16 bits, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt16%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `HexString` classe que implementa o <xref:System.IConvertible> interface e que é criado para conter a representação de cadeia de caracteres de ambos os 16 bits assinados e 16 bits valores sem sinal. A classe inclui um `Sign` propriedade que indica o sinal do valor hexadecimal.  
  
 [!code-csharp[System.Convert.ToUInt16#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_3.cs#16)]
 [!code-vb[System.Convert.ToUInt16#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_3.vb#16)]  
  
 O exemplo a seguir mostra que uma chamada para o <xref:System.Convert.ToUInt16%28System.Object%2CSystem.IFormatProvider%29> método passa um `HexString` objeto como um parâmetro, por sua vez, chama o <xref:System.IConvertible.ToUInt16%2A?displayProperty=nameWithType> implementação o `HexString` classe.  
  
 [!code-csharp[System.Convert.ToUInt16#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_3.cs#17)]
 [!code-vb[System.Convert.ToUInt16#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_3.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um equivalente 16 bits sem sinal inteiro, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado da invocação <xref:System.UInt16.Parse%2A?displayProperty=nameWithType> em `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt16.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define um objeto <xref:System.Globalization.NumberFormatInfo> personalizado que reconhece a cadeia de caracteres "pos" como o sinal positivo e a cadeia de caracteres "neg" como o sinal negativo. Em seguida, ele tenta converter cada elemento de uma matriz de cadeia de caracteres numérica em um inteiro usando esse provedor e o provedor <xref:System.Globalization.NumberFormatInfo> para a cultura invariável.  
  
 [!code-csharp[System.Convert.ToUInt16#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_4.cs#18)]
 [!code-vb[System.Convert.ToUInt16#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_4.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 ToUInt16(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt16(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada em um inteiro sem sinal de 16 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 16 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque o <xref:System.UInt16> tipo de dados oferece suporte a valores não assinados, o <xref:System.Convert.ToUInt16%28System.String%2CSystem.Int32%29> método pressupõe que `value` é expressado usando a representação binária não assinada. Em outras palavras, todos os 16 bits são usados para representar o valor numérico, e um pouco de entrada está ausente. Como resultado, é possível gravar o código no qual um inteiro assinado de valor que está fora do intervalo de <xref:System.UInt16> tipo de dados é convertido em um <xref:System.UInt16> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.Int16.MinValue?displayProperty=nameWithType> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToUInt16%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x8000 converte 32768."  
  
 [!code-csharp[System.Convert.BaseConversion#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#11)]
 [!code-vb[System.Convert.BaseConversion#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#11)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método ou operador está usando a representação numérica apropriada para interpretar um valor específico. O exemplo a seguir ilustra uma técnica para garantir que o método não inadequadamente usa representação binária para interpretar um valor que usa a representação de complemento de dois ao converter uma cadeia de caracteres hexadecimal para uma <xref:System.UInt16> valor. O exemplo determina se um valor representa um inteiro assinado ou não assinado enquanto converte esse valor na representação da cadeia de caracteres. Quando o exemplo converte o valor em uma <xref:System.UInt16> valor, ele verifica se o valor original era um inteiro com sinal. Nesse caso, e se o bit de ordem alta é definido (que indica que o valor original era negativo), o método gera uma exceção.  
  
 [!code-csharp[System.Convert.BaseConversion#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#12)]
 [!code-vb[System.Convert.BaseConversion#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#12)]  
  
   
  
## Examples  
 O exemplo a seguir tenta interpretar a cada elemento em uma matriz de cadeias de caracteres numéricas como um valor hexadecimal e para convertê-lo em um inteiro de 16 bits sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt16#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint16/cs/touint16_2.cs#15)]
 [!code-vb[System.Convert.ToUInt16#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint16/vb/touint16_2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt16.MinValue" /> ou maior que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte os valores booleanos `true` e `false` para números inteiros sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#1)]
 [!code-vb[System.Convert.ToUInt32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#2)]
 [!code-vb[System.Convert.ToUInt32#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de caracteres em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#3)]
 [!code-vb[System.Convert.ToUInt32#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor de número decimal especificado para um inteiro não assinado de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores para um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#4)]
 [!code-vb[System.Convert.ToUInt32#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Double> valores para um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#5)]
 [!code-vb[System.Convert.ToUInt32#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros de 16 bits em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#6)]
 [!code-vb[System.Convert.ToUInt32#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro com sinal de 32 bits especificado em um inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#7)]
 [!code-vb[System.Convert.ToUInt32#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 64 bits especificado para um inteiro não assinado de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#8)]
 [!code-vb[System.Convert.ToUInt32#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro não assinado de 32 bits.</summary>
        <returns>Um inteiro não assinado de 32 bits que é equivalente a <paramref name="value" />, ou 0 (zero) se <paramref name="value" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt32%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objetos em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#9)]
 [!code-vb[System.Convert.ToUInt32#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de byte assinado para um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#10)]
 [!code-vb[System.Convert.ToUInt32#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro não assinado de 32 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 32 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores para um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#11)]
 [!code-vb[System.Convert.ToUInt32#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToUInt32%28System.String%29> método é equivalente à passagem `value` para o <xref:System.UInt32.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt32.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir interpreta os elementos em uma matriz de cadeia de caracteres como cadeias de caracteres numéricas e tenta convertê-los em inteiros sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#12)]
 [!code-vb[System.Convert.ToUInt32#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para o inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiro de 16 bits sem sinal em um valor inteiro não assinado.  
  
 [!code-csharp[System.Convert.ToUInt32#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#13)]
 [!code-vb[System.Convert.ToUInt32#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser retornado.</param>
        <summary>Retorna o inteiro sem sinal de 32 bits especificado; nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 64 bits especificado em um inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiro longo não assinado com um valor inteiro não assinado.  
  
 [!code-csharp[System.Convert.ToUInt32#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_1.cs#14)]
 [!code-vb[System.Convert.ToUInt32#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro sem sinal de 32 bits, usando as informações de formatação específicas da cultura especificada.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente a <paramref name="value" /> ou zero caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt32%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `HexString` classe que implementa o <xref:System.IConvertible> interface e que é criado para conter a representação de cadeia de caracteres de ambos os 32 bits assinados e 32 bits valores sem sinal. A classe inclui um `Sign` propriedade que indica o sinal do valor hexadecimal.  
  
 [!code-csharp[System.Convert.ToUInt32#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_4.cs#17)]
 [!code-vb[System.Convert.ToUInt32#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_4.vb#17)]  
  
 O exemplo a seguir mostra que uma chamada para o <xref:System.Convert.ToUInt32%28System.Object%2CSystem.IFormatProvider%29> método passa um `HexString` objeto como um parâmetro, por sua vez, chama o <xref:System.IConvertible.ToUInt32%2A?displayProperty=nameWithType> implementação o `HexString` classe.  
  
 [!code-csharp[System.Convert.ToUInt32#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_4.cs#18)]
 [!code-vb[System.Convert.ToUInt32#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_4.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um equivalente 32-bit inteiro sem sinal, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado da invocação <xref:System.UInt32.Parse%2A?displayProperty=nameWithType> em `value`.  
  
 `provider` é uma instância de <xref:System.IFormatProvider> que obtém um objeto <xref:System.Globalization.NumberFormatInfo>. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt32.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define um objeto <xref:System.Globalization.NumberFormatInfo> personalizado que reconhece a cadeia de caracteres "pos" como o sinal positivo e a cadeia de caracteres "neg" como o sinal negativo. Em seguida, ele tenta converter cada elemento de uma matriz de cadeia de caracteres numérica em um inteiro usando esse provedor e o provedor <xref:System.Globalization.NumberFormatInfo> para a cultura invariável.  
  
 [!code-csharp[System.Convert.ToUInt32#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_2.cs#15)]
 [!code-vb[System.Convert.ToUInt32#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32">
      <MemberSignature Language="C#" Value="public static uint ToUInt32 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 ToUInt32(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt32(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada em um inteiro sem sinal de 32 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 32 bits equivalente ao número em <paramref name="value" />, ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque o <xref:System.UInt32> tipo de dados oferece suporte a valores não assinados, o <xref:System.Convert.ToUInt32%28System.String%2CSystem.Int32%29> método pressupõe que `value` é expressado usando a representação binária não assinada. Em outras palavras, todos os 32 bits são usados para representar o valor numérico, e um pouco de entrada está ausente. Como resultado, é possível gravar o código no qual um inteiro assinado de valor que está fora do intervalo de <xref:System.UInt32> tipo de dados é convertido em um <xref:System.UInt32> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.Int32.MinValue> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToUInt32%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x80000000 converte a 2147483648".  
  
 [!code-csharp[System.Convert.BaseConversion#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#13)]
 [!code-vb[System.Convert.BaseConversion#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#13)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método ou operador está usando a representação numérica apropriada para interpretar um valor específico. O exemplo a seguir ilustra uma técnica para garantir que o método não inadequadamente usa representação binária para interpretar um valor que usa a representação de complemento de dois ao converter uma cadeia de caracteres hexadecimal para uma <xref:System.UInt32> valor. O exemplo determina se um valor representa um inteiro assinado ou não assinado enquanto converte esse valor na representação da cadeia de caracteres. Quando o exemplo converte o valor em uma <xref:System.UInt32> valor, ele verifica se o valor original era um inteiro com sinal. Nesse caso, e se o bit de ordem alta é definido (que indica que o valor original era negativo), o método gera uma exceção.  
  
 [!code-csharp[System.Convert.BaseConversion#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#14)]
 [!code-vb[System.Convert.BaseConversion#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#14)]  
  
   
  
## Examples  
 O exemplo a seguir tenta interpretar a cada elemento em uma matriz de cadeias de caracteres numéricas como um valor hexadecimal e para convertê-lo em um inteiro sem sinal.  
  
 [!code-csharp[System.Convert.ToUInt32#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint32/cs/touint32_3.cs#16)]
 [!code-vb[System.Convert.ToUInt32#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint32/vb/touint32_3.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt32.MinValue" /> ou maior que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser convertido.</param>
        <summary>Converte o valor booliano especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>O número 1 caso <paramref name="value" /> seja <see langword="true" />; do contrário, 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte booliano `true` e `false` valores inteiros sem sinal de tempo.  
  
 [!code-csharp[System.Convert.ToUInt64#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#1)]
 [!code-vb[System.Convert.ToUInt64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 8 bits especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de bytes em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#2)]
 [!code-vb[System.Convert.ToUInt64#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser convertido.</param>
        <summary>Converte o valor do caractere Unicode especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de caracteres em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#3)]
 [!code-vb[System.Convert.ToUInt64#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (DateTime value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(valuetype System.DateTime value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="value">O valor de data e tempo a ser convertido.</param>
        <summary>A chamada desse método sempre lança <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Esta conversão não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O número decimal a ser convertido.</param>
        <summary>Converte o valor de número decimal especificado para um inteiro não assinado de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Decimal> valores como um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#4)]
 [!code-vb[System.Convert.ToUInt64#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão dupla a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão dupla especificado em um inteiro sem sinal de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Double> valores como um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#5)]
 [!code-vb[System.Convert.ToUInt64#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 16 bits especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros de 16 bits em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#6)]
 [!code-vb[System.Convert.ToUInt64#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 32 bits a converter.</param>
        <summary>Converte o valor do inteiro assinado de 32 bits especificado para um inteiro não assinado de 64 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros como um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#7)]
 [!code-vb[System.Convert.ToUInt64#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 64 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro com sinal de 64 bits especificado em um inteiro sem sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de inteiros longos em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#8)]
 [!code-vb[System.Convert.ToUInt64#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface <see cref="T:System.IConvertible" /> ou <see langword="null" />.</param>
        <summary>Converte o valor do objeto especificado em um inteiro não assinado de 64 bits.</summary>
        <returns>Um inteiro não assinado de 64 bits que é equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt64%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
   
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de objetos em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#9)]
 [!code-vb[System.Convert.ToUInt64#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro com sinal de 8 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro assinado de 8 bits especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de byte assinado para um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#10)]
 [!code-vb[System.Convert.ToUInt64#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O número de ponto flutuante de precisão simples a ser convertido.</param>
        <summary>Converte o valor do número de ponto flutuante de precisão simples especificado em um inteiro não assinado de 64 bits equivalente.</summary>
        <returns>
          <paramref name="value" />, arredondado para o próximo inteiro sem sinal de 64 bits. Caso <paramref name="value" /> esteja entre dois números inteiros, o número par é retornado; ou seja, 4,5 é convertido em 4 e 5,5 é convertido em 6.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir tenta converter cada elemento em uma matriz de <xref:System.Single> valores como um inteiro longo não assinado. A saída mostra que os valores fracionários são arredondados para a conversão é executada.  
  
 [!code-csharp[System.Convert.ToUInt64#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#11)]
 [!code-vb[System.Convert.ToUInt64#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é menor que zero ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um inteiro sem sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro assinado de 64 bits equivalente ao número em <paramref name="value" />, ou 0 (zero) caso <paramref name="value" /> seja <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando o <xref:System.Convert.ToInt64%28System.String%29> método é equivalente à passagem `value` para o <xref:System.Int64.Parse%28System.String%29?displayProperty=nameWithType> método. `value` é interpretado usando-se as convenções de formatação da cultura do thread atual.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt64.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir interpreta os elementos de uma matriz de cadeia de caracteres como cadeias de caracteres numéricas e tenta convertê-los em inteiros longo não assinados.  
  
 [!code-csharp[System.Convert.ToUInt64#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#12)]
 [!code-vb[System.Convert.ToUInt64#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro não assinado de 16 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 16 bits especificado para o equivalente inteiro sem sinal de 64 bits.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros de 16 bits sem sinal em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#13)]
 [!code-vb[System.Convert.ToUInt64#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O inteiro sem sinal de 32 bits a ser convertido.</param>
        <summary>Converte o valor do inteiro sem sinal de 32 bits especificado para um inteiro não assinado de 64 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte cada elemento em uma matriz de inteiros sem sinal em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_1.cs#14)]
 [!code-vb[System.Convert.ToUInt64#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Inteiro sem sinal de 64 bits para retornar.</param>
        <summary>Retorna o inteiro de não assinado de 64 bits especificado; Nenhuma conversão real é executada.</summary>
        <returns>
          <paramref name="value" /> é retornado inalterado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (object value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(object value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.Object,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto que implementa a interface do <see cref="T:System.IConvertible" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor do objeto especificado em um inteiro não assinado de 64 bits, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro não assinado de 64 bits que é equivalente a <paramref name="value" />, ou zero se <paramref name="value" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado de chamar o <xref:System.IConvertible.ToUInt64%2A?displayProperty=nameWithType> método do tipo subjacente de `value`.  
  
 `provider` permite que o usuário especifique informações de conversão específicas de cultura sobre o conteúdo de `value`. Por exemplo, se `value` fosse um <xref:System.String> que representa um número, `provider` poderia fornecer informações específicas de cultura sobre a notação usada para representar esse número.  
  
 Os tipos de base ignoram `provider`; no entanto, o parâmetro pode ser usado caso `value` seja um tipo definido pelo usuário que implementa a interface <xref:System.IConvertible>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `HexString` classe que implementa o <xref:System.IConvertible> interface e que é criado para conter a representação de cadeia de caracteres de ambos os 64 bits assinados e 64 bits valores sem sinal. A classe inclui um `Sign` propriedade que indica o sinal do valor hexadecimal.  
  
 [!code-csharp[System.Convert.ToUInt64#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_4.cs#17)]
 [!code-vb[System.Convert.ToUInt64#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_4.vb#17)]  
  
 O exemplo a seguir mostra que uma chamada para o <xref:System.Convert.ToUInt64%28System.Object%2CSystem.IFormatProvider%29> método passa um `HexString` objeto como um parâmetro, por sua vez, chama o <xref:System.IConvertible.ToUInt64%2A?displayProperty=nameWithType> implementação o `HexString` classe.  
  
 [!code-csharp[System.Convert.ToUInt64#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_4.cs#18)]
 [!code-vb[System.Convert.ToUInt64#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_4.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está em um formato adequado.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IConvertible" />.  
  
 -ou-  
  
 A conversão não é suportada.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte a representação de cadeia de caracteres especificada de um número em um equivalente 64-bit inteiro sem sinal, usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o resultado da invocação <xref:System.UInt64.Parse%2A?displayProperty=nameWithType> em `value`.  
  
 `provider`é um <xref:System.IFormatProvider> implementação que obtém um <xref:System.Globalization.NumberFormatInfo> objeto. O objeto <xref:System.Globalization.NumberFormatInfo> fornece informações específicas da cultura sobre o formato de `value`. Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
 Se você preferir não tratar uma exceção se a conversão falhar, você pode chamar o <xref:System.UInt64.TryParse%2A?displayProperty=nameWithType> método em vez disso. Ele retorna um valor <xref:System.Boolean> que indica se a conversão foi bem-sucedida ou falhou.  
  
   
  
## Examples  
 O exemplo a seguir define um objeto <xref:System.Globalization.NumberFormatInfo> personalizado que reconhece a cadeia de caracteres "pos" como o sinal positivo e a cadeia de caracteres "neg" como o sinal negativo. Em seguida, ele tentará converter cada elemento de uma matriz de cadeia de caracteres numéricos em um inteiro longo não assinado. A conversão usa um provedor personalizado e o <xref:System.Globalization.NumberFormatInfo> provedor para a cultura invariável.  
  
 [!code-csharp[System.Convert.ToUInt64#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_2.cs#15)]
 [!code-vb[System.Convert.ToUInt64#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_2.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não consiste em um sinal opcional seguido de uma sequência de dígitos (de 0 a 9).</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64 (string value, int fromBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 ToUInt64(string value, int32 fromBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Convert.ToUInt64(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="fromBase" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <param name="fromBase">A base do número em <c>valor</c>, que deve ser 2, 8, 10 ou 16.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em uma base especificada em um inteiro sem sinal de 64 bits equivalente.</summary>
        <returns>Um inteiro sem sinal de 64 bits equivalente ao número em <paramref name="value" /> ou 0 (zero), se <paramref name="value" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `fromBase` seja 16, é possível prefixar o número especificado pelo parâmetro `value` com "0x" ou "0X".  
  
 Porque o <xref:System.UInt64> tipo de dados oferece suporte a valores não assinados, o <xref:System.Convert.ToUInt64%28System.String%2CSystem.Int32%29> método pressupõe que `value` é expressado usando a representação binária não assinada. Em outras palavras, todos de 64 bits são usados para representar o valor numérico, e um pouco de entrada está ausente. Como resultado, é possível gravar o código no qual um inteiro longo valor que está fora do intervalo de <xref:System.UInt64> tipo de dados é convertido em um <xref:System.UInt64> valor sem o método lançar uma exceção. O exemplo a seguir converte <xref:System.Int64.MinValue> representação de cadeia de caracteres hexadecimal e, em seguida, chama o <xref:System.Convert.ToUInt64%28System.String%2CSystem.Int32%29> método. Em vez de gerar uma exceção, o método exibe a mensagem "0x8000000000000000 converte para 9223372036854775808".  
  
 [!code-csharp[System.Convert.BaseConversion#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#15)]
 [!code-vb[System.Convert.BaseConversion#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#15)]  
  
 Durante a realização de operações binárias ou conversões numéricas, sempre é responsabilidade do desenvolvedor verificar se um método ou operador está usando a representação numérica apropriada para interpretar um valor específico. O exemplo a seguir ilustra uma técnica para garantir que o método não inadequadamente usa representação binária para interpretar um valor que usa a representação de complemento de dois ao converter uma cadeia de caracteres hexadecimal para uma <xref:System.UInt64> valor. O exemplo determina se um valor representa um inteiro assinado ou não assinado enquanto converte esse valor na representação da cadeia de caracteres. Quando o exemplo converte o valor em uma <xref:System.UInt64> valor, ele verifica se o valor original era um inteiro com sinal. Nesse caso, e se o bit de ordem alta é definido (que indica que o valor original era negativo), o método gera uma exceção.  
  
 [!code-csharp[System.Convert.BaseConversion#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Convert.BaseConversion/cs/Conversion.cs#16)]
 [!code-vb[System.Convert.BaseConversion#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Convert.BaseConversion/vb/Conversion.vb#16)]  
  
   
  
## Examples  
 O exemplo a seguir tenta interpretar a cada elemento em uma matriz de cadeias de caracteres numéricas como um valor hexadecimal e para convertê-lo em um inteiro longo não assinado.  
  
 [!code-csharp[System.Convert.ToUInt64#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.convert.touint64/cs/touint64_3.cs#16)]
 [!code-vb[System.Convert.ToUInt64#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.convert.touint64/vb/touint64_3.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="fromBase" /> não é 2, 8, 10 ou 16.  
  
 -ou-  
  
 <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> é <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> contém um caractere que não é um dígito válido na base especificada por <paramref name="fromBase" />. A mensagem de exceção indica que não há dígitos a serem convertidos caso o primeiro caractere em <paramref name="value" /> seja inválido; do contrário, a mensagem indica que <paramref name="value" /> contém caracteres à direita inválidos.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" />, que representa um número não assinado de base não 10, é prefixado com um sinal negativo.  
  
 -ou-  
  
 <paramref name="value" /> representa um número que é menor que <see cref="F:System.UInt64.MinValue" /> ou maior que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
