<Type Name="Double" FullName="System.Double">
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um número de ponto flutuante de precisão dupla.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double> tipo de valor representa um número de 64 bits de precisão dupla com valores que variam de 1, 79769313486232E308 negativo ao 1, 79769313486232E308 positivo, bem como zero positivo ou negativo, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>e não um número (<xref:System.Double.NaN>). Ele destina-se para representar valores que são extremamente pequeno ou muito grande (como distâncias entre planetas ou galáxias) (moleculares em massa de uma substância em kg) e que geralmente são imprecisa (como a distância da Terra em outro sistema solar), o <xref:System.Double> tipo compatível com o 60559:1989 IEC (IEEE 754) padrão para aritmética de ponto flutuante binário.  
  
 Este tópico é composto pelas seguintes seções:  
  
-   [Precisão e a representação de ponto flutuante](#Precision)  
  
-   [Teste de igualdade](#Equality)  
  
-   [Exceções e valores de ponto flutuante](#Exceptions)  
  
-   [Conversões de tipo e a estrutura dupla](#Conversions)  
  
-   [Funcionalidade de ponto flutuante](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Representação de ponto flutuante e precisão  
 O <xref:System.Double> tipo de dados armazena valores de ponto flutuante de precisão dupla em um formato binário de 64 bits, conforme mostrado na tabela a seguir:  
  
|Parte|Bits|  
|----------|----------|  
|Significando ou mantissa|0-51|  
|Expoente|52-62|  
|Entrada (0 = positivo, 1 = negativo)|63|  
  
 Assim como frações decimais não conseguem precisamente representam alguns valores fracionários (como 1/3 ou <xref:System.Math.PI?displayProperty=nameWithType>), frações binárias são não consegue representar alguns valores fracionários. Por exemplo, 1 a 10, que é representada com precisão,.1 como uma fração decimal, é representado por.001100110011 como uma fração binária, com o padrão "0011" Repetir até o infinito. Nesse caso, o valor de ponto flutuante fornece uma representação imprecisa do número que representa. Executar operações matemáticas adicionais no valor de ponto flutuante original geralmente tende a aumentar sua falta de precisão. Por exemplo, se compararmos o resultado da multiplicação.1 por 10 e adicionando.1 para.1 nove vezes, vemos que adição, porque tem oito operações mais envolvida, produziu o resultado menos preciso. Observe que essa diferença é aparente apenas se podemos exibir dois <xref:System.Double> valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), que se necessário exibe todos os 17 dígitos de precisão com suporte a <xref:System.Double> tipo.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Como alguns números não podem ser representados exatamente como valores binários fracionários, números de ponto flutuante podem apenas em números reais aproximados.  
  
 Todos os números de ponto flutuantes também tem um número limitado de dígitos significativos, que também determina a precisão com um valor de ponto flutuante aproxima um número real.   Um <xref:System.Double> valor tem até 15 dígitos decimais de precisão, embora um máximo de 17 dígitos seja mantido internamente. Isso significa que algumas operações de ponto flutuantes podem não ter a precisão para alterar um flutuante valor de ponto. O exemplo a seguir fornece uma ilustração. Ele define um valor de ponto flutuante muito grande e, em seguida, adiciona o produto de <xref:System.Double.Epsilon?displayProperty=nameWithType> e um quatrilhão a ele. O produto, no entanto, é muito pequeno para modificar o valor de ponto flutuante original. Seus dígitos menos significativo é milésimos, enquanto o dígito mais significativo do produto é 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 A precisão limitada do número de ponto flutuante tem várias consequências:  
  
-   Dois números de ponto flutuantes que pareçam iguais para uma determinada precisão podem não comparados como iguais porque seus dígitos menos significantes são diferentes. No exemplo a seguir, uma série de números são adicionados juntos e seu total é comparado com o total esperado. Embora os dois valores parecem ser os mesmos, uma chamada para o `Equals` método indica que não são.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Se você alterar os itens de formato no <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> instrução do `{0}` e `{1}` para `{0:R}` e `{1:R}` para exibir todos os dígitos significativos dos dois <xref:System.Double> valores, é claro que os dois valores são diferentes devido a uma perda de precisão durante as operações de adição. Nesse caso, o problema pode ser resolvido por meio da chamada de <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> método para arredondar o <xref:System.Double> valores para a precisão desejada antes de executar a comparação.  
  
-   Uma operação matemática ou de comparação que usa um número de ponto flutuante pode não produzir o mesmo resultado se for usado um número decimal, porque o número de ponto flutuante binário não pode ser igual ao número de decimal. Um exemplo anterior ilustrado isso exibindo o resultado da multiplicação.1 por 10 e adicionando.1 vezes.  
  
     Quando a precisão em operações numéricas com valores fracionários é importante, você pode usar o <xref:System.Decimal> em vez de <xref:System.Double> tipo. Quando a precisão em operações numéricas com valores integrais além do intervalo da <xref:System.Int64> ou <xref:System.UInt64> tipos é importante, use o <xref:System.Numerics.BigInteger> tipo.  
  
-   Um valor pode não ida e volta se um número de ponto flutuante estiver envolvido. Um valor é chamado de viagem se uma operação converte um número de ponto flutuante original em outro formato, uma operação inversa transforma a forma convertida de volta para um número de ponto flutuante e o número de ponto flutuante final não é igual ao número de ponto flutuante original. A viagem de ida e pode falhar porque um ou mais dígitos menos significantes são perdidos ou alterados na conversão. No exemplo a seguir, três <xref:System.Double> valores são convertidos em cadeias de caracteres e salvos em um arquivo. Como mostra a saída, no entanto, mesmo que os valores parecem idênticos, os valores restaurados não são iguais aos valores originais.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     Nesse caso, os valores podem ser recuperado com êxito usando "G17" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) para preservar a precisão completa de <xref:System.Double> valores, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Quando usado com um <xref:System.Double> valor, o especificador de formato "R" em alguns casos falha para ir e voltar com êxito, o valor original. Para garantir que <xref:System.Double> valores com êxito ida e volta, use o especificador de formato "G17".

-   <xref:System.Single>valores têm menos precisão que <xref:System.Double> valores. Um <xref:System.Single> valor que é convertido em um equivalente aparentemente <xref:System.Double> geralmente não é igual a <xref:System.Double> valor devido a diferenças na precisão. No exemplo a seguir, o resultado de operações de divisão idênticos é atribuído a um <xref:System.Double> e um <xref:System.Single> valor. Após o <xref:System.Single> valor é convertido em um <xref:System.Double>, uma comparação entre dois valores mostra que elas são diferentes.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Para evitar esse problema, use o <xref:System.Double> em vez do <xref:System.Single> tipo de dados ou usar o <xref:System.Math.Round%2A> método para que ambos os valores têm a mesma precisão.  
  
 Além disso, o resultado das operações aritméticas e atribuição com <xref:System.Double> valores podem diferir ligeiramente pela plataforma devido à perda de precisão do <xref:System.Double> tipo. Por exemplo, o resultado de atribuir um valor literal <xref:System.Double> valor pode ser diferente nas versões de 32 bits e 64 bits do .NET Framework. O exemplo a seguir ilustra essa diferença quando o literal de valor - 4.42330604244772E-305 e uma variável cujo valor é - 4.42330604244772E-305 são atribuídos a um <xref:System.Double> variável. Observe que o resultado da <xref:System.Double.Parse%28System.String%29> método nesse caso não apresenta uma perda de precisão.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testando igualdade  
 Para ser considerado igual, dois <xref:System.Double> valores devem representar valores idênticos. No entanto, devido às diferenças na precisão entre valores, ou devido a uma perda de precisão por um ou ambos os valores, valores de ponto flutuante que devem ser idênticos geralmente ficam diferenciem devido a diferenças nos seus dígitos menos significantes. Como resultado, chamadas para o <xref:System.Double.Equals%2A> método para determinar se dois valores são iguais ou chamadas para o <xref:System.Double.CompareTo%2A> método para determinar a relação entre duas <xref:System.Double> valores, geralmente produzir resultados inesperados. Isso fica evidente no exemplo a seguir, onde duas igual aparentemente <xref:System.Double> valores se tornar diferentes porque o primeiro tem 15 dígitos de precisão, enquanto o segundo tem 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Valores calculados que seguem caminhos de código diferentes e que geralmente são manipuladas de diferentes maneiras mostrará como diferentes. No exemplo a seguir, um <xref:System.Double> valor é quadrado e, em seguida, a raiz quadrada é calculada para restaurar o valor original. Um segundo <xref:System.Double> é multiplicado por 3.51 e quadrado antes da raiz quadrada do resultado é dividida por 3.51 para restaurar o valor original. Embora os dois valores parecem idênticos, uma chamada para o <xref:System.Double.Equals%28System.Double%29> método indica que não são iguais. Usando a cadeia de caracteres de formato padrão de "R" para retornar uma cadeia de caracteres de resultado que exibe todos os dígitos significativos de cada valor duplo mostra que o segundo valor é.0000000000001 menor do que o primeiro.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 Em casos em que uma perda de precisão é provavelmente afetará o resultado de uma comparação, você pode adotar qualquer uma das alternativas a seguir para chamar o <xref:System.Double.Equals%2A> ou <xref:System.Double.CompareTo%2A> método:  
  
-   Chamar o <xref:System.Math.Round%2A?displayProperty=nameWithType> método para garantir que os dois valores tenham a mesma precisão. O exemplo a seguir modifica um exemplo anterior para usar essa abordagem para que os dois valores fracionários são equivalentes.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     No entanto, observe que o problema de precisão ainda se aplica a valores de ponto médio de arredondamento. Para obter mais informações, consulte o método <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Testar a igualdade aproximada, em vez de igualdade. Isso requer que você defina um absoluto qualquer valor pelo qual os dois valores podem diferir mas ainda pode ser igual ou que você definir uma quantidade relativa pelo qual o menor valor possível divergir do maior valor.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType>às vezes, é usado como uma medida absoluta da distância entre dois <xref:System.Double> valores de durante o teste de igualdade.  No entanto, <xref:System.Double.Epsilon?displayProperty=nameWithType> mede o menor valor possível que pode ser adicionado ou subtraído de um <xref:System.Double> cujo valor é zero. Para a maioria dos positivo e negativo <xref:System.Double> valores, o valor de <xref:System.Double.Epsilon?displayProperty=nameWithType> é muito pequeno para ser detectada. Portanto, exceto os valores que forem zero, não recomendamos seu uso em testes de igualdade.  
  
     O exemplo a seguir usa a segunda abordagem para definir um `IsApproximatelyEqual` método que testa a diferença relativa entre dois valores. Ele também compara o resultado de chamadas para o `IsApproximatelyEqual` método e o <xref:System.Double.Equals%28System.Double%29> método.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Valores de ponto flutuante e exceções  
 Ao contrário de operações com tipos integrais, que lançam exceções em casos de estouro ou ilegais operações como divisão por zero, as operações com valores de ponto flutuante não lançam exceções. Em vez disso, em casos excepcionais, o resultado de uma operação de ponto flutuante é zero, infinito positivo, infinito negativo ou não é um número (NaN):  
  
-   Se o resultado de uma operação de ponto flutuante é muito pequeno para o formato de destino, o resultado será zero. Isso pode ocorrer quando dois números muito pequenos são multiplicados, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Se a magnitude do resultado de uma operação de ponto flutuante excede o intervalo de formato de destino, o resultado da operação é <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>, conforme apropriado para o sinal do resultado. O resultado de uma operação que estoura <xref:System.Double.MaxValue?displayProperty=nameWithType> é <xref:System.Double.PositiveInfinity>e o resultado de uma operação que estoura <xref:System.Double.MinValue?displayProperty=nameWithType> é <xref:System.Double.NegativeInfinity>, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity>também resulta de uma divisão por zero com um dividendo positivo, e <xref:System.Double.NegativeInfinity> resulta de uma divisão por zero com um dividendo negativo.  
  
-   Se uma operação de ponto flutuante é inválida, o resultado da operação é <xref:System.Double.NaN>. Por exemplo, <xref:System.Double.NaN> resultados entre as seguintes operações:  
  
    -   Divisão por zero com um dividendo igual a zero. Observe que os outros casos de divisão por zero resultado no <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>.  
  
-   Qualquer operação de ponto flutuante com uma entrada inválida. Por exemplo, chamar o <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> método com um valor negativo retorna <xref:System.Double.NaN>, como chamar o <xref:System.Math.Acos%2A?displayProperty=nameWithType> método com um valor que é maior que ou menor que um negativo.  
  
-   Qualquer operação com um argumento cujo valor é <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Conversões de tipo e a estrutura dupla  
 O <xref:System.Double> estrutura não define os operadores de conversão explícita ou implícita; em vez disso, as conversões são implementadas pelo compilador.  
  
 A conversão do valor de qualquer tipo primitivo numérico para um <xref:System.Double> é uma conversão de ampliação e, portanto, não exige um operador de conversão explícita ou chamar um método de conversão, a menos que um compilador exija explicitamente. Por exemplo, o compilador c# requer que um operador de conversão para conversões de <xref:System.Decimal> para <xref:System.Double>, enquanto o compilador do Visual Basic, não. O exemplo a seguir converte o valor mínimo ou máximo de outros tipos primitivos numéricos para um <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Além disso, o <xref:System.Single> valores <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> oculto para <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Observe que a conversão do valor de alguns tipos numéricos para um <xref:System.Double> valor pode envolver uma perda de precisão. Como mostra o exemplo, uma perda de precisão é possível ao converter <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, e <xref:System.UInt64> valores <xref:System.Double> valores.  
  
 A conversão de um <xref:System.Double> valor para um valor de qualquer outro tipo de dados numérico primitivo é uma conversão de restrição e requer um operador cast (em c#), um método de conversão (no Visual Basic) ou uma chamada para um <xref:System.Convert> método. Os valores que estão fora do intervalo do tipo de dados de destino, que são definidos pelo tipo de destino `MinValue` e `MaxValue` se comportam como propriedades, conforme mostrado na tabela a seguir.  
  
|Tipo de destino|Resultado|  
|-----------------|------------|  
|Qualquer tipo integral|Um <xref:System.OverflowException> exceção se a conversão ocorre em um contexto verificado.<br /><br /> Se a conversão ocorre em um contexto desmarcado (o padrão em c#), a operação de conversão for bem-sucedida, mas o valor estoura.|  
|<xref:System.Decimal>|Um <xref:System.OverflowException> exceção.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType>para valores negativos.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>para valores positivos.|  
  
 Além disso, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> lançar um <xref:System.OverflowException> para conversões em números inteiros em um contexto verificado, mas estouro esses valores quando convertidos em inteiros em um contexto desmarcado. Para conversões em <xref:System.Decimal>, eles sempre lançam um <xref:System.OverflowException>. Para conversões em <xref:System.Single>, eles convertidos <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, e <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 Observe que uma perda de precisão pode resultar de converter um <xref:System.Double> valor em outro tipo numérico. No caso de conversão não integral <xref:System.Double> valores, como mostra a saída do exemplo, o componente fracionário é perdido quando o <xref:System.Double> valor é arredondado (como Visual Basic) ou truncado (como em c#). Para conversões em <xref:System.Decimal> e <xref:System.Single> valores, o <xref:System.Double> valor não pode ter uma representação exata no tipo de dados de destino.  
  
 O exemplo a seguir converte um número de <xref:System.Double> valores em vários outros tipos numéricos. As conversões ocorrem em um contexto verificado no Visual Basic (o padrão) e em c# (porque o [check](~/docs/csharp/language-reference/keywords/checked.md) palavra-chave). A saída do exemplo mostra o resultado para conversões em ambas as um check um contexto desmarcado. Você pode executar conversões em um contexto desmarcado no Visual Basic compilando com o `/removeintchecks+` opção de compilador e no c# comentando o `checked` instrução.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Para obter mais informações sobre a conversão de tipos numéricos, consulte [conversão de tipo do .NET Framework](~/docs/standard/base-types/type-conversion.md) e [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Funcionalidade de ponto flutuante  
 O <xref:System.Double> estrutura e tipos relacionados fornecem métodos para executar operações nas seguintes áreas:  
  
-   **Comparação de valores**. Você pode chamar o <xref:System.Double.Equals%2A> método para determinar se dois <xref:System.Double> valores forem iguais, ou o <xref:System.Double.CompareTo%2A> método para determinar a relação entre dois valores.  
  
     O <xref:System.Double> estrutura também oferece suporte a um conjunto completo de operadores de comparação. Por exemplo, você pode testar a igualdade ou desigualdade ou determinar se um valor é maior que ou igual a outro. Se um dos operandos for um tipo numérico diferente de um <xref:System.Double>, ele será convertido em um <xref:System.Double> antes de executar a comparação.  
  
    > [!WARNING]
    >  Devido às diferenças na precisão, dois <xref:System.Double> valores que você espera que seja igual podem se tornar diferentes, que afeta o resultado da comparação. Consulte o [testes de igualdade](#Equality) para obter mais informações sobre como comparar dois <xref:System.Double> valores.  
  
     Você também pode chamar o <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> métodos para testar esses valores especiais.  
  
-   **Operações matemáticas**. Operações aritméticas comuns, como adição, subtração, multiplicação e divisão, são implementadas por compiladores de linguagem e instruções de linguagem comum intermediário (CIL), em vez de <xref:System.Double> métodos. Se um dos operandos em uma operação matemática é um tipo numérico diferente de um <xref:System.Double>, ele será convertido em um <xref:System.Double> antes de executar a operação. O resultado da operação também é um <xref:System.Double> valor.  
  
     Outras operações matemáticas podem ser executadas chamando `static` (`Shared` no Visual Basic) métodos de <xref:System.Math?displayProperty=nameWithType> classe. Ele inclui métodos adicionais usados para aritmética (como <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, e <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometria (como <xref:System.Math.Cos%2A?displayProperty=nameWithType> e <xref:System.Math.Sin%2A?displayProperty=nameWithType>) e cálculo (como <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     Você também pode manipular bits individuais em um <xref:System.Double> valor. O <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> método preserva um <xref:System.Double> valor do padrão de bits em um inteiro de 64 bits. O <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> método retorna o padrão de bit em uma matriz de bytes.  
  
-   **Arredondamento**. Arredondamento geralmente é usado como uma técnica para reduzir o impacto das diferenças entre valores causadas por problemas de representação de ponto flutuante e precisão. Você poderá arredondar um <xref:System.Double> valor chamando o <xref:System.Math.Round%2A?displayProperty=nameWithType> método.  
  
-   **Formatação**. Você pode converter um <xref:System.Double> valor em sua representação de cadeia de caracteres ao chamar o <xref:System.Double.ToString%2A> método ou usando o recurso de formatação composta. Para obter informações sobre como controlam a representação de cadeia de caracteres de valores de ponto flutuante a cadeias de caracteres de formato, consulte o [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) tópicos.  
  
-   **Analisando cadeias de caracteres**. Você pode converter a representação de cadeia de caracteres de um valor de ponto flutuante para um <xref:System.Double> valor chamando o <xref:System.Double.Parse%2A> ou <xref:System.Double.TryParse%2A> método. Se a operação de análise falhar, o <xref:System.Double.Parse%2A> método lançará uma exceção, enquanto o <xref:System.Double.TryParse%2A> método retornará `false`.  
  
-   **Conversão de tipo**. O <xref:System.Double> estrutura fornece uma implementação de interface explícita para o <xref:System.IConvertible> interface, que oferece suporte à conversão entre quaisquer dois tipos de dados padrão do .NET Framework. Compiladores de linguagem também oferecem suporte a conversão implícita de valores de todos os outros tipos numéricos padrão para <xref:System.Double> valores. Conversão de um valor de qualquer tipo numérico padrão para um <xref:System.Double> é uma conversão de ampliação e não exigem que o usuário de um método de operador ou conversão de conversão  
  
     No entanto, a conversão de <xref:System.Int64> e <xref:System.Single> valores podem envolver uma perda de precisão. A tabela a seguir lista as diferenças na precisão para cada um destes tipos:  
  
    |Tipo|Precisão máxima|Precisão interna|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 dígitos decimais|19 dígitos decimais|  
    |<xref:System.Single>|7 dígitos decimais|9 dígitos decimais|  
  
     O problema de precisão com mais frequência afeta <xref:System.Single> valores são convertidos em <xref:System.Double> valores. No exemplo a seguir, dois valores produzidos por operações de divisão idênticos são diferentes porque um dos valores é um valor convertido em um flutuante de precisão única do ponto um <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros desse tipo são thread-safe. Os membros que aparentam modificar efetivamente o estado retornam uma nova instância inicializada com o novo valor. Assim como acontece com qualquer outro tipo, a leitura e a gravação em uma variável compartilhada que contém uma instância desse tipo devem ser protegidas por um bloqueio para garantir thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão dupla a ser comparado.</param>
        <summary>Compara essa instância a um número de ponto flutuante de precisão dupla especificado e retorna um inteiro que indica se o valor dessa instância é menor que, igual a ou maior que o valor do que o número especificado de ponto flutuante de precisão dupla especificado.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância não é um número (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> é um número.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 -ou-  
  
 Esta instância e <paramref name="value" /> não são um número (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância é um número (<paramref name="value" />) e <see cref="F:System.Double.NaN" /> não é um número.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os valores devem ser idênticos para serem considerados iguais. Particularmente quando valores de ponto flutuante dependem de várias operações matemáticas, é comum para a perda de precisão e seus valores sejam quase idênticos, exceto seus dígitos menos significantes. Por isso, o valor de retorno de <xref:System.Double.CompareTo%2A> método às vezes pode parecer surpreendente. Por exemplo, a multiplicação por um determinado valor seguido por divisão com o mesmo valor deve gerar o valor original. No exemplo a seguir, no entanto, o valor calculado se torna maior que o valor original. Mostrando todos os dígitos significativos dos dois valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que o valor calculado é diferente do valor original em seus dígitos menos significantes. Para obter informações sobre como tratar essas comparações, consulte a seção comentários a <xref:System.Double.Equals%28System.Double%29> método.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Implementa esse método de <xref:System.IComparable%601?displayProperty=nameWithType> interface e executa um pouco melhor do que o <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> método porque ele não tem que converter a `value` parâmetro para um objeto.  
  
 Observe que, embora um objeto cujo valor é <xref:System.Double.NaN> não é considerado igual a outro objeto cujo valor é <xref:System.Double.NaN> (até mesmo em si), o <xref:System.IComparable%601> interface requer que `A.CompareTo(A)` retornar zero.  
  
## <a name="widening-conversions"></a>Conversões de expansão  
 Dependendo da linguagem de programação, talvez seja possível código um <xref:System.Double.CompareTo%2A> método em que o tipo de parâmetro tem bits menos (é mais estreita) que o tipo de instância. Isso é possível porque algumas linguagens de programação executam uma conversão de ampliação implícita que representa o parâmetro como um tipo com tantos bit quanto a instância.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Double> e o tipo de parâmetro seja <xref:System.Int32>. O compilador Microsoft c# gera instruções para representar o valor do parâmetro como um <xref:System.Double> do objeto e, em seguida, gera um <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> método que compara os valores da instância e a representação ampliou do parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador executa conversões ampliadoras implícitas de tipos numéricos. Para obter mais informações, consulte o [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md) tópico.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra genéricas e versões dos <xref:System.Double.CompareTo%2A> método para vários tipos de valor e referência.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto a ser comparado ou <see langword="null" />.</param>
        <summary>Compara esta instância a um objeto especificado e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um número assinado que indica os valores relativos dessa instância e de <paramref name="value" />.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Um inteiro negativo  
  
 </term><description>Esta instância é menor que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância não é um número (<see cref="F:System.Double.NaN" />) e <paramref name="value" /> é um número.  
  
 </description></item><item><term>Zero  
  
 </term><description>Esta instância é igual a <paramref name="value" />.  
  
 -ou-  
  
 Essa instância e <paramref name="value" /> são ambos <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" />, ou <see cref="F:System.Double.NegativeInfinity" /> </description> </item> <item> <term> um número inteiro positivo  
  
 </term><description>Esta instância é maior do que <paramref name="value" />.  
  
 -ou-  
  
 Esta instância é um número e <paramref name="value" /> não é um número (<see cref="F:System.Double.NaN" />).  
  
 -ou-  
  
 <paramref name="value" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser `null` ou uma instância de `Double`; caso contrário, uma exceção será lançada. Qualquer instância do <xref:System.Double>, independentemente de seu valor é considerado maior `null`.  
  
 Os valores devem ser idênticos para serem considerados iguais. Particularmente quando valores de ponto flutuante dependem de várias operações matemáticas, é comum para a perda de precisão e seus valores sejam quase idênticos, exceto seus dígitos menos significantes. Por isso, o valor de retorno de <xref:System.Double.CompareTo%2A> método às vezes pode parecer surpreendente. Por exemplo, a multiplicação por um determinado valor seguido por divisão com o mesmo valor deve gerar o valor original. No exemplo a seguir, no entanto, o valor calculado se torna maior que o valor original. Mostrando todos os dígitos significativos dos dois valores usando o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) indica que o valor calculado é diferente do valor original em seus dígitos menos significantes. Para obter informações sobre como tratar essas comparações, consulte a seção comentários a <xref:System.Double.Equals%28System.Double%29> método.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Esse método é implementado para dar suporte a <xref:System.IComparable> interface. Observe que, embora uma <xref:System.Double.NaN> não é igual ao outro <xref:System.Double.NaN> (até mesmo em si), o <xref:System.IComparable> interface requer que `A.CompareTo(A)` retornar zero.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de `CompareTo` no contexto de `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> não é um <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Representa o menor valor <see cref="T:System.Double" /> positivo maior que zero. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da <xref:System.Double.Epsilon> propriedade reflete o positivo menor <xref:System.Double> valor significativo em operações numéricas ou comparações quando o valor da <xref:System.Double> instância é zero. Por exemplo, a código a seguir mostra que zero e <xref:System.Double.Epsilon> são considerados valores diferentes, enquanto zero e metade do valor de <xref:System.Double.Epsilon> são considerados iguais.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Mais precisamente, flutuante ponto formato consiste em um sinal, um mantissa 52 bits ou significando e um expoente 11 bits. Como mostra o exemplo a seguir, zero tem um expoente de -1022 e um mantissa de 0. <xref:System.Double.Epsilon>tem um expoente de -1022 e um mantissa de 1. Isso significa que <xref:System.Double.Epsilon> é o menor positivo <xref:System.Double> valor maior que zero e representa o menor valor possível e o menor incremento possíveis para um <xref:System.Double> cujo expoente é -1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 No entanto, o <xref:System.Double.Epsilon> propriedade não é uma medida geral de precisão do <xref:System.Double> digite; ele se aplica somente ao <xref:System.Double> instâncias que têm um valor de zero ou um expoente de -1022.  
  
> [!NOTE]
>  O valor de <xref:System.Double.Epsilon> propriedade não é equivalente a épsilon de máquina, que representa o limite superior do erro relativo devido a um arredondamento em aritmética de ponto flutuante.  
  
 O valor dessa constante é 4.94065645841247e-324.  
  
 Dois números de ponto flutuantes aparentemente equivalentes não podem comparar igual devido a diferenças nos seus dígitos menos significantes. Por exemplo, a expressão de c#, `(double)1/3 == (double)0.33333`, não comparados como iguais porque a operação de divisão no lado esquerdo tem precisão máxima, enquanto a constante à direita é precisa apenas de dígitos especificados. Se você criar um algoritmo personalizado que determina se dois números de ponto flutuantes podem ser considerados iguais, não recomendamos que você basear seu algoritmo no valor da <xref:System.Double.Epsilon> constante para estabelecer a margem aceitável absoluta da diferença para os dois valores a serem considerados iguais.  (Normalmente, é muitas vezes maior que a margem de diferença <xref:System.Double.Epsilon>.) Para obter informações sobre como comparar dois valores de ponto flutuantes de precisão dupla, consulte <xref:System.Double> e <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Notas de plataforma  
 Em sistemas ARM, o valor de <xref:System.Double.Epsilon> constante é muito pequeno para ser detectada, para que ele é igual a zero. Você pode definir um valor de épsilon alternativo que é igual a 2.2250738585072014E-308 em vez disso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto <see cref="T:System.Double" /> para comparação com essa instância.</param>
        <summary>Retorna um valor que indica se essa instância e um objeto <see cref="T:System.Double" /> especificado representam o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for igual a essa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementa esse método de <xref:System.IEquatable%601?displayProperty=nameWithType> de interface e executa um pouco melhor do que <xref:System.Double.Equals%2A> porque ele não tem que converter a `obj` parâmetro para um objeto.  
  
## <a name="widening-conversions"></a>Conversões de expansão  
 Dependendo da linguagem de programação, talvez seja possível código um <xref:System.Double.Equals%2A> método em que o tipo de parâmetro tem bits menos (é mais estreita) que o tipo de instância. Isso é possível porque algumas linguagens de programação executam uma conversão de ampliação implícita que representa o parâmetro como um tipo com tantos bit quanto a instância.  
  
 Por exemplo, suponha que o tipo de instância seja <xref:System.Double> e o tipo de parâmetro seja <xref:System.Int32>. O compilador Microsoft c# gera instruções para representar o valor do parâmetro como um <xref:System.Double> do objeto e, em seguida, gera um <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> método que compara os valores da instância e a representação ampliou do parâmetro.  
  
 Consulte a documentação da linguagem de programação para determinar se o compilador executa conversões ampliadoras implícitas de tipos numéricos. Para obter mais informações, consulte o [tabelas de conversão de tipo](~/docs/standard/base-types/conversion-tables.md) tópico.  
  
## <a name="precision-in-comparisons"></a>Precisão em comparações  
 O <xref:System.Double.Equals%2A> método deve ser usado com cuidado, porque dois valores aparentemente equivalentes podem ser diferentes devido à precisão diferente dos dois valores. O exemplo a seguir relata que o <xref:System.Double> .333333 de valor e o <xref:System.Double> valor retornado pela divisão 1 por 3 são diferentes.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Em vez de comparação de igualdade, uma técnica envolve a definição de uma margem relativa aceitável de diferença entre dois valores (como. 001% de um dos valores). Se o valor absoluto da diferença entre os dois valores é menor ou igual a que a margem, a diferença é provavelmente devido a diferenças na precisão e, portanto, os valores devem ser iguais. O exemplo a seguir usa essa técnica para comparar.33333 e 1/3, os dois <xref:System.Double> valores encontrado diferenciem o exemplo de código anterior. Nesse caso, os valores são iguais.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Porque <xref:System.Double.Epsilon> define a expressão mínimo de um valor positivo cujo intervalo é quase zero, a margem de diferença entre dois valores semelhantes deve ser maior que <xref:System.Double.Epsilon>. Normalmente, é muitas vezes maior do que <xref:System.Double.Epsilon>. Por isso, recomendamos que você não use <xref:System.Double.Epsilon> ao comparar <xref:System.Double> valores para igualdade.  
  
 Uma segunda técnica envolve comparar a diferença entre dois números de ponto flutuante com um valor absoluto. Se a diferença for menor ou igual ao valor absoluto, os números são iguais. Se for maior, os números não são iguais. Uma alternativa é selecionar arbitrariamente um valor absoluto. Isso será um problema, no entanto, como uma margem aceitável de diferença depende da magnitude do <xref:System.Double> valores. Uma segunda alternativa tira proveito de um recurso de design do formato de ponto flutuante: A diferença entre a representação de inteiro de dois valores de ponto flutuantes indica o número de possíveis valores de ponto flutuante que separa-los. Por exemplo, a diferença entre 0,0 e <xref:System.Double.Epsilon> é 1, pois <xref:System.Double.Epsilon> é o menor valor representável ao trabalhar com um <xref:System.Double> cujo valor é zero. O exemplo a seguir usa essa técnica para comparar.33333 e 1/3, que são os dois <xref:System.Double> valores que o exemplo de código anterior com o <xref:System.Double.Equals%28System.Double%29> método encontrado para ser diferentes. Observe que o exemplo usa o <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> método para converter um valor de ponto flutuante de precisão dupla em sua representação de inteiro.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
 Se dois <xref:System.Double.NaN?displayProperty=nameWithType> valores são testados quanto à igualdade chamando o <xref:System.Double.Equals%2A> método, o método retornará `true`. No entanto, se duas <xref:System.Double.NaN> valores são testados para igualdade usando o operador de igualdade, o operador retornará `false`. Quando você deseja determinar se o valor de um <xref:System.Double> não é um número (NaN), uma alternativa é chamar o <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Double.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Double" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Double.Equals(System.Double)" /> método. Caso contrário, eles chamam o <see cref="M:System.Double.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Double" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos numéricos primitivo exceto para <see cref="T:System.Decimal" /> e no c#, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chama o <see cref="M:System.Double.Equals(System.Double)" /> método, enquanto a segunda comparação Retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Double.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> é uma instância de <see cref="T:System.Double" /> e é igual ao valor dessa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.Equals%2A> método deve ser usado com cuidado, porque dois valores aparentemente equivalentes podem ser diferentes devido à precisão diferente dos dois valores. O exemplo a seguir relata que o <xref:System.Double> valor.3333 e o <xref:System.Double> retornado pela divisão de 1 a 3 são diferentes.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Para alternativas para chamar o <xref:System.Double.Equals%2A> método, consulte a documentação para o <xref:System.Double.Equals%28System.Double%29> de sobrecarga.  
  
> [!NOTE]
>  Porque <xref:System.Double.Epsilon> define a expressão mínimo de um valor positivo cujo intervalo é quase zero, a margem de diferença entre dois valores semelhantes deve ser maior que <xref:System.Double.Epsilon>. Normalmente, é muitas vezes maior do que <xref:System.Double.Epsilon>.  
  
 A precisão dos números de ponto flutuante além da precisão documentada é específica da implementação e da versão do .NET Framework. Consequentemente, uma comparação entre dois números específicos pode mudar entre versões do .NET Framework porque a precisão da representação interna dos números pode mudar.  
  
 Se dois <xref:System.Double.NaN?displayProperty=nameWithType> valores são testados quanto à igualdade chamando o <xref:System.Double.Equals%2A> método, o método retornará `true`. No entanto, se duas <xref:System.Double.NaN> valores são testados para igualdade usando o operador de igualdade, o operador retornará `false`. Quando você deseja determinar se o valor de um <xref:System.Double> não é um número (NaN), uma alternativa é chamar o <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Resolução de sobrecarga de compilador pode ser responsável por uma aparente diferença no comportamento dos dois <see cref="M:System.Double.Equals(System.Object)" /> sobrecargas do método. Se uma conversão implícita entre o <paramref name="obj" /> argumento e uma <see cref="T:System.Double" /> é definido e o argumento não é digitado como um <see cref="T:System.Object" />, compiladores podem executar uma conversão implícita e a chamada a <see cref="M:System.Double.Equals(System.Double)" /> método. Caso contrário, eles chamam o <see cref="M:System.Double.Equals(System.Object)" /> método, que sempre retorna <see langword="false" /> se seu <paramref name="obj" /> argumento não é um <see cref="T:System.Double" /> valor. O exemplo a seguir ilustra a diferença no comportamento entre as sobrecargas de dois método. No caso de todos os tipos numéricos primitivo exceto para <see cref="T:System.Decimal" /> e no c#, retorna a primeira comparação <see langword="true" /> porque o compilador executa automaticamente uma conversão de ampliação e chama o <see cref="M:System.Double.Equals(System.Double)" /> método, enquanto a segunda comparação Retorna <see langword="false" /> porque o compilador chama o <see cref="M:System.Double.Equals(System.Object)" /> método.  
  
 [!code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)]
 [!code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para tipo de valor <see cref="T:System.Double" />.</summary>
        <returns>A constante enumerada, <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliado como infinito positivo ou negativo</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> for avaliado como <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna um valor que indica se o valor especificado não é um número (<see cref="F:System.Double.NaN" />).</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> for avaliado como <see cref="F:System.Double.NaN" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Double.NaN> para sinalizar que o resultado da operação é indefinido. Por exemplo, dividindo 0,0, 0,0 resulta em <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A>Retorna `false` se um <xref:System.Double> valor seja <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>. Para testar esses valores, use o <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, e <xref:System.Double.IsNegativeInfinity%2A> métodos.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliado quanto ao infinito negativo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> for avaliado como <see cref="F:System.Double.NegativeInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Double.NegativeInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna um valor que indica se o número especificado é avaliado quanto ao infinito positivo.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d" /> for avaliado como <see cref="F:System.Double.PositiveInfinity" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operações de ponto flutuante retornam <xref:System.Double.PositiveInfinity> para sinalizar uma condição de estouro.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Representa o maior valor possível de um <see cref="T:System.Double" />. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é positivo 1.7976931348623157E + 308.  
  
 O resultado de uma operação que excede <xref:System.Double.MaxValue?displayProperty=nameWithType> é <xref:System.Double?displayProperty=nameWithType>. No exemplo a seguir, <xref:System.Double?displayProperty=nameWithType> quando o resultado excede os resultados de operações de adição, a multiplicação e a exponenciação <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Representa o menor valor possível de um <see cref="T:System.Double" />. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é negativo 1.7976931348623157E + 308.  
  
 O resultado de uma operação que é menor que <xref:System.Double.MinValue?displayProperty=nameWithType> é <xref:System.Double?displayProperty=nameWithType>. No exemplo a seguir, <xref:System.Double?displayProperty=nameWithType> resultados de operações de subtração, multiplicação quando o resultado é menor que <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Representa um valor que não é um número (<see langword="NaN" />). Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um método ou operador retorna <xref:System.Double.NaN> quando o resultado de uma operação é indefinido. Por exemplo, o resultado da divisão por zero de zero é <xref:System.Double.NaN>, como mostra o exemplo a seguir. (Mas observe que a divisão de um número diferente de zero por zero retorna <xref:System.Double.PositiveInfinity> ou <xref:System.Double.NegativeInfinity>, dependendo do sinal do divisor.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Além disso, uma chamada de método com um <xref:System.Double.NaN> valor ou uma operação em um <xref:System.Double.NaN> valor retorna <xref:System.Double.NaN>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Use o <xref:System.Double.IsNaN%2A> método para determinar se um valor não é um número. O <xref:System.Double.op_Equality%2A> operador considera dois <xref:System.Double.NaN> valores sejam diferentes entre si. Em geral, <xref:System.Double> operadores não podem ser usados para comparar <xref:System.Double.NaN?displayProperty=nameWithType> com outros <xref:System.Double> valores, embora os métodos de comparação (como <xref:System.Double.Equals%2A> e <xref:System.Double.CompareTo%2A>) pode. O exemplo a seguir ilustra a diferença no comportamento entre <xref:System.Double> métodos e operadores de comparação.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de <xref:System.Double.NaN>:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Representa o infinito negativo. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é o resultado da divisão por zero de um número negativo.  
  
 Esta constante é retornado quando o resultado de uma operação é menor que <xref:System.Double.MinValue>.  
  
 Use <xref:System.Double.IsNegativeInfinity%2A> para determinar se um valor é avaliada como infinito negativo.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se os dois valores <see cref="T:System.Double" /> especificados são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> e <paramref name="right" /> forem iguais; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_Equality%2A> método define o operador de igualdade para <xref:System.Double> valores.  
  
 Se dois <xref:System.Double?displayProperty=nameWithType> valores são testados quanto à igualdade usando o operador de igualdade, o resultado será `false`; dois <xref:System.Double?displayProperty=nameWithType> valores não são considerados iguais. Se eles são testados quanto à igualdade chamando o <xref:System.Double.Equals%2A> método, o resultado é `true`.  Quando você deseja determinar se o valor de um <xref:System.Double> não é um número (NaN), uma alternativa é chamar o <xref:System.Double.IsNaN%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor <see cref="T:System.Double" /> especificado é maior que outro valor <see cref="T:System.Double" /> especificado.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_GreaterThan%2A> método define a operação de maior-que o operador para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um especificado <see cref="T:System.Double" /> valor é maior que ou igual a outro especificado <see cref="T:System.Double" /> valor.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> for maior ou igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_GreaterThanOrEqual%2A> método define a operação do operador greater-than-ou-equal para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois especificada <see cref="T:System.Double" /> valores não forem iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_Inequality%2A> método define o operador de desigualdade para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor especificado de <see cref="T:System.Double" /> é menor que outro valor especificado de <see cref="T:System.Double" />.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_LessThan%2A> método define a operação de menos-que o operador para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um especificado <see cref="T:System.Double" /> valor é menor ou igual a outro especificado <see cref="T:System.Double" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.op_LessThanOrEqual%2A> método define a operação do operador less-than-or-equal para <xref:System.Double> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no equivalente do número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `s` parâmetro pode conter a cultura atual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, ou uma cadeia de caracteres do formulário:  
  
 [*ws*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.* [*dígitos fracionários*]] [E [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+). Somente um sinal pode ser usado.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Executa de *integral dígitos* pode ser particionado por um símbolo de separador de grupo. Por exemplo, em algumas culturas, uma vírgula (,) separa grupos de milhares. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|,|Um símbolo de separador de milhares específico da cultura.|  
|.|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 O parâmetro `s` é interpretado usando-se uma combinação dos sinalizadores <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Isso significa que o espaço em branco e milhar são permitidos separadores, por exemplo, enquanto os símbolos de moeda não são. Para melhor controle sobre qual estilo elementos são permitidos em `s` para a operação de análise seja bem-sucedida, chame o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> ou <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 O `s` parâmetro é interpretado usando as informações de formatação em um <xref:System.Globalization.NumberFormatInfo> objeto que é inicializado para a cultura do thread atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Para analisar uma cadeia de caracteres usando as informações de formatação de alguns outros cultura, chame o <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> ou <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 Normalmente, se você passa ao método <xref:System.Double.Parse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não representa um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indicam os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico para especificar é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> combinado com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo especificado para o número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `style` define os elementos de estilo (como espaço em branco, separadores de milhares e símbolos de moeda) que são permitidos no parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 O `s` parâmetro pode conter a cultura atual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. Dependendo do valor de `style`, ele também pode assumir a forma:  
  
 [*ws*][*$*][*sign*][*integral-digits*[*,*]]*integral-digits*[*.* [*dígitos fracionários*]] [E [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|$|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+). O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|,|Um separador de grupo específico de cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>|  
|.|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `s` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. Os elementos de controle dos membros <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em `s` além de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador de milhares (.).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o símbolo de ponto decimal (.). O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de milhares (.) e elementos de vírgula decimal (,).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal.|  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Normalmente, se você passa ao método <xref:System.Double.Parse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método para analisar as representações de cadeia de caracteres de <xref:System.Double> valores usando a cultura en-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não representa um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico da cultura para o número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> método normalmente é usado para converter um texto que pode ser formatado de várias maneiras de um <xref:System.Double> valor. Por exemplo, ele pode ser usado para converter o texto inserido por um usuário em uma caixa de texto HTML para um valor numérico.  
  
 O parâmetro `s` é interpretado usando-se uma combinação dos sinalizadores <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para a cultura especificada pelo `provider`, ou ele pode conter uma cadeia de caracteres do formulário:  
  
 [*ws*][*sign*]*integral-digits*[*.* [*dígitos fracionários*]] [E [*sinal*]*exponencial dígitos*] [*ws*]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Os elementos que contêm o termo "digits" consistem em uma série de caracteres numéricos que varia de 0 a 9.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+).|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Executa de *integral dígitos* pode ser particionado por um símbolo de separador de grupo. Por exemplo, em algumas culturas, uma vírgula (,) separa grupos de milhares. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|.|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Para obter mais informações sobre formatos numéricos, consulte o [tipos de formatação](~/docs/standard/base-types/formatting-types.md) tópico.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cujo <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas de cultura usadas em interpretar o formato de `s`. Normalmente, é um <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objeto. Se `provider` é `null` ou <xref:System.Globalization.NumberFormatInfo> não pode ser obtido, as informações de formatação para a cultura atual do sistema é usada.  
  
 Normalmente, se você passa ao método <xref:System.Double.Parse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir é o manipulador de eventos de clique do botão de um formulário da Web. Ele usa a matriz retornada pela propriedade <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> para determinar a localidade do usuário. Em seguida, ele instancia um objeto <xref:System.Globalization.CultureInfo> que corresponde à localidade. O <xref:System.Globalization.NumberFormatInfo> que pertence ao objeto <xref:System.Globalization.CultureInfo> objeto é transmitido para o <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> método para converter o usuário de entrada para um <xref:System.Double> valor.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> não representa um número em um formato válido.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indicam os elementos de estilo que podem estar presentes em <c>s</c>. Um valor típico para ser especificado é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>s</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico de cultura e estilo para o número de ponto flutuante de precisão dupla equivalente.</summary>
        <returns>Um número de ponto flutuante de precisão dupla que é equivalente ao valor numérico ou ao símbolo especificado em <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `style` define os elementos de estilo (como espaço em branco, separadores de milhares e símbolos de moeda) que são permitidos no parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para a cultura especificada pelo `provider`. Dependendo do valor de `style`, ele também pode assumir a forma:  
  
 [*ws*] [*$*] [*sign*][*integral-digits*,]*integral-digits*[.[ *dígitos fracionários*]] [E[*sign*]*exponential-digits*][*ws*]  
  
 Elementos entre colchetes ([e]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco. Espaço em branco pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|$|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um símbolo de sinal negativo (-) ou um símbolo de sinal positivo (+). O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. O *integral dígitos* elemento pode estar ausente se a cadeia de caracteres contém a *dígitos fracionários* elemento.|  
|,|Um separador de grupo específico de cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>|  
|.|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `s` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. Os elementos de controle dos membros <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em `s` além de dígitos|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *dígitos*E*dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador de milhares (.).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o símbolo de ponto decimal (.). O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de milhares (.) e elementos de vírgula decimal (,).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `s` não pode representar um número hexadecimal.|  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cujo <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações específicas de cultura usadas em interpretar o formato de `s`. Normalmente, é um <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objeto. Se `provider` é `null` ou <xref:System.Globalization.NumberFormatInfo> não pode ser obtido, as informações de formatação para a cultura atual do sistema é usada.  
  
 Normalmente, se você passa ao método <xref:System.Double.Parse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método para atribuir várias representações de cadeia de caracteres de valores de temperatura para um `Temperature` objeto.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" />não representa um valor numérico.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> é o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> representa um número que é menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Representa infinito positivo. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor dessa constante é o resultado da divisão de um número positivo por zero.  
  
 Esta constante é retornado quando o resultado de uma operação é maior do que <xref:System.Double.MaxValue>.  
  
 Use <xref:System.Double.IsPositiveInfinity%2A> para determinar se um valor é avaliada como infinito positivo.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso de <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> caso o valor da instância atual não seja zero; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. A tentativa de usar esse método lança um <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Esta conversão não é suportada. Tentativa de usar este método lança um<see cref="T:System.InvalidCastException" /></summary>
        <returns>Esta conversão não é suportada. Nenhum valor é retornado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual converter isso <see cref="T:System.Double" /> valor.</param>
        <param name="provider">Uma implementação de <see cref="T:System.IFormatProvider" /> que fornece informações específicas da cultura sobre o formato do valor retornado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o método `static` (`Shared` no Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor da instância atual, convertido em um <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Double> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.ToString> formatos do método um <xref:System.Double> valor padrão ("G" ou geral), formato da cultura atual. Se você quiser especificar um formato diferente, a precisão ou a cultura, use as outras sobrecargas do <xref:System.Double.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Um formato específico ou a precisão|Cultura do padrão (atual)|<xref:System.Double.ToString%28System.String%29>|  
|Um formato específico ou a precisão|Uma cultura específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> ou uma cadeia de caracteres do formulário:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Os elementos que contêm o termo "digits" consistem em uma série de caracteres numéricos que varia de 0 a 9. Há suporte para os elementos listados na tabela a seguir.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*logon*|Um símbolo de sinal negativo ou de sinal positivo.|  
|*dígitos de integral*|Uma série de dígitos que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|'*.*'|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que especificam a parte fracionária do número.|  
|'*e*'|Um caractere minúsculo 'e', indicando a notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que especificam um expoente.|  
  
 Alguns exemplos do valor de retorno são "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o padrão <xref:System.Double.ToString?displayProperty=nameWithType> método para exibir as representações de cadeia de caracteres de um número de <xref:System.Double> valores.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 O exemplo a seguir ilustra o uso de <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.ToString%28System.IFormatProvider%29> formatos do método um <xref:System.Double> valor padrão ("G" ou geral) formato de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Double.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Padrão (atual)|<xref:System.Double.ToString>|  
|Um formato específico ou a precisão|Cultura do padrão (atual)|<xref:System.Double.ToString%28System.String%29>|  
|Um formato específico ou a precisão|Uma cultura específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> ou uma cadeia de caracteres do formulário:  
  
 [sign]integral-digits[.[fractional-digits]][e[sign]exponential-digits]  
  
 Os elementos opcionais são colocados entre colchetes ([ e ]). Os elementos que contêm o termo "digits" consistem em uma série de caracteres numéricos que varia de 0 a 9. Há suporte para os elementos listados na tabela a seguir.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*logon*|Um símbolo de sinal negativo ou de sinal positivo.|  
|*dígitos de integral*|Uma série de dígitos que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|'*.*'|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de dígitos que especificam a parte fracionária do número.|  
|'*e*'|Um caractere minúsculo 'e', indicando a notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de dígitos que especificam um expoente.|  
  
 Alguns exemplos do valor de retorno são "100", "-123,456,789", "123.45e+6", "500", "3.1416", "600", "-0.123" e "-Infinity".  
  
 Esta instância é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um objeto <xref:System.Globalization.CultureInfo> ou um objeto <xref:System.Globalization.NumberFormatInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Se `provider` é `null`, o valor de retorno é formatado usando o <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir exibe a representação de cadeia de caracteres de dois <xref:System.Double> valores usando <xref:System.Globalization.CultureInfo> objetos que representam várias culturas diferentes.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 O exemplo a seguir ilustra o uso de <xref:System.Double.ToString%2A>, aceitando um <xref:System.String> e um <xref:System.IFormatProvider> como parâmetros.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato numérico.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.ToString%28System.String%29> formatos do método um <xref:System.Double> valor em um formato especificado usando as convenções da cultura atual. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Double.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Double.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Um formato específico ou a precisão|Uma cultura específica|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou a representação de cadeia de caracteres de um número, conforme especificado por `format`.  
  
 O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, exceto para D e X, bem como qualquer combinação de especificadores de formato numérico personalizados. Se `format` é `null` ou uma cadeia de caracteres vazia, o valor de retorno é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Por padrão, o valor de retorno contém 15 dígitos de precisão somente Embora um máximo de 17 dígitos seja mantido internamente. Se o valor desta instância tem maior que 15 dígitos, <xref:System.Double.ToString%2A> retorna <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> em vez do número esperado. Se você precisar de mais precisão, especificar `format` com a especificação de formato "G17", que sempre retorna 17 dígitos de precisão ou "R", que retorna 15 dígitos se o número pode ser representado com que a precisão ou 17 dígitos, se o número só pode ser representado com precisão máxima.  
  
   
  
## Examples  
 O exemplo a seguir define um valor numérico e formata como um valor de moeda usando a cadeia de caracteres de formato numérico padrão "C" e como um valor numérico para três casas decimais, usando a cadeia de caracteres de formato numérico padrão de "N". As cadeias de caracteres de resultado são formatadas usando as convenções de cultura en-US. Para obter mais informações sobre cadeias de caracteres de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 O exemplo a seguir exibe vários <xref:System.Double> valores usando especificadores de formato numérico padrão com suporte, juntamente com três cadeias de caracteres de formato numérico personalizado. Uma dessas cadeias de caracteres de formato personalizado ilustra como preencher uma <xref:System.Single> valor com zeros à esquerda. Além disso, o exemplo usa especificadores de precisão com cada especificador de formato padrão, exceto "R". Os valores do intervalo de especificadores de precisão de 0 a 3. Para converter os valores numéricos em cadeias de caracteres, o exemplo usa as convenções de formatação da cultura en-US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.</exception>
        <block subset="none" type="usage">
          <para>Em alguns casos, <see cref="T:System.Double" /> valores formatados com o processamento não com êxito são de cadeia de caracteres de formato numérico padrão "R" se compilada usando o <see langword="/platform:x64" /> ou <see langword="/platform:anycpu" /> comutadores e executados em sistemas de 64 bits. Para contornar esse problema, você pode formatar <see cref="T:System.Double" /> valores usando a cadeia de caracteres de formato numérico padrão "G17". O exemplo a seguir usa a cadeia de caracteres de formato "R" com um <see cref="T:System.Double" /> valor que não não ida e volta com êxito, e também usa "G17" formato de cadeia de caracteres de ida e volta com êxito o valor original.  
  
 [!code-csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)]
 [!code-vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato numérico.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico dessa instância na representação da cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicas da cultura especificada.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" /> e <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> formatos do método um <xref:System.Double> valor em um formato especificado de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Double.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato padrão ("G")|Cultura do padrão (atual)|<xref:System.Double.ToString>|  
|Formato padrão ("G")|Uma cultura específica|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Um formato específico ou a precisão|Cultura do padrão (atual)|<xref:System.Double.ToString%28System.String%29>|  
  
 O valor de retorno pode ser <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, ou a representação de cadeia de caracteres de um número, conforme especificado por `format`.  
  
 O parâmetro `format` pode ser qualquer especificador de formato numérico padrão válido, exceto para D e X, bem como qualquer combinação de especificadores de formato numérico personalizados. Se `format` é `null` ou uma cadeia de caracteres vazia, o valor de retorno para esta instância é formatada com o especificador de formato numérico geral ("G").  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre a formatação, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider> cujo método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo>. Normalmente, `provider` é um objeto <xref:System.Globalization.CultureInfo> ou um objeto <xref:System.Globalization.NumberFormatInfo>. O parâmetro `provider` fornece informações específicas da cultura usadas na formatação. Se `provider` é `null`, o valor de retorno é formatado usando o <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual.  
  
 Por padrão, o valor de retorno contém 15 dígitos de precisão somente Embora um máximo de 17 dígitos seja mantido internamente. Se o valor desta instância tem maior que 15 dígitos, <xref:System.Double.ToString%2A> retorna <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> ou <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> em vez do número esperado. Se você precisar de mais precisão, especificar `format` com a especificação de formato "G17", que sempre retorna 17 dígitos de precisão ou "R", que retorna 15 dígitos se o número pode ser representado com que a precisão ou 17 dígitos, se o número só pode ser representado com precisão máxima.  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Double> valor usando cada um dos especificadores de formato numérico padrão com suporte para várias culturas diferentes.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 O exemplo a seguir ilustra o uso de <xref:System.Double.ToString%2A>, aceitando um <xref:System.String> e um <xref:System.IFormatProvider> como parâmetros.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Em alguns casos, <see cref="T:System.Double" /> valores formatados com o processamento não com êxito são de cadeia de caracteres de formato numérico padrão "R" se compilada usando o <see langword="/platform:x64" /> ou <see langword="/platform:anycpu" /> comutadores e executados em sistemas de 64 bits. Para contornar esse problema, você pode formatar <see cref="T:System.Double" /> valores usando a cadeia de caracteres de formato numérico padrão "G17". O exemplo a seguir usa a cadeia de caracteres de formato "R" com um <see cref="T:System.Double" /> valor que não não ida e volta com êxito, e também usa "G17" formato de cadeia de caracteres de ida e volta com êxito o valor original.  
  
 [!code-csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)]
 [!code-vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="result">Quando este método retorna, contém o número de ponto flutuante de precisão dupla equivalente do <c>s</c> parâmetro, se a conversão foi bem-sucedida ou zero se a conversão falha. A conversão falhará se o <c>s</c> parâmetro é <see langword="null" /> ou <see cref="F:System.String.Empty" />, não é um número em um formato válido ou representa um número menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />. Este parâmetro é passado não inicializado; qualquer valor fornecido originalmente no <c>resultados</c> será substituído.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no equivalente do número de ponto flutuante de precisão dupla. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga difere de <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> método retornando um valor booliano que indica se a operação de análise foi bem-sucedida em vez de retornar o valor numérico analisado. Ele elimina a necessidade de usar a identificação de exceções para testar um <xref:System.FormatException> caso esse `s` seja inválido e não possa ser analisado com êxito.  
  
 O `s` parâmetro pode conter a cultura atual <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (a comparação de cadeia de caracteres diferencia maiusculas de minúsculas), ou uma cadeia de caracteres do formulário:  
  
 [ws] [entrada] [integral dígitos,] integral dígitos [. [ dígitos de fração]] [exponencial e [logon] dígitos] [ws]  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Uma série de caracteres de espaço em branco.|  
|*logon*|Um símbolo de sinal negativo ou de sinal positivo.|  
|*dígitos de integral*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|*,*|Um símbolo de separador do grupo específico da cultura.|  
|*.*|Um símbolo de vírgula decimal específico de cultura.|  
|*dígitos fracionários*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam a parte fracionária do número.|  
|*E*|Um maiusculo ou minúsculo caractere 'e', que indica a notação exponencial (científica).|  
|*dígitos exponencial*|Uma série de caracteres numéricos, variando de 0 a 9 que especificam um expoente.|  
  
 Para obter mais informações sobre formatos numéricos, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O `s` parâmetro é interpretado usando uma combinação da <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizadores. Isso significa que o espaço em branco e os separadores de milhares são permitidos, mas os símbolos de moeda não. Para definir explicitamente os elementos (como símbolos de moeda, milhares separadores e espaços em branco) que podem estar presentes em `s`, use o <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> sobrecarga do método.  
  
 O parâmetro `s` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analisar uma cadeia de caracteres usar as informações de formatação de alguma outra especificado cultura, use o <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> sobrecarga do método.  
  
 Normalmente, se você passa ao método <xref:System.Double.TryParse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Se um separador é encontrado na `s` parâmetro durante uma operação de análise e os separadores decimais e de grupo são os mesmos, a operação de análise assumirá que o separador é um separador decimal em vez de um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> método para converter as representações de cadeia de caracteres de valores numéricos para <xref:System.Double> valores. Ele pressupõe que en-US é a cultura atual.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit de <see cref="T:System.Globalization.NumberStyles" /> valores que indica o formato permitido de <c>s</c>. Um valor típico para ser especificado é uma combinação de <see cref="F:System.Globalization.NumberStyles.Float" /> com <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Um <see cref="T:System.IFormatProvider" /> que forneça informações de formatação de cultura específica sobre <c>s</c>.</param>
        <param name="result">Quando este método retorna, contém um número de ponto flutuante de precisão dupla equivalente do valor numérico ou símbolo contidos em <c>s</c>, se a conversão foi bem-sucedida ou zero se a conversão falha. A conversão falhará se o <c>s</c> parâmetro é <see langword="null" /> ou <see cref="F:System.String.Empty" />, não está em um formato compatível com <c>estilo</c>, representa um número menor que <see cref="F:System.SByte.MinValue" /> ou maior que <see cref="F:System.SByte.MaxValue" />, ou se <c>estilo</c> não é uma combinação válida de <see cref="T:System.Globalization.NumberStyles" /> constantes enumeradas. Este parâmetro é passado não inicializado; qualquer valor fornecido originalmente no <c>resultados</c> será substituído.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico de cultura e estilo para o número de ponto flutuante de precisão dupla equivalente. Um valor de retorno indica se a conversão foi bem-sucedida ou falhou.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="s" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Double.TryParse%2A> método é como o <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método, exceto pelo fato desse método gerará uma exceção se a conversão falhar. Se a conversão for bem-sucedida, o valor de retorno é `true` e `result` parâmetro está definido como o resultado da conversão. Se a conversão falhar, o valor de retorno é `false` e `result` parâmetro for definido como zero. Isso elimina a necessidade de usar tratamento de exceções para testar um <xref:System.FormatException> caso `s` é inválido e não pode ser analisado com êxito.  
  
 O parâmetro `style` define o formato permitido do parâmetro `s` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Os seguintes membros <xref:System.Globalization.NumberStyles> não são suportados:  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>  
  
 O `s` parâmetro pode conter <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, ou <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> para a cultura indicada pelo `provider`. Além disso, dependendo do valor de `style`, o `s` parâmetro pode incluir os seguintes elementos:  
  
 [ws] [$] [entrada] [integral dígitos,] dígitos integral [fracionários dígitos] [exponencial e [logon] dígitos] [ws]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início do `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador. Ele pode aparecer no final da `s` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. Sua posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> ou <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriedades do <xref:System.Globalization.NumberFormatInfo> objeto retornado pelo <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> método do `provider` parâmetro. O símbolo de moeda pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `s` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos de integral*|Uma série de dígitos que varia de 0 a 9 que especificam a parte integral do número. Os dígitos integrais podem estar ausentes caso sejam dígitos fracionários.|  
|*,*|Um símbolo de separador de milhares específico da cultura. O símbolo do separador do grupo da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*dígitos fracionários*|Uma série de dígitos que varia de 0 a 9 que especificam a parte fracionária do número. Os dígitos fracionários podem ser exibidos em `s` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*e*|O caractere e ou E, que indica que `s` pode representar um número usando a notação exponencial. O `s` parâmetro pode representar um número em notação exponencial se estilo inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*dígitos exponencial*|Uma série de dígitos que varia de 0 a 9 que especificam um expoente.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. O restante <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> elementos que podem ser, mas não precisa estar presente na cadeia de entrada de controle de membros. A tabela a seguir indica como os sinalizadores individuais <xref:System.Globalization.NumberStyles> afetam os elementos que podem estar presentes em `s`.  
  
|Valor NumberStyles|Elementos permitidos em s além de dígitos|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *integral dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O elemento de linguagem *.* e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O parâmetro `s` também pode usar notação exponencial. Esse sinalizador por si só oferece suporte a valores no formulário *integral dígitos*E*exponencial dígitos*; adicionais sinalizadores são necessários para analisar com sucesso cadeias de caracteres em notação exponencial com elementos como sinais positivos ou negativos e símbolos de ponto decimal.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O *,* elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O * $ * elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os. O parâmetro `s` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final da `s`, *sinal* no início de `s`e o *.* símbolo. O parâmetro `s` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, milhares separador (*,),* e ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os estilos, exceto caso `s` não possa representar um número hexadecimal.|  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação, como um <xref:System.Globalization.NumberFormatInfo> ou <xref:System.Globalization.CultureInfo> objeto. O parâmetro `provider` fornece informações específicas da cultura usadas na análise. Se `provider` é `null` ou <xref:System.Globalization.NumberFormatInfo> não é possível obter o objeto, as informações de formato para a cultura atual são usadas.  
  
 A conversão falhará se o `s` parâmetro é `null` ou não é um valor numérico, o `provider` parâmetro não produz um <xref:System.Globalization.NumberFormatInfo> objeto, ou o `style` parâmetro não é uma combinação de sinalizadores de bit do <xref:System.Globalization.NumberStyles> enumeração.  
  
 Normalmente, se você passa ao método <xref:System.Double.TryParse%2A?displayProperty=nameWithType>, uma cadeia de caracteres criada chamando-se o método <xref:System.Double.ToString%2A?displayProperty=nameWithType>, o valor <xref:System.Double> original é retornado. No entanto, por conta de uma perda de precisão, os valores talvez não sejam iguais. Além disso, tente analisar a representação da cadeia de caracteres de <xref:System.Double.MinValue> ou <xref:System.Double.MaxValue> lança um <xref:System.OverflowException>, como ilustra o exemplo a seguir.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Caso um separador esteja no parâmetro `s` durante uma operação de análise e a moeda aplicável ou os separadores de casa decimal e grupo sejam iguais, a operação de análise pressupõe que o separador seja um separador decimal, e não um separador de grupo. Para obter mais informações sobre separadores, consulte <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> e <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> método ao analisar a representação da cadeia de números que tem um estilo específico e são formatados usando as convenções de uma determinada cultura.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o valor <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
