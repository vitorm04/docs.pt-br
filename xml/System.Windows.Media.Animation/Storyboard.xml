<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Um cronograma de contêiner que fornece o objeto e a propriedade direcionando informações para suas animações filho.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Controlando interativamente Storyboards  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável na marcação, você deve especificar o <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> propriedade o <xref:System.Windows.Media.Animation.BeginStoryboard> objeto que cria; por exemplo, consulte [como: usar gatilhos de eventos para controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Associação de dados e linhas de tempo de animação  
 A maioria das propriedades de linha do tempo podem ser associadas a dados ou animadas; No entanto, devido o funcionamento do sistema de controle de tempo, cronogramas associadas ou animadas não se comportam como outros dados de dados associado ou objetos animados. Para entender seu comportamento, é importante para entender o que significa para ativar uma linha do tempo.  
  
 Quando uma linha do tempo é ativada, as cópias são feitas da linha do tempo e seus cronogramas filhos. Essas cópias são congeladas (somente leitura) e <xref:System.Windows.Media.Animation.Clock> objetos são criados a partir delas. Esses relógios fazem o verdadeiro trabalho de animar as propriedades usadas como destino. Se for uma linha do tempo de associação de dados ou de animação, um instantâneo de seus valores atuais é feito quando seu relógio é criado. Mesmo que a linha do tempo original pode continuar a alteração, seu relógio não.  
  
 Para uma linha do tempo refletir as alterações de animação ou de associação de dados, seu relógio deve ser recriado. Relógios não serão recriados para você automaticamente. A seguir estão várias maneiras para aplicar alterações de linha do tempo:  
  
-   Se o cronograma for ou pertence a um <xref:System.Windows.Media.Animation.Storyboard>, você pode torná-lo refletir alterações reaplicando seu storyboard usando um <xref:System.Windows.Media.Animation.BeginStoryboard> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método. Isso tem o efeito colateral de também reiniciar a animação. No código, você pode usar o <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> método para avançar o storyboard de volta para sua posição anterior.  
  
-   Se você aplicar uma animação diretamente a uma propriedade usando o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> método, chame o <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> método novamente e passá-lo a animação que foi modificada.  
  
-   Se você estiver trabalhando diretamente no nível do relógio, criar e aplicar um novo conjunto de relógios e usá-los para substituir o conjunto anterior de relógios criados.  
  
 Para um exemplo de dados de animação associada, consulte [chave Spline Animation Sample](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia o conjunto de animações associado a esta <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Storyboards iniciados com esse método não é possível em pausa, retomados ou caso contrário interativamente controlados depois que eles são iniciados. Para tornar um storyboard controlável, use o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Storyboards iniciados com esse método não é possível em pausa, retomados ou caso contrário interativamente controlados depois que eles são iniciados. Para tornar um storyboard controlável, use o <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> ou <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> método.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" />Se o storyboard interativamente controlável; Caso contrário, <see langword="false" />.</param>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Para controlar este storyboard interativamente, você deve especificar o mesmo `containingObject` ao chamar os métodos interativos que é usada para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para suas metas e inicia, usando especificado <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.  
  
 Para evitar problemas de desempenho ao aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão. Há várias maneiras para remover um relógio.  
  
-   Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado. Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.  
  
-   Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>. Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos. Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`. Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será chamado se a duração efetiva do relógio for indefinida.  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.  
  
 Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar quando o usuário left-clicks e o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando o usuário clica.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="isControllable">
          <see langword="true" />Se o storyboard interativamente controlável; Caso contrário, <see langword="false" />.</param>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto ao qual especificado <c>frameworkTemplate</c> foi aplicada. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">O modelo para animar.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para seus destinos dentro do modelo especificado e iniciá-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para suas metas e inicia, usando especificado <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar quando o usuário left-clicks e o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando o usuário clica.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <param name="isControllable">Declara se a animação é controlável (pode ser pausado) iniciado uma vez.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para suas metas e inicia, usando especificado <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o comportamento de entrega especificada.  
  
 Para controlar este storyboard interativamente, você deve especificar o mesmo `containingObject` ao chamar os métodos interativos que é usada para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Usando o HandoffBehavior de composição  
 Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.  
  
 Para evitar problemas de desempenho ao aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão. Há várias maneiras para remover um relógio.  
  
-   Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado. Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.  
  
-   Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>. Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos. Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`. Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será chamado se a duração efetiva do relógio for indefinida.  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.  
  
 Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 O exemplo a seguir usa o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar quando o usuário left-clicks e o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando o usuário clica.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto ao qual especificado <c>frameworkTemplate</c> foi aplicada.  Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">O modelo para animar.</param>
        <param name="isControllable">
          <see langword="true" />Se o storyboard interativamente controlável; Caso contrário, <see langword="false" />.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para seus destinos dentro do modelo especificado e iniciá-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se as propriedades de destino já são animadas, eles serão substituídos usando o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> comportamento de entrega.  
  
 Para controlar este storyboard interativamente, você deve especificar o mesmo `containingObject` ao chamar os métodos interativos que é usada para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto ao qual especificado <c>frameworkTemplate</c> foi aplicada. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">O modelo para animar.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para seus destinos dentro do modelo especificado e iniciá-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Usando o HandoffBehavior de composição  
 Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.  
  
 Para evitar problemas de desempenho ao aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão. Há várias maneiras para remover um relógio.  
  
-   Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado. Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.  
  
-   Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>. Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos. Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`. Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será chamado se a duração efetiva do relógio for indefinida.  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.  
  
 Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Um objeto contido no mesmo escopo de nome que os destinos das animações desse storyboard. Animações sem um especificado <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <param name="isControllable">Declara se a animação é controlável (pode ser pausado) iniciado uma vez.</param>
        <summary>Aplica as animações associadas a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> a seus destinos e os inicia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Usando o HandoffBehavior de composição  
 Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.  
  
 Para evitar problemas de desempenho ao aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão. Há várias maneiras para remover um relógio.  
  
-   Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado. Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.  
  
-   Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>. Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos. Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`. Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será chamado se a duração efetiva do relógio for indefinida.  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.  
  
 Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um storyboard controlável.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 O exemplo a seguir usa o <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> para animar quando o usuário left-clicks e o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> quando o usuário clica.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto ao qual especificado <c>frameworkTemplate</c> foi aplicada. Animações sem um <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> são aplicadas a <c>containingObject</c>.</param>
        <param name="frameworkTemplate">O modelo para animar.</param>
        <param name="handoffBehavior">O comportamento a nova animação deve usar para interagir com qualquer animações atuais.</param>
        <param name="isControllable">
          <see langword="true" />Se o storyboard interativamente controlável; Caso contrário, <see langword="false" />.</param>
        <summary>Aplica as animações associadas a esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> para seus destinos dentro do modelo especificado e iniciá-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve especificar o mesmo `containingObject` ao chamar os métodos interativos que é usada para iniciar o storyboard  
  
 Quando este método é chamado, <xref:System.Windows.Media.Animation.Clock> objetos são criados para o storyboard e cronogramas que ele contém. Esses relógios são armazenados com `containingObject`.  
  
 Os gatilhos de storyboard a partir de <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="using-the-compose-handoffbehavior"></a>Usando o HandoffBehavior de composição  
 Quando você aplica um <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, ou <xref:System.Windows.Media.Animation.AnimationClock> para uma propriedade usando o <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, qualquer <xref:System.Windows.Media.Animation.Clock> objetos anteriormente associados com aquela propriedade continuam a consumir recursos do sistema; o sistema de tempo não removerá esses relógios automaticamente.  
  
 Para evitar problemas de desempenho ao aplicar um grande número de relógios usando <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, você deve remover relógios de composição da propriedade animada após a conclusão. Há várias maneiras para remover um relógio.  
  
-   Para remover todos os relógios de uma propriedade, use o <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> ou <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> método do objeto animado. Especifique a propriedade sendo animada como o primeiro parâmetro, e `null` como o segundo. Isso remove todos os relógios de animação da propriedade.  
  
-   Para remover um determinado <xref:System.Windows.Media.Animation.AnimationClock> de uma lista de relógios, use o <xref:System.Windows.Media.Animation.Clock.Controller%2A> propriedade do <xref:System.Windows.Media.Animation.AnimationClock> para recuperar um <xref:System.Windows.Media.Animation.ClockController>, chame o <xref:System.Windows.Media.Animation.ClockController.Remove%2A> método do <xref:System.Windows.Media.Animation.ClockController>. Isso geralmente é feito o <xref:System.Windows.Media.Animation.Clock.Completed> um relógio de manipulador de eventos. Observe que somente relógios de raiz podem ser controlados por um <xref:System.Windows.Media.Animation.ClockController>; o <xref:System.Windows.Media.Animation.Clock.Controller%2A> retorna a propriedade de um relógio filho `null`. Observe também que o <xref:System.Windows.Media.Animation.Clock.Completed> evento não será chamado se a duração efetiva do relógio for indefinida.  Nesse caso, o usuário deve determinar quando chamar <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Isso é basicamente um problema para animações em objetos que têm um longo tempo de vida.  Quando um objeto é coletado como lixo, seus relógios também serão desconectados e coletados como lixo.  
  
 Para obter mais informações sobre objetos clock, consulte [visão geral do sistema de controle de tempo e animação](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável desse <see cref="T:System.Windows.Media.Animation.Storyboard" />, fazendo cópias em profundidade dos valores do objeto. Ao copiar as propriedades de dependência, esse método copia associações de dados e referências de recurso (mas eles não podem mais resolver), mas não animações ou seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. O objeto clonado <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade <see langword="false" /> mesmo se a fonte <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade<see langword="true." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para produzir cópias modificáveis de congelada <xref:System.Windows.Freezable> objetos (ou qualquer <xref:System.Windows.Freezable> objeto). Para sua conveniência, este método sombreia a versão herdada com uma implementação fortemente tipada.  
  
 Para obter mais informações, consulte <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma nova instância da classe <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>Um novo <see cref="T:System.Windows.Media.Animation.Storyboard" /> instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado internamente pelo <xref:System.Windows.Freezable.CreateInstance%2A> durante a criação de novas instâncias de <xref:System.Windows.Media.Animation.Storyboard> classe para os vários métodos de clonagem (como <xref:System.Windows.Freezable.Clone%2A> e <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 O exemplo a seguir mostra uma implementação típica de <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cada <see cref="T:System.Windows.Media.Animation.Storyboard" /> subclasse deve implementar esse método. Implementação típica é simplesmente chamar o construtor padrão da classe e retornar o resultado.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um relógio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidade é a taxa em que seu tempo está atualmente em andamento, comparada ao tempo do mundo real.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A velocidade global atual, ou 0 se o relógio for interrompido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A velocidade global atual, ou <see langword="null" /> se o relógio for interrompido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um relógio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidade é a taxa em que seu tempo está atualmente em andamento, comparada ao tempo do mundo real.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A velocidade global atual, ou <see langword="null" /> se o relógio for interrompido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um relógio <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> velocidade é a taxa em que seu tempo está atualmente em andamento, comparada ao tempo do mundo real.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A iteração atual do relógio neste dentro de seu período ativo atual, ou <see langword="null" /> se este relógio for interrompido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primeira iteração do relógio tem um valor de 1.  
  
 Se este storyboard tem um <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, uma iteração completa consiste em um par de reversão de encaminhamento, não apenas um desses segmentos.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A iteração atual do relógio neste dentro de seu período ativo atual, ou <see langword="null" /> se este relógio for interrompido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primeira iteração do relógio tem um valor de 1.  
  
 Se este storyboard tem um <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> de `true`, uma iteração completa consiste em um par de reversão de encaminhamento, não apenas um desses segmentos.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>A iteração atual do relógio neste dentro de seu período ativo atual, ou <see langword="null" /> se este relógio for interrompido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Primeira iteração do relógio tem um valor de 1.  
  
 Se a linha de tempo do relógio, este tem um <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> configuração de `true`, uma iteração completa consiste em um par de reversão de encaminhamento, não apenas um desses segmentos.  
  
 Independentemente de sua iteração atual, procurando um relógio retorna sua iteração atual como 1. Também reiniciar um relógio retorna sua iteração atual como 1.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se for esse clock <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, ou 0.0 se este relógio está ativo e sua <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tem um <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; caso contrário, um valor entre 0,0 e 1,0 que indica o progresso atual desse clock dentro de sua iteração atual. Um valor igual a 0,0 não indica que nenhum progresso, e um valor de 1,0 indica que o relógio está no final da sua iteração atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se for esse clock <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, ou 0.0 se este relógio está ativo e sua <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tem um <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; caso contrário, um valor entre 0,0 e 1,0 que indica o progresso atual desse clock dentro de sua iteração atual. Um valor igual a 0,0 não indica que nenhum progresso, e um valor de 1,0 indica que o relógio está no final da sua iteração atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se for esse clock <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />, ou 0.0 se este relógio está ativo e sua <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> tem um <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> de <see cref="P:System.Windows.Duration.Forever" />; caso contrário, um valor entre 0,0 e 1,0 que indica o progresso atual desse clock dentro de sua iteração atual. Um valor igual a 0,0 não indica que nenhum progresso, e um valor de 1,0 indica que o relógio está no final da sua iteração atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>O estado atual do relógio criado para esse storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não informa se um storyboard está em pausa. Para determinar se um storyboard é pausado, use o <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>O estado atual do relógio criado para esse storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não informa se um storyboard está em pausa. Para determinar se um storyboard é pausado, use o <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>O estado atual do relógio criado para esse storyboard: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> ou <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não informa se um storyboard está em pausa. Para determinar se um storyboard é pausado, use o <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> método.  
  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se o relógio deste storyboard <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; caso contrário, a hora atual do relógio do storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se o relógio deste storyboard <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; caso contrário, a hora atual do relógio do storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <returns>
          <see langword="null" />Se o relógio deste storyboard <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />; caso contrário, a hora atual do relógio do storyboard.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um valor que indica se o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está em pausa.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Windows.Media.Animation.Clock" /> criada para esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> pausado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera um valor que indica se o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está em pausa.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Windows.Media.Animation.Clock" /> criada para esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> pausado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Recupera um valor que indica se o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" /> está em pausa.</summary>
        <returns>
          <see langword="true" />Se o <see cref="T:System.Windows.Media.Animation.Clock" /> criada para esta <see cref="T:System.Windows.Media.Animation.Storyboard" /> pausado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método para recuperar informações sobre o relógio do storyboard, o storyboard deve ser controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">A linha do tempo da qual recuperar o <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> valor especificada <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>O objeto de dependência direcionados por <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriedade com linhas de tempo de animação para indicar o objeto que eles se destinam a anexada. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">A linha do tempo da qual recuperar o <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> valor especificada <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>O nome do objeto de dependência direcionado por <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método obtém o <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> anexado a propriedade no objeto especificado. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">O objeto de dependência da qual obter o <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />.</param>
        <summary>Recupera o <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> valor especificada <see cref="T:System.Windows.Media.Animation.Timeline" />.</summary>
        <returns>A propriedade de destino <paramref name="element" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método obtém o <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> anexado a propriedade no objeto especificado. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> propriedade anexada. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Observe que, se o <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> foi definida na marcação, esse método retornará um elemento <xref:System.Windows.PropertyPath> porque a referência da propriedade é resolvida e armazenada internamente quando ela é analisada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pausa o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz uma pausa o storyboard, mas não tem nenhum efeito perceptível se ele não está ativa ou em pausa no momento. Como um efeito colateral, todos os filhos associados também foram pausados.  
  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de um Storyboard pausado  
 Quando você <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> um storyboard que estava em pausa, ele aparece para retomar e reinicie. No entanto, que é não o que realmente acontece. O <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método na verdade substitui o pausada <xref:System.Windows.Media.Animation.Storyboard> com uma nova versão de sair da pausa. Cada vez que o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado, o relógio objetos são criados para o storyboard. Esses relógios são distribuídos para as propriedades que eles animam. Portanto, quando o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado novamente, ele não reiniciar seus relógios; substitui-los com os relógios dos novos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Pausa o <see cref="T:System.Windows.Media.Animation.Clock" /> especificada <see cref="T:System.Windows.FrameworkContentElement" /> associado a esta <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz uma pausa o storyboard, mas não tem nenhum efeito perceptível se ele não está ativa ou em pausa no momento. Como um efeito colateral, todos os filhos associados também foram pausados.  
  
 Busca um storyboard pausado não retomá-lo. A única maneira de retomar um storyboard pausado é usar o <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Chamar o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método substitui novamente o storyboard pausado por um novo, que tem a aparência de continuando.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausando gatilhos de relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de um Storyboard pausado  
 Quando você <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> um storyboard que estava em pausa, ele aparece para retomar e reinicie. No entanto, que é não o que realmente acontece. O <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método substitui em si, na verdade, com uma versão de sair da pausa. Cada vez que o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado, o relógio objetos são criados para o storyboard. Esses relógios são distribuídos para as propriedades que eles animam. Portanto, quando o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado novamente, ele não reiniciar seus relógios; substitui-los com os relógios dos novos.  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Pausa o <see cref="T:System.Windows.Media.Animation.Clock" /> especificada <see cref="T:System.Windows.FrameworkElement" /> associado a esta <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz uma pausa o storyboard, mas não tem nenhum efeito perceptível se ele não está ativa ou em pausa no momento. Como um efeito colateral, todos os filhos associados também foram pausados.  
  
 Busca um storyboard pausado não retomá-lo. A única maneira de retomar um storyboard pausado é usar o <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Chamar o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método substitui novamente o storyboard pausado por um novo, que tem a aparência de continuando.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Pausando gatilhos de relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
## <a name="beginning-a-paused-storyboard"></a>A partir de um Storyboard pausado  
 Quando você <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> um storyboard que estava em pausa, ele aparece para retomar e reinicie. No entanto, que é não o que realmente acontece. O <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método substitui em si, na verdade, com uma versão de sair da pausa. Cada vez que o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado, o relógio objetos são criados para o storyboard. Esses relógios são distribuídos para as propriedades que eles animam. Portanto, quando o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método é chamado novamente, ele não reiniciar seus relógios; substitui-los com os relógios dos novos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. As animações que pertencem a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> não afetam mais as propriedades que ele já animou, independentemente de sua configuração <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Todas as ações interativas executadas em um <xref:System.Windows.Media.Animation.Clock>e, portanto, também em um <xref:System.Windows.Media.Animation.Storyboard>, ocorrem no próximo tick do mecanismo de tempo, o que acontece logo antes da próxima renderização. Isso significa que o <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> método ainda afeta as propriedades de animação até o momento. Em outras palavras, na próxima vez em que o quadro é exibido, o storyboard é removido. Se você precisa desassociar uma animação de uma propriedade antes dessa hora, use o <xref:System.Windows.UIElement.BeginAnimation%2A> método com um `animation` valor de parâmetro de `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Remove os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. As animações que pertencem a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> não afetam mais as propriedades que ele já animou, independentemente de sua configuração <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Removendo gatilhos de relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Remove os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para este <see cref="T:System.Windows.Media.Animation.Storyboard" />. As animações que pertencem a este <see cref="T:System.Windows.Media.Animation.Storyboard" /> não afetam mais as propriedades que ele já animou, independentemente de sua configuração <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Removendo gatilhos de relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retoma o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Retoma o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retomar um storyboard que não está em pausa não tem nenhum efeito.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca um storyboard pausado não retomá-lo. A única maneira de retomar um storyboard pausado é usar o <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Chamar o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método depois que tiver iniciado o storyboard substitui o storyboard antigo, que tem a aparência de continuando.  
  
 Retomando pausada dispara o relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Retoma o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retomar um storyboard que não está em pausa não tem nenhum efeito.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca um storyboard pausado não retomá-lo. A única maneira de retomar um storyboard pausado é usar o <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> método. Chamar o <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método depois que tiver iniciado o storyboard substitui o storyboard antigo, que tem a aparência de continuando.  
  
 Retomando pausada dispara o relógio do storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover para frente ou para trás.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> na posição especificada. O <see cref="T:System.Windows.Media.Animation.Storyboard" /> executa a solicitação de busca quando ocorre a escala de relógio Avançar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> na posição especificada. O <see cref="T:System.Windows.Media.Animation.Storyboard" /> executa a solicitação de busca quando ocorre a escala de relógio Avançar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> na posição especificada. O <see cref="T:System.Windows.Media.Animation.Storyboard" /> executa a solicitação de busca quando ocorre a escala de relógio Avançar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Esse método altera o relógio de storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> para <xref:System.Windows.Media.Animation.ClockState.Active>. Este método não tem nenhum efeito na árvore de tempo até a próxima vez que um tique é processado. Como um efeito colateral, os eventos adequados também não são gerados até lá.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca um gatilhos de storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 O exemplo a seguir mostra o <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> na posição especificada. O <see cref="T:System.Windows.Media.Animation.Storyboard" /> executa a solicitação de busca quando ocorre a escala de relógio Avançar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Esse método altera o relógio de storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> para <xref:System.Windows.Media.Animation.ClockState.Active>. Este método não tem nenhum efeito na árvore de tempo até a próxima vez que um tique é processado. Como um efeito colateral, os eventos adequados também não são gerados até lá.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida se ele for feito controlável. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Busca um gatilhos de storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como buscar um segundo após o início de um Storyboard (ignorar).  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 O exemplo a seguir mostra o <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover para frente ou para trás.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> para uma nova posição imediatamente (de forma síncrona).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Alinha a hora buscado do <xref:System.Windows.Media.Animation.Storyboard> com a última escala de relógio. Valores são imediatamente atualizados para refletir as alterações devido à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mesmo que a tela não reflete as alterações até que as atualizações de tela.  
  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> para uma nova posição imediatamente (de forma síncrona).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Alinha a hora buscado do <xref:System.Windows.Media.Animation.Storyboard> com a última escala de relógio. Valores são imediatamente atualizados para refletir as alterações devido à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mesmo que a tela não reflete as alterações até que as atualizações de tela.  
  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> para uma nova posição imediatamente (de forma síncrona).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Alinha a hora buscado do <xref:System.Windows.Media.Animation.Storyboard> com a última escala de relógio. Valores são imediatamente atualizados para refletir as alterações devido à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mesmo que a tela não reflete as alterações até que as atualizações de tela.  
  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Esse método altera o relógio de storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> para  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Busca um gatilhos de storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra o <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="offset">Um valor positivo ou negativo que descreve a quantidade pela qual a linha de tempo deve mover Avançar ou retroceder especificado <c>origem</c>.</param>
        <param name="origin">A posição na qual <c>deslocamento</c> é aplicada.</param>
        <summary>Buscas isso <see cref="T:System.Windows.Media.Animation.Storyboard" /> para uma nova posição imediatamente (de forma síncrona).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>Alinha a hora buscado do <xref:System.Windows.Media.Animation.Storyboard> com a última escala de relógio. Valores são imediatamente atualizados para refletir as alterações devido à <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, mesmo que a tela não reflete as alterações até que as atualizações de tela.  
  
 Observe que as operações de busca não executam o storyboard <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> ou <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> configurações em conta. O storyboard é tratado como se tivesse um <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> de 1 e não <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Esse método altera o relógio de storyboard <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> para  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Busca um gatilhos de storyboard a <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra o <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> e <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> métodos.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Um valor finito maior que zero é o novo índice de velocidade interativa do storyboard. Esse valor é multiplicado contra o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> valor para determinar a velocidade do storyboard efetivo. Esse valor não substituirá o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> propriedade. Por exemplo, chamar este método e especificando uma razão de velocidade interativa de 3 em um storyboard com um <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 fornece o storyboard uma velocidade efetiva de 1,5.</param>
        <summary>Define a taxa de velocidade interativa para o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="speedRatio">Um valor finito maior que zero é o novo índice de velocidade interativa do storyboard. Esse valor é multiplicado contra o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> valor para determinar a velocidade do storyboard efetivo. Esse valor não substituirá o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> propriedade. Por exemplo, chamar este método e especificando uma razão de velocidade interativa de 3 em um storyboard com um <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 fornece o storyboard uma velocidade efetiva de 1,5.</param>
        <summary>Define a taxa de velocidade interativa do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Chamar esse método dispara o <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <param name="speedRatio">Um valor finito maior que zero é o novo índice de velocidade interativa do storyboard. Esse valor é multiplicado contra o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> valor para determinar a velocidade do storyboard efetivo. Esse valor não substituirá o storyboard <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> propriedade. Por exemplo, chamar este método e especificando uma razão de velocidade interativa de 3 em um storyboard com um <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> de 0,5 fornece o storyboard uma velocidade efetiva de 1,5.</param>
        <summary>Define a taxa de velocidade interativa do <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Chamar esse método dispara o <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.Media.Animation.Timeline" /> que devem ser voltados para o objeto de dependência especificada.</param>
        <param name="value">O objeto de dependência para destino.</param>
        <summary>Faz com que o especificado <see cref="T:System.Windows.Media.Animation.Timeline" /> o objeto de dependência de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método define o <xref:System.Windows.Media.Animation.Storyboard.Target%2A> anexado a propriedade no objeto especificado. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  O <xref:System.Windows.Media.Animation.Storyboard.Target%2A> propriedade não é serializável, pois ela pode ser definida para qualquer <xref:System.Windows.DependencyObject>. Não há garantia de que esse objeto pode ser referenciado corretamente do XAML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">O <see cref="T:System.Windows.Media.Animation.Timeline" /> que devem ser voltados para o objeto de dependência especificada.</param>
        <param name="name">O nome do objeto de dependência para destino.</param>
        <summary>Faz com que o especificado <see cref="T:System.Windows.Media.Animation.Timeline" /> direcionados ao objeto de dependência com o nome especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método define o <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> anexado a propriedade no objeto especificado. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">A <see cref="T:System.Windows.Media.Animation.Timeline" /> com a qual associar a propriedade de dependência especificada.</param>
        <param name="path">Um caminho que descreve a propriedade de dependência a ser animada.</param>
        <summary>Faz com que a <see cref="T:System.Windows.Media.Animation.Timeline" /> especificada destine-se à propriedade de dependência especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método define o <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> anexado a propriedade no objeto especificado. Para obter mais informações sobre como funciona o direcionamento de storyboard, consulte <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Para obter mais informações sobre o trabalho de propriedades como anexado, consulte [visão geral de propriedades anexado](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adianta a hora atual deste storyboard <see cref="T:System.Windows.Media.Animation.Clock" /> até o final do seu período ativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Adianta a hora atual deste storyboard <see cref="T:System.Windows.Media.Animation.Clock" /> até o final do seu período ativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método avança o storyboard atual tempo até o final do seu período ativo; comportamento do storyboard neste ponto é especificado pelo seu <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuração. Se <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> é definido como <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, preenche o storyboard; se a propriedade é definida como <xref:System.Windows.Media.Animation.FillBehavior.Stop>, o storyboard parar.  
  
 Chamar este método em um storyboard com uma duração infinita, um número infinito de repetições não tem nenhum efeito. Chamar este método em um storyboard inativo não tem nenhum efeito.  
  
 Aprimorando um relógio a seu preenchimento gatilhos períodos o <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Adianta a hora atual deste storyboard <see cref="T:System.Windows.Media.Animation.Clock" /> até o final do seu período ativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método avança o storyboard atual tempo até o final do seu período ativo; comportamento do storyboard neste ponto é especificado pelo seu <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> configuração. Se <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> é definido como <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, preenche o storyboard; se a propriedade é definida como <xref:System.Windows.Media.Animation.FillBehavior.Stop>, o storyboard parar.  
  
 Chamar este método em um storyboard com uma duração infinita, um número infinito de repetições não tem nenhum efeito. Chamar este método em um storyboard inativo não tem nenhum efeito.  
  
 Aprimorando um relógio a seu preenchimento gatilhos períodos o <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que interromper um storyboard não dispara o <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Interrompe o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard não afeta mais suas propriedades de destino: propriedades que foram animadas reverter para os valores anteriores.  
  
 Parando gatilhos um relógio de <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, mas não o <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 O exemplo a seguir usa um storyboard controlável para animar uma <xref:System.Windows.Media.TextEffect>. O <xref:System.Windows.Media.TextEffect> está dentro de uma <xref:System.Windows.FrameworkContentElement>do nome do escopo.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">O objeto especificado quando o método <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" /> foi chamado. Esse objeto contém os objetos <see cref="T:System.Windows.Media.Animation.Clock" /> que foram criados para esse storyboard e seus filhos.</param>
        <summary>Interrompe o <see cref="T:System.Windows.Media.Animation.Clock" /> que foi criado para este <see cref="T:System.Windows.Media.Animation.Storyboard" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Media.Animation.ClockState.Stopped> storyboard não afeta mais suas propriedades de destino: propriedades que foram animadas reverter para os valores anteriores.  
  
 Parando gatilhos um relógio de <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> e <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> eventos, mas não o <xref:System.Windows.Media.Animation.Timeline.Completed> evento.  
  
 Para controlar este storyboard interativamente, você deve usar o mesmo `containingObject` parâmetro ao chamar os métodos interativos que você usou para iniciar o storyboard. Um storyboard controlável pode pausar, retomar, procurar, parar e ser removida. Para tornar um storyboard controlável no código, você deve usar a sobrecarga apropriada do storyboard <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> método e especifique `true` para torná-lo controlável. Para obter um exemplo, consulte [como: controlar um Storyboard após iniciar](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> anexada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade <see cref="P:System.Windows.Media.Animation.Storyboard.Target" /> anexada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> anexada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
