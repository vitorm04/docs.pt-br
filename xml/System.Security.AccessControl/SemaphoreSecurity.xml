<Type Name="SemaphoreSecurity" FullName="System.Security.AccessControl.SemaphoreSecurity">
  <TypeSignature Language="C#" Value="public sealed class SemaphoreSecurity : System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit SemaphoreSecurity extends System.Security.AccessControl.NativeObjectSecurity" />
  <TypeSignature Language="DocId" Value="T:System.Security.AccessControl.SemaphoreSecurity" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.AccessControl</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.AccessControl.NativeObjectSecurity</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa a segurança de controle de acesso do Windows para um semáforo com nome. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto Especifica direitos de acesso para um semáforo de sistema nomeado e também especifica como as tentativas de acesso são auditadas. Direitos de acesso para o semáforo são expressos como regras, com cada regra de acesso representado por um <xref:System.Security.AccessControl.SemaphoreAccessRule> objeto. Cada regra de auditoria é representada por um <xref:System.Security.AccessControl.SemaphoreAuditRule> objeto.  
  
 Isso reflete o sistema de segurança de Windows subjacente, em que cada objeto protegível tem no máximo um controle lista de acesso discricionário (DACL) que controla o acesso para o objeto protegido e no máximo um sistema controle lista de acesso (SACL) que especifica que as tentativas de acesso são auditadas. A DACL e SACL são ordenados listas de entradas de controle de acesso (ACE) que especificam o acesso e auditoria para usuários e grupos. Um <xref:System.Security.AccessControl.SemaphoreAccessRule> ou <xref:System.Security.AccessControl.SemaphoreAuditRule> objeto pode representar mais de uma ACE.  
  
> [!NOTE]
>  Um <xref:System.Threading.Semaphore> objeto pode representar um semáforo local ou um semáforo de sistema nomeado. Segurança de controle de acesso do Windows é significativa apenas para semáforos sistema nomeado.  
  
 O <xref:System.Security.AccessControl.SemaphoreSecurity>, <xref:System.Security.AccessControl.SemaphoreAccessRule>, e <xref:System.Security.AccessControl.SemaphoreAuditRule> classes ocultar os detalhes de implementação de ACEs e ACLs. Elas permitem que você ignore os diferentes tipos ACE dezessete e a complexidade de manter corretamente herança e propagação de direitos de acesso. Esses objetos também foram projetados para impedir que os seguintes erros comuns de controle de acesso:  
  
-   Criando um descritor de segurança com uma DACL null. Uma referência nula para uma DACL permite que qualquer usuário adicionar regras de acesso a um objeto, potencialmente, criando um ataque de negação de serviço. Um novo <xref:System.Security.AccessControl.SemaphoreSecurity> objeto sempre começa com uma DACL vazia, o que nega todo o acesso para todos os usuários.  
  
-   Violando a ordem canônica de ACEs. Se a lista ACE na DACL não é mantida na ordem canônica, os usuários podem inadvertidamente receberá acesso para o objeto protegido. Por exemplo, os direitos de acesso negado sempre devem aparecer antes de direitos de acesso permitido. <xref:System.Security.AccessControl.SemaphoreSecurity>objetos de mantém a ordem correta internamente.  
  
-   Manipulando os sinalizadores de descritor de segurança, que devem estar sob controle do Gerenciador de recursos somente.  
  
-   Criando combinações inválidas de sinalizadores ACE.  
  
-   Manipulação de ACEs herdadas. Herança e propagação são manipulados pelo Gerenciador de recursos, em resposta a alterações feitas às regras de acesso e auditoria.  
  
-   Inserindo ACEs sentidas ACLs.  
  
 Os recursos somente os objetos de segurança do .NET não oferece suportados são perigosas atividades que devem ser evitadas, a maioria dos desenvolvedores de aplicativos, como o seguinte:  
  
-   Tarefas de nível inferior que são normalmente executadas pelo Gerenciador de recursos.  
  
-   Adicionar ou remover entradas de controle de acesso de maneiras que não precisam manter a ordem canônica.  
  
 Para modificar a segurança de controle de acesso do Windows para um semáforo com nome, use o <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> método para obter o <xref:System.Security.AccessControl.SemaphoreSecurity> objeto. Modificar o objeto de segurança, adicionando e removendo regras e, em seguida, usar o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> método para recolocá-la.  
  
> [!IMPORTANT]
>  Alterações feitas em um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto não afetam os níveis de acesso do sinal do nomeada até que você chamar o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> método para atribuir o objeto de segurança alterado para o semáforo com nome.  
  
 Para copiar a segurança de controle de acesso de um sinal para outro, use o <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> método para obter um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que representa as regras de acesso e auditoria para o sinal do primeiro e depois use o <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType> método ou um construtor que aceite um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto atribuir essas regras para o sinal do segundo.  
  
 Os usuários com um investimento em linguagem de definição de descritor de segurança (SDDL) podem usar o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para definir regras de acesso para um semáforo com nome e o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método para obter uma cadeia de caracteres que representa as regras de acesso no formato SDDL. Isso não é recomendado para novo desenvolvimento.  
  
> [!NOTE]
>  Não há suporte para segurança em objetos de sincronização para o Windows 98 ou Windows Millennium Edition.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a separação entre <xref:System.Security.AccessControl.AccessControlType.Allow> regras e <xref:System.Security.AccessControl.AccessControlType.Deny> regras e exibe a combinação de direitos em regras compatíveis. O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto adiciona regras de permissão e negação vários direitos para o usuário atual e exibe o par resultante de regras. O exemplo permite que novos direitos para o usuário atual e exibe o resultado mostra que novos direitos são mesclados com a existente <xref:System.Security.AccessControl.AccessControlType.Allow> regra.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> com valores padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um novo <xref:System.Security.AccessControl.SemaphoreSecurity> objeto sempre começa com uma lista vazia de acesso discricionário (DACL), que nega todo o acesso para todos os usuários.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Essa classe não tem suporte no Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SemaphoreSecurity (string name, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.#ctor(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="name">O nome do sinal do sistema cujas regras de segurança de controle de acesso devem ser recuperados.</param>
        <param name="includeSections">Uma combinação de <see cref="T:System.Security.AccessControl.AccessControlSections" /> sinalizadores que especificam as seções a serem recuperados.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> classe com as seções especificadas, as regras de segurança de controle de acesso de sinal do sistema com o nome especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor permite obter a segurança de controle de acesso para um semáforo de sistema nomeado sem primeiro criar uma <xref:System.Threading.Semaphore> objeto.  
  
 Deve ser tomado cuidado ao trabalhar com objetos de sistema nomeado. Se houver um objeto de sistema chamado `name` que não é um sinal, a segurança de acesso de controle pode ser recuperada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Essa classe não tem suporte no Windows 98 ou Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRightType">
      <MemberSignature Language="C#" Value="public override Type AccessRightType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRightType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRightType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a enumeração que a classe <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> usa para representar os direitos de acesso.</summary>
        <value>Um objeto <see cref="T:System.Type" /> que representa a enumeração <see cref="T:System.Security.AccessControl.SemaphoreRights" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity> classe substituição de <xref:System.Security.AccessControl.ObjectSecurity.AccessRightType%2A> propriedade e retornar o tipo que eles usam para representar os direitos de acesso. Quando você trabalha com matrizes ou coleções que contêm vários tipos de objetos de segurança, use essa propriedade para determinar o tipo de enumeração correto a ser usado com cada objeto de segurança.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AccessRule AccessRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AccessRule AccessRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AccessControlType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AccessControlType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AccessRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="type" Type="System.Security.AccessControl.AccessControlType" />
      </Parameters>
      <Docs>
        <param name="identityReference">Um <see cref="T:System.Security.Principal.IdentityReference" /> que identifica o usuário ou grupo a regra se aplica a.</param>
        <param name="accessMask">Uma combinação bit a bit de <see cref="T:System.Security.AccessControl.SemaphoreRights" /> valores que especificam os direitos de acesso para permitir ou negar, convertido em um número inteiro.</param>
        <param name="isInherited">Sentido para a chamada semáforos, porque eles têm nenhuma hierarquia.</param>
        <param name="inheritanceFlags">Sentido para a chamada semáforos, porque eles têm nenhuma hierarquia.</param>
        <param name="propagationFlags">Sentido para a chamada semáforos, porque eles têm nenhuma hierarquia.</param>
        <param name="type">Uma da <see cref="T:System.Security.AccessControl.AccessControlType" /> valores que especificam se os direitos são permitidos ou negados.</param>
        <summary>Cria uma nova regra de controle de acesso para o usuário especificado, com direitos de acesso especificado, o controle de acesso e os sinalizadores.</summary>
        <returns>Um <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> objeto que representa os direitos especificados para o usuário especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maneira recomendada para criação de regras de controle de acesso é usar os construtores de <xref:System.Security.AccessControl.SemaphoreAccessRule> classe.  
  
> [!NOTE]
>  Embora os sinalizadores de herança e propagação fazem sentidos para semáforos nomeados, é possível especificá-los, que isso não é recomendado, pois ela desnecessariamente complica a manutenção de regras, por exemplo por interferir com a combinação de regras que seriam compatíveis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, ou <paramref name="type" /> Especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="accessMask" /> é zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> não e do tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> nem de um tipo como <see cref="T:System.Security.Principal.NTAccount" /> que pode ser convertido para o tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AccessRuleType">
      <MemberSignature Language="C#" Value="public override Type AccessRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AccessRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AccessRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo que o <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> classe usa para representar as regras de acesso.</summary>
        <value>Um objeto <see cref="T:System.Type" /> que representa a classe <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity> classe substituição a <xref:System.Security.AccessControl.ObjectSecurity.AccessRuleType%2A> propriedade e retornar o tipo que eles usam para representar as regras de acesso. Quando você trabalha com matrizes ou coleções que contêm vários tipos de objetos de segurança, use essa propriedade para determinar o tipo de regra de acesso corretas para usar com cada objeto de segurança.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAccessRule">
      <MemberSignature Language="C#" Value="public void AddAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">A regra de controle de acesso a ser adicionada.</param>
        <summary>Procura por uma regra de correspondência com a qual a nova regra pode ser mesclada. Se nenhum erro for encontrado, adiciona a nova regra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.AccessControl.SemaphoreSecurity.AddAccessRule%2A> método procura regras com o mesmo usuário ou grupo e o mesmo <xref:System.Security.AccessControl.AccessControlType> como `rule`. Se nenhum for encontrado, `rule` é adicionado. Se uma regra de correspondência for encontrada, os direitos no `rule` são mescladas com a regra existente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a separação entre <xref:System.Security.AccessControl.AccessControlType.Allow> regras e <xref:System.Security.AccessControl.AccessControlType.Deny> regras e exibe a combinação de direitos em regras compatíveis. O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto adiciona regras de permissão e negação vários direitos para o usuário atual e exibe o par resultante de regras. O exemplo permite que novos direitos para o usuário atual e exibe o resultado mostra que novos direitos são mesclados com a existente <xref:System.Security.AccessControl.AccessControlType.Allow> regra.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.AddAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.AddAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAuditRule">
      <MemberSignature Language="C#" Value="public void AddAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">A regra de auditoria para adicionar. O usuário especificado por essa regra determina a pesquisa.</param>
        <summary>Procura por uma regra de auditoria com a qual a nova regra pode ser mesclada. Se nenhum erro for encontrado, adiciona a nova regra.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.AccessControl.SemaphoreSecurity.AddAuditRule%2A> método procura regras com o mesmo usuário ou grupo como `rule`. Se nenhum for encontrado, `rule` é adicionado. Se uma regra de correspondência for encontrada, os sinalizadores no `rule` são mesclados para a regra existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleFactory">
      <MemberSignature Language="C#" Value="public override System.Security.AccessControl.AuditRule AuditRuleFactory (System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.AccessControl.AuditRule AuditRuleFactory(class System.Security.Principal.IdentityReference identityReference, int32 accessMask, bool isInherited, valuetype System.Security.AccessControl.InheritanceFlags inheritanceFlags, valuetype System.Security.AccessControl.PropagationFlags propagationFlags, valuetype System.Security.AccessControl.AuditFlags flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory(System.Security.Principal.IdentityReference,System.Int32,System.Boolean,System.Security.AccessControl.InheritanceFlags,System.Security.AccessControl.PropagationFlags,System.Security.AccessControl.AuditFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.AuditRule</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="identityReference" Type="System.Security.Principal.IdentityReference" />
        <Parameter Name="accessMask" Type="System.Int32" />
        <Parameter Name="isInherited" Type="System.Boolean" />
        <Parameter Name="inheritanceFlags" Type="System.Security.AccessControl.InheritanceFlags" />
        <Parameter Name="propagationFlags" Type="System.Security.AccessControl.PropagationFlags" />
        <Parameter Name="flags" Type="System.Security.AccessControl.AuditFlags" />
      </Parameters>
      <Docs>
        <param name="identityReference">Um <see cref="T:System.Security.Principal.IdentityReference" /> que identifica o usuário ou grupo a regra se aplica a.</param>
        <param name="accessMask">Uma combinação bit a bit de <see cref="T:System.Security.AccessControl.SemaphoreRights" /> valores que especificam os direitos de acesso para auditoria, convertido em um número inteiro.</param>
        <param name="isInherited">Sentido de identificadores de espera nomeada, porque eles têm nenhuma hierarquia.</param>
        <param name="inheritanceFlags">Sentido de identificadores de espera nomeada, porque eles têm nenhuma hierarquia.</param>
        <param name="propagationFlags">Sentido de identificadores de espera nomeada, porque eles têm nenhuma hierarquia.</param>
        <param name="flags">Uma combinação bit a bit de <see cref="T:System.Security.AccessControl.AuditFlags" /> valores que especificam se a auditoria de acesso com êxito, falhas de acesso ou ambos.</param>
        <summary>Cria uma nova regra de auditoria, especificando o usuário que a regra se aplica, os direitos de acesso para auditoria e o resultado que dispara a regra de auditoria.</summary>
        <returns>Um <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> objeto que representa a regra de auditoria para o usuário especificado. O tipo de retorno do método é a classe base, <see cref="T:System.Security.AccessControl.AuditRule" />, mas o valor de retorno pode ser convertido com segurança para a classe derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maneira recomendada para criar regras de auditoria é usar os construtores de <xref:System.Security.AccessControl.SemaphoreAuditRule> classe.  
  
> [!NOTE]
>  Embora os sinalizadores de herança e propagação fazem sentidos para semáforos nomeados, ele ainda é possível especificá-los. Isso não é recomendável, pois ela desnecessariamente complica a manutenção de regras, por exemplo por interferir com a combinação de regras que seriam compatíveis.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, ou <paramref name="flags" /> Especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="identityReference" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="accessMask" /> é zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="identityReference" /> não e do tipo <see cref="T:System.Security.Principal.SecurityIdentifier" /> nem de um tipo como <see cref="T:System.Security.Principal.NTAccount" /> que pode ser convertido para o tipo <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AuditRuleType">
      <MemberSignature Language="C#" Value="public override Type AuditRuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type AuditRuleType" />
      <MemberSignature Language="DocId" Value="P:System.Security.AccessControl.SemaphoreSecurity.AuditRuleType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo que o <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> classe usa para representar as regras de auditoria.</summary>
        <value>Um objeto <see cref="T:System.Type" /> que representa a classe <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes que derivam de <xref:System.Security.AccessControl.ObjectSecurity> classe substituição a <xref:System.Security.AccessControl.ObjectSecurity.AuditRuleType%2A> propriedade e retornar o tipo que eles usam para representar os direitos de auditoria. Quando você trabalha com matrizes ou coleções que contêm vários tipos de objetos de segurança, use essa propriedade para determinar o tipo de regra de auditoria correto a ser usado com cada objeto de segurança.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRule">
      <MemberSignature Language="C#" Value="public bool RemoveAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Um <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> que especifica o usuário e <see cref="T:System.Security.AccessControl.AccessControlType" /> para pesquisa e um conjunto de sinalizadores de herança e propagação que a correspondência de uma regra, se encontrado, deve ser compatível com. Especifica os direitos para remover a regra compatíveis, se encontrado.</param>
        <summary>Procura uma regra de controle de acesso com o mesmo usuário e <see cref="T:System.Security.AccessControl.AccessControlType" /> (permitir ou negar) como a regra especificada e com herança compatível e sinalizadores de propagação; se tal uma regra for encontrada, os direitos contidos na regra de acesso especificado serão removidos dele.</summary>
        <returns>
          <see langword="true" />Se for encontrada uma regra compatível; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atual <xref:System.Security.AccessControl.SemaphoreSecurity> é pesquisada para uma regra que tem o mesmo usuário e o mesmo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Se nenhuma regra for encontrada, nenhuma ação é executada e o método retornará `false`. Se as regras de correspondência for encontradas, seus sinalizadores de herança e compatibilidade são verificados quanto à compatibilidade com os sinalizadores especificados na `rule`. Se nenhuma regra compatível foi encontrada, nenhuma ação é executada e o método retornará `false`. Se uma regra com sinalizadores compatíveis for encontrada, os direitos especificados em `rule` são removidos da regra compatível, e o método retornará `true`. Se `rule` Especifica direitos não contidos na regra compatível, nenhuma ação será tomada em relação a esses direitos. Se todos os direitos são removidos da regra compatível, toda a regra será removida do atual <xref:System.Security.AccessControl.SemaphoreSecurity> objeto.  
  
> [!IMPORTANT]
>  Embora você possa especificar sinalizadores de herança e propagação para regras de acesso de semáforo, criando-as com o <xref:System.Security.AccessControl.SemaphoreSecurity.AccessRuleFactory%2A> método, isso não é recomendado. Herança e propagação não têm significado para semáforos nomeados e façam a manutenção de regras de acesso mais complicado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> método para remover direitos de um <xref:System.Security.AccessControl.AccessControlType.Allow> regra em um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto. Ele também mostra que outros direitos no `rule` são ignorados.  
  
 O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> e o adiciona regras que permitirem e negar vários direitos para o usuário atual. Os direitos de permissão incluem <xref:System.Security.AccessControl.SemaphoreRights.Modify>, <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions>, e <xref:System.Security.AccessControl.SemaphoreRights.Synchronize>. O exemplo cria uma nova regra para o usuário atual, incluindo <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> e <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> direitos e usa a regra com o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule%2A> método para remover <xref:System.Security.AccessControl.SemaphoreRights.ReadPermissions> do <xref:System.Security.AccessControl.AccessControlType.Allow> regra no <xref:System.Security.AccessControl.SemaphoreSecurity> objeto. O estranhas <xref:System.Security.AccessControl.SemaphoreRights.TakeOwnership> diretamente no `rule` será ignorado.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleAll (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleAll(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">Um <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> que especifica o usuário e <see cref="T:System.Security.AccessControl.AccessControlType" /> para pesquisar. Quaisquer direitos especificados por essa regra são ignorados.</param>
        <summary>Pesquisas para todas as regras de controle com o mesmo usuário de acesso e <see cref="T:System.Security.AccessControl.AccessControlType" /> (permitir ou negar) conforme o especificado regra e, se encontrado, remove-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atual <xref:System.Security.AccessControl.SemaphoreSecurity> objeto é pesquisado para regras que têm o mesmo usuário e o mesmo <xref:System.Security.AccessControl.AccessControlType> valor como `rule`. Quaisquer direitos especificados pelo `rule` são ignorados quando executar esta pesquisa. Se nenhuma regra de correspondência for encontrada, nenhuma ação é executada.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra que o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll%2A> método Remove todas as regras de correspondam de usuário e <xref:System.Security.AccessControl.AccessControlType>, ignorando direitos.  
  
 O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto, adiciona regras de permissão e negação vários direitos para o usuário atual e, em seguida, mescla direitos adicionais para o <xref:System.Security.AccessControl.AccessControlType.Allow> regra. O exemplo cria uma nova regra que permite que o usuário atual assumir a propriedade e usa a regra para remover o <xref:System.Security.AccessControl.AccessControlType.Allow> regra do <xref:System.Security.AccessControl.SemaphoreSecurity> objeto.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleAll/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAccessRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAccessRuleSpecific (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAccessRuleSpecific(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">O <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> a ser removido.</param>
        <summary>Procura por uma regra de controle de acesso que corresponda exatamente ao especificado regra e, se encontrado, remove-lo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A regra será removida somente se ele corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Outras regras com o mesmo usuário e <xref:System.Security.AccessControl.AccessControlType> não são afetados.  
  
> [!IMPORTANT]
>  Uma regra representa um ou mais subjacente entradas controle de acesso (ACE) e essas entradas são divididos ou combinados conforme necessário, quando você modificar as regras de segurança de acesso para um usuário. Portanto, uma regra não existe mais no formulário específico que tinha quando foi adicionado e nesse caso o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> método não pode removê-lo.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra que o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> método requer uma correspondência exata para remover uma regra e regras para permitir e negar direitos são independentes umas das outras.  
  
 O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto, adiciona regras de permissão e negação vários direitos para o usuário atual e, em seguida, mescla direitos adicionais para o <xref:System.Security.AccessControl.AccessControlType.Allow> regra de acesso. O exemplo, em seguida, passa o original <xref:System.Security.AccessControl.AccessControlType.Allow> regra para o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> método e exibe os resultados, mostrando que nada é excluído. O exemplo constrói uma regra que corresponda a <xref:System.Security.AccessControl.AccessControlType.Allow> regra no <xref:System.Security.AccessControl.SemaphoreSecurity> objeto e, com êxito, usa o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific%2A> método para remover a regra.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.RemoveAccessRuleSpecific/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRule">
      <MemberSignature Language="C#" Value="public bool RemoveAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Um <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> que especifica o usuário para pesquisar e um conjunto de sinalizadores de herança e propagação de uma correspondência de regra, se encontrado, deve ser compatível com. Especifica os direitos para remover a regra compatíveis, se encontrado.</param>
        <summary>Procura uma regra de controle de auditoria com o mesmo usuário conforme a regra especificada e com herança compatível e sinalizadores de propagação; Se uma regra compatível for encontrada, os direitos contidos na regra especificada são removidos dele.</summary>
        <returns>
          <see langword="true" />Se for encontrada uma regra compatível; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atual <xref:System.Security.AccessControl.SemaphoreSecurity> é pesquisada para uma regra de auditoria que tenha o mesmo usuário conforme `rule`. Se nenhuma regra for encontrada, nenhuma ação é executada e o método retornará `false`. Se as regras de correspondência for encontradas, seus sinalizadores de herança e compatibilidade são verificados quanto à compatibilidade com os sinalizadores especificados na `rule`. Se nenhuma regra compatível foi encontrada, nenhuma ação é executada e o método retornará `false`. Se uma regra com sinalizadores compatíveis for encontrada, os direitos especificados em `rule` são removidos da regra compatível, e o método retornará `true`. Se `rule` Especifica direitos não contidos na regra compatível, nenhuma ação será tomada em relação a esses direitos. Se todos os direitos são removidos da regra compatível, toda a regra será removida do atual <xref:System.Security.AccessControl.SemaphoreSecurity> objeto.  
  
> [!IMPORTANT]
>  Embora você possa especificar sinalizadores de herança e propagação para regras de auditoria de semáforo, criando-as com o <xref:System.Security.AccessControl.SemaphoreSecurity.AuditRuleFactory%2A> método, isso não é recomendado. Herança e propagação não têm significado para semáforos nomeados e façam a manutenção de regras de auditoria mais complicado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleAll">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleAll (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleAll(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleAll(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">Um <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> que especifica o usuário a ser pesquisado. Quaisquer direitos especificados por essa regra são ignorados.</param>
        <summary>Pesquisa para todas as regras com o mesmo usuário conforme a regra especificada de auditoria e, se encontrado, remove-los.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atual <xref:System.Security.AccessControl.SemaphoreSecurity> é pesquisada para regras de auditoria que têm o mesmo usuário conforme `rule`. Quaisquer direitos especificados pelo `rule` são ignorados quando executar esta pesquisa. Todas as regras correspondentes são removidas. Se nenhuma regra de correspondência for encontrada, nenhuma ação é executada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAuditRuleSpecific">
      <MemberSignature Language="C#" Value="public void RemoveAuditRuleSpecific (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAuditRuleSpecific(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">O <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> a ser removido.</param>
        <summary>Procura por uma regra de auditoria que corresponda exatamente ao especificado regra e, se encontrado, remove-lo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A regra será removida somente se ele corresponde exatamente `rule` em todos os detalhes, incluindo sinalizadores. Outras regras de auditoria para o mesmo usuário não são afetadas.  
  
> [!IMPORTANT]
>  Uma regra representa um ou mais subjacente entradas controle de acesso (ACE) e essas entradas são divididos ou combinados conforme necessário, quando você modificar as regras de segurança de auditoria para um usuário. Portanto, uma regra não existe mais no formulário específico que tinha quando foi adicionado e nesse caso o <xref:System.Security.AccessControl.SemaphoreSecurity.RemoveAuditRuleSpecific%2A> método não pode removê-lo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetAccessRule">
      <MemberSignature Language="C#" Value="public void ResetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">O <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> a ser adicionado. O usuário especificado por essa regra determina as regras para remover antes de é adicionada a essa regra.</param>
        <summary>Remove todas as regras de controle de acesso com o mesmo usuário conforme a regra especificada, independentemente de <see cref="T:System.Security.AccessControl.AccessControlType" />e, em seguida, adiciona a regra especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver nenhuma regra de acesso cujo usuário corresponder a regra especificada, `rule` é adicionado.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como o <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> método substitui todas as regras para o usuário correspondente com a regra especificada para a correspondência.  
  
 O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> e o adiciona regras que permitirem e negar vários direitos para o usuário atual. O exemplo cria uma nova regra que permite o controle total do usuário atual e usa o <xref:System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule%2A> método para substituir as regras existentes com a nova regra.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.ResetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.ResetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessRule">
      <MemberSignature Language="C#" Value="public void SetAccessRule (System.Security.AccessControl.SemaphoreAccessRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessRule(class System.Security.AccessControl.SemaphoreAccessRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule(System.Security.AccessControl.SemaphoreAccessRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAccessRule" />
      </Parameters>
      <Docs>
        <param name="rule">O <see cref="T:System.Security.AccessControl.SemaphoreAccessRule" /> a ser adicionado. O usuário e <see cref="T:System.Security.AccessControl.AccessControlType" /> desta regra determinam as regras para remover antes de é adicionada a essa regra.</param>
        <summary>Remove todas as regras de controle de acesso com o mesmo usuário e <see cref="T:System.Security.AccessControl.AccessControlType" /> (permitir ou negar) como a regra especificada e, em seguida, adiciona a regra especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType.Allow>, é o efeito desse método para remover todos os <xref:System.Security.AccessControl.AccessControlType.Allow> regras para o usuário especificado, substituindo-os com a regra especificada. Se a regra especificada tem <xref:System.Security.AccessControl.AccessControlType.Deny>, todos os <xref:System.Security.AccessControl.AccessControlType.Deny> regras para o usuário especificado são substituídas com a regra especificada.  
  
 Se não houver nenhuma regra cujo usuário e <xref:System.Security.AccessControl.AccessControlType> correspondem à regra especificada, `rule` é adicionado.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como o <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> método Remove todas as regras que correspondem o usuário e o <xref:System.Security.AccessControl.AccessControlType> de `rule`, substituí-las com `rule`.  
  
 O exemplo cria um <xref:System.Security.AccessControl.SemaphoreSecurity> e o adiciona regras que permitirem e negar vários direitos para o usuário atual. O exemplo cria uma nova regra que permite o controle total do usuário atual e usa o <xref:System.Security.AccessControl.SemaphoreSecurity.SetAccessRule%2A> regra com a nova regra de permissão de método para substituir a existente. A regra que nega o acesso não é afetada.  
  
> [!NOTE]
>  Este exemplo não anexa o objeto de segurança para um <xref:System.Threading.Semaphore> objeto. Exemplos que anexa os objetos de segurança podem ser encontrados em <xref:System.Threading.Semaphore.GetAccessControl%2A?displayProperty=nameWithType> e <xref:System.Threading.Semaphore.SetAccessControl%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/CS/source.cs#1)]
 [!code-vb[System.Security.AccessControl.SemaphoreSecurity.SetAccessRule#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.AccessControl.SemaphoreSecurity.SetAccessRule/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAuditRule">
      <MemberSignature Language="C#" Value="public void SetAuditRule (System.Security.AccessControl.SemaphoreAuditRule rule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAuditRule(class System.Security.AccessControl.SemaphoreAuditRule rule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.AccessControl.SemaphoreSecurity.SetAuditRule(System.Security.AccessControl.SemaphoreAuditRule)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.AccessControl</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rule" Type="System.Security.AccessControl.SemaphoreAuditRule" />
      </Parameters>
      <Docs>
        <param name="rule">O <see cref="T:System.Security.AccessControl.SemaphoreAuditRule" /> a ser adicionado. O usuário especificado por essa regra determina as regras para remover antes de é adicionada a essa regra.</param>
        <summary>Remove todas as regras com o mesmo usuário conforme a regra especificada, de auditoria independentemente do <see cref="T:System.Security.AccessControl.AuditFlags" /> valor e, em seguida, adiciona a regra especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se não houver nenhuma regra de auditoria cujo usuário corresponder a regra especificada, `rule` é adicionado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rule" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
