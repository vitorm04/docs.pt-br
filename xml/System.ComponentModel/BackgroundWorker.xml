<Type Name="BackgroundWorker" FullName="System.ComponentModel.BackgroundWorker">
  <TypeSignature Language="C#" Value="public class BackgroundWorker : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BackgroundWorker extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.BackgroundWorker" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("DoWork")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Executa uma operação em outro thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker> classe permite que você execute uma operação em um thread separado e dedicado. Operações demoradas como downloads e transações de banco de dados podem fazer com que sua interface de usuário (UI) para se parecer que parou de responder enquanto eles estão em execução. Quando desejar que uma interface do usuário responsivo e você enfrentar atrasos longos associados a essas operações, o <xref:System.ComponentModel.BackgroundWorker> classe fornece uma solução conveniente.  
  
 Para executar uma operação demorada em segundo plano, criar um <xref:System.ComponentModel.BackgroundWorker> e escutar eventos que informam o andamento da operação e sinalizam quando a operação é concluída. Você pode criar o <xref:System.ComponentModel.BackgroundWorker> programaticamente ou você pode arrastá-la para seu formulário do **componentes** guia do **caixa de ferramentas**. Se você criar o <xref:System.ComponentModel.BackgroundWorker> no Designer de formulários do Windows, ele será exibido na bandeja de componentes e suas propriedades aparecerão na janela Propriedades.  
  
 Para configurar para uma operação em segundo plano, adicione um manipulador de eventos para o <xref:System.ComponentModel.BackgroundWorker.DoWork> evento. Chame sua operação demorada neste manipulador de eventos. Para iniciar a operação, chame <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>. Para receber notificações de atualizações de andamento, manipule o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento. Para receber uma notificação quando a operação é concluída, tratar o <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> evento.  
  
> [!NOTE]
>  Você deve ter cuidado para não manipular quaisquer objetos de interface do usuário no seu <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos. Em vez disso, se comunicar com a interface do usuário por meio de <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> e <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> eventos.  
>   
>  <xref:System.ComponentModel.BackgroundWorker>eventos não são empacotados em <xref:System.AppDomain> limites. Não use um <xref:System.ComponentModel.BackgroundWorker> componente para realizar operações multi-threaded em mais de um <xref:System.AppDomain>.  
  
 Se a operação em segundo plano requer um parâmetro, chame <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> com o parâmetro. Dentro de <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos, você pode extrair o parâmetro do <xref:System.ComponentModel.DoWorkEventArgs.Argument%2A?displayProperty=nameWithType> propriedade.  
  
 Para obter mais informações sobre <xref:System.ComponentModel.BackgroundWorker>, consulte [como: executar uma operação em segundo plano](~/docs/framework/winforms/controls/how-to-run-an-operation-in-the-background.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra os conceitos básicos do <xref:System.ComponentModel.BackgroundWorker> classe para executar uma operação demorada de forma assíncrona. A ilustração a seguir mostra um exemplo da saída.  
  
 ![Exemplo simples de BackgroundWorker](~/add/media/backgroundworker-simple.png "exemplo simples de BackgroundWorker")  
  
 Para testar esse código, crie um aplicativo do Windows Forms. Adicionar um <xref:System.Windows.Forms.Label> controle chamado `resultLabel` e adicionar dois <xref:System.Windows.Forms.Button> controles denominados `startAsyncButton` e `cancelAsyncButton`. Criar <xref:System.Windows.Forms.Control.Click> manipuladores de eventos para os dois botões. Do **componentes** guia da caixa de ferramentas, adicione um <xref:System.ComponentModel.BackgroundWorker> componente denominado `backgroundWorker1`. Criar <xref:System.ComponentModel.BackgroundWorker.DoWork>, <xref:System.ComponentModel.BackgroundWorker.ProgressChanged>, e <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipuladores de eventos para o <xref:System.ComponentModel.BackgroundWorker>. No código para o formulário, substitua o código existente com o código a seguir.  
  
 [!code-csharp[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/cs/form1.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorkerSimple#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.componentmodel.backgroundworkersimple/vb/form1.vb#1)]  
  
 O exemplo de código a seguir demonstra o uso da <xref:System.ComponentModel.BackgroundWorker> classe para executar uma operação demorada de forma assíncrona. A ilustração a seguir mostra um exemplo da saída.  
  
 ![Exemplo de BackgroundWorker Fibonacci](~/add/media/backgroundworker-fibonacci.png "BackgroundWorker Fibonacci exemplo")  
  
 A operação calcula o número de Fibonacci selecionado, relatórios de atualizações de andamento, como os resultados de cálculo e permite que um cálculo pendente a ser cancelada.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#1)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#1)]
 [!code-vb[System.ComponentModel.BackgroundWorker#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BackgroundWorker ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ComponentModel.BackgroundWorker" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.CancelAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Solicita o cancelamento de uma operação pendente em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>envia uma solicitação para encerrar a operação pendente do plano de fundo e define o <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade `true`.  
  
 Quando você chama <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A>, o método de trabalho tiver uma oportunidade de interromper sua execução e sair. O código de trabalho deve verificar periodicamente o <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade para ver se ele foi definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que o código a <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e o loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é um problema comum em programação multithread. Para obter mais informações sobre o design de multithreading problemas, consulte [gerenciados Threading práticas recomendadas](~/docs/standard/threading/managed-threading-best-practices.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método para cancelar uma operação assíncrona ("em segundo plano"). Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#4)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#4)]
 [!code-vb[System.ComponentModel.BackgroundWorker#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationPending">
      <MemberSignature Language="C#" Value="public bool CancellationPending { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CancellationPending" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.CancellationPending" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o aplicativo solicitou o cancelamento de uma operação em segundo plano.</summary>
        <value>
          <see langword="true" /> se o aplicativo tiver solicitado o cancelamento de uma operação em segundo plano; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> é `true`, em seguida, o <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método foi chamado o <xref:System.ComponentModel.BackgroundWorker>.  
  
 Essa propriedade é destinada para uso pelo thread de trabalho, deve verificar periodicamente <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> e anule a operação em segundo plano quando ele é definido como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> propriedade para consultar um <xref:System.ComponentModel.BackgroundWorker> sobre seu estado de cancelamento. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DoWork">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.DoWorkEventHandler DoWork;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.DoWorkEventHandler DoWork" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.DoWork" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.DoWorkEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" /> é chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando você chamar o <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método. Isso é onde você pode iniciar a operação que realiza o trabalho potencialmente demorado.  
  
 O código do <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos deve verificar periodicamente o <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> o valor da propriedade e anular a operação se ele for `true`. Quando isso ocorrer, você pode definir o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> sinalizador de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> para `true`e o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos será definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que o código a <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e o loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é um problema comum em programação multithread. Para obter mais informações sobre o design de multithreading problemas, consulte [gerenciados Threading práticas recomendadas](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 Se a operação que produz um resultado, você pode atribuir o resultado para o <xref:System.ComponentModel.DoWorkEventArgs.Result%2A?displayProperty=nameWithType> propriedade. Isso estará disponível para o <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos de <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade.  
  
 Se a operação gerará uma exceção que não lidar com o seu código, o <xref:System.ComponentModel.BackgroundWorker> captura a exceção e o transmite para o <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos, onde ele é exposto como o <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriedade <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType>. Se você estiver executando sob o depurador do Visual Studio, o depurador será interrompido no ponto de <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos em que a exceção não tratada foi gerada. Se você tiver mais de um <xref:System.ComponentModel.BackgroundWorker>, você não deve referenciar qualquer um deles diretamente, pois isso seria acoplar o <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos para uma instância específica do <xref:System.ComponentModel.BackgroundWorker>. Em vez disso, você deve acessar sua <xref:System.ComponentModel.BackgroundWorker> convertendo o `sender` parâmetro em sua <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos.  
  
 Você deve ter cuidado para não manipular quaisquer objetos de interface do usuário no seu <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos. Em vez disso, se comunicar com a interface do usuário por meio de <xref:System.ComponentModel.BackgroundWorker> eventos.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.DoWork> evento para iniciar uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#5)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#5)]
 [!code-vb[System.ComponentModel.BackgroundWorker#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBusy">
      <MemberSignature Language="C#" Value="public bool IsBusy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBusy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.IsBusy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> está executando uma operação assíncrona.</summary>
        <value>
          <see langword="true" />, se o <see cref="T:System.ComponentModel.BackgroundWorker" /> estiver executando uma operação assíncrona; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker> inicia uma operação assíncrona ao chamar <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.ComponentModel.BackgroundWorker.IsBusy%2A> propriedade para aguardar a conclusão de uma <xref:System.ComponentModel.BackgroundWorker> operação. Este exemplo de código é parte de um exemplo maior descrito em [como: baixar um arquivo no plano de fundo](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDoWork">
      <MemberSignature Language="C#" Value="protected virtual void OnDoWork (System.ComponentModel.DoWorkEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoWork(class System.ComponentModel.DoWorkEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnDoWork(System.ComponentModel.DoWorkEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.DoWorkEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnProgressChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnProgressChanged (System.ComponentModel.ProgressChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProgressChanged(class System.ComponentModel.ProgressChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ProgressChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.OnProgressChanged%2A> método para relatar o progresso de uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.AsyncOperationManager> classe.  
  
 [!code-csharp[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/CS/primenumbercalculatormain.cs#24)]
 [!code-vb[System.ComponentModel.AsyncOperationManager#24](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.AsyncOperationManager/VB/primenumbercalculatormain.vb#24)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.BackgroundWorker.OnProgressChanged(System.ComponentModel.ProgressChangedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRunWorkerCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnRunWorkerCompleted (System.ComponentModel.RunWorkerCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRunWorkerCompleted(class System.ComponentModel.RunWorkerCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.RunWorkerCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.ComponentModel.BackgroundWorker.OnRunWorkerCompleted(System.ComponentModel.RunWorkerCompletedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProgressChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ProgressChangedEventHandler ProgressChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ProgressChangedEventHandler ProgressChanged" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ProgressChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando <see cref="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" /> é chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando você chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#7)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#7)]
 [!code-vb[System.ComponentModel.BackgroundWorker#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percentProgress">O percentual, de 0 a 100, da operação em segundo plano concluída.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar a relatar o andamento da operação em segundo plano, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento. O <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> o valor da propriedade deve ser `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lançará um <xref:System.InvalidOperationException>.  
  
 Cabe a você implementar uma maneira significativa de medir o progresso da operação de seu plano de fundo como uma porcentagem do total da tarefa foi concluída.  
  
 A chamada para o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método é assíncrono e retorna imediatamente. O <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> manipulador de eventos é executado no thread que criou o <xref:System.ComponentModel.BackgroundWorker>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#8)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#8)]
 [!code-vb[System.ComponentModel.BackgroundWorker#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> é definida como <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReportProgress">
      <MemberSignature Language="C#" Value="public void ReportProgress (int percentProgress, object userState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReportProgress(int32 percentProgress, object userState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.ReportProgress(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percentProgress" Type="System.Int32" />
        <Parameter Name="userState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="percentProgress">O percentual, de 0 a 100, da operação em segundo plano concluída.</param>
        <param name="userState">O objeto de estado passado para <see cref="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />.</param>
        <summary>Aciona o evento <see cref="E:System.ComponentModel.BackgroundWorker.ProgressChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar a relatar o andamento da operação em segundo plano, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento. O <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> o valor da propriedade deve `true`, ou <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> lançará um <xref:System.InvalidOperationException>.  
  
 Cabe a você implementar uma maneira significativa de medir o progresso da operação de seu plano de fundo como uma porcentagem do total da tarefa foi concluída.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para relatar o progresso de uma operação assíncrona para o usuário. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Windows.Forms.ToolStripProgressBar> classe.  
  
 [!code-csharp[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/CS/form1.cs#10)]
 [!code-vb[System.Windows.Forms.ToolStripProgressBar#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ToolStripProgressBar/VB/form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" /> é definida como <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia a execução de uma operação em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envia uma solicitação para iniciar a operação de execução de forma assíncrona. Quando a solicitação é atendida, o <xref:System.ComponentModel.BackgroundWorker.DoWork> é gerado, que por sua vez inicia a execução de sua operação em segundo plano.  
  
 Se a operação em segundo plano estiver sendo executado, chamando <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> irá gerar novamente uma <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar uma operação assíncrona. Já faz parte de um exemplo maior descrito em [como: baixar um arquivo no plano de fundo](~/docs/framework/winforms/controls/how-to-download-a-file-in-the-background.md).  
  
 [!code-csharp[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/CS/Form1.cs#2)]
 [!code-vb[System.ComponentModel.BackgroundWorker.IsBusy#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker.IsBusy/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> é <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerAsync">
      <MemberSignature Language="C#" Value="public void RunWorkerAsync (object argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunWorkerAsync(object argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.BackgroundWorker.RunWorkerAsync(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argument" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="argument">Um parâmetro para uso pela operação em segundo plano a ser executado no manipulador de eventos <see cref="E:System.ComponentModel.BackgroundWorker.DoWork" />.</param>
        <summary>Inicia a execução de uma operação em segundo plano.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método envia uma solicitação para iniciar a operação de execução de forma assíncrona. Quando a solicitação é atendida, o <xref:System.ComponentModel.BackgroundWorker.DoWork> é gerado, que por sua vez inicia a execução de sua operação em segundo plano.  
  
 Se a operação exige um parâmetro, você pode fornecer como o `argument` parâmetro <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A>.  
  
 Se a operação em segundo plano estiver sendo executado, chamando <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> irá gerar novamente uma <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerAsync%2A> método para iniciar uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#3)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#3)]
 [!code-vb[System.ComponentModel.BackgroundWorker#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.BackgroundWorker.IsBusy" /> é <see langword="true" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunWorkerCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.RunWorkerCompletedEventHandler RunWorkerCompleted" />
      <MemberSignature Language="DocId" Value="E:System.ComponentModel.BackgroundWorker.RunWorkerCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.RunWorkerCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a operação em segundo plano foi concluída, cancelada ou gerou uma exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento é gerado quando o <xref:System.ComponentModel.BackgroundWorker.DoWork> retorna do manipulador de eventos.  
  
 Se a operação for concluída com êxito e o resultado é atribuído a <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos, você pode acessar o resultado por meio de <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade.  
  
 O <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A> propriedade <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica que uma exceção foi lançada pela operação.  
  
 O <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> propriedade <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> indica se uma solicitação de cancelamento foi processada pela operação em segundo plano. Se seu código no <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos detecta uma solicitação de cancelamento, verificando o <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> sinalizador e configuração de <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> sinalizador de <xref:System.ComponentModel.DoWorkEventArgs?displayProperty=nameWithType> para `true`, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> também será definido como `true`.  
  
> [!CAUTION]
>  Lembre-se que o código a <xref:System.ComponentModel.BackgroundWorker.DoWork> manipulador de eventos pode concluir seu trabalho como uma solicitação de cancelamento está sendo feita, e o loop de sondagem pode perder <xref:System.ComponentModel.BackgroundWorker.CancellationPending%2A> sendo definido como `true`. Nesse caso, o <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A> sinalizador de <xref:System.ComponentModel.RunWorkerCompletedEventArgs?displayProperty=nameWithType> no seu <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos não será definido como `true`, mesmo que foi feita uma solicitação de cancelamento. Essa situação é chamada uma *condição de corrida* e é um problema comum em programação multithread. Para obter mais informações sobre o design de multithreading problemas, consulte [gerenciados Threading práticas recomendadas](~/docs/standard/threading/managed-threading-best-practices.md).  
  
 O <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> manipulador de eventos deve sempre verificar o <xref:System.ComponentModel.AsyncCompletedEventArgs.Error%2A?displayProperty=nameWithType> e <xref:System.ComponentModel.AsyncCompletedEventArgs.Cancelled%2A?displayProperty=nameWithType> propriedades antes de acessar o <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade. Se uma exceção foi gerada ou se a operação foi cancelada, acessando o <xref:System.ComponentModel.RunWorkerCompletedEventArgs.Result%2A?displayProperty=nameWithType> propriedade gera uma exceção.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.ComponentModel.BackgroundWorker.RunWorkerCompleted> evento para manipular o resultado de uma operação assíncrona. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.ComponentModel.BackgroundWorker> classe.  
  
 [!code-cpp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CPP/fibonacciform.cpp#6)]
 [!code-csharp[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/CS/fibonacciform.cs#6)]
 [!code-vb[System.ComponentModel.BackgroundWorker#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.ComponentModel.BackgroundWorker/VB/fibonacciform.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkerReportsProgress">
      <MemberSignature Language="C#" Value="public bool WorkerReportsProgress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerReportsProgress" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerReportsProgress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> pode relatar atualizações de progresso.</summary>
        <value>
          <see langword="true" /> se <see cref="T:System.ComponentModel.BackgroundWorker" /> der suporte a atualizações de progresso; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o <xref:System.ComponentModel.BackgroundWorker.WorkerReportsProgress%2A> propriedade `true` se você quiser que o <xref:System.ComponentModel.BackgroundWorker> para oferecer suporte a atualizações de andamento. Quando essa propriedade é `true`, código do usuário pode chamar o <xref:System.ComponentModel.BackgroundWorker.ReportProgress%2A> método para gerar o <xref:System.ComponentModel.BackgroundWorker.ProgressChanged> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkerSupportsCancellation">
      <MemberSignature Language="C#" Value="public bool WorkerSupportsCancellation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WorkerSupportsCancellation" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.EventBasedAsync</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.ComponentModel.BackgroundWorker" /> dá suporte ao cancelamento assíncrono.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.ComponentModel.BackgroundWorker" /> der suporte ao cancelamento; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o <xref:System.ComponentModel.BackgroundWorker.WorkerSupportsCancellation%2A> propriedade `true` se você quiser que o <xref:System.ComponentModel.BackgroundWorker> para oferecer suporte ao cancelamento. Quando essa propriedade é `true`, você pode chamar o <xref:System.ComponentModel.BackgroundWorker.CancelAsync%2A> método para interromper uma operação em segundo plano.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
