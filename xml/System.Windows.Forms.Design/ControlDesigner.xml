<Type Name="ControlDesigner" FullName="System.Windows.Forms.Design.ControlDesigner">
  <TypeSignature Language="C#" Value="public class ControlDesigner : System.ComponentModel.Design.ComponentDesigner" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ControlDesigner extends System.ComponentModel.Design.ComponentDesigner" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Design.ControlDesigner" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Design.ComponentDesigner</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Estende o comportamento do modo de design de um <see cref="T:System.Windows.Forms.Control" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Design.ControlDesigner>Fornece uma classe base para os designers de componentes que derivam de <xref:System.Windows.Forms.Control>. Além dos métodos e funcionalidade herdado da <xref:System.ComponentModel.Design.ComponentDesigner> classe <xref:System.Windows.Forms.Design.ControlDesigner> fornece métodos adicionais para dar suporte a extensão e alterar o comportamento de um associado <xref:System.Windows.Forms.Control> em tempo de design.  
  
 Você pode associar um designer de um tipo usando um <xref:System.ComponentModel.DesignerAttribute>. Para obter uma visão geral de como personalizar o comportamento de tempo de design, consulte [Estendendo suporte em tempo de Design](http://msdn.microsoft.com/library/d6ac8a6a-42fd-4bc8-bf33-b212811297e2).  
  
   
  
## Examples  
 O exemplo a seguir <xref:System.Windows.Forms.Design.ControlDesigner> implementação demonstra manipulação `MouseEnter` e `MouseLeave` eventos, desenho no controle do código de designer e usando a parte do <xref:System.ComponentModel.Design.IDesignerFilter> interface para adicionar uma propriedade para o controle em tempo de design. O código de exemplo a seguir contém um designer e um exemplo de controle de usuário associada com o designer. Para criar este exemplo, compilar o exemplo em uma biblioteca de classe, adicionar uma referência para a biblioteca a um projeto do Windows Forms, adicione o controle à caixa de ferramentas e adicionar uma instância do controle ao formulário. Quando você aponta para o controle, a estrutura interna de perímetro do controle é realçada e a cor usada para desenhar o contorno corresponde do `OutlineColor` propriedade que o designer foi adicionado às propriedades listadas para o controle.  
  
 Adicione uma referência ao assembly System para compilar o exemplo de código.  
  
 [!code-cpp[ControlDesignerExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlDesignerExample/CPP/controldesignerexample.cpp#1)]
 [!code-csharp[ControlDesignerExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlDesignerExample/CS/controldesignerexample.cs#1)]
 [!code-vb[ControlDesignerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlDesignerExample/VB/controldesignerexample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ControlDesigner ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="accessibilityObj">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AccessibleObject accessibilityObj;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Windows.Forms.AccessibleObject accessibilityObj" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Design.ControlDesigner.accessibilityObj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o objeto de acessibilidade para o designer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão é `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Forms.AccessibleObject" /> atribuído ao controle.</summary>
        <value>O <see cref="T:System.Windows.Forms.AccessibleObject" /> atribuído ao controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre objetos acessíveis, consulte a seção de acessibilidade ativa da biblioteca MSDN.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssociatedComponents">
      <MemberSignature Language="C#" Value="public override System.Collections.ICollection AssociatedComponents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ICollection AssociatedComponents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AssociatedComponents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de componentes associado ao componente gerenciado pelo designer.</summary>
        <value>Os componentes que estão associados com o componente gerenciado pelo designer.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade indica todos os componentes para copiar ou mover junto com o componente gerenciado pelo designer durante uma cópia, arraste ou operação de movimentação.  
  
 Se esta coleção contém referências a outros componentes no documento atual do modo de design, esses componentes serão copiados junto com o componente gerenciado pelo designer durante uma operação de cópia.  
  
 Quando o componente gerenciado pelo designer é selecionado, essa coleção é preenchida com os controles aninhados. Essa coleção também pode incluir outros componentes, como os botões da barra de ferramentas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoResizeHandles">
      <MemberSignature Language="C#" Value="public bool AutoResizeHandles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoResizeHandles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.AutoResizeHandles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se redimensionar alocação de identificador depende do valor da <see cref="P:System.Windows.Forms.Control.AutoSize" /> propriedade.</summary>
        <value>
          <see langword="true" />se redimensionar alocação de identificador depende do valor da <see cref="P:System.Windows.Forms.Control.AutoSize" /> e <see langword="AutoSizeMode" /> propriedades; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseWndProc">
      <MemberSignature Language="C#" Value="protected void BaseWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BaseWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.BaseWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">O <see cref="T:System.Windows.Forms.Message" /> a processar.</param>
        <summary>Processa mensagens do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz com que a mensagem a ser processado pelo Windows, ignorando o controle. Isso é útil se você deseja bloquear a mensagem ao obter o controle, mas não desejar bloqueá-lo de chegar ao próprio Windows porque ele pode fazer com que outras mensagens a serem gerados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BehaviorService">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.Design.Behavior.BehaviorService BehaviorService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Design.Behavior.BehaviorService BehaviorService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.BehaviorService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.BehaviorService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Forms.Design.Behavior.BehaviorService" /> do ambiente de design.</summary>
        <value>O <see cref="T:System.Windows.Forms.Design.Behavior.BehaviorService" />, ou <see langword="null" /> se o serviço está indisponível.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanBeParentedTo">
      <MemberSignature Language="C#" Value="public virtual bool CanBeParentedTo (System.ComponentModel.Design.IDesigner parentDesigner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanBeParentedTo(class System.ComponentModel.Design.IDesigner parentDesigner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.CanBeParentedTo(System.ComponentModel.Design.IDesigner)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentDesigner" Type="System.ComponentModel.Design.IDesigner" />
      </Parameters>
      <Docs>
        <param name="parentDesigner">O <see cref="T:System.ComponentModel.Design.IDesigner" /> que gerencia o controle para verificar.</param>
        <summary>Indica se o controle de designer especificado pode ter controle do designer para este.</summary>
        <returns>
          <see langword="true" />Se o controle é gerenciado pelo designer especificado pode pai do controle gerenciado por este designer; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é útil para testar se um controle pode ter um tipo específico de pai. Por exemplo, <xref:System.Windows.Forms.TabPage> controles só podem ser pai <xref:System.Windows.Forms.TabControl> controles.  
  
> [!NOTE]
>  Este método não é chamado quando um item é arrastado do **caixa de ferramentas** na superfície de design.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o controle que o designer está criando.</summary>
        <value>O controle que o designer está criando.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">O <see cref="T:System.Windows.Forms.Message" /> a processar.</param>
        <summary>Fornece o padrão de processamento de mensagens do Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz com que a mensagem a ser processada pelo controle, em vez de pelo designer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayError">
      <MemberSignature Language="C#" Value="protected void DisplayError (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DisplayError(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.DisplayError(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">O <see cref="T:System.Exception" /> a ser exibido.</param>
        <summary>Exibe informações sobre a exceção especificada para o usuário.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método <xref:System.Object.Finalize%2A>. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Windows.Forms.Design.ControlDesigner> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" />, tenha cuidado em não para referenciar objetos que foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [substituindo o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EnableDesignMode">
      <MemberSignature Language="C#" Value="protected bool EnableDesignMode (System.Windows.Forms.Control child, string name);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool EnableDesignMode(class System.Windows.Forms.Control child, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.EnableDesignMode(System.Windows.Forms.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Forms.Control" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="child">O controle filho para o qual o modo de design será habilitado.</param>
        <param name="name">O nome do <c>filho</c> como exposto ao usuário final.</param>
        <summary>Habilita a funcionalidade de tempo de design para um controle filho.</summary>
        <returns>
          <see langword="true" /> se o controle filho puder ser habilitado para o tempo de design; <see langword="false" /> se a infraestrutura de hospedagem não dá suporte a ele.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O controle filho especificado por `child` é um filho do controle do designer de controle. O filho não participam diretamente persistência, mas que ele é exposto como uma propriedade do controle principal. Considere a possibilidade de um controle, como o <xref:System.Windows.Forms.SplitContainer>: ele tem dois painéis, `Panel1` e `Panel2`. Esses painéis são expostos por meio de somente leitura <xref:System.Windows.Forms.SplitContainer.Panel1%2A> e <xref:System.Windows.Forms.SplitContainer.Panel2%2A> propriedades de <xref:System.Windows.Forms.SplitContainer> controle. O <xref:System.Windows.Forms.SplitContainer> chamadas de designer do controle <xref:System.Windows.Forms.Design.ControlDesigner.EnableDesignMode%2A> para cada painel, que permite que outros componentes a serem removidos neles. Mas, para que o conteúdo de <xref:System.Windows.Forms.SplitContainer.Panel1%2A> e <xref:System.Windows.Forms.SplitContainer.Panel2%2A> a ser salvo, o <xref:System.Windows.Forms.SplitContainer> controle em si deve expor os painéis como propriedades públicas.  
  
 Nomes de controle devem ser exclusivos dentro de um designer de controle, mas eles não são necessários para ser exclusivo em relação os filhos de outros designers de controle.  
  
 Para dar suporte a esse recurso, a infraestrutura de hospedagem deve expor o <xref:System.ComponentModel.INestedContainer> classe como um serviço por meio do site.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="child" /> ou <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableDragDrop">
      <MemberSignature Language="C#" Value="protected void EnableDragDrop (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnableDragDrop(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.EnableDragDrop(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          <see langword="true" />Para habilitar o suporte de arrastar e soltar do controle; <see langword="false" /> se o controle não deve ter suporte a arrastar e soltar. O padrão é <see langword="false" />.</param>
        <summary>Habilita ou desabilita o suporte a arrastar e soltar do controle que está sendo criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão de `false` Especifica que um controle não pode ter filhos arrastados para ele em tempo de design. Para permitir que um controle pai outros controles em tempo de design, associá-lo a um designer que deriva de <xref:System.Windows.Forms.Design.ParentControlDesigner>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableDragRect">
      <MemberSignature Language="C#" Value="protected virtual bool EnableDragRect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableDragRect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.EnableDragRect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se arraste retângulos podem ser desenhados neste componente designer.</summary>
        <value>
          <see langword="true" />Se arrastar retângulos podem ser desenhados; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetControlGlyph">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Design.Behavior.ControlBodyGlyph GetControlGlyph (System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Design.Behavior.ControlBodyGlyph GetControlGlyph(valuetype System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetControlGlyph(System.Windows.Forms.Design.Behavior.GlyphSelectionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.ControlBodyGlyph</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectionType" Type="System.Windows.Forms.Design.Behavior.GlyphSelectionType" />
      </Parameters>
      <Docs>
        <param name="selectionType">Um <see cref="T:System.Windows.Forms.Design.Behavior.GlyphSelectionType" /> valor que especifica o estado de seleção.</param>
        <summary>Retorna um <see cref="T:System.Windows.Forms.Design.Behavior.ControlBodyGlyph" /> que representa os limites deste controle.</summary>
        <returns>Um <see cref="T:System.Windows.Forms.Design.Behavior.ControlBodyGlyph" /> que representa os limites deste controle.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGlyphs">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.Behavior.GlyphCollection GetGlyphs (System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.Design.Behavior.GlyphCollection GetGlyphs(valuetype System.Windows.Forms.Design.Behavior.GlyphSelectionType selectionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetGlyphs(System.Windows.Forms.Design.Behavior.GlyphSelectionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.Behavior.GlyphCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="selectionType" Type="System.Windows.Forms.Design.Behavior.GlyphSelectionType" />
      </Parameters>
      <Docs>
        <param name="selectionType">Um <see cref="T:System.Windows.Forms.Design.Behavior.GlyphSelectionType" /> valor que especifica o estado de seleção.</param>
        <summary>Obtém uma coleção de <see cref="T:System.Windows.Forms.Design.Behavior.Glyph" /> objetos que representam as bordas de seleção e identificadores de captura para um controle padrão.</summary>
        <returns>Uma coleção de objetos <see cref="T:System.Windows.Forms.Design.Behavior.Glyph" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que, com base em `selectionType`, o <xref:System.Windows.Forms.Design.Behavior.Glyph> objetos retornados representará um desses estados de seleção:  
  
-   Uma borda de seleção totalmente redimensionável com identificadores de captura;  
  
-   Uma borda de seleção bloqueado;  
  
-   Uma única seleção 'oculta' <xref:System.Windows.Forms.Design.Behavior.Glyph>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHitTest">
      <MemberSignature Language="C#" Value="protected virtual bool GetHitTest (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool GetHitTest(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.GetHitTest(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Um <see cref="T:System.Drawing.Point" /> indicando a posição na qual o mouse foi clicado, em coordenadas da tela.</param>
        <summary>Indica se um clique do mouse no ponto especificado deve ser tratado pelo controle.</summary>
        <returns>
          <see langword="true" />Se um clique no ponto especificado deve ser tratado pelo controle; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Design.ControlDesigner.GetHitTest%2A> método determina se um clique no ponto especificado deve ser passado para o controle, enquanto o controle está no modo de design. Você pode substituir e implementar esse método para habilitar o controle receber cliques no ambiente de tempo de design.  
  
> [!NOTE]
>  Você pode passar um ponto em coordenadas da tela para o <xref:System.Windows.Forms.Control.PointToClient%2A> método o <xref:System.Windows.Forms.Control> classe para obter as coordenadas de ponto em relação ao canto superior esquerdo do controle.  
  
 O <xref:System.Windows.Forms.Design.ControlDesigner.GetHitTest%2A> método é chamado em resposta à mensagem WM_NCHITTEST, portanto, ele é chamado em cada movimento do mouse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HookChildControls">
      <MemberSignature Language="C#" Value="protected void HookChildControls (System.Windows.Forms.Control firstChild);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void HookChildControls(class System.Windows.Forms.Control firstChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.HookChildControls(System.Windows.Forms.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstChild" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="firstChild">O primeiro filho <see cref="T:System.Windows.Forms.Control" /> ao processo. Esse método pode se chamar recursivamente para os filhos do controle.</param>
        <summary>Encaminha mensagens dos controles filho do controle especificado para o designer.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceAttribute">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.InheritanceAttribute InheritanceAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.InheritanceAttribute InheritanceAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.InheritanceAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.InheritanceAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.ComponentModel.InheritanceAttribute" /> do designer.</summary>
        <value>
          <see cref="F:System.ComponentModel.InheritanceAttribute.Inherited" />Se o designer é um designer raiz. Caso contrário, o valor do designer de pai <see cref="P:System.ComponentModel.Design.ComponentDesigner.InheritanceAttribute" /> propriedade.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public override void Initialize (System.ComponentModel.IComponent component);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Initialize(class System.ComponentModel.IComponent component) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.Initialize(System.ComponentModel.IComponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="component">O <see cref="T:System.ComponentModel.IComponent" /> para associar o designer. Este componente sempre deve ser uma instância de, ou derivar do <see cref="T:System.Windows.Forms.Control" />.</param>
        <summary>Inicializa o designer com o componente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo host de designer para inicializar o designer.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeExistingComponent">
      <MemberSignature Language="C#" Value="public override void InitializeExistingComponent (System.Collections.IDictionary defaultValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void InitializeExistingComponent(class System.Collections.IDictionary defaultValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InitializeExistingComponent(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="defaultValues">Um dicionário de nome/valor de valores padrão se aplicam a propriedades. Pode ser <see langword="null" /> se nenhum valor padrão especificado.</param>
        <summary>Reinicializa um componente existente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Design.ControlDesigner> classe substitui esse método para lidar com casos de soltar After.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeNewComponent">
      <MemberSignature Language="C#" Value="public override void InitializeNewComponent (System.Collections.IDictionary defaultValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void InitializeNewComponent(class System.Collections.IDictionary defaultValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InitializeNewComponent(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValues" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="defaultValues">Um dicionário de nome/valor de valores padrão se aplicam a propriedades. Pode ser <see langword="null" /> se nenhum valor padrão especificado.</param>
        <summary>Inicializa um componente recém-criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.Design.ControlDesigner> classe substitui esse método. Ele examinará a propriedade padrão para o controle e, se ela é do tipo `string`, ele definirá o valor dessa propriedade para o nome do componente. Ele faz isso apenas se o designer tiver sido configurado com essa opção no serviço de opções. Esse método também conecta-se o controle de seu pai e posiciona-lo. Se você substituir esse método, você sempre deve chamar base.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InternalControlDesigner">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.ControlDesigner InternalControlDesigner (int internalControlIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.Design.ControlDesigner InternalControlDesigner(int32 internalControlIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.InternalControlDesigner(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.ControlDesigner</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="internalControlIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="internalControlIndex">Um índice especificado para selecionar o designer de controle interno. Esse índice é baseado em zero.</param>
        <summary>Retorna o designer de controle interno com o índice especificado no <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <returns>Um <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> no índice especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um controle interno é um controle que não está no <xref:System.ComponentModel.IContainer.Components%2A> coleção do <xref:System.ComponentModel.Design.IDesignerHost.Container%2A>. <xref:System.Windows.Forms.SplitterPanel>é um exemplo de um controle como.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidPoint">
      <MemberSignature Language="C#" Value="protected static readonly System.Drawing.Point InvalidPoint;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly valuetype System.Drawing.Point InvalidPoint" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Design.ControlDesigner.InvalidPoint" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define um local <see cref="T:System.Drawing.Point" /> que representa os valores de inválido <see cref="T:System.Drawing.Point" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Design.ControlDesigner.InvalidPoint>tem um <xref:System.Drawing.Point.X%2A> e <xref:System.Drawing.Point.Y%2A> propriedade definida como o valor mínimo para o tipo de dados inteiro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumberOfInternalControlDesigners">
      <MemberSignature Language="C#" Value="public virtual int NumberOfInternalControlDesigners ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 NumberOfInternalControlDesigners() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.NumberOfInternalControlDesigners" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o número de designers de controle interno no <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <returns>O número de designers de controle interno no <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um controle interno é um controle que não está no <xref:System.ComponentModel.IContainer.Components%2A> coleção do <xref:System.ComponentModel.Design.IDesignerHost.Container%2A>. <xref:System.Windows.Forms.SplitterPanel>é um exemplo de um controle como.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenu">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenu (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenu(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnContextMenu(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada x no qual exibir o menu de contexto.</param>
        <param name="y">A coordenada y no qual exibir o menu de contexto.</param>
        <summary>Mostra o menu de contexto e fornece uma oportunidade para executar processamento adicional quando o menu de contexto está prestes a ser exibido.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnCreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece uma oportunidade para executar processamento adicional imediatamente após o identificador do controle foi criado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnDragComplete (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragComplete(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragComplete(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de">Um <see cref="T:System.Windows.Forms.DragEventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada para limpar uma operação de arrastar e soltar.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de">Um <see cref="T:System.Windows.Forms.DragEventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada quando um objeto de arrastar e soltar é descartado para a exibição de designer do controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de">Um <see cref="T:System.Windows.Forms.DragEventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada quando uma operação de arrastar e soltar insere o modo de exibição de designer do controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada quando uma operação de arrastar e soltar sai do modo de exibição de designer do controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs de);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs de) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="de" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="de">Um <see cref="T:System.Windows.Forms.DragEventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada quando um objeto de arrastar e soltar é arrastado sobre o modo de exibição de designer do controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> que fornece dados para o evento.</param>
        <summary>Recebe uma chamada quando uma operação de arrastar e soltar está em andamento para fornecer dicas visuais com base no local do mouse enquanto uma operação de arrastar estiver em andamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O host de designer chama este método quando ocorre um evento de arrastar OLE.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragBegin (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragBegin(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragBegin(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A posição x do mouse em coordenadas da tela.</param>
        <param name="y">A posição y do mouse em coordenadas da tela.</param>
        <summary>Recebe uma chamada em resposta ao botão esquerdo do mouse está sendo e mantido pressionado enquanto está sobre o componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado no início de uma operação de arrastar e soltar.  
  
> [!NOTE]
>  Você pode passar um ponto em coordenadas da tela para o <xref:System.Windows.Forms.Control.PointToClient%2A> método o <xref:System.Windows.Forms.Control> classe para obter as coordenadas de ponto em relação ao canto superior esquerdo do controle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragEnd (bool cancel);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragEnd(bool cancel) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragEnd(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancel" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="cancel">
          <see langword="true" />Para cancelar a operação de arrastar; <see langword="false" /> para confirmá-la.</param>
        <summary>Recebe uma chamada no final de uma operação de arrastar e soltar para concluir ou cancelar a operação.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDragMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDragMove (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDragMove(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseDragMove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A posição x do mouse em coordenadas da tela.</param>
        <param name="y">A posição y do mouse em coordenadas da tela.</param>
        <summary>Recebe uma chamada para cada movimento do mouse durante uma operação de arrastar e soltar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Você pode passar um ponto em coordenadas da tela para o <xref:System.Windows.Forms.Control.PointToClient%2A> método o <xref:System.Windows.Forms.Control> classe para obter as coordenadas de ponto em relação ao canto superior esquerdo do controle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseEnter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe uma chamada quando o mouse entra pela primeira vez o controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseHover" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe uma chamada depois que o mouse passa sobre o controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnMouseLeave" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe uma chamada quando o mouse entra pela primeira vez o controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPaintAdornments">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintAdornments (System.Windows.Forms.PaintEventArgs pe);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintAdornments(class System.Windows.Forms.PaintEventArgs pe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnPaintAdornments(System.Windows.Forms.PaintEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pe" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pe">Um <see cref="T:System.Windows.Forms.PaintEventArgs" /> pode usar o designer para desenhar o controle.</param>
        <summary>Recebe uma chamada quando o controle que está gerenciando o designer tem pintado sua superfície para que o designer pode pintar qualquer ornamentos adicionais sobre o controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetComponentDefaults">
      <MemberSignature Language="C#" Value="public override void OnSetComponentDefaults ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void OnSetComponentDefaults() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnSetComponentDefaults" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use InitializeNewComponent instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado quando o designer é inicializado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSetCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnSetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.OnSetCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe uma chamada de cada vez que o cursor deve ser definido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método trata o redirecionamento e a manipulação de eventos de cursor do conjunto. Se o serviço de caixa de ferramentas tem uma ferramenta selecionada, este método permitirá que o serviço de caixa de ferramentas definir o cursor. Se a seleção de serviço de interface do usuário tem uma seleção bloqueada, ou se não houver nenhuma propriedade de local no controle, o cursor de seta padrão será definido. Se um usuário está arrastando um componente, o cursor cruz será definido. Caso contrário, um cursor de seta de quatro pontas será definido para indicar que o componente pode ser clicado e movido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentComponent">
      <MemberSignature Language="C#" Value="protected override System.ComponentModel.IComponent ParentComponent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.IComponent ParentComponent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.ParentComponent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.IComponent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o componente pai para o <see cref="T:System.Windows.Forms.Design.ControlDesigner" />.</summary>
        <value>O componente pai para o <see cref="T:System.Windows.Forms.Design.ControlDesigner" />; caso contrário, <see langword="null" /> se não houver nenhum componente pai.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão simplesmente verifica se o componente que está sendo criado é um controle e, se for, <xref:System.Windows.Forms.Design.ControlDesigner.ParentComponent%2A> retorna seu pai.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParticipatesWithSnapLines">
      <MemberSignature Language="C#" Value="public virtual bool ParticipatesWithSnapLines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ParticipatesWithSnapLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.ParticipatesWithSnapLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> permitirá que o alinhamento de snapline durante uma operação de arrastar.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Windows.Forms.Design.ControlDesigner" /> permitirá que o alinhamento de snapline durante uma operação de arrastar quando o controle de arrastar primário está sobre este designer; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>A implementação padrão sempre retorna <see langword="true" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PreFilterProperties">
      <MemberSignature Language="C#" Value="protected override void PreFilterProperties (System.Collections.IDictionary properties);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PreFilterProperties(class System.Collections.IDictionary properties) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.PreFilterProperties(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="properties" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="properties">Um <see cref="T:System.Collections.IDictionary" /> que contém as propriedades para a classe do componente.</param>
        <summary>Ajusta o conjunto de propriedades que o componente expõe por meio de um <see cref="T:System.ComponentModel.TypeDescriptor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso <xref:System.ComponentModel.Design.IDesignerFilter> substituição de método de interface adiciona um conjunto de propriedades para componente deste designer em tempo de design. Este método adiciona as seguintes propriedades navegáveis: `Visible`, `Enabled`, `ContextMenu`, `AllowDrop`, `Location`, `Name`, `Controls`, e `Locked`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionRules">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Design.SelectionRules SelectionRules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Design.SelectionRules SelectionRules" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.SelectionRules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Design.SelectionRules</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as regras de seleção que indicam os recursos de movimentação de um componente.</summary>
        <value>Uma combinação bit a bit dos valores <see cref="T:System.Windows.Forms.Design.SelectionRules" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum designer fornece regras para um componente, o componente não terá quaisquer serviços de interface do usuário.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapLines">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IList SnapLines { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList SnapLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Design.ControlDesigner.SnapLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> objetos que representam os pontos de alinhamento significativo para este controle.</summary>
        <value>Uma lista de <see cref="T:System.Windows.Forms.Design.Behavior.SnapLine" /> objetos que representam os pontos de alinhamento significativo para este controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o oferecidos <xref:System.Windows.Forms.Design.Behavior.SnapLine> objetos para ajudar a posicionar o controle em uma superfície de design.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnhookChildControls">
      <MemberSignature Language="C#" Value="protected void UnhookChildControls (System.Windows.Forms.Control firstChild);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UnhookChildControls(class System.Windows.Forms.Control firstChild) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.UnhookChildControls(System.Windows.Forms.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="firstChild" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="firstChild">O primeiro filho <see cref="T:System.Windows.Forms.Control" /> ao processo. Esse método pode se chamar recursivamente para os filhos do controle.</param>
        <summary>Encaminha mensagens para os filhos do controle especificado para cada controle em vez de um designer de pai.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Design.ControlDesigner.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">O <see cref="T:System.Windows.Forms.Message" /> a processar.</param>
        <summary>Processa mensagens do Windows e, opcionalmente, roteia para o controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado para cada mensagem que geralmente receberia o controle. Isso permite que o designer de pré-processamento mensagens antes de, opcionalmente, roteá-los para o controle.  
  
 Para enviar a mensagem para o controle <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType> método, chame <xref:System.Windows.Forms.Design.ControlDesigner.WndProc%2A> no designer do controle.  
  
> [!NOTE]
>  O designer filtra as mensagens, para que algumas mensagens não serão enviadas para o controle. Por exemplo, mensagens de mouse são interceptadas pelo designer. Se isso não é o comportamento desejado, chame <xref:System.Windows.Forms.Design.ControlDesigner.DefWndProc%2A> em vez disso.  
  
 Passar `m` como um parâmetro. Opcionalmente, você pode alterar ou criar um novo <xref:System.Windows.Forms.Message?displayProperty=nameWithType> para passar para o método do controle.  
  
 A tabela a seguir mostra o fluxo de mensagens.  
  
|Sem um designer|Com um designer|  
|------------------------|---------------------|  
|USER32<br /><br /> <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType><br /><br /> <xref:System.Windows.Forms.Control.DefWndProc%2A?displayProperty=nameWithType><br /><br /> USER32|USER32<br /><br /> `Control.Designer.` <xref:System.Windows.Forms.Design.ControlDesigner.WndProc%2A><br /><br /> <xref:System.Windows.Forms.Design.ControlDesigner.DefWndProc%2A><br /><br /> <xref:System.Windows.Forms.Control.WndProc%2A?displayProperty=nameWithType><br /><br /> <xref:System.Windows.Forms.Control.DefWndProc%2A?displayProperty=nameWithType><br /><br /> USER32|  
  
 O designer intercepta mensagens, substituindo o <xref:System.Windows.Forms.Control.WindowTarget%2A?displayProperty=nameWithType> propriedade no controle. Normalmente, <xref:System.Windows.Forms.Control.WindowTarget%2A> aponta para o <xref:System.Windows.Forms.NativeWindow> contidos dentro do controle. Durante o tempo de design, o designer substituirá isso pelo destino sua própria janela e armazena em cache o valor original.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
