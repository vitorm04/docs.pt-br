<Type Name="ProxyWebPartManager" FullName="System.Web.UI.WebControls.WebParts.ProxyWebPartManager">
  <TypeSignature Language="C#" Value="public class ProxyWebPartManager : System.Web.UI.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProxyWebPartManager extends System.Web.UI.Control" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.ProxyWebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma maneira para os desenvolvedores declare estáticos conexões em um conteúdo de página quando um <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle foi declarado no página mestra associado do conteúdo da página.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle existe para o determinado cenário de declarar conexões estáticas no conteúdo de páginas quando um <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle já foi declarado em uma página mestra.  
  
 Por design, uma página da Web que usa os controles de Web Parts deve conter um (e apenas um) <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle que gerencia todos os controles de Web Parts na página. Quando um aplicativo Web Parts usa páginas mestras, é comum para colocar o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página mestra, porque todas as páginas de conteúdo são mescladas com a página mestra em tempo de execução e o único <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle gerenciará todos os controles de Web Parts de todas as páginas de conteúdo. No entanto, quando os desenvolvedores desejam declarar conexões estáticas nas páginas de um aplicativo desse tipo de conteúdo, eles podem parecer enfrentar uma limitação. Uma conexão de Web Parts estático pode ser declarado apenas adicionando um <`asp:webpartconnection>` elemento como um filho de um `<staticconnections>` elemento, que por si só deve ser um filho de um `<asp:webpartmanager>` elemento. Mas, como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle já foi declarado na página mestra e a um é permitido <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle, os desenvolvedores não é possível declarar adicionais <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controles nas páginas de conteúdo para adicionar conexões estáticas.  
  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle assume o lugar do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle neste cenário. Os desenvolvedores declarar uma `<asp:proxywebpartmanager>` elemento em vez de um `<asp:webpartmanager>` elemento em suas páginas de conteúdo e pode, em seguida, declarar conexões estáticas como filho elementos. No tempo de execução, as conexões no <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle simplesmente são adicionados ao <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> coleção do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar e tratado como qualquer outra conexão.  
  
 Porque o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle é usado apenas nesse cenário de desenvolvimento específico, ele tem mais funcionalidade limitada que o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> classe. Na verdade, embora o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle atua como um proxy para conter conexões estáticas para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle nas páginas de conteúdo, ele não herda do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Ele herda diretamente a partir de <xref:System.Web.UI.Control> classe e substitui apenas alguns dos membros de base. O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming%2A>, <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible%2A>, e <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID%2A> propriedades são substituídas e atribuir valores que impedem que está sendo usado. Outras propriedades herdadas são substituídas para ajustar seu comportamento de tempo de design, mas, caso contrário, eles têm o mesmo comportamento que as propriedades de base. Isso inclui o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Controls%2A> e <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.ClientID%2A> propriedades. Por fim, o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> classe tem uma propriedade não é herdado. O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade retorna sua própria coleção de conexões estáticas (um <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection> objeto).  
  
 Para métodos, a <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> classe da mesma forma substitui apenas alguns métodos, principalmente para impedir seu uso. O herdadas <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus%2A> método fica inutilizável lançando uma exceção se for chamado. O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection%2A> método sempre retorna uma coleção de controle vazio, que tem o efeito de impedindo que ele seja capaz de conter uma coleção de controles. Por fim, o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit%2A> método chama o método base e, em seguida, atribui a coleção de conexões referenciadas pelo <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> propriedade do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle. Isso tem o efeito de acumular todas as conexões estáticas declaradas em todas as páginas de conteúdo e torná-los parte da coleção de conexões mantido pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página mestra.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> classe declarar conexões estáticas em páginas de conteúdo em um aplicativo que usa páginas mestras. O exemplo tem cinco partes:  
  
-   Modo de exibição de um controle de usuário que permite que você altere as Web Parts em uma página.  
  
-   Fonte de código para uma interface e dois <xref:System.Web.UI.WebControls.WebParts.WebPart> controla atuar como o provedor e consumidor para uma conexão.  
  
-   Uma página da Web principal que hospeda o controle de usuário, as páginas de conteúdo, e o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle para o aplicativo.  
  
-   Uma página da Web de conteúdo que hospeda um <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle, dois personalizado <xref:System.Web.UI.WebControls.WebParts.WebPart> controles e uma conexão estática para conectar os dois controles.  
  
-   Uma explicação de como executar o exemplo de página.  
  
 A primeira parte deste exemplo de código é o controle de usuário que permite aos usuários alterar modos de exibição em uma página da Web. Salve o seguinte código-fonte para um arquivo. ascx, dando a ele o nome do arquivo que é atribuído para o `Src` atributo da `Register` diretiva para este controle de usuário, que está na parte superior da página mestra hospedagem. Para obter detalhes sobre como exibem modos e uma descrição do código-fonte nesse controle, consulte [passo a passo: alterando modos de exibição em uma página de Web Parts](http://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0).  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/DisplayModeMenuVB.ascx#6)]  
  
 A segunda parte do exemplo de código é o código-fonte para a interface e controles. O arquivo de origem contém uma interface simples chamada `IZipCode`. Também há um <xref:System.Web.UI.WebControls.WebParts.WebPart> classe denominada `ZipCodeWebPart` que implementa a interface e atua como o provedor de controle. Seu `ProvideIZipCode` método é o método de retorno de chamada que implementa o membro de apenas da interface. O método simplesmente retorna uma instância da interface. Observe que o método está marcado com um `ConnectionProvider` atributo em seus metadados. Esse é o mecanismo para identificar o método como o método de retorno de chamada para o ponto de conexão do provedor. O outro <xref:System.Web.UI.WebControls.WebParts.WebPart> classe é chamada `WeatherWebPart`, e ele atua como o consumidor para a conexão. Essa classe tem um método chamado `GetZipCode` que obtém uma instância do `IZipCode` interface do controle de provedor. Observe que esse método está marcado como método de ponto de conexão do consumidor com uma `ConnectionConsumer` atributo em seus metadados.  
  
 Para o exemplo de código seja executado, você deve compilar este código-fonte. Você pode compilá-lo explicitamente e colocar o assembly resultante na pasta Bin do seu site da Web ou o cache de assembly global. Como alternativa, você pode colocar o código-fonte na pasta App_Code de seu site, onde ele será compilado dinamicamente em tempo de execução. Este exemplo de código usa compilação dinâmica. Para uma explicação passo a passo que demonstre como compilar, consulte [passo a passo: desenvolvendo e usando um controle de servidor Web personalizado](http://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08).  
  
 [!code-csharp[WebParts_ProxyWebPartManager_Overview#4](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/ZipCodeComponent.cs#4)]
 [!code-vb[WebParts_ProxyWebPartManager_Overview#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/ZipCodeComponent.vb#4)]  
  
 A terceira parte do exemplo de código é a página mestra. Você deve fazer o seguinte código-fonte e salvá-lo em um arquivo, nomeando-MasterPageCS.master ou MasterPageVB.master (dependendo de qual idioma você usar). Observe que a página mestra contém um `Register` diretiva para registrar o controle de usuário e referencia o controle de usuário em si no corpo da página. A página mestra também declara o único `<asp:webpartmanager>` elemento usado para esta página e páginas de conteúdo todos relacionadas. Por fim, a página mestra tem um `<asp: contentplaceholder>` elemento que declara o ponto na página de onde a página de conteúdo é inserida.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/MasterPageCS.master#1)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/MasterPageVB.master#1)]  
  
 A quarta parte do exemplo de código é a página de conteúdo. Você deve copiar o seguinte código-fonte e salve-o em um arquivo com extensão. Observe que seu `Page` diretiva contém um `MasterFile` atributo para referir-se a página mestra. Além disso, esta página tem uma `Register` diretiva para registrar o arquivo na pasta App_Code que contém a custom compilado dinamicamente <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que participam de conexão. Dentro de `<asp:content>` marcas da página, há um <`asp:proxywebpartmanager>` elemento, com um filho `<staticconnections>` elemento, que por sua vez, tem um filho `<asp:webpartconnection>` elemento para declarar os detalhes de conexão. Dentro de `<script>` marcas na página, o `Button1_Click` método adiciona algum código que acessa o principal <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página mestra e o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle na página de conteúdo e grava alguns dos seus detalhes na página.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/contentPage1CS.aspx#2)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/contentPage1VB.aspx#2)]  
  
 Depois de carregar a página em um navegador, clique o **WebPartManager informações** botão e observar as informações sobre o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle em uma página mestre e o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle na página de conteúdo. Por exemplo, observe que ambas tenham a mesma contagem em suas respectivas propriedades que controlam conexões estáticas (o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade). Observe também que, embora o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle tem um <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> propriedade que controla o número de <xref:System.Web.UI.WebControls.WebParts.WebPart> controles que gerencia, o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle não tem nenhuma dessas propriedades, como seu único propósito é conter conexões estáticas.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ProxyWebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public override string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID de controle de marcação HTML gerada pelo ASP.NET.</summary>
        <value>A ID do controle de marcação HTML gerada pelo ASP.NET.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ControlCollection" /> que representa os controles filho para um controle de servidor especificado na hierarquia de interface do usuário.</summary>
        <value>A coleção de controles filho para o controle de servidor especificado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substitui a propriedade base para impedir que o <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartManager" /> controle que contém os controles.</summary>
        <returns>Sempre retorna um <see cref="T:System.Web.UI.EmptyControlCollection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.CreateControlCollection%2A> método substitui o método base para impedir que o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle de conteúdo e retornar coleções de controles. Sua única finalidade é habilitar conexões estáticas ser declarada em páginas de conteúdo em um aplicativo que usa páginas mestras.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui a propriedade base para impedir que os temas que está sendo usado.</summary>
        <value>Sempre retorna <see langword="false" />, para impedir que os temas que está sendo usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.EnableTheming%2A> propriedade substitui a propriedade base para impedir que os temas que está sendo usado com o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle. Isso é para evitar que entram em conflito com qualquer temas que está sendo usados com o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle na página mestra (seu <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A?displayProperty=nameWithType> propriedade sempre retorna `true`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Um chamador tenta atribuir um valor para essa propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Substitui o método base para impedir que o método que está sendo chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Focus%2A> método substitui o método base e gera uma exceção se qualquer chamador tentar chamar o método. Isso ocorre porque o herdadas <xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType> método destina-se a controles com uma interface do usuário (IU), mas o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle não tem nenhuma interface do usuário e, portanto, não precisa definir o foco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Um chamador tenta chamar este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o <see cref="E:System.Web.UI.Control.Init" /> evento e inicia o controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.OnInit%2A> método chama o método base e, em seguida, executa tarefas ao inicializar o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle. É uma tarefa importante deste método atribuir a coleção de conexões referenciadas pelo <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade para o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> do controle <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> controle da página mestra associada é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui a propriedade base para impedir que um valor que está sendo atribuído.</summary>
        <value>Sempre retorna uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.SkinID%2A> substituições de propriedade capas a propriedade base para impedir que um valor que está sendo atribuído a ele, que tem o efeito de impedir que sejam usados com o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle. Isso é feito porque o controle nunca expõe uma interface de usuário (UI) em uma página. O mesmo comportamento é implementado pelo <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar para a sua <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Um chamador tenta atribuir um valor para essa propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de conexões estáticas declarada dentro de <see langword="&lt;asp:proxywebpartmanager&gt;" /> elemento em uma página de conteúdo.</summary>
        <value>Um <see cref="T:System.Web.UI.WebControls.WebParts.ProxyWebPartConnectionCollection" /> que contém todos static <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> objetos declarada dentro de um <see langword="&lt;asp:proxywebpartmanager&gt;" /> elemento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade faz referência a coleção de <xref:System.Web.UI.WebControls.WebParts.WebPartConnection> objetos declarado em um `<asp:proxywebpartmanager>` elemento. As conexões contidas nesta coleção são adicionadas para as conexões estáticas do <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controles (referenciado por seu <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A?displayProperty=nameWithType> coleção) e tratada exatamente como qualquer outra conexão associada a <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle.  
  
 O elemento declarativo que corresponde ao <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> é de propriedade de `<staticconnections>` elemento. Em um aplicativo que usa páginas mestras, o `<staticconnections>` elemento é adicionado como um filho do `<asp:proxywebpartmanager>` elemento em uma página de conteúdo e um `<asp:webpartconnection>` elemento por sua vez é adicionado como um filho do `<staticconnections>` elemento. Vários `<asp:webpartconnection>` elementos podem ser adicionados a um `<staticconnections>` elemento e várias páginas de conteúdo podem declarar conexões estáticas como parte de um aplicativo de páginas mestras.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> classe. Este exemplo de código mostra apenas a parte relevante do código da página de conteúdo que declara o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle e a conexão estática. Para as outras páginas necessárias para executar o exemplo de código e uma descrição de como configurá-las, consulte a seção exemplo de <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> visão geral da classe.  
  
 O código a seguir é a página de conteúdo que declara o `<staticconnections>` elemento como um filho de `<asp:proxywebpartmanager>` elemento. Observe também que o `Button1_Click` método verifica a contagem do <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controlar e grava-o para a página.  
  
 [!code-aspx-csharp[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/CS/contentPage1CS.aspx#2)]
 [!code-aspx-vb[WebParts_ProxyWebPartManager_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_ProxyWebPartManager_Overview/VB/contentPage1VB.aspx#2)]  
  
 Depois de carregar a página em um navegador, clique o **WebPartManager informações** botão e observar as informações sobre o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controle em uma página mestre e o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle na página de conteúdo. Por exemplo, observe que ambas tenham a mesma contagem em suas respectivas propriedades que controlam conexões estáticas (o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.StaticConnections%2A> propriedade).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui a propriedade base para impedir que um valor que está sendo atribuído.</summary>
        <value>Sempre retorna <see langword="false" />, para evitar que o controle que está sendo feita visível.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager.Visible%2A> propriedade substitui a propriedade base para impedir que o <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controle nunca sejam estabelecidas visível. O <xref:System.Web.UI.WebControls.WebParts.ProxyWebPartManager> controlar, como o <xref:System.Web.UI.WebControls.WebParts.WebPartManager> controlar, não tem nenhuma interface de usuário (UI) e nunca é exibido para o usuário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Um chamador tenta atribuir um valor para essa propriedade.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
