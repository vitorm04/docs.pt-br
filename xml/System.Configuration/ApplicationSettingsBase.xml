<Type Name="ApplicationSettingsBase" FullName="System.Configuration.ApplicationSettingsBase">
  <TypeSignature Language="C#" Value="public abstract class ApplicationSettingsBase : System.Configuration.SettingsBase, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ApplicationSettingsBase extends System.Configuration.SettingsBase implements class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Configuration.ApplicationSettingsBase" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.SettingsBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Atua como uma classe base para derivar classes de wrapper concretas para implementar o recurso de configurações do aplicativo em aplicativos Windows Forms.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Configuration.ApplicationSettingsBase>Adiciona a seguinte funcionalidade para o <xref:System.Configuration.SettingsBase> classe, que é usado por aplicativos baseados na Web:  
  
-   A capacidade de detectar atributos em uma classe derivada, de wrapper de configurações. <xref:System.Configuration.ApplicationSettingsBase>suporta o modelo declarativo usado para propriedades de classe de invólucro, conforme descrito posteriormente.  
  
-   Nível superior <xref:System.Configuration.ApplicationSettingsBase.Save%2A> e <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> métodos.  
  
-   Eventos de validação adicionais que você pode manipular para garantir a exatidão de configurações individuais.  
  
 Na arquitetura de configurações do aplicativo, para acessar um grupo de propriedades de configurações necessária para derivar uma classe wrapper concreta do <xref:System.Configuration.ApplicationSettingsBase>. A classe de invólucro personaliza <xref:System.Configuration.ApplicationSettingsBase> das seguintes maneiras:  
  
-   Para cada propriedade de configurações para ser acessado, uma propriedade pública com rigidez de tipos correspondente é adicionada à classe wrapper. Essa propriedade tem `get` e `set` acessadores para configurações de aplicativo de leitura/gravação, mas apenas um `get` acessador para configurações de somente leitura.  
  
-   Atributos apropriados devem ser aplicados às propriedades de público da classe wrapper para indicar as características da propriedade de configurações, como escopo a configuração do (aplicativo ou usuário), se a configuração deve dar suporte a roaming, o valor padrão para a configuração, o provedor de configurações a ser usada e assim por diante. Cada propriedade é necessária para especificar seu escopo, usando um <xref:System.Configuration.ApplicationScopedSettingAttribute> ou <xref:System.Configuration.UserScopedSettingAttribute>. Configurações de escopo do aplicativo são somente leitura se o padrão <xref:System.Configuration.LocalFileSettingsProvider> é usado.  
  
 O <xref:System.Configuration.ApplicationSettingsBase> classe usa reflexão para detectar esses atributos em tempo de execução. A maioria dessas informações é passada para a camada de provedor de configurações, que é responsável pelo armazenamento, formato de persistência e assim por diante.  
  
 Quando um aplicativo tem várias classes de wrapper de configurações, cada classe define um *grupo de configurações*. Cada grupo tem as seguintes características:  
  
-   Um grupo pode conter qualquer número ou tipo de configurações de propriedade.  
  
-   Se o nome do grupo não for definido explicitamente, a classe de invólucro com decorando um <xref:System.Configuration.SettingsGroupNameAttribute>, em seguida, um nome é gerado automaticamente.  
  
 Por padrão, todos os aplicativos cliente usam o <xref:System.Configuration.LocalFileSettingsProvider> para fornecer armazenamento. Se um provedor de configurações alternativas for desejado, a classe de invólucro ou propriedade deve ser decorada com um correspondente <xref:System.Configuration.SettingsProviderAttribute>.  
  
 Para obter mais informações sobre como usar as configurações do aplicativo, consulte [configurações de aplicativo para o Windows Forms](~/docs/framework/winforms/advanced/application-settings-for-windows-forms.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso das configurações de aplicativo para manter os seguintes atributos do formulário principal: local, tamanho, cor do plano de fundo e texto da barra de título. Todos esses atributos são persistidos como propriedades de configurações de aplicativo único nos `FormSettings` classe, denominada `FormLocation`, `FormSize`, `FormBackColor` e `FormText`, respectivamente. Tudo exceto para `FormText` e `Size` são vinculados às suas propriedades de formulário associado de dados e tem uma configuração aplicado com o uso do valor padrão <xref:System.Configuration.DefaultSettingValueAttribute>.  
  
 O formulário contém quatro controles filho que têm os nomes e as funções a seguir:  
  
-   Um botão chamado `btnBackColor` usada para exibir o **cor** caixa de diálogo comum.  
  
-   Um botão chamado `btnReload` usado para <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> as configurações do aplicativo.  
  
-   Um botão chamado `btnReset` usado para <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> as configurações do aplicativo.  
  
-   Uma caixa de texto denominada `tbStatus` usada para exibir informações de status sobre o programa.  
  
 Observe que após cada execução do aplicativo, um caractere de período adicional é acrescentado ao texto do título do formulário.  
  
 Este exemplo de código requer um formulário com um <xref:System.Windows.Forms.ColorDialog> classe denominada `colorDialog1`e um <xref:System.Windows.Forms.StatusStrip> controlar com um <xref:System.Windows.Forms.ToolStripStatusLabel> chamado `tbStatus`. Além disso, ele requer três <xref:System.Windows.Forms.Button> objetos nomeados `btnReload`, `btnReset`, e `btnBackColor`.  
  
 [!code-cpp[AppSettingsSample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#1)]
 [!code-csharp[AppSettingsSample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#1)]
 [!code-vb[AppSettingsSample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma instância do <see cref="T:System.Configuration.ApplicationSettingsBase" /> classe ao seu estado padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor padrão foi projetado para trabalhar sob a suposição de que não há nenhum componente associado à classe de invólucro de configurações atual, que deriva de <xref:System.Configuration.ApplicationSettingsBase>.  
  
 Quando uma instância de uma classe wrapper é criada, o código herdado executará automaticamente as seguintes ações:  
  
1.  Refletir sobre a classe.  
  
2.  Para cada propriedade em um wrapper marcados com um `[UserScopedSettingAttribute]` ou `[ApplicationScopedSettingAttribute]`, correspondente <xref:System.Configuration.SettingsProperty> é criado.  
  
3.  Cada <xref:System.Configuration.SettingsProperty> tem algumas seu conjunto de propriedades com base em outros atributos que estão presentes, opcionalmente, nas propriedades do wrapper, como o valor padrão ou o provedor de configurações.  
  
4.  Todos os outros atributos simplesmente são colocados em um recipiente de atributo, o <xref:System.Configuration.SettingsProperty.Attributes%2A> propriedade o <xref:System.Configuration.SettingsProperty> classe.  
  
5.  Todos os <xref:System.Configuration.SettingsProperty> objetos são adicionados a um <xref:System.Configuration.SettingsPropertyCollection> representado pelo <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> propriedade do <xref:System.Configuration.ApplicationSettingsBase> classe. Essa coleção é então passada para o <xref:System.Configuration.SettingsBase.Initialize%2A> método.  
  
 Como implícita pela etapa 3 mencionado anteriormente, <xref:System.Configuration.ApplicationSettingsBase> nativamente funciona com vários atributos de propriedade, especificamente o seguinte: <xref:System.Configuration.SettingsProviderAttribute>, <xref:System.Configuration.DefaultSettingValueAttribute>, e <xref:System.Configuration.SettingsSerializeAsAttribute>. Todos os outros atributos de configurações simplesmente são passados para o provedor subjacente apropriado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
      </Parameters>
      <Docs>
        <param name="owner">O componente que atuará como o proprietário do objeto de configurações do aplicativo.</param>
        <summary>Inicializa uma instância do <see cref="T:System.Configuration.ApplicationSettingsBase" /> classe usando o componente proprietário fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é exatamente equivalente para o <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.ComponentModel.IComponent%2CSystem.String%29> usando a invocação do construtor:  
  
 `ApplicationSettingsBase(owner, String.Empty)`  
  
 Para obter informações sobre como a reflexão é usada durante a instanciação de uma classe wrapper, consulte o padrão <xref:System.Configuration.ApplicationSettingsBase.%23ctor> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="settingsKey">Um <see cref="T:System.String" /> que identifica exclusivamente a instâncias separadas da classe wrapper.</param>
        <summary>Inicializa uma instância do <see cref="T:System.Configuration.ApplicationSettingsBase" /> classe usando a chave de configurações fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa o <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> o valor da propriedade de `settingsKey` parâmetro. Essa propriedade é útil em desambiguação diferentes instâncias da classe wrapper configurações no mesmo domínio do aplicativo.  
  
 Para obter informações sobre como a reflexão é usada durante a instanciação de uma classe wrapper, consulte o padrão <xref:System.Configuration.ApplicationSettingsBase.%23ctor> construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ApplicationSettingsBase (System.ComponentModel.IComponent owner, string settingsKey);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IComponent owner, string settingsKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.#ctor(System.ComponentModel.IComponent,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="owner" Type="System.ComponentModel.IComponent" />
        <Parameter Name="settingsKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="owner">O componente que atuará como o proprietário do objeto de configurações do aplicativo.</param>
        <param name="settingsKey">Um <see cref="T:System.String" /> que identifica exclusivamente a instâncias separadas da classe wrapper.</param>
        <summary>Inicializa uma instância do <see cref="T:System.Configuration.ApplicationSettingsBase" /> usando o componente proprietário fornecido e a chave de configurações de classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ComponentModel.IComponent> o objeto especificado pelo `owner` parâmetro atua como o proprietário da instância atual dessa classe de configurações de aplicativos. Durante a inicialização das configurações de wrapper de classe derivado de <xref:System.Configuration.ApplicationSettingsBase>, site do proprietário é consultado para uma <xref:System.Configuration.ISettingsProviderService>. Se existir, ele é usado em vez do provedor de configurações nativo para todas as propriedades da classe wrapper, conforme especificado pelo <xref:System.Configuration.SettingsProviderAttribute>.  
  
 Este construtor inicializa o <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> o valor da propriedade de `settingsKey` parâmetro. Essa propriedade é útil em desambiguação diferentes instâncias da classe wrapper no mesmo domínio do aplicativo.  
  
 Para obter informações sobre como a reflexão é usada durante a instanciação de uma classe wrapper, consulte o padrão <xref:System.Configuration.ApplicationSettingsBase.%23ctor> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="owner" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o contexto de configurações do aplicativo associado ao grupo de configurações.</summary>
        <value>A <see cref="T:System.Configuration.SettingsContext" /> associada ao grupo de configurações.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada classe de invólucro configurações derivada de <xref:System.Configuration.ApplicationSettingsBase> tem um contexto associado a ele. O contexto é passado para o provedor de configurações para cada propriedade para identificar como a propriedade é usada. Portanto, contexto atua como uma dica para ajudar a determinar a melhor para manter os valores de configurações do aplicativo associado o provedor de configurações.  
  
 Em contraste, o <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> propriedade permite que o provedor de configurações para resolver a ambiguidade várias instâncias da mesma classe wrapper.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPreviousVersion">
      <MemberSignature Language="C#" Value="public object GetPreviousVersion (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetPreviousVersion(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.GetPreviousVersion(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Um <see cref="T:System.String" /> que contém o nome da propriedade de configuração cujo valor será retornado.</param>
        <summary>Retorna o valor da propriedade de configuração nomeada para a versão anterior do mesmo aplicativo.</summary>
        <returns>Um <see cref="T:System.Object" /> que contém o valor do <see cref="T:System.Configuration.SettingsProperty" /> especificado se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A> método é geralmente usado em conjunto com o <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> método ao migrar as configurações do aplicativo durante a instalação de uma nova versão de um aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">A propriedade não existe. A contagem de propriedades é zero ou não foi possível encontrar a propriedade no armazenamento de dados.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string propertyName] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Um <see cref="T:System.String" /> que contém o nome da propriedade a ser acessada.</param>
        <summary>Obtém ou define o valor da propriedade especificada das configurações do aplicativo.</summary>
        <value>Se encontrado, o valor da propriedade das configurações nomeada; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.Item%2A> propriedade, também conhecido como o indexador normalmente é usada nas configurações do wrapper de classe derivado de <xref:System.Configuration.ApplicationSettingsBase>. <xref:System.Configuration.ApplicationSettingsBase.Item%2A>associa a propriedade pública da classe wrapper para a propriedade de configurações correspondente.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Item%2A>gera vários eventos dependendo da operação que está sendo executada:  
  
-   Na primeira vez que uma propriedade é recuperada, o <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded> é gerado.  
  
-   Quando uma propriedade é definida, o <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> é gerado. Se o manipulador não cancelar o evento, o valor da propriedade é definido e o <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> é gerado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.SettingsPropertyNotFoundException">Não existem propriedades associadas ao wrapper atual ou não foi possível encontrar a propriedade especificada.</exception>
        <exception cref="T:System.Configuration.SettingsPropertyIsReadOnlyException">Foi feita uma tentativa de definir esta propriedade como somente leitura.</exception>
        <exception cref="T:System.Configuration.SettingsPropertyWrongTypeException">O valor fornecido é de um tipo incompatível com a propriedade das configurações durante uma operação de conjuntos.</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Não foi possível analisar o arquivo de configuração.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (object sender, System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(object sender, class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte do evento.</param>
        <param name="e">Um <see cref="T:System.ComponentModel.PropertyChangedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.Configuration.ApplicationSettingsBase.OnPropertyChanged%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Configuration.ApplicationSettingsBase.OnPropertyChanged(System.Object,System.ComponentModel.PropertyChangedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingChanging (object sender, System.Configuration.SettingChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingChanging(object sender, class System.Configuration.SettingChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte do evento.</param>
        <param name="e">Um <see cref="T:System.Configuration.SettingChangingEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.Configuration.ApplicationSettingsBase.OnSettingChanging%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingChanging(System.Object,System.Configuration.SettingChangingEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingsLoaded">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsLoaded (object sender, System.Configuration.SettingsLoadedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsLoaded(object sender, class System.Configuration.SettingsLoadedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.Configuration.SettingsLoadedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte do evento.</param>
        <param name="e">Um <see cref="T:System.Configuration.SettingsLoadedEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsLoaded(System.Object,System.Configuration.SettingsLoadedEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSettingsSaving">
      <MemberSignature Language="C#" Value="protected virtual void OnSettingsSaving (object sender, System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSettingsSaving(object sender, class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte do evento.</param>
        <param name="e">Um <see cref="T:System.ComponentModel.CancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.Configuration.ApplicationSettingsBase.OnSettingsSaving%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Configuration.ApplicationSettingsBase.OnSettingsSaving(System.Object,System.ComponentModel.CancelEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyCollection Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyCollection Properties" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de propriedades de configurações no wrapper.</summary>
        <value>Um <see cref="T:System.Configuration.SettingsPropertyCollection" /> que contém todos os objetos <see cref="T:System.Configuration.SettingsProperty" /> usados no wrapper atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `get` acessador do <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> propriedade reflete nos metadados da classe wrapper configurações, que é derivado de <xref:System.Configuration.ApplicationSettingsBase>, para determinar dinamicamente o conjunto de propriedades de configurações do aplicativo disponível.  
  
 O <xref:System.Configuration.ApplicationSettingsBase> classe nativamente reconhece certas características de uma configuração de aplicativo, como seu nome, o tipo de propriedade, o provedor de configurações, o valor padrão, ler apenas o status e a preferência de serialização. Essas características são espelhadas como propriedades de <xref:System.Configuration.SettingsProperty> classe. Todos os outros atributos da propriedade configurações somente são passados para o seu provedor de configurações associadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Não foi possível localizar o provedor de configurações associado ou houve falha na sua instanciação.</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.PropertyChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes do valor de uma propriedade de configurações do aplicativo ser alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> evento é gerado quando uma propriedade de configurações é alterada por meio de `set` acessador do <xref:System.Configuration.ApplicationSettingsBase.Item%2A> método, ou para todas as propriedades que é restaurada quando é feita uma chamada para o <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> ou <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> métodos.  
  
 Não há nenhum correspondente `PropertyChanging` eventos para essa classe; em vez disso, consulte o <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyValues">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsPropertyValueCollection PropertyValues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsPropertyValueCollection PropertyValues" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.PropertyValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsPropertyValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de valores de propriedade.</summary>
        <value>Um <see cref="T:System.Configuration.SettingsPropertyValueCollection" /> de valores de propriedade.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public override System.Configuration.SettingsProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Configuration.SettingsProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de provedores de configurações do aplicativo usado pelo wrapper.</summary>
        <value>Um <see cref="T:System.Configuration.SettingsProviderCollection" /> que contém todos os <see cref="T:System.Configuration.SettingsProvider" /> objetos usados pelas propriedades de configurações do wrapper configurações atuais.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.SettingsProviderAttribute> determina qual provedor de configuração é usado por uma classe de invólucro de configurações ou uma propriedade de configuração individual. Se esse atributo não for especificado, um aplicativo cliente usará o <xref:System.Configuration.LocalFileSettingsProvider>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reload">
      <MemberSignature Language="C#" Value="public void Reload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reload" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Atualiza os valores de propriedade das configurações do aplicativo do armazenamento persistente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> método limpa os valores de propriedade atualmente em cache, fazendo com que um recarregamento desses valores de armazenamento persistente, quando eles são acessados posteriormente. Esse método executa as seguintes ações:  
  
-   Ele limpa as propriedades atualmente em cache, limpando a coleção representada pelo <xref:System.Configuration.SettingsBase.PropertyValues%2A> propriedade.  
  
-   Ele gera o <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> evento para cada membro do <xref:System.Configuration.ApplicationSettingsBase.Properties%2A> coleção.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>contrasta com <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> em que o primeiro carregará o último conjunto de valores de configurações de aplicativo salvo, enquanto o segundo carregará os valores padrão salvos.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> método está sendo invocado no corpo do <xref:System.Windows.Forms.Control.Click> manipulador de eventos para um botão chamado `btnReload`. Como resultado dessa chamada, os valores armazenados no momento para as configurações do aplicativo são recarregados em suas propriedades correspondentes. O exemplo de código completo está listado no <xref:System.Configuration.ApplicationSettingsBase> visão geral da classe.  
  
 [!code-cpp[AppSettingsSample#6](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#6)]
 [!code-csharp[AppSettingsSample#6](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#6)]
 [!code-vb[AppSettingsSample#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Restaura os valores de configurações de aplicativo persistentes para suas propriedades padrão correspondentes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> método substitui as propriedades de configurações no escopo do usuário, restaurando o valor atualmente persistente de cada configuração de aplicativo. Esse método executa as seguintes ações:  
  
-   Ele chama o <xref:System.Configuration.IApplicationSettingsProvider.Reset%2A?displayProperty=nameWithType> método em cada provedor de configurações que dá suporte a esse método opcional.  
  
-   Ele chama o <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> método para forçar uma atualização dos valores de propriedade de configurações.  
  
 <xref:System.Configuration.ApplicationSettingsBase.Reload%2A>contrasta com <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> em que o primeiro carregará o último conjunto de valores de configurações de aplicativo salvo, enquanto o segundo carregará os valores padrão salvos.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> método está sendo invocado no corpo do <xref:System.Windows.Forms.Control.Click> manipulador de eventos para um botão chamado `btnReset`. Como resultado dessa chamada, os valores padrão armazenado para as configurações do aplicativo são recarregados em suas propriedades correspondentes. O exemplo de código completo está listado no <xref:System.Configuration.ApplicationSettingsBase> visão geral da classe.  
  
 [!code-cpp[AppSettingsSample#5](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#5)]
 [!code-csharp[AppSettingsSample#5](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#5)]
 [!code-vb[AppSettingsSample#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Não foi possível analisar o arquivo de configuração.</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public override void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Save" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Armazena os valores atuais das propriedades de configurações do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.Save%2A> método grava o valor atual de cada propriedade de configurações para seu repositório de dados associado. Para cada propriedade, este método chama o <xref:System.Configuration.SettingsProvider.SetPropertyValues%2A> método no provedor de configurações associadas.  
  
 Esse método difere a implementação da classe base em que ele gera o <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> evento antes que os valores sejam gravados.  
  
 Se as únicas configurações definidas são configurações no escopo do aplicativo, <xref:System.Configuration.ApplicationSettingsBase.Save%2A> terá nenhum efeito e não retornar nenhum erro se for chamado com o padrão <xref:System.Configuration.LocalFileSettingsProvider>. <xref:System.Configuration.LocalFileSettingsProvider>salva apenas as configurações no escopo do usuário.  
  
> [!IMPORTANT]
>  Não há nenhum método de carga correspondente porque os valores das configurações de aplicativo são carregados automaticamente durante a inicialização de classe wrapper. Por outro lado, esses valores não são salvas automaticamente quando um aplicativo termina. Portanto, você deve chamar explicitamente o <xref:System.Configuration.ApplicationSettingsBase.Save%2A> método para manter os valores atuais das configurações do aplicativo. Isso é geralmente executado o <xref:System.Windows.Forms.Form.Closing> manipulador de eventos do primário ou contendo <xref:System.Windows.Forms.Form>.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o <xref:System.Configuration.ApplicationSettingsBase.Save%2A> método sendo chamado a partir de <xref:System.Windows.Forms.Form.Closing> manipulador de eventos para o formulário principal. Esse método também acrescenta um período adicional para a propriedade de configurações que está associada com o formulário <xref:System.Windows.Forms.Control.Text%2A> propriedade.  
  
 O exemplo de código completo está listado no <xref:System.Configuration.ApplicationSettingsBase> visão geral da classe.  
  
 [!code-cpp[AppSettingsSample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#3)]
 [!code-csharp[AppSettingsSample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#3)]
 [!code-vb[AppSettingsSample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingChanging">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingChangingEventHandler SettingChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingChangingEventHandler SettingChanging" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes que o valor de uma propriedade de configurações do aplicativo é alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> evento ocorre antes de uma propriedade de valor de configuração de aplicativo é alterada por meio de <xref:System.Configuration.ApplicationSettingsBase.Item%2A> método. Esse evento não é gerado quando o <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> ou <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> métodos são chamados. <xref:System.Configuration.ApplicationSettingsBase.SettingChanging>pode ser cancelado por meio de <xref:System.Configuration.SettingChangingEventArgs> classe de dados de evento.  
  
 Você normalmente usa o <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> eventos para lidar com a validação imediata de uma propriedade de configurações individuais. Para obter mais informações sobre validação, consulte [como: validar as configurações do aplicativo](~/docs/framework/winforms/advanced/how-to-validate-application-settings.md).  
  
 Não há nenhum correspondente `SettingChanged` eventos para essa classe; em vez disso, consulte o <xref:System.Configuration.ApplicationSettingsBase.PropertyChanged> evento.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> manipulador de eventos para o objeto do tipo `FormSettings`, que é uma classe wrapper derivada de <xref:System.Configuration.ApplicationSettingsBase>. O manipulador exibe as informações de evento em uma caixa de texto denominada `tbStatus`. O exemplo de código completo está listado no <xref:System.Configuration.ApplicationSettingsBase> visão geral da classe.  
  
 [!code-cpp[AppSettingsSample#7](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#7)]
 [!code-csharp[AppSettingsSample#7](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#7)]
 [!code-vb[AppSettingsSample#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsKey">
      <MemberSignature Language="C#" Value="public string SettingsKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SettingsKey" />
      <MemberSignature Language="DocId" Value="P:System.Configuration.ApplicationSettingsBase.SettingsKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a chave de configurações para o grupo de configurações do aplicativo.</summary>
        <value>Um <see cref="T:System.String" /> que contém a chave de configurações para o grupo de configurações atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> é fornecida para habilitar o código do cliente e, em particular, o provedor de configurações, para resolver a ambiguidade entre várias instâncias da mesma classe de configurações do aplicativo.  
  
 A menos que a classe de invólucro de configurações é criada usando o padrão de singleton, pode haver várias instâncias da mesma classe de configurações de aplicativo em um único aplicativo. O valor de <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> deve ser definida de acordo com como os valores de propriedade devem ser compartilhadas.  
  
-   Se as propriedades de configurações do wrapper devem ser compartilhados entre todas as instâncias do wrapper no mesmo aplicativo, em seguida, <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> devem ter o mesmo valor em todas as instâncias. Esse é o comportamento padrão da <xref:System.Configuration.ApplicationSettingsBase> classe.  
  
-   Se as propriedades de configurações do wrapper devem ser por instância, em seguida, <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> devem ter um valor exclusivo para cada instância. O <xref:System.Configuration.ApplicationSettingsBase.%23ctor%28System.String%29> versão do construtor permite que você inicialize <xref:System.Configuration.ApplicationSettingsBase.SettingsKey%2A> para uma cadeia de caracteres exclusiva.  
  
 Em contraste, o <xref:System.Configuration.ApplicationSettingsBase.Context%2A> propriedade fornece dicas para o provedor de configurações para habilitá-lo manter os valores de uma maneira eficiente e ordenada.  
  
 O <xref:System.Configuration.SettingChangingEventArgs> classe contém semelhantes <xref:System.Configuration.SettingChangingEventArgs.SettingKey%2A> que ajuda a identificar a origem da propriedade de <xref:System.Configuration.ApplicationSettingsBase.SettingChanging> eventos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsLoaded">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsLoadedEventHandler SettingsLoaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsLoadedEventHandler SettingsLoaded" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsLoaded" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsLoadedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após as configurações de aplicativo serem recuperadas do armazenamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.SettingsLoaded> evento ocorre somente após a inicial `get` acesso da primeira propriedade de configuração usado, normalmente por meio de <xref:System.Configuration.ApplicationSettingsBase.Item%2A> método. Acessos subsequentes usam valores para a propriedade de configurações que são armazenados em cache localmente. O <xref:System.Configuration.ApplicationSettingsBase.Reset%2A> e <xref:System.Configuration.ApplicationSettingsBase.Reload%2A> métodos limpará armazenado em cache todos os valores para esse evento será gerado novamente após o acesso à propriedade subsequentes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SettingsSaving">
      <MemberSignature Language="C#" Value="public event System.Configuration.SettingsSavingEventHandler SettingsSaving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Configuration.SettingsSavingEventHandler SettingsSaving" />
      <MemberSignature Language="DocId" Value="E:System.Configuration.ApplicationSettingsBase.SettingsSaving" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Configuration.SettingsSavingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes de os valores serem salvos no armazenamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> é gerado pelo <xref:System.Configuration.ApplicationSettingsBase.Save%2A> método antes que ele armazena as propriedades de configurações do aplicativo para seu repositório de dados associados. O manipulador de eventos associado pode cancelar este evento.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra o <xref:System.Configuration.ApplicationSettingsBase.SettingsSaving> manipulador de eventos para o objeto do tipo `FormSettings`, que é uma classe wrapper derivada de <xref:System.Configuration.ApplicationSettingsBase>. O manipulador de consulta o usuário para salvar os valores de propriedade de configurações de aplicativo atual. O exemplo de código completo está listado no <xref:System.Configuration.ApplicationSettingsBase> visão geral da classe.  
  
 [!code-cpp[AppSettingsSample#8](~/samples/snippets/cpp/VS_Snippets_Winforms/AppSettingsSample/cpp/AppSettingsSample.cpp#8)]
 [!code-csharp[AppSettingsSample#8](~/samples/snippets/csharp/VS_Snippets_Winforms/AppSettingsSample/CS/AppSettingsSample.cs#8)]
 [!code-vb[AppSettingsSample#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/AppSettingsSample/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Upgrade">
      <MemberSignature Language="C#" Value="public virtual void Upgrade ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Upgrade() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Configuration.ApplicationSettingsBase.Upgrade" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Configuration.ConfigurationManager</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Atualiza as configurações do aplicativo para refletir uma instalação mais recente do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> método executa duas ações para garantir uma transição suave para uma nova versão de um aplicativo:  
  
-   Todos os provedores de configurações correspondente da existência de aplicativo atualizado por meio de uma chamada para ele o notificará seus <xref:System.Configuration.IApplicationSettingsProvider.Upgrade%2A?displayProperty=nameWithType> método, supondo que eles implementou o <xref:System.Configuration.IApplicationSettingsProvider> interface. Esta ação não será executada se a classe de invólucro de configurações está marcada com <xref:System.Configuration.NoSettingsVersionUpgradeAttribute>.  
  
-   Recarrega os valores para todas as configurações de aplicativo.  
  
 Você pode substituir o comportamento padrão de <xref:System.Configuration.ApplicationSettingsBase.Upgrade%2A> para implementar atualizar ou mesclar o comportamento personalizado. Use o <xref:System.Configuration.ApplicationSettingsBase.GetPreviousVersion%2A> método para recuperar valores individuais de uma configuração para a versão anterior do aplicativo. Exemplos de comportamento de atualização personalizado:  
  
-   Usando novos padrões de política que substituam um ou mais dos valores especificados pelo usuário anteriores ou os padrões anteriores.  
  
-   Conversão especial de valores antigos para ser compatível com a mais recente intervalos, um grupo de propriedades de configurações diferentes e assim por diante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException">Não foi possível analisar o arquivo de configuração.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
