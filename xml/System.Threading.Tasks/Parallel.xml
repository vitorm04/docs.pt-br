<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece suporte para regiões e loops paralelos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Parallel> classe fornece substituições de dados com base em biblioteca paralela para operações comuns como loops, para cada loops e execução de um conjunto de instruções.  
  
   
  
## Examples  
 Este exemplo demonstra várias abordagens para implementar um loop paralelo usando vários construções de linguagem.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros protegidos e públicos da <see cref="T:System.Threading.Tasks.Parallel" /> são thread-safe e podem ser usados simultaneamente em vários threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com dois argumentos:  
  
-   Um <xref:System.Int32> valor que representa a contagem de iteração.  
  
-   Um <xref:System.Threading.Tasks.ParallelLoopState> instância pode ser usada para interromper o loop prematuramente. O <xref:System.Threading.Tasks.ParallelLoopState> objeto é criado pelo compilador; ele não pode ser instanciado no código do usuário.  
  
 Chamando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método informa o `for` operação que não é necessário executar iterações depois do atual. No entanto, todas as iterações antes atual um ainda terá a ser executado se eles ainda não o fez.  
  
 Portanto, ao chamar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> é semelhante ao uso de uma operação de quebra dentro de um convencional `for` loop em uma linguagem como c#, mas ele não é um substituto perfeito: por exemplo, há nenhuma garantia que iterações depois atual definitivamente não será executado.  
  
 Se a execução de todas as iterações antes do ano atual não é necessário, use o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método em vez de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Chamando <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa o `for` loop que ele pode abandonar iterações todos os demais, independentemente de eles estarem antes ou depois da iteração atual, porque todos os necessário trabalho terá já foi concluído. No entanto, como com <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, não há nenhuma garantia dizem respeito às outras iterações não serão executado.  
  
 Se um loop for encerrado prematuramente, o <xref:System.Threading.Tasks.ParallelLoopResult> estrutura que é retornada conterá informações relevantes sobre a conclusão do loop.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir executa até 100 iterações de um loop em paralelo. Cada iteração pausa por um intervalo aleatório de 1 para 1.000 milissegundos. Um valor gerado aleatoriamente determina em qual iteração do loop de <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método é chamado. Como a saída mostra o exemplo, nenhum iterações cujo índice é maior do que o <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> início do valor de propriedade após a chamada para o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 Como iterações do loop são ainda podem estar em execução quando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método é chamado, chamadas de cada iteração a <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propriedade para verificar se a outra iteração chamou o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método. Se o valor da propriedade é `true`, a iteração verifica o valor da <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propriedade e, se for maior que o valor de índice de iteração atual, retorna imediatamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) no qual as iterações podem ser executadas em paralelo.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com a contagem de iteração (<xref:System.Int32>) como um parâmetro.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.Parallel.For%2A> método para 100 invocações de um delegado que gera o byte aleatórios valores e calcula a soma.  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um <see langword="for" /> (<see langword="For" /> no Visual Basic) loop com índices de 64 bits em que iterações possam ser executadas em paralelo e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> estrutura que contém informações sobre qual parte do loop foi concluído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.  
  
 Chamando o <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> método informa o `for` operação iterações depois do atual não tem que ser executado, mas siga todas as iterações antes do ano atual.  
  
 Portanto, é semelhante ao uso de uma operação de quebra dentro de um convencional chamar quebra `for` loop em uma linguagem como c#, mas ele não é um substituto perfeito: por exemplo, há nenhuma garantia que iterações depois atual definitivamente não será executado.  
  
 Se a execução de todas as iterações antes do ano atual não é necessário, use o <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método em vez de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>. Chamando <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa o `for` loop que ele pode abandonar iterações todos os demais, independentemente de eles estarem antes ou depois da iteração atual, porque todos os necessário trabalho terá já foi concluído. No entanto, como com <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, não há nenhuma garantia dizem respeito às outras iterações não serão executado.  
  
 Se um loop for encerrado prematuramente, o <xref:System.Threading.Tasks.ParallelLoopResult> estrutura que é retornada conterá informações relevantes sobre a conclusão do loop.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) com índices de 64 bits no qual as iterações podem ser executadas em paralelo.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com a contagem de iteração (<xref:System.Int64>) como um parâmetro.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) no qual as iterações podem ser executadas em paralelo, as opções do loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) em que as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com a contagem de iteração (<xref:System.Int32>) como um parâmetro.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir mostra como cancelar um loop paralelo:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) com índices de 64 bits no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>) e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método com um <xref:System.Threading.Tasks.ParallelOptions> objeto:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa um <see langword="for" /> (<see langword="For" /> no Visual Basic) loop com índices de 64 bits, no qual iterações possam ser executadas em paralelo e opções de loop podem ser configuradas.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oferece suporte a índices de 64 bits. O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com a contagem de iteração (<xref:System.Int64>) como um parâmetro.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.Threading.Tasks.ParallelOptions> para especificar um agendador de tarefas personalizadas:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) com os dados locais de thread no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
 Para obter um exemplo que usa esse método, consulte [como: gravar um Loop Parallel. for com variáveis locais de Thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa um <see langword="for" /> (<see langword="For" /> no Visual Basic) loop com índices de 64 bits e dados de local de thread no qual iterações possam ser executadas em paralelo, e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações executadas na mesma tarefa.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
 Para obter um exemplo que usa esse método, consulte [como: gravar um Loop Parallel. for com variáveis locais de Thread](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) com os dados locais do thread nos quais iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int32>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações executadas na mesma tarefa.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser invocado simultaneamente em vários threads; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
   
  
## Examples  
 O exemplo a seguir usa variáveis locais de thread para calcular a soma dos resultados de muitas operações longas. Esse exemplo limita o grau de paralelismo para quatro.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="fromInclusive">O índice inicial, inclusivo.</param>
        <param name="toExclusive">O índice do fim, exclusivo.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada thread.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada thread.</param>
        <summary>Executa um loop <see langword="for" /> (<see langword="For" /> no Visual Basic) com índices de 64 bits e dados locais do thread nos quais iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada valor no intervalo de iteração (`fromInclusive`, `toExclusive`). Ele é fornecido com os seguintes parâmetros: a contagem de iteração (<xref:System.Int64>), um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada thread que participa na execução do loop e retorna o estado inicial do local para cada um desses threads. Esses estados iniciais são passados para o primeiro `body` invocações cada thread. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo cada thread retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado de local de cada segmento. Este delegado pode ser invocado simultaneamente em vários threads; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 Se `fromInclusive` é maior que ou igual a `toExclusive`, em seguida, o método retornará imediatamente sem executar qualquer iterações.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador solicitável que contém a fonte de dados original.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 O <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> propriedade no particionador ordenável origem retorna <see langword="false" />.  
  
 -ou-  
  
 Quaisquer métodos no particionador solicitável de origem retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" />, na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 O método no particionador <paramref name="source" /> retorna <see langword="null" />.  
  
 - ou -  
  
 O método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> no particionador <paramref name="source" /> não retorna o número de partições correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" /> no qual as iterações podem ser executadas em paralelo.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um particionador de intervalo para uso com <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.  
  
 -ou-  
  
 O método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> no particionador <paramref name="source" /> não retorna o número de partições correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de 64 bits em uma <see cref="T:System.Collections.IEnumerable" /> na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e o índice do elemento atual (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em uma <see cref="T:System.Collections.IEnumerable" /> na qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com o elemento atual como um parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> método para contar o número de caracteres de espaço não em um arquivo de texto e vogais. Nesse caso, o <xref:System.Threading.Tasks.ParallelLoopResult> valor retornado pelo método é ignorado. Observe que, como operações podem ser executados em paralelo, você deve garantir que incrementar as variáveis de contador é uma operação atômica, e que vários threads não tentar acessar as variáveis de contador simultaneamente. Para essa finalidade, o exemplo usa o `lock` instrução (em c#) e o `SyncLock` instrução (no Visual Basic).  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador solicitável que contém a fonte de dados original.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, em que iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> no particionador solicitável <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 A exceção que é gerada quando qualquer método no particionador solicitável <paramref name="source" /> retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" />, em que iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.Concurrent.Partitioner" /> no qual as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no particionador <paramref name="source" /> retorna <see langword="false" />.  
  
 -ou-  
  
 A exceção que é gerada quando qualquer método no particionador <paramref name="source" /> retorna <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em índices de 64 bits em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e o índice do elemento atual (<xref:System.Int64>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual e um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo e as opções de loop podem ser configuradas.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com o elemento atual como um parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="source">O particionador ordenável que contém a fonte de dados original.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados de local de thread em um <see cref="T:System.Collections.Concurrent.Partitioner" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 O `localInit` delegado é invocado uma vez para cada thread que participa na execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <typeparam name="TLocal">O tipo dos dados do local de thread.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa um <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) a operação com dados de local de thread em um <see cref="T:System.Collections.IEnumerable" /> no qual iterações possam ser executadas em paralelo e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente, o índice do elemento atual (<xref:System.Int64>) e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <typeparam name="TLocal">O tipo dos dados do local de thread.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de dados de local de thread em um <see cref="T:System.Collections.IEnumerable" />, no qual as iterações podem ser executadas em paralelo e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar um <xref:System.Threading.Tasks.Parallel.ForEach%2A> método com o estado local:  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="source">O particionador ordenável que contém a fonte de dados original.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com índices de 64 bits e dados locais do thread em um <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo cada thread retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> ou <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos no <c>fonte</c>.</typeparam>
        <typeparam name="TLocal">O tipo dos dados locais do thread.</typeparam>
        <param name="source">O particionador que contém a fonte de dados original.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.Concurrent.Partitioner" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para situações em que você deseja substituir o padrão do esquema de particionamento. Por exemplo, corpos de loop pequenos podem se beneficiar do particionamento do intervalo. O <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para dar suporte a particionamento dinâmico. Essa sobrecarga é fornecida para cenários com corpos de loop pequenos que poderiam se beneficiar do particionamento de intervalo estático. Particionadores devem oferecer suporte a partições dinâmicas.  Para obter mais informações, consulte [Particionadores personalizados para PLINQ e TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) e [como: implementar as partições dinâmicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por tarefa para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> no <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> retorna <see langword="false" /> ou o particionador retorna partições <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais geradas em todos os threads.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <typeparam name="TLocal">O tipo dos dados do local de thread.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais de thread e índices de 64 bits em um <see cref="T:System.Collections.IEnumerable" />, no qual iterações podem ser executadas em paralelo, opções de loop podem ser configuradas e o estado de loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente, o índice do elemento atual (<xref:System.Int64>) e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo de dados na fonte.</typeparam>
        <typeparam name="TLocal">O tipo dos dados do local de thread.</typeparam>
        <param name="source">Uma fonte de dados enumerável.</param>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="localInit">O delegado de função que retorna o estado inicial de dados locais para cada tarefa.</param>
        <param name="body">O delegado é invocado uma vez por iteração.</param>
        <param name="localFinally">O delegado que executa uma ação final no estado local de cada tarefa.</param>
        <summary>Executa uma operação <see langword="foreach" /> (<see langword="For Each" /> no Visual Basic) com os dados locais do thread em um <see cref="T:System.Collections.IEnumerable" /> no qual as iterações podem ser executadas em paralelo, as opções de loop podem ser configuradas e o estado do loop pode ser monitorado e manipulado.</summary>
        <returns>Uma estrutura que contém informações sobre qual parte do loop foi concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `body` delegado é invocado uma vez para cada elemento de `source` enumerável. Ele é fornecido com os seguintes parâmetros: o elemento atual, um <xref:System.Threading.Tasks.ParallelLoopState> instância que pode ser usada para interromper o loop prematuramente e alguns estados de local que podem ser compartilhado entre iterações que executam no mesmo thread.  
  
 O `localInit` delegado é invocado uma vez para cada tarefa que participa de execução do loop e retorna o estado inicial do local para cada uma dessas tarefas. Esses estados iniciais são passados para o primeiro `body` invocações em cada tarefa. Em seguida, cada invocação subsequente corpo retorna um valor de estado modificado possivelmente que é passado para a próxima chamada de corpo. Por fim, a última chamada de corpo em cada tarefa que retorna um valor de estado que é passado para o `localFinally` delegate. O `localFinally` delegado é invocado uma vez por thread para executar uma ação final no estado de local de cada tarefa. Este delegado pode ser chamado simultaneamente em várias tarefas; Portanto, você deve sincronizar o acesso a todas as variáveis compartilhados.  
  
 O <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método podem usar mais tarefas de threads no decorrer da sua execução, como concluir as tarefas existentes e são substituídas por novas tarefas. Isso fornece subjacente <xref:System.Threading.Tasks.TaskScheduler> objeto a possibilidade de adicionar, alterar ou remover threads que o loop de serviço.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="source" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="body" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localInit" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="localFinally" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no argumento <paramref name="parallelOptions" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">A exceção que contém todas as exceções individuais lançadas em todos os threads.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions">Uma matriz de <see cref="T:System.Action" /> para executar.</param>
        <summary>Executa cada uma das ações fornecidas, possivelmente em paralelo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para executar um conjunto de operações, potencialmente em paralelo.  
  
 Não há garantias sobre a ordem na qual executar as operações ou se eles são executados em paralelo. Este método não retorna até que cada uma das operações fornecidas for concluída, independentemente se o preenchimento ocorra devido ao encerramento normal ou excepcional.  
  
 Para obter mais informações, consulte [Como usar Parallel.Invoke para executar operações em paralelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
   
  
## Examples  
 Este exemplo demonstra como usar o <xref:System.Threading.Tasks.Parallel.Invoke%2A> método com outros métodos, delegados anônimos e expressões lambda.  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="actions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que é gerada quando qualquer ação na matriz <paramref name="actions" /> gerar uma exceção.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="actions" /> contém um elemento <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions">Um objeto que configura o comportamento dessa operação.</param>
        <param name="actions">Uma matriz de ações a serem executadas.</param>
        <summary>Executa cada uma das ações fornecidas, possivelmente em paralelo, a menos que a operação seja cancelada pelo usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para executar um conjunto de operações, potencialmente em paralelo. O token de cancelamento passado com o <xref:System.Threading.Tasks.ParallelOptions> estrutura permite que o chamador cancelar a operação inteira. Para obter mais informações, consulte [cancelamento em Threads gerenciados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
 Não há garantias sobre a ordem na qual executar as operações ou se eles são executados em paralelo. Este método não retorna até que cada uma das operações fornecidas for concluída, independentemente se o preenchimento ocorra devido ao encerramento normal ou excepcional.  
  
 Para obter mais informações, consulte [Como usar Parallel.Invoke para executar operações em paralelo](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> está definido.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="actions" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="parallelOptions" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">A exceção que é gerada quando qualquer ação na matriz <paramref name="actions" /> gerar uma exceção.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="actions" /> contém um elemento <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <see cref="T:System.Threading.CancellationToken" /> no <paramref name="parallelOptions" /> foi descartado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
