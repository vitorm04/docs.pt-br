<Type Name="TaskFactory" FullName="System.Threading.Tasks.TaskFactory">
  <TypeSignature Language="C#" Value="public class TaskFactory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TaskFactory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskFactory" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece suporte para criação e agendamento de objetos <see cref="T:System.Threading.Tasks.Task" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework fornece dois fábricas para criação e agendamento de tarefas:  
  
-   O <xref:System.Threading.Tasks.TaskFactory> classe, que cria <xref:System.Threading.Tasks.Task> e <xref:System.Threading.Tasks.Task%601> objetos. Você pode chamar as sobrecargas do método para criar e executar uma tarefa que requer argumentos não-padrão.  
  
    > [!WARNING]
    >  Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método fornece a maneira mais fácil de criar uma tarefa com padrão valores de configuração e iniciá-lo imediatamente.  
  
-   O <xref:System.Threading.Tasks.TaskFactory%601> classe, que cria <xref:System.Threading.Tasks.Task%601> objetos.  
  
 O <xref:System.Threading.Tasks.TaskFactory> classe permite que você faça o seguinte:  
  
-   Criar uma tarefa e inicie-o imediatamente ao chamar o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método.  
  
    > [!WARNING]
    >  Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método fornece a maneira mais fácil de criar uma tarefa com padrão valores de configuração e iniciá-lo imediatamente.  
  
-   Criar uma tarefa que é iniciado quando qualquer uma das tarefas em uma matriz tem sido concluída chamando o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A> método.  
  
-   Criar uma tarefa que é iniciado quando concluir todas as tarefas em uma matriz chamando o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método.  
  
 Estático <xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType> propriedade retorna um padrão <xref:System.Threading.Tasks.TaskFactory%601> objeto. Você também pode chamar um do <xref:System.Threading.Tasks.TaskFactory> classe construtores para configurar o <xref:System.Threading.Tasks.Task> objetos que o <xref:System.Threading.Tasks.TaskFactory> classe cria. O exemplo a seguir configura um novo <xref:System.Threading.Tasks.TaskFactory> objeto para criar tarefas que têm um token de cancelamento especificado, opções de criação de tarefa, opções de continuação e um agendador de tarefas personalizadas.  
  
 [!code-csharp[TPL_Factories#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_factories/cs/program.cs#1)]
 [!code-vb[TPL_Factories#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_factories/vb/factories_vb.vb#1)]  
  
 Na maioria dos casos, você não precisa criar uma instância de um novo <xref:System.Threading.Tasks.TaskFactory> instância. Em vez disso, você pode usar o <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriedade, que retorna um objeto de fábrica que usa valores padrão. Em seguida, você pode chamar seus métodos para iniciar novas tarefas ou definir a continuação de tarefas. Para obter uma ilustração, consulte o exemplo.  
  
   
  
## Examples  
 O exemplo a seguir usa estático <xref:System.Threading.Tasks.Task.Factory%2A> propriedade fazer duas chamadas para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. O primeiro preenche uma matriz com os nomes dos arquivos no diretório de Meus documentos do usuário, enquanto a segunda preenche uma matriz com os nomes de subpastas da pasta de Meus documentos do usuário. Depois, ele chama o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> método, que exibe informações sobre o número de arquivos e diretórios em duas matrizes, após as duas primeiras tarefas concluiu a execução.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros protegidos e públicos da <see cref="T:System.Threading.Tasks.TaskFactory" /> são thread-safe e podem ser usados simultaneamente em vários threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma instância de <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Threading.Tasks.TaskFactory> instância com uma configuração padrão. O <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada com o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído às tarefas criadas por este <see cref="T:System.Threading.Tasks.TaskFactory" />, a menos que outro CancellationToken seja especificado explicitamente ao chamar os métodos de fábrica.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Threading.Tasks.TaskFactory> instância com uma configuração padrão. O <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada com o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> a ser usado para agendar tarefas criadas com esse TaskFactory. Um valor nulo indica que o TaskScheduler atual deve ser usado.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskCreationOptions.None>, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para <xref:System.Threading.Tasks.TaskContinuationOptions.None>e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para `scheduler`, a menos que seja nula, caso em que a propriedade é inicializada com o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> padrão a ser usado ao criar tarefas com essa TaskFactory.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> padrão a ser usado ao criar tarefas de continuação com essa TaskFactory.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para `creationOptions`, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para `continuationOptions`e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada com o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> inválido. Para obter mais informações, consulte os Comentários sobre <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TaskFactory (System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.#ctor(System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O padrão <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que serão atribuídos às tarefas criadas por este <see cref="T:System.Threading.Tasks.TaskFactory" />, a menos que outro CancellationToken seja especificado explicitamente ao chamar os métodos de fábrica.</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> padrão a ser usado ao criar tarefas com essa TaskFactory.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> padrão a ser usado ao criar tarefas de continuação com essa TaskFactory.</param>
        <param name="scheduler">O padrão <see cref="T:System.Threading.Tasks.TaskScheduler" /> usar para agendar tarefas criadas com esse TaskFactory. Um valor nulo indica que o TaskScheduler.Current deve ser usado.</param>
        <summary>Inicializa uma instância <see cref="T:System.Threading.Tasks.TaskFactory" /> com a configuração especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Com esse construtor o <xref:System.Threading.Tasks.TaskCreationOptions> propriedade é inicializada para `creationOptions`, o <xref:System.Threading.Tasks.TaskContinuationOptions> propriedade é inicializada para `continuationOptions`e o <xref:System.Threading.Tasks.TaskScheduler> propriedade é inicializada para `scheduler`, a menos que seja nula, caso em que a propriedade é inicializada com o Agendador atual (consulte <xref:System.Threading.Tasks.TaskScheduler.Current%2A>).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> inválido. Para obter mais informações, consulte os Comentários sobre <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancellationToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken CancellationToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken CancellationToken" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CancellationToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o token de cancelamento padrão desta fábrica de tarefas.</summary>
        <value>O token de cancelamento de tarefas padrão desta fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna o padrão <xref:System.Threading.CancellationToken> que será atribuído a todas as tarefas criadas por essa fábrica, a menos que outro <xref:System.Threading.CancellationToken> valor é explicitamente especificado durante a chamada para os métodos de fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinuationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskContinuationOptions ContinuationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskContinuationOptions ContinuationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.ContinuationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskContinuationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções de continuação de tarefas padrão dessa fábrica de tarefas.</summary>
        <value>As opções de continuação de tarefas padrão dessa fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para criar todas as tarefas de continuação, a menos que outras opções são especificadas explicitamente durante as chamadas para métodos essa fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método executa o `continuationAction` delegado quando todas as tarefas na `tasks` matriz concluiu, independentemente de seu status de conclusão.  
  
 Exceções lançadas por tarefas de `tasks` matriz não estão disponíveis para a tarefa de continuação por meio de tratamento estruturado de exceções. Você pode determinar quais exceções foram apresentadas, examinando o <xref:System.Threading.Tasks.Task.Exception%2A?displayProperty=nameWithType> propriedade de cada tarefa na `tasks` matriz. Para usar para manipular exceções lançadas por tarefas de tratamento de exceção estruturada de `tasks` de matriz, chame o <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir inicia tarefas separadas que usam uma expressão regular para contar o número de palavras em um conjunto de arquivos de texto. O <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A> método é usado para iniciar uma tarefa que exibe a contagem total de palavras, quando tem concluído todas as tarefas antecedente.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall1.vb#1)]  
  
 A chamada para a tarefa de continuação <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método não permite manipular exceções lançadas por tarefas antecedente, portanto o exemplo examina o <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriedade de cada tarefa antecedente para determinar se a tarefa foi bem-sucedida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [\], ação (tarefa\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%2CSystem.Threading.CancellationToken%29 > método executa o `continuationAction` delegado quando todas as tarefas na `tasks` matriz concluiu, independentemente de seu status de conclusão.  
  
   
  
## Examples  
 O exemplo a seguir cria um token de cancelamento, ele passa para separar as tarefas que usam uma expressão regular para contar o número de palavras em um conjunto de arquivos de texto. O token de cancelamento será definido se um arquivo não pode ser encontrado. O [\], ação (tarefa\<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A > método é usado para iniciar uma tarefa que exibe a contagem total de palavras, quando tem concluído todas as tarefas antecedente. Se o token de cancelamento for definido, que indica que uma ou mais tarefas foram canceladas, ele trata o <xref:System.AggregateException> exceção e exibe uma mensagem de erro.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/cs/continuewhenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewhenall/vb/continuewhenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAll&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[]&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}[]},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationAction">O representante da ação ser executada quando todas as tarefas de <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task[],``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAll&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAll&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAll&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[], !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[],TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associadas à tarefa criada.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando todas as tarefas no <c>tarefas</c> matriz concluiu.</param>
        <param name="cancellationToken">O token de cancelamento a ser atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Uma combinação bit a bit dos valores de enumeração que controlam o comportamento da nova tarefa de continuação. Não há suporte para a NotOn * e membros da somente sob.</param>
        <param name="scheduler">O objeto que é usado para agendar a nova tarefa de continuação.</param>
        <summary>Cria uma tarefa de continuação que começa quando um conjunto de tarefas especificadas foi concluído.</summary>
        <returns>A nova tarefa de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationFunction" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz do <paramref name="tasks" /> está vazia ou contém um valor nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido.</exception>
        <exception cref="T:System.ObjectDisposedException">Um elemento na matriz do <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como usar `ContinueWhenAny` e `ContinueWhenAll`:  
  
 [!code-csharp[System.Threading.Tasks.Task#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuewhenmulti.cs#05)]
 [!code-vb[System.Threading.Tasks.Task#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuewhenmulti.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um dos elementos na matriz <paramref name="tasks" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> contém um valor <see langword="null" />.  
  
 - ou -  
  
 A matriz <paramref name="tasks" /> está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um dos elementos na matriz <paramref name="tasks" /> foi descartado.  
  
 -ou-  
  
 <paramref name="cancellationToken" />já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A matriz do <paramref name="tasks" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> contém um valor <see langword="null" />.  
  
 -ou-  
  
 O <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção que é lançada quando o <paramref name="continuationOptions" /> argumento especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny (System.Threading.Tasks.Task[] tasks, Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny(class System.Threading.Tasks.Task[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a continuação criada <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção que é lançada quando o <paramref name="continuationOptions" /> argumento especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWhenAny&lt;TAntecedentResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task{``0}[],System.Action{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationAction">O representante da ação ser executada quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a continuação criada <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationAction" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção que é lançada quando o <paramref name="continuationOptions" /> argumento especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TResult&gt; (System.Threading.Tasks.Task[] tasks, Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``1(System.Threading.Tasks.Task[],System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a continuação criada <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A exceção que é lançada quando um dos elementos na <paramref name="tasks" /> matriz foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção que é lançada quando o <paramref name="continuationOptions" /> argumento especifica um valor de TaskContinuationOptions inválido.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWhenAny&lt;TAntecedentResult,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWhenAny&lt;TAntecedentResult,TResult&gt; (System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[] tasks, Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWhenAny&lt;TAntecedentResult, TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;[] tasks, class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!!TAntecedentResult&gt;, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TAntecedentResult" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TAntecedentResult&gt;[]" />
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TAntecedentResult&gt;,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TAntecedentResult">O tipo do resultado do antecessor <c>tarefas</c>.</typeparam>
        <typeparam name="TResult">O tipo do resultado retornado pelo <c>continuationFunction</c> delegar e associados criados <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="tasks">A matriz de tarefas da qual continuar quando uma tarefa for concluída.</param>
        <param name="continuationFunction">O delegado de função para executar de forma assíncrona quando uma tarefa no <c>tarefas</c> matriz é concluída.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">O <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> valor que controla o comportamento da continuação criado <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a continuação criada <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> de continuação que será iniciado mediante a conclusão de qualquer Tarefa no conjunto fornecido.</summary>
        <returns>O novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NotOn * e * somente sob <xref:System.Threading.Tasks.TaskContinuationOptions>, que restringem para o qual <xref:System.Threading.Tasks.TaskStatus> uma continuação será executada, os estados são ilegais com ContinueWhenAny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção que é lançada quando o <paramref name="tasks" /> matriz é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="continuationFunction" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentException">A exceção que é lançada quando o <paramref name="tasks" /> matriz contém um valor nulo.  
  
 -ou-  
  
 A exceção que é lançada quando o <paramref name="tasks" /> matriz está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as opções de criação de tarefa padrão para essa fábrica de tarefas.</summary>
        <value>As opções de criação de tarefa padrão para essa fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para criar todas as tarefas, a menos que outras opções são especificadas explicitamente durante as chamadas para métodos essa fábrica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O representante da ação que processa concluído <c>asyncResult</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no.  Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O representante da ação que processa concluído <c>asyncResult</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`. O <xref:System.Threading.Tasks.TaskCreationOptions> valores <xref:System.Threading.Tasks.TaskCreationOptions.PreferFairness>, <xref:System.Threading.Tasks.TaskCreationOptions.LongRunning> e <xref:System.Threading.Tasks.TaskCreationOptions.AttachedToParent> são todos mutuamente exclusivos. Nos métodos de FromAsync, o `LongRunning` ou `AttachedToParent` por si mesmos fará com que um <xref:System.ArgumentOutOfRangeException> seja gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync (IAsyncResult asyncResult, Action&lt;IAsyncResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync(class System.IAsyncResult asyncResult, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync(System.IAsyncResult,System.Action{System.IAsyncResult},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O representante da ação que processa concluído <c>asyncResult</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a tarefa que executa o método end.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que executa uma ação do método de encerramento quando um <see cref="T:System.IAsyncResult" /> especificado é concluído.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O delegado de função que processa concluído <c>asyncResult</c>.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função de método final quando especificada <see cref="T:System.IAsyncResult" /> é concluída.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O delegado de função que processa concluído <c>asyncResult</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função de método final quando especificada <see cref="T:System.IAsyncResult" /> é concluída.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (Func&lt;AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.Func`3&lt;class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TResult&gt; (IAsyncResult asyncResult, Func&lt;IAsyncResult,TResult&gt; endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TResult&gt;(class System.IAsyncResult asyncResult, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``1(System.IAsyncResult,System.Func{System.IAsyncResult,``0},System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="asyncResult">O IAsyncResult cuja conclusão deve disparar o processamento de <c>endMethod</c>.</param>
        <param name="endMethod">O delegado de função que processa concluído <c>asyncResult</c>.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> que é usado para agendar a tarefa que executa o método end.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que executa uma função de método final quando especificada <see cref="T:System.IAsyncResult" /> é concluída.</summary>
        <returns>Um <see cref="T:System.Threading.Tasks.Task`1" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
>  O <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> sobrecargas que usam um `asyncResult` parâmetro não é tão eficiente quanto as sobrecargas que obtêm um `beginMethod` parâmetro. Se o desempenho for um problema, use as sobrecargas que fornecem o `beginMethod` / `endMethod` padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="asyncResult" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TResult&gt; (Func&lt;TArg1,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TResult&gt;(class System.Func`4&lt;!!TArg1, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``2(System.Func{``0,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``1},``0,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg3">O terceiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FromAsync&lt;TArg1,TArg2,TArg3&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Action&lt;IAsyncResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FromAsync&lt;TArg1, TArg2, TArg3&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Action`1&lt;class System.IAsyncResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Action&lt;System.IAsyncResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg3">O terceiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TResult&gt; (Func&lt;TArg1,TArg2,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TResult&gt;(class System.Func`5&lt;!!TArg1, !!TArg2, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``3(System.Func{``0,``1,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``2},``0,``1,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg3">O terceiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; FromAsync&lt;TArg1,TArg2,TArg3,TResult&gt; (Func&lt;TArg1,TArg2,TArg3,AsyncCallback,object,IAsyncResult&gt; beginMethod, Func&lt;IAsyncResult,TResult&gt; endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromAsync&lt;TArg1, TArg2, TArg3, TResult&gt;(class System.Func`6&lt;!!TArg1, !!TArg2, !!TArg3, class System.AsyncCallback, object, class System.IAsyncResult&gt; beginMethod, class System.Func`2&lt;class System.IAsyncResult, !!TResult&gt; endMethod, !!TArg1 arg1, !!TArg2 arg2, !!TArg3 arg3, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.FromAsync``4(System.Func{``0,``1,``2,System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``3},``0,``1,``2,System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TArg1" />
        <TypeParameter Name="TArg2" />
        <TypeParameter Name="TArg3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="beginMethod" Type="System.Func&lt;TArg1,TArg2,TArg3,System.AsyncCallback,System.Object,System.IAsyncResult&gt;" />
        <Parameter Name="endMethod" Type="System.Func&lt;System.IAsyncResult,TResult&gt;" />
        <Parameter Name="arg1" Type="TArg1" />
        <Parameter Name="arg2" Type="TArg2" />
        <Parameter Name="arg3" Type="TArg3" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TArg1">O tipo do segundo argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg2">O tipo do terceiro argumento passado para <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TArg3">O tipo do primeiro argumento passado para o <c>beginMethod</c> delegate.</typeparam>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="beginMethod">O delegado que inicia a operação assíncrona.</param>
        <param name="endMethod">O delegado que finaliza a operação assíncrona.</param>
        <param name="arg1">O primeiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg2">O segundo argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="arg3">O terceiro argumento passado para o <c>beginMethod</c> delegate.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>beginMethod</c> delegate.</param>
        <param name="creationOptions">O valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que representa um par de métodos begin e end que estão em conformidade com o padrão do Modelo de Programação Assíncrona.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> criado que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `beginMethod` delegado é iniciado no thread que <xref:System.Threading.Tasks.TaskFactory.FromAsync%2A> está em execução no. Este método lança as exceções geradas pelo `beginMethod`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="beginMethod" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="endMethod" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Scheduler">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskScheduler Scheduler { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.TaskScheduler Scheduler" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskFactory.Scheduler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o agendador de tarefas padrão para esta fábrica de tarefas.</summary>
        <value>O agendador de tarefas padrão para esta fábrica de tarefas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da propriedade é usado para programar todas as tarefas, a menos que outro Agendador é explicitamente especificado durante as chamadas para métodos essa fábrica.  
  
 Se o valor dessa propriedade é `null`, o valor de <xref:System.Threading.Tasks.TaskScheduler.Current%2A> propriedade é usada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartNew">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> é a maneira recomendada para iniciar uma tarefa vinculada à computação. Use o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método somente quando você precisar de um controle refinado para uma tarefa demorada, vinculada à computação. Isso inclui cenários em que você deseja controlar o seguinte:  
  
-   Opções de criação de tarefa. Tarefas criadas pelo <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método por padrão são criados com o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção. Para substituir esse comportamento, ou fornecer outros <xref:System.Threading.Tasks.TaskCreationOptions> opções, chame um <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> de sobrecarga.  
  
-   Passagem de parâmetro. As sobrecargas do <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método não permite que você passe um parâmetro para o representante de tarefa. Sobrecargas do <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método.  
  
-   O Agendador de tarefas. As sobrecargas do <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método usar o Agendador de tarefas padrão. Para controlar o Agendador de tarefas, chame um <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> sobrecarga com um `scheduler` parâmetro. Para obter mais informações, consulte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <summary>Cria e inicia uma tarefa.</summary>
        <returns>A tarefa iniciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar o <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> método para agendar a tarefa para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> com os parâmetros padrão. No entanto, observe que há uma diferença de comportamento entre os dois métodos sobre: <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção de anexar atual <xref:System.Threading.Tasks.Task> instância, enquanto <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> does. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29> método a ser chamado repetidamente um <xref:System.Action> representante que gera um número aleatório, interpreta como um ponto de código Unicode, converte-o em uma unidade de código UTF16 codificado e exibe informações sobre resultante caractere ou caracteres.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew1.cs#1)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando `StartNew` é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> com os parâmetros padrão. No entanto, observe que há uma diferença de comportamento entre os dois métodos sobre: <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção de anexar atual <xref:System.Threading.Tasks.Task> instância, enquanto <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> does. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29> método para criar uma tarefa que itera os arquivos no diretório C:\Windows\System32. A expressão de lambda chama o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para adicionar informações sobre cada arquivo a um <xref:System.Collections.Generic.List%601> objeto. Cada desanexado tarefa aninhada invocada pelo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop verifica o estado do token de cancelamento e, se cancelamento for solicitado, chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. O <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método lança um <xref:System.OperationCanceledException> exceção que é tratada de uma `catch` bloquear quando o thread de chamada chama o <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew2.cs#2)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>ação</c> delegate.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task> usando um dos seus construtores e, em seguida, chamar o <xref:System.Threading.Tasks.Task.Start%2A> método agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de palavras de letra 6. Cada palavra é então passada para um <xref:System.Action%601> delegado, que codifica o word e exibe a palavra original e sua versão embaralhado.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew3.vb#3)]  
  
 Observe que o exemplo inicializa um único número aleatório, que é protegido por um bloqueio. A necessidade de um bloqueio, consulte "o Random classe e o thread segurança" de <xref:System.Random> tópico sobre a classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>ação</c> delegate.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de palavras de letra 6. Cada palavra é então passada para um <xref:System.Action%601> delegado, que codifica o word e exibe a palavra original e sua versão embaralhado.  
  
 [!code-csharp[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/cs/startnew4.cs#4)]
 [!code-vb[System.Threading.Tasks.TaskFactory.StartNew#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.taskfactory.startnew/vb/startnew4.vb#4)]  
  
 Observe que o exemplo inicializa um único número aleatório, que é protegido por um bloqueio. A necessidade de um bloqueio, consulte "o Random classe e o thread segurança" de <xref:System.Random> tópico sobre a classe. Para lidar com a possibilidade de corrupção do gerador de número aleatório, um token de cancelamento é passado à tarefa. Se dois números aleatórios igual a zero, o método pressupõe que o gerador de número aleatório está corrompido e define o token de cancelamento. Antes de classificar o `chars` matriz que contém as seis caracteres em uma palavra, chamadas de método de <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método para lançar uma <xref:System.OperationCanceledException> se o token foi cancelado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>ação</c> delegate.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task StartNew (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task StartNew(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="action">O delegado da ação a ser executado de forma assíncrona.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>ação</c> delegate.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task" /> criado</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de uma tarefa usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte [Task. Run vs Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="action" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode chamar o <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. No entanto, observe que há uma diferença de comportamento entre os dois métodos sobre: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção de anexar atual <xref:System.Threading.Tasks.Task%601> instância, enquanto <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%29> does. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 O exemplo a seguir é um aplicativo simples adição que gera dois números aleatórios e solicita que o usuário insira sua soma. Em seguida, ele indica se a resposta está correta ou, se a resposta do usuário não é um número válido, solicita que o usuário insira novamente um número válido. O <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é usado para criar o <xref:System.Threading.Tasks.Task%601> objetos que retornam os números aleatórios para adicionar.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Run#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="function" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>função</c> delegate.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> com os parâmetros padrão. No entanto, observe que há uma diferença de comportamento entre os dois métodos sobre: <xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> por padrão não permite filho tarefas iniciadas com o <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> opção de anexar atual <xref:System.Threading.Tasks.Task%601> instância, enquanto <xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29> does. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
   
  
## Examples  
 O exemplo a seguir usa duas tarefas para calcular a sequência de Fibonacci termina em F100 = F100 1 + 2 F100 com valores de semente F1 = 1, F2 = 1 e F1 = 0, F2 = 1. Aproximadamente metade do tempo, um token de cancelamento está definido como executar as operações. A saída do exemplo mostra o resultado se as duas tarefas concluídas com êxito e se o token foi cancelado.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run9.cs#9)]
 [!code-vb[System.Threading.Tasks.Task.Run#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run9.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>função</c> delegate.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído ao novo <see cref="T:System.Threading.Tasks.Task" /></param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>função</c> delegate.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
    <Member MemberName="StartNew&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; StartNew&lt;TResult&gt; (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; StartNew&lt;TResult&gt;(class System.Func`2&lt;object, !!TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskFactory.StartNew``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado disponível por meio de <see cref="T:System.Threading.Tasks.Task`1" />.</typeparam>
        <param name="function">Um delegado de função que retorna o resultado futuro que estará disponível por meio do <see cref="T:System.Threading.Tasks.Task`1" />.</param>
        <param name="state">Um objeto que contém dados a serem usados pelo <c>função</c> delegate.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído a nova tarefa.</param>
        <param name="creationOptions">Um valor de TaskCreationOptions que controla o comportamento do <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> usado para agendar o <see cref="T:System.Threading.Tasks.Task`1" /> criado.</param>
        <summary>Cria e inicia um <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <returns>O <see cref="T:System.Threading.Tasks.Task`1" /> iniciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar StartNew é funcionalmente equivalente à criação de um <xref:System.Threading.Tasks.Task%601> usando um dos seus construtores e, em seguida, chamar <xref:System.Threading.Tasks.Task.Start%2A> agendá-lo para execução.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], você pode usar o <xref:System.Threading.Tasks.Task.Run%2A> método com um <xref:System.Action> objeto como uma maneira rápida de chamar <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> com os parâmetros padrão. Para obter mais informações e exemplos de código, consulte a entrada [Task. Run vs. Task.Factory.StartNew](http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">A exceção lançada quando o argumento <paramref name="function" /> é nulo.  
  
 -ou-  
  
 A exceção lançada quando o argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. A exceção lançada quando o argumento <paramref name="creationOptions" /> especifica um valor de TaskCreationOptions inválido. Para obter mais informações, consulte as Observações para <see cref="M:System.Threading.Tasks.TaskFactory.FromAsync(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Action{System.IAsyncResult},System.Object,System.Threading.Tasks.TaskCreationOptions)" /></exception>
      </Docs>
    </Member>
  </Members>
</Type>
