<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma operação assíncrona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs#045a746eb48cbaa9). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 O <xref:System.Threading.Tasks.Task> classe representa uma única operação que não retorna um valor e que normalmente executa de forma assíncrona. <xref:System.Threading.Tasks.Task>objetos são um dos componentes da centrais de [padrão assíncrono baseado em tarefa](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) introduzida no .NET Framework 4. Porque o trabalho executado por um <xref:System.Threading.Tasks.Task> objeto normalmente executa de forma assíncrona em um thread do pool em vez de forma síncrona no thread principal do aplicativo, você pode usar o <xref:System.Threading.Tasks.Task.Status%2A> propriedade, bem como o <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, e <xref:System.Threading.Tasks.Task.IsFaulted%2A> propriedades, para determinar o estado de uma tarefa. Geralmente, uma expressão lambda é usada para especificar que a tarefa é executar o trabalho.  
  
 Para operações que retornam valores, você deve usar o <xref:System.Threading.Tasks.Task%601> classe.  
  
 Nesta seção:  
  
 [Criar e executar uma tarefa](#Creating)   
 [A separação de execução e criação de tarefa](#Separating)   
 [Aguardando a conclusão de tarefas um ou mais](#WaitingForOne)   
 [Tarefas e cultura](#Culture)   
 [Para desenvolvedores do depurador](#Debugger)  
  
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a>Criar e executar uma tarefa  
 <xref:System.Threading.Tasks.Task>instâncias podem ser criadas em uma variedade de maneiras. A abordagem mais comum, que está disponível desde o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é chamar estático <xref:System.Threading.Tasks.Task.Run%2A> método. O <xref:System.Threading.Tasks.Task.Run%2A> método fornece uma maneira simples de iniciar uma tarefa usando valores padrão e sem a necessidade de parâmetros adicionais. O exemplo a seguir usa o <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método para iniciar uma tarefa que executa um loop e, em seguida, exibe o número de iterações do loop:  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 Uma alternativa e o método mais comum para iniciar uma tarefa [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], é estático <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. O <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> propriedade retorna um <xref:System.Threading.Tasks.TaskFactory> objeto. Sobrecargas do <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método permitem que você especifique parâmetros passados para as opções de criação de tarefa e um agendador de tarefas. O exemplo a seguir usa o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método para iniciar uma tarefa. É funcionalmente equivalente ao código no exemplo anterior.  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 Para obter mais exemplos, consulte [baseado em tarefas de programação assíncrona](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a>A separação de execução e criação de tarefa  
 O <xref:System.Threading.Tasks.Task> classe também fornece construtores que inicializar a tarefa, mas que não agendá-lo para execução. Por motivos de desempenho, o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método é o mecanismo preferido para criar e agendar tarefas de computação, mas para cenários em que a criação e agendamento devem ser separados, você pode usar os construtores e, em seguida, chamar o <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> método para agendar a tarefa para execução em um momento posterior.  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a>Aguardando a conclusão de tarefas um ou mais  
 Como tarefas normalmente executados de forma assíncrona em um pool de threads, o thread que cria e inicia a tarefa continua a execução assim que a tarefa foi criada. Em alguns casos, quando o thread de chamada é o thread principal do aplicativo, o aplicativo pode encerrar antes de qualquer tarefa realmente começa a ser executada. Em outros, a lógica do aplicativo pode exigir que o thread de chamada continuar execução somente quando uma ou mais tarefas concluiu a execução. Você pode sincronizar a execução do thread de chamada assíncrona tarefas e ela inicia chamando um `Wait` método para aguardar a conclusão de tarefas um ou mais.  
  
 Para aguardar uma única tarefa ser concluída, você pode chamar seu <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método. Uma chamada para o <xref:System.Threading.Tasks.Task.Wait%2A> método bloqueia o thread de chamada até que a instância da classe único concluiu a execução.  
  
 O exemplo a seguir chama o sem parâmetros <xref:System.Threading.Tasks.Task.Wait> método incondicionalmente aguardar até que uma tarefa seja concluída. A tarefa simula trabalho chamando o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método no modo de suspensão por dois segundos.  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 Você pode também condicionalmente esperar a conclusão de uma tarefa. O <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> e <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> métodos bloqueiam o thread de chamada até que a tarefa seja concluída ou um intervalo de tempo limite expira, o que ocorrer primeiro. Como o exemplo a seguir inicia uma tarefa que define um valor de tempo limite de um segundo, os blocos de thread de chamada até que o tempo limite expirar, mas ficará suspenso por dois segundos e antes da tarefa foi concluída a execução.  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 Você também pode fornecer um token de cancelamento chamando o <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> e <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> métodos. Se o token <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> é de propriedade `true`, a espera foi cancelada; se ela for verdadeira durante o <xref:System.Threading.Tasks.Task.Wait%2A> método termina.  
  
 Em alguns casos, talvez você queira aguardar para a primeira de uma série de tarefas em execução concluir, mas não é cuidado qual tarefa-lo.  Para essa finalidade, você pode chamar uma das sobrecargas do <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método.  O exemplo a seguir cria três tarefas, cada uma delas é suspenso para determinar um intervalo por um gerador de número aleatório. O <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> método aguarda a conclusão da tarefa primeiro. O exemplo, em seguida, exibe informações sobre o status de todas as três tarefas.  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 Você também pode aguardar todos de uma série de tarefas a concluir ao chamar o <xref:System.Threading.Tasks.Task.WaitAll%2A> método. O exemplo a seguir cria as dez tarefas, aguarda até que todos os dez ser concluída e, em seguida, exibe seu status.  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 Observe que, quando você espera por uma ou mais tarefas concluir, as exceções geradas na execução de tarefas são propagadas no thread que chama o `Wait` método, como mostra o exemplo a seguir. Ela inicia 12 tarefas, três dos quais concluída normalmente e três dos quais lançar uma exceção. Seis tarefas restantes, três são cancelada antes do início e três serão cancelados durante a eles em execução. As exceções são geradas <xref:System.Threading.Tasks.Task.WaitAll%2A> chamada de método e são tratadas por um `try` / `catch` bloco.  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 Para obter mais informações sobre o tratamento de exceções em baseado em tarefas de operações assíncronas, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a>Tarefas e cultura  
 Começando com aplicativos de desktop que visam o [!INCLUDE[net_v46](~/includes/net-v46-md.md)], a cultura do thread que cria e invoca uma tarefa se torna parte do contexto do thread. Ou seja, independentemente da cultura atual do thread no qual a tarefa é executada, a cultura atual da tarefa é a cultura do thread de chamada. Para aplicativos que usam versões do .NET Framework antes do [!INCLUDE[net_v46](~/includes/net-v46-md.md)], a cultura da tarefa é a cultura do thread no qual a tarefa será executada. Para obter mais informações, consulte a seção "Cultura e baseado em tarefas de operações assíncronas" o <xref:System.Globalization.CultureInfo> tópico.  
  
> [!NOTE]
>  Aplicativos da Windows Store siga o tempo de execução do Windows na configuração e obter a cultura padrão.  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a>Para desenvolvedores do depurador  
 Para desenvolvedores implementando depuradores personalizados, vários membros internos e privados de tarefa podem ser útil de (eles podem ser alterados de versão para versão). O `m_taskId` campo serve como armazenamento de backup para o <xref:System.Threading.Tasks.Task.Id%2A> propriedade, no entanto ao acessar esse campo diretamente de um depurador pode ser mais eficiente do que acessar o mesmo valor por meio do método de getter da propriedade (o `s_taskIdCounter` contador é usado para recuperar a próxima ID disponível para uma tarefa). Da mesma forma, o `m_stateFlags` campo armazena informações sobre o estágio do ciclo de vida atual da tarefa, as informações também acessíveis por meio de <xref:System.Threading.Tasks.Task.Status%2A> propriedade. O `m_action` campo armazena uma referência ao representante da tarefa e o `m_stateObject` campo armazena o estado de async passado para a tarefa pelo desenvolvedor. Finalmente, para depuradores que analisam os quadros de pilha, o `InternalWait` método serve um marcador potencial para quando uma tarefa está inserindo uma operação de espera.  
  
   
  
## Examples  
 O exemplo a seguir cria e executa quatro tarefas. Três tarefas executar um <xref:System.Action%601> delegado chamado `action`, que aceita um argumento de tipo <xref:System.Object>. Uma tarefa do quarta executa uma expressão lambda (um <xref:System.Action> delegar) que é definida embutida na chamada para o método de criação de tarefa. Cada tarefa é instanciada e executada de maneira diferente:  
  
-   Tarefa `t1` é instanciado chamando um construtor de classe de tarefa, mas é iniciada chamando seu <xref:System.Threading.Tasks.Task.Start> método somente após a tarefa `t2` foi iniciado.  
  
-   Tarefa `t2` é criada e iniciada em uma única chamada de método chamando o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> método.  
  
-   Tarefa `t3` é criada e iniciada em uma única chamada de método chamando o <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método.  
  
-   Tarefa `t4` é executada modo síncrono no thread principal chamando o <xref:System.Threading.Tasks.Task.RunSynchronously> método.  
  
 Como tarefa `t4` executado de modo síncrono, ele executa no thread principal do aplicativo. As tarefas restantes executadas de forma assíncrona normalmente em um ou mais threads do pool.  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros de <see cref="T:System.Threading.Tasks.Task" />, exceto para <see cref="M:System.Threading.Tasks.Task.Dispose" />, são thread-safe e podem ser usados em vários threads ao mesmo tempo.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> especificado de construtor para criar tarefas que recuperar os nomes dos arquivos em diretórios. Todas as tarefas de gravar os nomes de arquivo em um único <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto. O exemplo, em seguida, chama o <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método para garantir que todas as tarefas concluiu e, em seguida, exibe uma contagem do número total de nomes de arquivo gravado para o <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 O exemplo a seguir é idêntico, exceto que ele usado o <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método para instanciar e executar a tarefa em uma única operação. O método retorna o <xref:System.Threading.Tasks.Task> objeto que representa a tarefa.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que a nova tarefa será observar.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação especificada e <see cref="T:System.Threading.CancellationToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> e <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> métodos. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 Para obter mais informações, consulte [paralelismo de tarefas (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [cancelamento em Threads gerenciados](~/docs/standard/threading/cancellation-in-managed-threads.md).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> construtor para criar uma tarefa que itera os arquivos no diretório C:\Windows\System32. A expressão de lambda chama o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para adicionar informações sobre cada arquivo a um <xref:System.Collections.Generic.List%601> objeto. Cada desanexado tarefa aninhada invocada pelo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop verifica o estado do token de cancelamento e, se cancelamento for solicitado, chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. O <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método lança um <xref:System.OperationCanceledException> exceção que é tratada de uma `catch` bloquear quando o thread de chamada chama o <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  O <xref:System.Threading.Tasks.Task.Start%2A> método é chamado para iniciar a tarefa.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para personalizar o comportamento da tarefa.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação especificada e opções de criação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="state">Um objeto que representa dados a serem usados pela ação.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação especificada e estado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de palavras de letra 6. Cada palavra é passada como um argumento para o <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> construtor, cujo <xref:System.Action%601> delegado codifica os caracteres na palavra, em seguida, exibe a palavra original e sua versão embaralhado.  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que a nova tarefa será observar.</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para personalizar o comportamento da tarefa.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação especificada e opções de criação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 Para obter mais informações, consulte [paralelismo de tarefas (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [cancelamento da tarefa](~/docs/standard/parallel-programming/task-cancellation.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="state">Um objeto que representa dados a serem usados pela ação.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que a nova tarefa observará.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação, o estado e as opções especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="state">Um objeto que representa dados a serem usados pela ação.</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para personalizar o comportamento da tarefa.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação, o estado e as opções especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action">O delegado que representa o código a ser executado na tarefa.</param>
        <param name="state">Um objeto que representa dados a serem usados pela ação.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que a nova tarefa observará...</param>
        <param name="creationOptions">O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para personalizar o comportamento da tarefa.</param>
        <summary>Inicializa um novo <see cref="T:System.Threading.Tasks.Task" /> com a ação, o estado e as opções especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de chamar este construtor, a maneira mais comum para instanciar um <xref:System.Threading.Tasks.Task> objeto e inicie uma tarefa está chamando estático <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> método. A única vantagem oferecida por esse construtor é que ele permite que a instanciação do objeto a ser separado da invocação de tarefa.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> que criou <paramref name="cancellationToken" /> já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="action" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="creationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto de estado fornecido quando o <see cref="T:System.Threading.Tasks.Task" /> foi criado ou nulo se não foi fornecido.</summary>
        <value>Um <see cref="T:System.Object" /> que representa os dados de estado que foram passados para a tarefa quando ela foi criada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Converta o objeto para o tipo original ao recuperar seus dados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma tarefa que já foi concluída com êxito.</summary>
        <value>A tarefa concluída com êxito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna uma tarefa cujo <xref:System.Threading.Tasks.Task.Status%2A> está definida como <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. Para criar a tarefa que retorna um valor e é executado até a conclusão, chame o <xref:System.Threading.Tasks.Task.FromResult%2A> método.  
  
 As tentativas repetidas para recuperar o valor dessa propriedade podem não retornar sempre a mesma instância.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">
          <see langword="true" />para tentar realizar marshaling de continuação para o contexto original capturada; Caso contrário, <see langword="false" />.</param>
        <summary>Configura um awaiter usado para aguardar este <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Um objeto usado para aguardar essa tarefa.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
   
  
## Examples  
 O exemplo a seguir define uma tarefa que preenche uma matriz com 100 aleatória valores de data e hora. Ele usa o <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> método para selecionar o mais recente e os valores de data mais recentes quando a matriz é totalmente preenchida.  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 Como um aplicativo de console pode ser encerrada antes de executa a tarefa de continuação, o <xref:System.Threading.Tasks.Task.Wait> método é chamado para garantir que a continuação termina de executar antes do término de exemplo.  
  
 Para obter um exemplo adicional, consulte [encadeamento de tarefas por tarefas de continuação usando](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando a tarefa for concluída. Quando executado, o representante é passado a tarefa concluída e um objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela ação de acompanhamento.</param>
        <summary>Cria uma continuação que recebe informações de estado fornecidas pelo chamador e executa quando <see cref="T:System.Threading.Tasks.Task" /> de destino for concluída.</summary>
        <returns>Uma nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou saindo no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma continuação que recebe um token de cancelamento e é executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino é concluído.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executado de acordo com a especificada <c>continuationOptions</c>. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Cria uma continuação que é executada quando a tarefa de destino é concluída conforme o <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios de continuação especificado por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar <xref:System.Threading.Tasks.TaskContinuationOptions> para especificar que uma tarefa de continuação deve executar sincronicamente quando a tarefa antecedente é concluída. (Se a tarefa especificada já foi concluída no momento <xref:System.Threading.Tasks.Task.ContinueWith%2A> é chamado, o síncrona continuação será executado na chamada do thread <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído. A continuação usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é <see langword="null" />.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela ação de acompanhamento.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Cria uma continuação que recebe informações de estado e um token de cancelamento fornecidos pelo chamador e que será executada de maneira assíncrona quando a <see cref="T:System.Threading.Tasks.Task" /> de destino for concluída.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela ação de acompanhamento.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Cria uma continuação que recebe informações de estado fornecidas pelo chamador e executa quando <see cref="T:System.Threading.Tasks.Task" /> de destino for concluída. A continuação é executada com base em um conjunto de condições especificadas.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios de continuação especificado por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído.  Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela ação de acompanhamento.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Cria uma continuação que recebe informações de estado fornecidas pelo chamador e executa de forma assíncrona quando o destino <see cref="T:System.Threading.Tasks.Task" /> for concluído. A continuação usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executado de acordo com a especificada <c>continuationOptions</c>. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Cria uma continuação que é executada quando a tarefa de destino compete conforme o <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> especificado. A continuação recebe um token de cancelamento e usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios especificados por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
   
  
## Examples  
 Este é um exemplo de uso ContinueWith para executar o trabalho em segundo plano e no usuário de threads de interface.  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationAction" /> é nulo.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">Uma ação a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela ação de acompanhamento.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Cria uma continuação que recebe informações de estado e um token de cancelamento fornecidos pelo chamador e que será executada quando a <see cref="T:System.Threading.Tasks.Task" /> de destino for concluída. A continuação é executada com base em um conjunto de condições especificadas e usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios especificados por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task`1" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task`1" /> de destino for concluído e retornar um valor.</summary>
        <returns>Uma nova tarefa de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o método ContinueWith:  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela função de continuação.</param>
        <summary>Cria uma continuação que recebe informações de estado fornecidas pelo chamador e que é executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino é concluído e retorna um valor.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído e retornar um valor. A continuação recebe um token de cancelamento.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executado de acordo com a condição especificada em <c>continuationOptions</c>. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Cria uma continuação que executa de acordo com as opções de continuação especificadas e retorna um valor.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios de continuação especificado por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído e retornar um valor. A continuação usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é nulo.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela função de continuação.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído e retornar um valor. A continuação recebe informações de estado fornecido pelo chamador e um token de cancelamento.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela função de continuação.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <summary>Cria uma continuação que é executada com base nas opções de continuação de tarefas especificadas quando o <see cref="T:System.Threading.Tasks.Task" /> de destino é concluído. A continuação recebe informações de estado fornecidas pelo chamador.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios de continuação especificado por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído.  Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela função de continuação.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Criará uma continuação executada de forma assíncrona quando o <see cref="T:System.Threading.Tasks.Task" /> de destino for concluído. A continuação recebe informações de estado fornecido pelo chamador e usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não é agendado para execução até que a tarefa atual for concluída, se ela é concluída devido a execução até a conclusão com êxito, falha devido a uma exceção sem tratamento ou sair no início devido a cancelamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executado de acordo com a especificada <c>continuationOptions.</c> Quando executado, o delegado passará a tarefa concluída como um argumento.</param>
        <param name="cancellationToken">O <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Cria uma continuação que executa de acordo com as opções de continuação especificadas e retorna um valor. Um token de cancelamento é passado à continuação e ela usa um agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios especificados por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o método ContinueWith com opções de continuação:  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.  
  
 -ou-  
  
 O <see cref="T:System.Threading.CancellationTokenSource" /> que criou o token já foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="continuationFunction" /> é nulo.  
  
 -ou-  
  
 O argumento <paramref name="scheduler" /> é nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do resultado produzido pela continuação.</typeparam>
        <param name="continuationFunction">Uma função a ser executada quando o <see cref="T:System.Threading.Tasks.Task" /> for concluído. Quando executado, o representante será passado a tarefa concluída e o objeto de estado fornecido pelo chamador como argumentos.</param>
        <param name="state">Um objeto que representa os dados a serem usados pela função de continuação.</param>
        <param name="cancellationToken">O <see cref="T:System.Threading.CancellationToken" /> que será atribuído à nova tarefa de continuação.</param>
        <param name="continuationOptions">Opções de agendamento de continuação e como ele se comporta. Isso inclui critérios, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, bem como opções de execução, como <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</param>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> para associar a tarefa de continuação e usar para sua execução.</param>
        <summary>Cria uma continuação é executado com base em especificado continuação tarefas opções quando o destino <see cref="T:System.Threading.Tasks.Task" /> for concluído e retorna um valor. A continuação recebe informações de estado fornecido pelo chamador e um token de cancelamento e usa o Agendador especificado.</summary>
        <returns>Um novo <see cref="T:System.Threading.Tasks.Task`1" /> de continuação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornado <xref:System.Threading.Tasks.Task%601> não será agendado para execução até que a tarefa atual seja concluída. Se os critérios especificados por meio de `continuationOptions` parâmetro não forem atendidos, a tarefa de continuação será cancelada em vez de agendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="continuationOptions" /> especifica um valor inválido para <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para criar esta tarefa.</summary>
        <value>O <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> usado para criar esta tarefa.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna a ID de execução que atualmente está executando <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>Um inteiro atribuído pelo sistema à tarefa em execução no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.CurrentId%2A>é um `static` (`Shared` no Visual Basic) propriedade que é usada para obter o identificador da tarefa em execução no momento do código que está executando a tarefa. Ele difere de <xref:System.Threading.Tasks.Task.Id%2A> propriedade, que retorna o identificador de um determinado <xref:System.Threading.Tasks.Task> instância. Se você tentar recuperar o <xref:System.Threading.Tasks.Task.CurrentId%2A> valor de fora do código que está executando uma tarefa, a propriedade retornará `null`.  
  
 Observe que, embora colisões são muito raras, identificadores de tarefa não têm garantia de exclusividade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">O número de milissegundos para esperar antes de concluir a tarefa retornada ou -1 para aguardar indefinidamente.</param>
        <summary>Cria uma tarefa que é concluída após um atraso.</summary>
        <returns>Uma tarefa que representa o atraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task.Delay%2A> método normalmente é usado para atrasar a operação de todos ou parte de uma tarefa para um intervalo de tempo especificado. Normalmente, o tempo de espera é apresentado:  
  
-   No início da tarefa, como o exemplo a seguir mostra.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   Em algum momento durante a execução da tarefa. Nesse caso, a chamada para o <xref:System.Threading.Tasks.Task.Delay%2A> método é executado como uma tarefa filho dentro de uma tarefa, como mostra o exemplo a seguir. Observe que desde a tarefa que chama o <xref:System.Threading.Tasks.Task.Delay%2A> método é executado de forma assíncrona, a tarefa pai deve aguardar a conclusão, usando o `await` palavra-chave.  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 Após o atraso de tempo especificado, a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Esse método depende do relógio do sistema. Isso significa que o tempo de espera será aproximadamente igual a resolução do relógio do sistema se o `millisecondsDelay` argumento for menor do que a resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso simple de <xref:System.Threading.Tasks.Task.Delay%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="millisecondsDelay" /> é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="delay">O tempo que se deve aguardar antes de concluir a tarefa retornada ou <see langword="TimeSpan.FromMilliseconds(-1)" /> para aguardar indefinidamente.</param>
        <summary>Cria uma tarefa que é concluída após um intervalo de tempo especificado.</summary>
        <returns>Uma tarefa que representa o atraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após o atraso de tempo especificado, a tarefa é concluída em <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Para cenários de uso e exemplos adicionais, consulte a documentação para o <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Esse método depende do relógio do sistema. Isso significa que o tempo de espera será aproximadamente igual a resolução do relógio do sistema se o `delay` argumento for menor do que a resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows.  
  
   
  
## Examples  
 O exemplo a seguir mostra um uso simple de <xref:System.Threading.Tasks.Task.Delay%2A> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />representa um intervalo de tempo negativo que <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.TimeSpan.TotalMilliseconds" /> do argumento <paramref name="delay" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay">O número de milissegundos para esperar antes de concluir a tarefa retornada ou -1 para aguardar indefinidamente.</param>
        <param name="cancellationToken">O token de cancelamento será verificado antes de concluir a tarefa retornada.</param>
        <summary>Cria uma tarefa que pode ser cancelada, que é concluída após um atraso.</summary>
        <returns>Uma tarefa que representa o atraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o token de cancelamento é sinalizado antes do intervalo de tempo especificado, um <xref:System.Threading.Tasks.TaskCanceledException> resultados de exceção e a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  Caso contrário, a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado após o atraso de tempo especificado tiver decorrido.  
  
 Para cenários de uso e exemplos adicionais, consulte a documentação para o <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Esse método depende do relógio do sistema. Isso significa que o tempo de espera será aproximadamente igual a resolução do relógio do sistema se o `millisecondsDelay` argumento for menor do que a resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma tarefa que inclui uma chamada para o <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> método com um atraso de um segundo. Antes de expira o intervalo de atraso, o símbolo é cancelado. A saída do exemplo mostra que, como resultado, um <xref:System.Threading.Tasks.TaskCanceledException> for lançada e as tarefas <xref:System.Threading.Tasks.Task.Status%2A> está definida como <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O argumento <paramref name="millisecondsDelay" /> é menor que -1.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <paramref name="cancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="delay">O tempo que se deve aguardar antes de concluir a tarefa retornada ou <see langword="TimeSpan.FromMilliseconds(-1)" /> para aguardar indefinidamente.</param>
        <param name="cancellationToken">O token de cancelamento será verificado antes de concluir a tarefa retornada.</param>
        <summary>Cria uma tarefa cancelável concluída após um intervalo de tempo especificado.</summary>
        <returns>Uma tarefa que representa o atraso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o token de cancelamento é sinalizado antes do intervalo de tempo especificado, um <xref:System.Threading.Tasks.TaskCanceledException> resultados de exceção e a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  Caso contrário, a tarefa é concluída no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado após o atraso de tempo especificado tiver decorrido.  
  
 Para cenários de uso e exemplos adicionais, consulte a documentação para o <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> de sobrecarga.  
  
 Esse método depende do relógio do sistema. Isso significa que o tempo de espera será aproximadamente igual a resolução do relógio do sistema se o `delay` argumento for menor do que a resolução do relógio do sistema, que é de aproximadamente 15 milissegundos em sistemas Windows.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma tarefa que inclui uma chamada para o <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método com um atraso de um e-e meio segundo. Antes de expira o intervalo de atraso, o símbolo é cancelado. A saída do exemplo mostra que, como resultado, um <xref:System.Threading.Tasks.TaskCanceledException> for lançada e as tarefas <xref:System.Threading.Tasks.Task.Status%2A> está definida como <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 Observe que este exemplo inclui uma condição de corrida potenciais: ele depende da tarefa executar assincronamente o atraso quando o token é cancelado. Embora a segunda 1,5 atraso da chamada para o <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método faz essa suposição provável, mesmo assim, é possível que a chamada para o <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> método pode retornar antes que o token seja cancelado. Nesse caso, o exemplo produz a saída a seguir:  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="delay" />representa um intervalo de tempo negativo que <see langword="TimeSpan.FromMillseconds(-1)" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.TimeSpan.TotalMilliseconds" /> do argumento <paramref name="delay" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <paramref name="cancellationToken" /> fornecido já foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task> classe implementa o <xref:System.IDisposable> interface porque, internamente ele usa recursos que também implementam <xref:System.IDisposable>. No entanto, especialmente se o aplicativo é destinado a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou posterior, não é necessário chamar <xref:System.Threading.Tasks.Task.Dispose%2A> , a menos que o teste de escalabilidade ou desempenho indica que, com base nos seus padrões de uso, desempenho do seu aplicativo deve ser melhorado com a eliminação de tarefas. Para obter mais informações, consulte [é necessário descartar tarefas?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tarefa não está em um dos estados finais: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> ou <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">Um valor booliano que indica se esse método está sendo chamado devido a uma chamada a <see cref="M:System.Threading.Tasks.Task.Dispose" />.</param>
        <summary>Descarta o <see cref="T:System.Threading.Tasks.Task" />, liberando todos os seus recursos não gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task> classe implementa o <xref:System.IDisposable> interface porque, internamente ele usa recursos que também implementam <xref:System.IDisposable>. No entanto, especialmente se o aplicativo é destinado a [!INCLUDE[net_v45](~/includes/net-v45-md.md)] ou posterior, não é necessário chamar <xref:System.Threading.Tasks.Task.Dispose%2A> , a menos que o teste de escalabilidade ou desempenho indica que, com base nos seus padrões de uso, desempenho do seu aplicativo deve ser melhorado com a eliminação de tarefas. Para obter mais informações, consulte [é necessário descartar tarefas?](http://blogs.msdn.com/b/pfxteam/archive/2012/03/25/10287435.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A tarefa não está em um dos estados finais: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> ou <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</exception>
        <threadsafe>Ao contrário da maioria dos membros a <see cref="T:System.Threading.Tasks.Task" /> classe, esse método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.AggregateException" /> que fez com que o <see cref="T:System.Threading.Tasks.Task" /> fosse encerrado prematuramente. Se o <see cref="T:System.Threading.Tasks.Task" /> tiver sido concluído com êxito ou ainda não tiver lançado exceções, isso retornará <see langword="null" />.</summary>
        <value>O <see cref="T:System.AggregateException" /> que fez com que o <see cref="T:System.Threading.Tasks.Task" /> fosse encerrado prematuramente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tarefas que lançam exceções sem tratamento armazenar a exceção resultante e propagá-lo encapsulado em um <xref:System.AggregateException> em chamadas para <xref:System.Threading.Tasks.Task.Wait%2A> ou em acessos para o <xref:System.Threading.Tasks.Task.Exception%2A> propriedade. Todas as exceções não observadas no momento em que a instância da tarefa é coletado como lixo serão propagadas no thread do finalizador. Para obter mais informações e um exemplo, consulte [tratamento de exceção (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fornece acesso a métodos de fábrica para criar e configurar as instâncias <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</summary>
        <value>Um objeto de fábrica que pode criar uma variedade de objetos <see cref="T:System.Threading.Tasks.Task" /> e <see cref="T:System.Threading.Tasks.Task`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna uma instância padrão do <xref:System.Threading.Tasks.TaskFactory> classe que é idêntica a uma criada chamando o sem parâmetros <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> construtor. Ela tem os seguintes valores de propriedade:  
  
|Propriedade|Valor|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|`null`, ou<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 O uso mais comum dessa propriedade é criar e iniciar uma nova tarefa em uma única chamada para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> método fornece a maneira mais fácil de criar um <xref:System.Threading.Tasks.Task> objeto com valores de configuração padrão.  
  
 O exemplo a seguir usa estático <xref:System.Threading.Tasks.Task.Factory%2A> propriedade fazer duas chamadas para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método. O primeiro preenche uma matriz com os nomes dos arquivos no diretório de Meus documentos do usuário, enquanto a segunda preenche uma matriz com os nomes de subpastas da pasta de Meus documentos do usuário. Depois, ele chama o <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> método, que exibe informações sobre o número de arquivos e diretórios em duas matrizes, após as duas primeiras tarefas concluiu a execução.  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O token de cancelamento que concluir a tarefa.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que é concluído devido ao cancelamento com um token de cancelamento especificado.</summary>
        <returns>A tarefa cancelada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O cancelamento não foi solicitado para <paramref name="cancellationToken" />; sua propriedade <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela tarefa.</typeparam>
        <param name="cancellationToken">O token de cancelamento que concluir a tarefa.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que é concluído devido ao cancelamento com um token de cancelamento especificado.</summary>
        <returns>A tarefa cancelada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O cancelamento não foi solicitado para <paramref name="cancellationToken" />; sua propriedade <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception">A exceção com a qual a tarefa será concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task" /> que foi concluído com uma exceção especificada.</summary>
        <returns>A tarefa com falha.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um <xref:System.Threading.Tasks.Task> do objeto cuja <xref:System.Threading.Tasks.Task.Status%2A> é de propriedade <xref:System.Threading.Tasks.TaskStatus.Faulted> e cuja <xref:System.Threading.Tasks.Task.Exception%2A> propriedade contém `exception`. O método normalmente é usado quando você sabe imediatamente que o trabalho que executa uma tarefa lançará uma exceção antes de executar um caminho mais longo de código. Para obter um exemplo, consulte o <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela tarefa.</typeparam>
        <param name="exception">A exceção com a qual a tarefa será concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que é concluído com uma exceção especificada.</summary>
        <returns>A tarefa com falha.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um <xref:System.Threading.Tasks.Task%601> do objeto cuja <xref:System.Threading.Tasks.Task.Status%2A> é de propriedade <xref:System.Threading.Tasks.TaskStatus.Faulted> e cuja <xref:System.Threading.Tasks.Task.Exception%2A> propriedade contém `exception`. O método normalmente é usado quando você sabe imediatamente que o trabalho que executa uma tarefa lançará uma exceção antes de executar um caminho mais longo de código. O exemplo fornece uma ilustração.  
  
   
  
## Examples  
 O exemplo a seguir é um utilitário de linha de comando que calcula o número de bytes em arquivos em cada diretório cujo nome é passado como um argumento de linha de comando. Em vez de executar um caminho mais longo de código que instancia um <xref:System.IO.FileInfo> de objeto e recupera o valor do seu <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> propriedade para cada arquivo no diretório, o exemplo simplesmente chama o <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> método para criar uma tarefa com falha se um determinado subdiretório não existe.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela tarefa.</typeparam>
        <param name="result">O resultado a armazenar na tarefa concluída.</param>
        <summary>Cria um <see cref="T:System.Threading.Tasks.Task`1" /> que é concluído com êxito com o resultado especificado.</summary>
        <returns>A tarefa concluída com êxito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um <xref:System.Threading.Tasks.Task%601> do objeto cuja <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> é de propriedade `result` e cuja <xref:System.Threading.Tasks.Task.Status%2A> é de propriedade <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>. O método normalmente é usado quando o valor de retorno de uma tarefa é conhecido imediatamente sem um caminho mais longo de código em execução. O exemplo fornece uma ilustração.  
  
 Para criar um objeto de tarefa que não retorna um valor, recuperar o objeto de tarefa do <xref:System.Threading.Tasks.Task.CompletedTask%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir é um utilitário de linha de comando que calcula o número de bytes em arquivos em cada diretório cujo nome é passado como um argumento de linha de comando. Em vez de executar um caminho mais longo de código que instancia um <xref:System.IO.FileStream> de objeto e recupera o valor do seu <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> propriedade para cada arquivo no diretório, o exemplo simplesmente chama o <xref:System.Threading.Tasks.Task.FromResult%2A> método para criar uma tarefa cujo <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriedade é zero (0) se um diretório não tem arquivos.  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um awaiter usado para aguardar este <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <returns>Uma instância de awaiter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método destina para uso do compilador em vez de para uso no código do aplicativo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma ID para esta instância <see cref="T:System.Threading.Tasks.Task" />.</summary>
        <value>O identificador atribuído pelo sistema para esta instância <see cref="T:System.Threading.Tasks.Task" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IDs de tarefas são atribuídas sob demanda e não representa necessariamente a ordem na qual a tarefa instâncias são criadas. Observe que, embora colisões são muito raras, identificadores de tarefa não têm garantia de exclusividade.  
  
 Para obter a ID da tarefa da tarefa em execução no momento de dentro do código que está executando essa tarefa, use o <xref:System.Threading.Tasks.Task.CurrentId%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se essa instância <see cref="T:System.Threading.Tasks.Task" /> concluiu sua execução porque foi cancelada.</summary>
        <value>
          <see langword="true" /> se a tarefa foi concluída porque foi cancelada, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Threading.Tasks.Task> será concluída no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado em qualquer uma das seguintes condições:  
  
-   Seu <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> foi marcada para cancelamento antes da tarefa começou a executar,  
  
-   A tarefa de confirmada a solicitação de cancelamento em sinalizado já <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> , lançando um <xref:System.OperationCanceledException> que tem o mesmo <xref:System.Threading.CancellationToken>.  
  
-   A tarefa de confirmada a solicitação de cancelamento em sinalizado já <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> chamando o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> método o <xref:System.Threading.CancellationToken>.  
  
> [!IMPORTANT]
>  Recuperar o valor da <xref:System.Threading.Tasks.Task.IsCanceled%2A> propriedade não bloqueia o thread de chamada até que a tarefa seja concluída.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a informação de se esta <see cref="T:System.Threading.Tasks.Task" /> foi concluída.</summary>
        <value>
          <see langword="true" /> se a tarefa foi concluída; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.IsCompleted%2A>retornará `true` quando a tarefa estiver em um dos três estados finais: <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>, <xref:System.Threading.Tasks.TaskStatus.Faulted>, ou <xref:System.Threading.Tasks.TaskStatus.Canceled>.  
  
> [!IMPORTANT]
>  Recuperar o valor da <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> propriedade não bloqueia o thread de chamada até que a tarefa seja concluída.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se o <see cref="T:System.Threading.Tasks.Task" /> foi concluído devido a uma exceção sem tratamento.</summary>
        <value>
          <see langword="true" /> se a tarefa lançou uma exceção sem tratamento; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Threading.Tasks.Task.IsFaulted%2A> é `true`, a tarefa <xref:System.Threading.Tasks.Task.Status%2A> é igual a <xref:System.Threading.Tasks.TaskStatus.Faulted>e sua <xref:System.Threading.Tasks.Task.Exception%2A> propriedade será não nulo.  
  
> [!IMPORTANT]
>  Recuperar o valor da <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> propriedade não bloqueia o thread de chamada até que a tarefa seja concluída.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>As filas de trabalho especificado para ser executado no objeto ThreadPool e retorna uma tarefa ou <see cref="T:System.Threading.Tasks.Task`1" /> identificador para esse trabalho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task.Run%2A> método fornece um conjunto de sobrecargas que tornam mais fácil iniciar uma tarefa usando valores padrão. É uma alternativa leve para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> sobrecargas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action">O trabalho a ser executado de forma assíncrona</param>
        <summary>Coloca o trabalho especificado em fila para execução no pool de threads e retorna um objeto <see cref="T:System.Threading.Tasks.Task" /> que representa o trabalho.</summary>
        <returns>Uma tarefa que representa o trabalho na fila a ser executado no ThreadPool.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task.Run%2A> método permite que você criar e executar uma tarefa em uma única chamada de método e é uma alternativa mais simples para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método. Ele cria uma tarefa com os seguintes valores padrão:  
  
-   Seu token de cancelamento é <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Seu <xref:System.Threading.Tasks.Task.CreationOptions%2A> é o valor da propriedade <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Ele usa o Agendador de tarefas padrão.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 O exemplo a seguir define uma `ShowThreadInfo` método que exibe o <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> do thread atual. Ele é chamado diretamente no thread do aplicativo e é chamado a partir de <xref:System.Action> delegado passado para o <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 O exemplo a seguir é semelhante ao anterior, exceto que ele usa uma expressão lambda para definir o código que a tarefa deve ser executada.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 Os exemplos mostram que a tarefa assíncrona é executado em um thread diferente do thread principal do aplicativo.  
  
 A chamada para o <xref:System.Threading.Tasks.Task.Wait%2A> método garante que a tarefa for concluída e exibe seu resultado antes do aplicativo terminar. Caso contrário, é possível que o `Main` método será concluído antes que a tarefa for concluída.  
  
 O exemplo a seguir ilustra o <xref:System.Threading.Tasks.Task.Run%28System.Action%29> método. Ele define uma matriz de nomes de diretórios e inicia uma tarefa separada para recuperar os nomes de arquivo em cada pasta. Todas as tarefas de gravar os nomes de arquivo em um único <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto. O exemplo, em seguida, chama o <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método para garantir que todas as tarefas concluiu e, em seguida, exibe uma contagem do número total de nomes de arquivo gravado para o <xref:System.Collections.Concurrent.ConcurrentBag%601> objeto.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="action" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="function">O trabalho a ser executado de forma assíncrona</param>
        <summary>Coloca o trabalho especificado na fila para execução no pool de threads e retorna um proxy para a tarefa retornada pelo <paramref name="function" />.</summary>
        <returns>Uma tarefa que representa um proxy para a tarefa retornada pelo <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action">O trabalho a ser executado de forma assíncrona</param>
        <param name="cancellationToken">Um token de cancelamento que pode ser usado para cancelar o trabalho</param>
        <summary>Coloca o trabalho especificado em fila para execução no pool de threads e retorna um objeto <see cref="T:System.Threading.Tasks.Task" /> que representa o trabalho. Um token de cancelamento permite que o trabalho seja cancelado.</summary>
        <returns>Uma tarefa que representa o trabalho na fila a ser executado no pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o cancelamento é solicitado antes da tarefa começa a ser executada, a tarefa não será executado. Em vez disso, ele é definido como o <xref:System.Threading.Tasks.TaskStatus.Canceled> estado e lança um <xref:System.Threading.Tasks.TaskCanceledException> exceção.  
  
 O <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> método é uma alternativa mais simples para o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> método. Ele cria uma tarefa com os seguintes valores padrão:  
  
-   Seu <xref:System.Threading.Tasks.Task.CreationOptions%2A> é o valor da propriedade <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Ele usa o Agendador de tarefas padrão.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> método para criar uma tarefa que itera os arquivos no diretório C:\Windows\System32. A expressão de lambda chama o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método para adicionar informações sobre cada arquivo a um <xref:System.Collections.Generic.List%601> objeto. Cada desanexado tarefa aninhada invocada pelo <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop verifica o estado do token de cancelamento e, se cancelamento for solicitado, chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método. O <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método lança um <xref:System.OperationCanceledException> exceção que é tratada de uma `catch` bloquear quando o thread de chamada chama o <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="action" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <paramref name="cancellationToken" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">O trabalho a ser executado de forma assíncrona.</param>
        <param name="cancellationToken">Um token de cancelamento que deve ser usado para cancelar o trabalho.</param>
        <summary>Coloca o trabalho especificado na fila para execução no pool de threads e retorna um proxy para a tarefa retornada pelo <paramref name="function" />.</summary>
        <returns>Uma tarefa que representa um proxy para a tarefa retornada pelo <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <paramref name="cancellationToken" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela tarefa de proxy.</typeparam>
        <param name="function">O trabalho a ser executado de forma assíncrona</param>
        <summary>Coloca o trabalho especificado na fila para execução no pool de threads e retorna um proxy para <see langword="Task(TResult)" /> retornado por <paramref name="function" />.</summary>
        <returns>Um <see langword="Task(TResult)" /> que representa um proxy para o <see langword="Task(TResult)" /> retornado por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> era <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de retorno da tarefa.</typeparam>
        <param name="function">O trabalho a ser executado de forma assíncrona.</param>
        <summary>Coloca o trabalho especificado em fila para execução no pool de threads e retorna um objeto <see cref="T:System.Threading.Tasks.Task`1" /> que representa o trabalho.</summary>
        <returns>Uma tarefa que representa o trabalho na fila a ser executada no pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task.Run%2A> método é uma alternativa mais simples para o <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> método. Ele cria uma tarefa com os seguintes valores padrão:  
  
-   Seu token de cancelamento é <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.  
  
-   Seu <xref:System.Threading.Tasks.Task.CreationOptions%2A> é o valor da propriedade <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Ele usa o Agendador de tarefas padrão.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número aproximado de palavras em arquivos de texto que representam os livros publicados. Cada tarefa é responsável para abertura de um arquivo, ler todo o seu conteúdo de forma assíncrona e calcular a contagem de palavras usando uma expressão regular. O <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> método é chamado para garantir que todas as tarefas sejam concluídas antes de exibir a contagem de palavras de cada livro para o console.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 A expressão regular `\p{P}*\s+` corresponde a zero, um ou mais caracteres de pontuação, seguidos por um ou mais caracteres de espaço em branco. Ele pressupõe que o número total de correspondências igual à contagem de palavras aproximado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado retornado pela tarefa de proxy.</typeparam>
        <param name="function">O trabalho a ser executado de forma assíncrona</param>
        <param name="cancellationToken">Um token de cancelamento que deve ser usado para cancelar o trabalho</param>
        <summary>Coloca o trabalho especificado na fila para execução no pool de threads e retorna um proxy para <see langword="Task(TResult)" /> retornado por <paramref name="function" />.</summary>
        <returns>Um <see langword="Task(TResult)" /> que representa um proxy para o <see langword="Task(TResult)" /> retornado por <paramref name="function" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> era <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <paramref name="cancellationToken" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de resultado da tarefa.</typeparam>
        <param name="function">O trabalho a ser executado de forma assíncrona</param>
        <param name="cancellationToken">Um token de cancelamento que deve ser usado para cancelar o trabalho</param>
        <summary>Coloca o trabalho especificado em fila para execução no pool de threads e retorna um objeto <see langword="Task(TResult)" /> que representa o trabalho. Um token de cancelamento permite que o trabalho seja cancelado.</summary>
        <returns>Um <see langword="Task(TResult)" /> que representa o trabalho na fila a ser executado no pool de threads.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o cancelamento é solicitado antes da tarefa começa a ser executada, a tarefa não será executado. Em vez disso, ele é definido como o <xref:System.Threading.Tasks.TaskStatus.Canceled> estado e lança um <xref:System.Threading.Tasks.TaskCanceledException> exceção.  
  
 O <xref:System.Threading.Tasks.Task.Run%2A> método é uma alternativa mais simples para o <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> método. Ele cria uma tarefa com os seguintes valores padrão:  
  
-   Seu <xref:System.Threading.Tasks.Task.CreationOptions%2A> é o valor da propriedade <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>.  
  
-   Ele usa o Agendador de tarefas padrão.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 O exemplo a seguir cria 20 tarefas que fará um loop até que um contador é incrementado em um valor de 2 milhões. Quando as 10 primeiras tarefas atingirem 2 milhões, o token de cancelamento é cancelado e as tarefas cujas contadores que não alcançaram 2 milhões serão canceladas. O exemplo mostra a saída possíveis.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 Em vez de usar o <xref:System.AggregateException.InnerExceptions%2A> propriedade para examinar as exceções, o exemplo itera todas as tarefas para determinar qual foram concluídos com êxito e que foram cancelado. Para aqueles que foram concluídas, ele exibe o valor retornado pela tarefa.  
  
 Como o cancelamento é cooperativo, cada tarefa pode decidir como reagir ao cancelamento. O exemplo a seguir é como o primeiro, exceto que, depois que o token é cancelado, tarefas de retornam o número de iterações que tiver concluído, em vez de lançam uma exceção.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 O exemplo deve tratar o <xref:System.AggregateException> exceção, desde que nenhuma das tarefas que não iniciaram quando o cancelamento for solicitado ainda lançar uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="function" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException">A tarefa foi cancelada.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.CancellationTokenSource" /> associado ao <paramref name="cancellationToken" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Executa o <see cref="T:System.Threading.Tasks.Task" /> de forma síncrona no <see cref="T:System.Threading.Tasks.TaskScheduler" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, as tarefas são executadas de forma assíncrona em um pool de threads e não bloqueiam o thread de chamada. As tarefas executadas chamando o <xref:System.Threading.Tasks.Task.RunSynchronously> método estão associados com a atual <xref:System.Threading.Tasks.TaskScheduler> e são executados no thread de chamada. Se o Agendador de destino não oferece suporte para executar esta tarefa no thread de chamada, a tarefa será agendada para execução no Agendador e o thread de chamada será bloqueado até que a tarefa foi concluída a execução. Mesmo que a tarefa é executada de forma síncrona, o thread de chamada ainda deve chamar <xref:System.Threading.Tasks.Task.Wait%2A> para lidar com todas as exceções que a tarefa poderá gerar.  Para obter mais informações sobre o tratamento de exceção, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 As tarefas executadas chamando o <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método são instanciados chamando um <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> construtor de classe. A tarefa para ser executado de forma síncrona deve estar no <xref:System.Threading.Tasks.TaskStatus.Created> estado. Uma tarefa pode ser iniciada e executada apenas uma vez. Qualquer tentativa para agendar uma tarefa um segundo momento resulta em uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir compara uma tarefa executada chamando o <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método com um executadas de forma assíncrona. Em ambos os casos, as tarefas executar expressões lambda idênticos que exibem a ID da tarefa e a ID do thread em que a tarefa está em execução. A tarefa calcula a soma de números inteiros entre 1 e 1.000.000. Como mostra a saída do exemplo, a tarefa executada chamando o <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método é executado no thread do aplicativo, enquanto a tarefa assíncrona não.  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.Tasks.Task" /> foi descartada.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.Tasks.Task" /> não está em um estado válido para ser iniciado. Ele pode já ter sido iniciado, executado ou cancelado ou pode ter sido criado de forma a não dar suporte ao agendamento direto.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">O agendador no qual haverá a tentativa de executar essa tarefa embutida.</param>
        <summary>Executa o <see cref="T:System.Threading.Tasks.Task" /> de forma síncrona no <see cref="T:System.Threading.Tasks.TaskScheduler" /> fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As tarefas executadas chamando o <xref:System.Threading.Tasks.Task.RunSynchronously%2A> método são instanciados chamando um <xref:System.Threading.Tasks.Task> ou <xref:System.Threading.Tasks.Task%601> construtor de classe. A tarefa para ser executado de forma síncrona deve estar no <xref:System.Threading.Tasks.TaskStatus.Created> estado. Uma tarefa pode ser iniciada e executada apenas uma vez. Qualquer tentativa para agendar uma tarefa um segundo momento resulta em uma exceção.  
  
 Se o Agendador de destino não oferece suporte para executar esta tarefa no thread atual, a tarefa será agendada para execução no Agendador e o segmento atual será bloqueado até que a tarefa foi concluída a execução. Por isso, o thread de chamada não precisa chamar um método, como <xref:System.Threading.Tasks.Task.Wait%2A> para garantir que a tarefa foi concluída a execução. Para obter mais informações sobre o tratamento de exceções para operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.Tasks.Task" /> foi descartada.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.Tasks.Task" /> não está em um estado válido para ser iniciado. Ele pode já ter sido iniciado, executado ou cancelado ou pode ter sido criado de forma a não dar suporte ao agendamento direto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia o <see cref="T:System.Threading.Tasks.Task" />, agendando-o para execução no <see cref="T:System.Threading.Tasks.TaskScheduler" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma tarefa pode ser iniciada e executada apenas uma vez. Qualquer tentativa para agendar uma tarefa de uma segunda vez resultará em uma exceção.  
  
 O <xref:System.Threading.Tasks.Task.Start%2A> é usada para executar uma tarefa que foi criada chamando um do <xref:System.Threading.Tasks.Task> construtores. Normalmente, você faz isso quando você precisar separar a criação da tarefa de sua execução, como quando você executar tarefas que você criou condicionalmente. Para o caso mais comum em que você não precisa separar instanciação de tarefa de execução, é recomendável que você chame uma sobrecarga de <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> ou <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> método.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> construtor para instanciar um novo <xref:System.Threading.Tasks.Task> objeto que exibe sua tarefa ID e a ID do thread gerenciado e, em seguida, executa um loop. Depois, ele chama o <xref:System.Threading.Tasks.Task.Start%2A> método para executar a tarefa.  Como esse é um aplicativo de console, a chamada para o <xref:System.Threading.Tasks.Task.Wait%2A> método é necessário para impedir que o aplicativo finalizando antes de terminar a execução.  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.Tasks.Task" /> foi descartada.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.Tasks.Task" /> não está em um estado válido para ser iniciado. Ele pode já ter sido iniciado, executado ou cancelado ou pode ter sido criado de forma a não dar suporte ao agendamento direto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler">O <see cref="T:System.Threading.Tasks.TaskScheduler" /> com o qual associar e executar essa tarefa.</param>
        <summary>Inicia o <see cref="T:System.Threading.Tasks.Task" />, agendando-o para execução no <see cref="T:System.Threading.Tasks.TaskScheduler" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma tarefa só pode ser iniciada e executada apenas uma vez. Qualquer tentativa para agendar uma tarefa de uma segunda vez resultará em uma exceção.  
  
 Para obter informações sobre como manipular exceções lançadas por operações de tarefa, consulte [tratamento de exceção](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="scheduler" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.Tasks.Task" /> não está em um estado válido para ser iniciado. Ele pode já ter sido iniciado, executado ou cancelado ou pode ter sido criado de forma a não dar suporte ao agendamento direto.</exception>
        <exception cref="T:System.ObjectDisposedException">A instância <see cref="T:System.Threading.Tasks.Task" /> foi descartada.</exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException">O agendador não pôde colocar essa tarefa na fila.</exception>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Threading.Tasks.TaskStatus" /> dessa tarefa.</summary>
        <value>O <see cref="T:System.Threading.Tasks.TaskStatus" /> atual desta instância de tarefa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o valor da <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriedade não bloqueia o thread de chamada até que a tarefa seja concluída.  
  
 Para obter mais informações e um exemplo, consulte [encadeamento de tarefas por tarefas de continuação usando](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) e [como: Cancelar uma tarefa e seus filhos](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).  
  
   
  
## Examples  
 O exemplo a seguir cria 20 tarefas que fará um loop até que um contador é incrementado em um valor de 2 milhões. Quando as 10 primeiras tarefas atingirem 2 milhões, o token de cancelamento é cancelado e as tarefas cujas contadores que não alcançaram 2 milhões serão canceladas. O exemplo, em seguida, examina o <xref:System.Threading.Tasks.Task.Status%2A> propriedade de cada tarefa para indicar se ele foi concluído com êxito ou foi cancelado. Para aqueles que concluído, ele exibe o valor retornado pela tarefa.  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar a conclusão da tarefa.</summary>
        <value>Um <see cref="T:System.Threading.WaitHandle" /> que pode ser usado para aguardar a conclusão da tarefa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usando a funcionalidade de espera fornecida pelo <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> é preferível a usar <xref:System.IAsyncResult.AsyncWaitHandle%2A> para uma funcionalidade semelhante. Para obter mais informações, consulte a seção "Aguardando em tarefas" [baseado em tarefas de programação assíncrona](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) e [usando TPL com outros padrões assíncronos](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma indicação de se concluir a operação de forma síncrona.</summary>
        <value>
          <see langword="true" />Se a operação é concluída de forma síncrona; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aguarda o <see cref="T:System.Threading.Tasks.Task" /> concluir a execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%2A>é um método de sincronização que faz com que o thread de chamada aguardar até que a tarefa atual for concluída. Se a tarefa atual não tiver iniciado a execução, o método espera tentará remover a tarefa do Agendador e executá-lo embutido no thread atual. Se não for possível fazer isso ou se a tarefa atual já iniciou a execução, ele bloqueia o thread de chamada até que a tarefa seja concluída. Para obter mais informações, consulte [Task.Wait e "Inlining"](http://blogs.msdn.com/b/pfxteam/archive/2009/10/15/9907713.aspx) em programação paralela com .NET blog.  
  
 Para obter mais informações e um exemplo, consulte [como: espera-se em uma ou mais tarefas a concluir](http://msdn.microsoft.com/library/79cb522b-9c93-46ed-b23a-c06908f3a374).  
  
   
  
## Examples  
 O exemplo a seguir inicia uma tarefa que gera um milhão de inteiros aleatórios entre 0 e 100 e computa sua média. O exemplo usa o <xref:System.Threading.Tasks.Task.Wait%2A> método para garantir que a tarefa é concluída antes do encerramento do aplicativo. Caso contrário, porque este é um aplicativo de console, o exemplo deve terminar antes que a tarefa pode calcular e exibir a média.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.AggregateException">A tarefa foi cancelada. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém um <see cref="T:System.Threading.Tasks.TaskCanceledException" /> objeto.  
  
 -ou-  
  
 Uma exceção foi lançada durante a execução da tarefa. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém informações sobre a exceção ou exceções.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Aguarda o <see cref="T:System.Threading.Tasks.Task" /> concluir a execução dentro de um número especificado. de milissegundos.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Threading.Tasks.Task" /> concluiu a execução dentro do tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>é um método de sincronização que faz com que o thread de chamada aguardar a instância atual da tarefa ser concluída até que ocorra um dos seguintes:  
  
-   A tarefa é concluída com êxito.  
  
-   A própria tarefa foi cancelada ou gera uma exceção. Nesse caso, você processa um <xref:System.AggregateException> exceção. O <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriedade contém detalhes sobre a exceção ou exceções.  
  
-   O intervalo definido pela `millisecondsTimeout` expira. Nesse caso, o thread atual continua a execução e o método retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma tarefa que gera cinco milhões de inteiros aleatórios entre 0 e 100 e computa sua média. O exemplo usa o <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> método de espera para o aplicativo ser concluída dentro de 150 milissegundos. Se o aplicativo for concluída normalmente, a tarefa exibe a soma e média dos números aleatórios que gerou. Se o intervalo de tempo limite expirou, o exemplo exibe uma mensagem antes de ele termina.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.AggregateException">A tarefa foi cancelada. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém um <see cref="T:System.Threading.Tasks.TaskCanceledException" /> objeto.  
  
 -ou-  
  
 Uma exceção foi lançada durante a execução da tarefa. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém informações sobre a exceção ou exceções.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">Um token de cancelamento a ser observado ao aguardar a conclusão da tarefa.</param>
        <summary>Aguarda o <see cref="T:System.Threading.Tasks.Task" /> concluir a execução. A espera termina se um token de cancelamento for cancelado antes que a tarefa seja concluída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> método cria uma espera cancelável; ou seja, ele faz com que o thread atual aguardar até que ocorra um dos seguintes:  
  
-   A tarefa é concluída.  
  
-   O token de cancelamento é cancelado. Nesse caso, a chamada para o <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> método lança um <xref:System.OperationCanceledException>.  
  
> [!NOTE]
>  Cancelando o `cancellationToken` token de cancelamento não tem efeito sobre a tarefa em execução, a menos que ele também foi passado o token de cancelamento e está preparado para lidar com cancelamento. Passando o `cancellationToken` objeto para este método simplesmente permite que a espera para ser cancelada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso simple de um token de cancelamento para cancelar aguardando a conclusão da tarefa. Uma tarefa é iniciada, chama o <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> método cancelar qualquer uma da origem de token tokens de cancelamento e, em seguida, atrasos de cinco segundos. Observe que a própria tarefa não passou o token de cancelamento e não é anulável. O thread de aplicativo chama a tarefa <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> método para aguardar a conclusão da tarefa, mas a espera for cancelada depois que o token de cancelamento é cancelado e um <xref:System.OperationCanceledException> é gerada. O manipulador de exceção relata a exceção e, em seguida, ficará suspenso por seis segundos. Como mostra a saída do exemplo, esse atraso permite que a tarefa concluir o <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">A tarefa foi descartada.</exception>
        <exception cref="T:System.AggregateException">A tarefa foi cancelada. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém um <see cref="T:System.Threading.Tasks.TaskCanceledException" /> objeto.  
  
 -ou-  
  
 Uma exceção foi lançada durante a execução da tarefa. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém informações sobre a exceção ou exceções.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Aguarda o <see cref="T:System.Threading.Tasks.Task" /> concluir a execução dentro de um intervalo especificado.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Threading.Tasks.Task" /> concluiu a execução dentro do tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>é um método de sincronização que faz com que o thread de chamada aguardar a instância atual da tarefa ser concluída até que ocorra um dos seguintes:  
  
-   A tarefa é concluída com êxito.  
  
-   A própria tarefa foi cancelada ou gera uma exceção. Nesse caso, você processa um <xref:System.AggregateException> exceção. O <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriedade contém detalhes sobre a exceção ou exceções.  
  
-   O intervalo definido pela `timeout` expira. Nesse caso, o thread atual continua a execução e o método retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma tarefa que gera cinco milhões de inteiros aleatórios entre 0 e 100 e computa sua média. O exemplo usa o <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> método de espera para o aplicativo ser concluída dentro de 150 milissegundos. Se o aplicativo for concluída normalmente, a tarefa exibe a soma e média dos números aleatórios que gerou. Se o intervalo de tempo limite expirou, o exemplo exibe uma mensagem antes de ele termina.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.AggregateException">A tarefa foi cancelada. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém um <see cref="T:System.Threading.Tasks.TaskCanceledException" /> objeto.  
  
 -ou-  
  
 Uma exceção foi lançada durante a execução da tarefa. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém informações sobre a exceção ou exceções.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um token de cancelamento a ser observado ao aguardar a conclusão da tarefa.</param>
        <summary>Aguarda o <see cref="T:System.Threading.Tasks.Task" /> concluir a execução. A espera termina se um intervalo de tempo limite expirar ou um token de cancelamento for cancelado antes que a tarefa seja concluída.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Threading.Tasks.Task" /> concluiu a execução dentro do tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>é um método de sincronização que faz com que o thread de chamada aguardar a instância atual da tarefa ser concluída até que ocorra um dos seguintes:  
  
-   A tarefa é concluída com êxito.  
  
-   A própria tarefa foi cancelada ou gera uma exceção. Nesse caso, você processa um <xref:System.AggregateException> exceção. O <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> propriedade contém detalhes sobre a exceção ou exceções.  
  
-   O `cancellationToken` token de cancelamento é cancelado. Nesse caso, a chamada para o <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> método lança um <xref:System.OperationCanceledException>.  
  
-   O intervalo definido pela `millisecondsTimeout` expira. Nesse caso, o thread atual continua a execução e o método retornará `false`.  
  
> [!NOTE]
>  Cancelando o `cancellationToken` token de cancelamento não tem efeito sobre a tarefa em execução, a menos que ele também foi passado o token de cancelamento e está preparado para lidar com cancelamento. Passando o `cancellationToken` objeto para este método simplesmente permite que a espera para ser cancelada com base em alguma condição.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> método para fornecer um valor de tempo limite e o cancelamento de um token que pode terminar a espera pela conclusão da tarefa. Um novo thread foi iniciado e executa o `CancelToken` método, que pausa e, em seguida, chama o <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> método para cancelar os tokens de cancelamento. Uma tarefa, em seguida, iniciado e atrasa por 5 segundos. O <xref:System.Threading.Tasks.Task.Wait%2A> método é chamado para aguardar a conclusão da tarefa e é fornecido um valor de tempo limite breve e um token de cancelamento.  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 Observe que a saída precisa do exemplo depende se a espera foi cancelada devido ao token de cancelamento ou porque o intervalo de tempo limite expirou.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.AggregateException">A tarefa foi cancelada. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém um <see cref="T:System.Threading.Tasks.TaskCanceledException" /> objeto.  
  
 -ou-  
  
 Uma exceção foi lançada durante a execução da tarefa. O <see cref="P:System.AggregateException.InnerExceptions" /> coleção contém informações sobre a exceção ou exceções.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <summary>Aguarda até que todos os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos tenham concluído a execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia 10 tarefas, cada um deles é passada um índice como um objeto de estado. Tarefas com um índice de duas a cinco lançam exceções. A chamada para o <xref:System.Threading.Tasks.Task.WaitAll%2A> método encapsula todas as exceções em um <xref:System.AggregateException> de objeto e propaga para o thread de chamada.  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um ou mais objetos <see cref="T:System.Threading.Tasks.Task" /> no <paramref name="tasks" /> foram descartados.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.  
  
 -ou-  
  
 O argumento <paramref name="tasks" /> é uma matriz vazia.</exception>
        <exception cref="T:System.AggregateException">Pelo menos uma das instâncias <see cref="T:System.Threading.Tasks.Task" /> foi cancelada. Se uma tarefa foi cancelada, o <see cref="T:System.AggregateException" /> exceção contém um <see cref="T:System.OperationCanceledException" /> exceção no seu <see cref="P:System.AggregateException.InnerExceptions" /> coleção.  
  
 -ou-  
  
 Uma exceção foi gerada durante a execução de, pelo menos, uma das instâncias <see cref="T:System.Threading.Tasks.Task" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Aguarda todos os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos concluírem a execução dentro de um número especificado de milissegundos.</summary>
        <returns>
          <see langword="true" /> se todas as instâncias do <see cref="T:System.Threading.Tasks.Task" /> tiverem concluído a execução no tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um ou mais objetos <see cref="T:System.Threading.Tasks.Task" /> no <paramref name="tasks" /> foram descartados.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Pelo menos uma das instâncias <see cref="T:System.Threading.Tasks.Task" /> foi cancelada. Se uma tarefa foi cancelada, o <see cref="T:System.AggregateException" /> contém um <see cref="T:System.OperationCanceledException" /> no seu <see cref="P:System.AggregateException.InnerExceptions" /> coleção.  
  
 -ou-  
  
 Uma exceção foi gerada durante a execução de, pelo menos, uma das instâncias <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.  
  
 -ou-  
  
 O argumento <paramref name="tasks" /> é uma matriz vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="cancellationToken">Um <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> a ser observado ao aguardar a conclusão das tarefas.</param>
        <summary>Aguarda até que todos os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos tenham concluído a execução, a menos que a espera seja cancelada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `cancellationToken` argumento é usado para cancelar a operação de espera. Cancelamento de tarefas é uma operação distinta e é sinalizado pelo <xref:System.AggregateException> conforme observado acima.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Pelo menos uma das instâncias <see cref="T:System.Threading.Tasks.Task" /> foi cancelada. Se uma tarefa foi cancelada, o <see cref="T:System.AggregateException" /> contém um <see cref="T:System.OperationCanceledException" /> no seu <see cref="P:System.AggregateException.InnerExceptions" /> coleção.  
  
 -ou-  
  
 Uma exceção foi gerada durante a execução de, pelo menos, uma das instâncias <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.  
  
 -ou-  
  
 O argumento <paramref name="tasks" /> é uma matriz vazia.</exception>
        <exception cref="T:System.ObjectDisposedException">Um ou mais objetos <see cref="T:System.Threading.Tasks.Task" /> no <paramref name="tasks" /> foram descartados.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Aguarda todos os objetos <see cref="T:System.Threading.Tasks.Task" /> canceláveis fornecidos concluírem a execução dentro de um intervalo de tempo especificado.</summary>
        <returns>
          <see langword="true" /> se todas as instâncias do <see cref="T:System.Threading.Tasks.Task" /> tiverem concluído a execução no tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">Um ou mais objetos <see cref="T:System.Threading.Tasks.Task" /> no <paramref name="tasks" /> foram descartados.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Pelo menos uma das instâncias <see cref="T:System.Threading.Tasks.Task" /> foi cancelada. Se uma tarefa foi cancelada, o <see cref="T:System.AggregateException" /> contém um <see cref="T:System.OperationCanceledException" /> no seu <see cref="P:System.AggregateException.InnerExceptions" /> coleção.  
  
 -ou-  
  
 Uma exceção foi gerada durante a execução de, pelo menos, uma das instâncias <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.  
  
 -ou-  
  
 O argumento <paramref name="tasks" /> é uma matriz vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> a ser observado ao aguardar a conclusão das tarefas.</param>
        <summary>Aguarda todos os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos concluírem a execução em um número especificado de milissegundos ou até que a espera seja cancelada.</summary>
        <returns>
          <see langword="true" /> se todas as instâncias do <see cref="T:System.Threading.Tasks.Task" /> tiverem concluído a execução no tempo determinado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `cancellationToken` argumento é usado para cancelar a operação de espera. Cancelamento de tarefas é uma operação distinta e é sinalizado pelo <xref:System.AggregateException> indicado acima.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Um ou mais objetos <see cref="T:System.Threading.Tasks.Task" /> no <paramref name="tasks" /> foram descartados.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.AggregateException">Pelo menos uma das instâncias <see cref="T:System.Threading.Tasks.Task" /> foi cancelada. Se uma tarefa foi cancelada, o <see cref="T:System.AggregateException" /> contém um <see cref="T:System.OperationCanceledException" /> no seu <see cref="P:System.AggregateException.InnerExceptions" /> coleção.  
  
 -ou-  
  
 Uma exceção foi gerada durante a execução de, pelo menos, uma das instâncias <see cref="T:System.Threading.Tasks.Task" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.  
  
 -ou-  
  
 O argumento <paramref name="tasks" /> é uma matriz vazia.</exception>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <summary>Aguarda até que todos os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos tenham concluído a execução.</summary>
        <returns>O índice do objeto <see cref="T:System.Threading.Tasks.Task" /> concluído na matriz <paramref name="tasks" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia cinco tarefas, cada uma delas ficará suspenso por um mínimo de 50 milissegundos ou um máximo de 1,050 milissegundos. O <xref:System.Threading.Tasks.Task.WaitAny%2A> método espera por qualquer uma das tarefas para concluir. O exemplo exibe a ID da tarefa da tarefa que terminou a espera, bem como o status atual de todas as tarefas.  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Aguarda qualquer um dos objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos concluírem a execução dentro de um número especificado de milissegundos.</summary>
        <returns>O índice da tarefa concluída no argumento da matriz <paramref name="tasks" /> ou -1 se o tempo limite ocorreu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="cancellationToken">Um <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> a ser observado ao aguardar a conclusão da tarefa.</param>
        <summary>Aguarda até que os objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos tenham concluído a execução, a menos que a espera seja cancelada.</summary>
        <returns>O índice da tarefa concluída no argumento da matriz <paramref name="tasks" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.</exception>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Aguarda algum dos objetos <see cref="T:System.Threading.Tasks.Task" /> fornecidos concluir a execução em um intervalo especificado.</summary>
        <returns>O índice da tarefa concluída no argumento da matriz <paramref name="tasks" /> ou -1 se o tempo limite ocorreu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks">Uma matriz de instâncias <see cref="T:System.Threading.Tasks.Task" /> para espera.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="cancellationToken">Um <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> a ser observado ao aguardar a conclusão da tarefa.</param>
        <summary>Aguarda a qualquer um dos fornecidos <see cref="T:System.Threading.Tasks.Task" /> objetos para concluir a execução dentro de um número especificado de milissegundos ou até que um token de cancelamento é cancelado.</summary>
        <returns>O índice da tarefa concluída no argumento da matriz <paramref name="tasks" /> ou -1 se o tempo limite ocorreu.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Threading.Tasks.Task" /> foi descartado.</exception>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="tasks" /> contém um elemento nulo.</exception>
        <exception cref="T:System.OperationCanceledException">O <paramref name="cancellationToken" /> foi cancelado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todos os objetos <see cref="T:System.Threading.Tasks.Task" /> em uma coleção enumerável forem concluídos.</summary>
        <returns>Uma tarefa que representa a conclusão de todas as tarefas fornecidas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Threading.Tasks.Task.WhenAll%2A> método que retorna um <xref:System.Threading.Tasks.Task> objeto normalmente são chamados quando você está interessado no status de um conjunto de tarefas ou a exceções lançadas por um conjunto de tarefas.  
  
> [!NOTE]
>  A chamada para <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método não bloqueia o thread de chamada.  
  
 Se qualquer uma das tarefas fornecidas é concluído em um estado de falha, a tarefa retornada também será concluída em um <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, em que suas exceções conterá a agregação do conjunto de exceções não encapsuladas de cada uma das tarefas fornecidas.  
  
 Se nenhuma das tarefas fornecidas com defeito, mas pelo menos um deles foi cancelado, a tarefa retornada terminará no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Se nenhuma das tarefas com falha e nenhuma das tarefas foram canceladas, a tarefa resultante terminará no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Se o fornecido matriz/enumerável não contém tarefas, a tarefa retornada imediatamente fará a transição para um <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de ser retornado ao chamador.  
  
   
  
## Examples  
 O exemplo a seguir cria um conjunto de tarefas que executar o ping de URLs em uma matriz. As tarefas são armazenadas em um `List<Task>` coleção que é passada para o <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método. Após a chamada para o <xref:System.Threading.Tasks.Task.Wait%2A> método garante que todos os threads concluir, o exemplo examina o <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriedade para determinar se todas as tarefas têm com defeito.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A coleção <paramref name="tasks" /> continha uma tarefa <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todos os objetos <see cref="T:System.Threading.Tasks.Task" /> em uma matriz forem concluídos.</summary>
        <returns>Uma tarefa que representa a conclusão de todas as tarefas fornecidas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Threading.Tasks.Task.WhenAll%2A> método que retorna um <xref:System.Threading.Tasks.Task> objeto normalmente são chamados quando você está interessado no status de um conjunto de tarefas ou a exceções lançadas por um conjunto de tarefas.  
  
> [!NOTE]
>  A chamada para <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> método não bloqueia o thread de chamada.  
  
 Se qualquer uma das tarefas fornecidas é concluído em um estado de falha, a tarefa retornada também será concluída em um <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, em que suas exceções conterá a agregação do conjunto de exceções não encapsuladas de cada uma das tarefas fornecidas.  
  
 Se nenhuma das tarefas fornecidas com defeito, mas pelo menos um deles foi cancelado, a tarefa retornada terminará no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Se nenhuma das tarefas com falha e nenhuma das tarefas foram canceladas, a tarefa resultante terminará no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  
  
 Se o fornecido matriz/enumerável não contém tarefas, a tarefa retornada imediatamente fará a transição para um <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de ser retornado ao chamador.  
  
   
  
## Examples  
 O exemplo a seguir cria um conjunto de tarefas que executar o ping de URLs em uma matriz. As tarefas são armazenadas em um `List<Task>` coleção que é convertida em uma matriz e passada para o <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> método. Após a chamada para o <xref:System.Threading.Tasks.Task.Wait%2A> método garante que todos os threads concluir, o exemplo examina o <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> propriedade para determinar se todas as tarefas têm com defeito.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de tarefa concluída.</typeparam>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todos os objetos <see cref="T:System.Threading.Tasks.Task`1" /> em uma coleção enumerável forem concluídos.</summary>
        <returns>Uma tarefa que representa a conclusão de todas as tarefas fornecidas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A chamada para <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> método não bloqueia o thread de chamada. No entanto, uma chamada para retornado <xref:System.Threading.Tasks.Task%601.Result%2A> propriedade bloquear o thread de chamada.  
  
 Se qualquer uma das tarefas fornecidas é concluído em um estado de falha, a tarefa retornada também será concluída em um <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, em que suas exceções conterá a agregação do conjunto de exceções não encapsuladas de cada uma das tarefas fornecidas.  
  
 Se nenhuma das tarefas fornecidas com defeito, mas pelo menos um deles foi cancelado, a tarefa retornada terminará no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Se nenhuma das tarefas com falha e nenhuma das tarefas foram canceladas, a tarefa resultante terminará no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  O <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> definirá a propriedade da tarefa retornada para uma matriz que contém todos os resultados das tarefas fornecidos na mesma ordem como eles foram fornecidos (por exemplo, se a entrada tarefas matriz contida t1, t2, t3, a tarefa de saída <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> propriedade retornará um `TResult[]` onde `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se o `tasks` argumento não contém tarefas, a tarefa retornada imediatamente fará a transição para um <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de ser retornado ao chamador. Retornado `TResult[]` será uma matriz de elementos de 0.  
  
   
  
## Examples  
 O exemplo a seguir cria dez tarefas, cada uma delas instancia um gerador de número aleatório que cria 1.000 números aleatórios entre 1 e 1.000 e computa sua média. O <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> método é usado para atrasar a instanciação de geradores de números aleatórios para que eles não são criados com valores de semente idênticos. A chamada para o <xref:System.Threading.Tasks.Task.WhenAll%2A> , em seguida, o método retorna um <xref:System.Int64> matriz que contém a média calculada por cada tarefa. Em seguida, eles são usados para calcular a média geral.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 Nesse caso, as dez tarefas individuais são armazenadas em um <xref:System.Collections.Generic.List%601> objeto. <xref:System.Collections.Generic.List%601> implementa a interface <xref:System.Collections.Generic.IEnumerable%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A coleção <paramref name="tasks" /> continha uma tarefa <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de tarefa concluída.</typeparam>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todos os objetos <see cref="T:System.Threading.Tasks.Task`1" /> em uma matriz forem concluídos.</summary>
        <returns>Uma tarefa que representa a conclusão de todas as tarefas fornecidas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A chamada para <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> método não bloqueia o thread de chamada. No entanto, uma chamada para retornado <xref:System.Threading.Tasks.Task%601.Result%2A> propriedade bloquear o thread de chamada.  
  
 Se qualquer uma das tarefas fornecidas é concluído em um estado de falha, a tarefa retornada também será concluída em um <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, em que suas exceções conterá a agregação do conjunto de exceções não encapsuladas de cada uma das tarefas fornecidas.  
  
 Se nenhuma das tarefas fornecidas com defeito, mas pelo menos um deles foi cancelado, a tarefa retornada terminará no <xref:System.Threading.Tasks.TaskStatus.Canceled> estado.  
  
 Se nenhuma das tarefas com falha e nenhuma das tarefas foram canceladas, a tarefa resultante terminará no <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado.  O <xref:System.Threading.Tasks.Task%601.Result%2A> da tarefa retornada será definido como uma matriz que contém todos os resultados das tarefas fornecidos na mesma ordem como eles foram fornecidos (por exemplo, se a entrada tarefas matriz contida t1, t2, t3, a tarefa de saída <xref:System.Threading.Tasks.Task%601.Result%2A> retornará um `TResult[]` onde `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.  
  
 Se o fornecido matriz/enumerável não contém tarefas, a tarefa retornada imediatamente fará a transição para um <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> estado antes de ser retornado ao chamador.  Retornado `TResult[]` será uma matriz de elementos de 0.  
  
   
  
## Examples  
 O exemplo a seguir cria dez tarefas, cada uma delas instancia um gerador de número aleatório que cria 1.000 números aleatórios entre 1 e 1.000 e computa sua média. Nesse caso, as dez tarefas individuais são armazenadas em um `Task<Int64>` matriz.  O <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> método é usado para atrasar a instanciação de geradores de números aleatórios para que eles não são criados com valores de semente idênticos. A chamada para o <xref:System.Threading.Tasks.Task.WhenAll%2A> , em seguida, o método retorna um <xref:System.Int64> matriz que contém a média calculada por cada tarefa. Em seguida, eles são usados para calcular a média geral.  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todas as tarefas fornecidas forem concluídas.</summary>
        <returns>Uma tarefa que representa a conclusão de uma das tarefas fornecidas.  O Resultado da tarefa de retorno é a tarefa concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa retornada será concluída quando qualquer uma das tarefas fornecidas foi concluída.  A tarefa retornada sempre terminará no `RanToCompletion` estado com seu conjunto de resultados para a primeira tarefa para ser concluída.  Isso é verdadeiro mesmo se a primeira tarefa para concluir terminou no `Canceled` ou `Faulted` estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa nula ou estava vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todas as tarefas fornecidas forem concluídas.</summary>
        <returns>Uma tarefa que representa a conclusão de uma das tarefas fornecidas.  O Resultado da tarefa de retorno é a tarefa concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa retornada será concluída quando qualquer uma das tarefas fornecidas foi concluída.  A tarefa retornada sempre terminará no `RanToCompletion` estado com seu `Result` definido para a primeira tarefa para ser concluído.  Isso é verdadeiro mesmo se a primeira tarefa para concluir terminou no `Canceled` ou `Faulted` estado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> era nulo.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa nula ou estava vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de tarefa concluída.</typeparam>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todas as tarefas fornecidas forem concluídas.</summary>
        <returns>Uma tarefa que representa a conclusão de uma das tarefas fornecidas.  O Resultado da tarefa de retorno é a tarefa concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa retornada será concluída quando qualquer uma das tarefas fornecidas foi concluída.  A tarefa retornada sempre terminará no estado RanToCompletion com seu conjunto de resultados para a primeira tarefa para ser concluída. Isso é verdadeiro mesmo se tiver terminado a primeira tarefa para ser concluída no estado cancelado ou com falha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa nula ou estava vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo de tarefa concluída.</typeparam>
        <param name="tasks">As tarefas para aguardar pela conclusão.</param>
        <summary>Cria uma tarefa que será concluída quando todas as tarefas fornecidas forem concluídas.</summary>
        <returns>Uma tarefa que representa a conclusão de uma das tarefas fornecidas.  O Resultado da tarefa de retorno é a tarefa concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa retornada será concluída quando qualquer uma das tarefas fornecidas foi concluída.  A tarefa retornada sempre terminará no estado RanToCompletion com seu conjunto de resultados para a primeira tarefa para ser concluída. Isso é verdadeiro mesmo se tiver terminado a primeira tarefa para ser concluída no estado cancelado ou com falha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="tasks" /> era nulo.</exception>
        <exception cref="T:System.ArgumentException">A matriz <paramref name="tasks" /> continha uma tarefa nula ou estava vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma tarefa que é possível aguardar que retorna assincronamente para o contexto atual quando aguardada.</summary>
        <returns>Um contexto que, quando aguardado, fará a transição de maneira assíncrona de volta ao contexto atual ao aguardar. Se o atual <see cref="T:System.Threading.SynchronizationContext" /> é não nulo, ele será tratado como o contexto atual. Caso contrário, o Agendador de Tarefas associado à tarefa em execução no momento será tratado como o contexto atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar `await Task.Yield();` em um método assíncrono para forçar o método de conclusão de forma assíncrona. Se houver um contexto de sincronização atual (<xref:System.Threading.SynchronizationContext> objeto), isso publicará o restante da execução do método para esse contexto. No entanto, o contexto decidirá como priorizar esse trabalho em relação a outro trabalho que pode estar pendente. O contexto de sincronização que está presente em um thread de interface do usuário na maioria dos ambientes de interface do usuário será geralmente priorizar lançado para o contexto maior do que a entrada e o trabalho de processamento de trabalho. Por esse motivo, não confie em `await Task.Yield();` manter uma interface do usuário responsiva.  Para obter mais informações, consulte a entrada [útil abstrações habilitado com o método ContinueWith](http://blogs.msdn.com/b/pfxteam/archive/2008/07/23/8768673.aspx) em programação paralela com .NET blog.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
