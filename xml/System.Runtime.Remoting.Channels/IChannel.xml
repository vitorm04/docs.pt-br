<Type Name="IChannel" FullName="System.Runtime.Remoting.Channels.IChannel">
  <TypeSignature Language="C#" Value="public interface IChannel" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IChannel" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.Channels.IChannel" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece os canais para mensagens que ultrapassam os limites de comunicação remota.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os limites de comunicação remota podem ser <xref:System.Runtime.Remoting.Contexts.Context>s, <xref:System.AppDomain>s, processos ou computadores. Um aplicativo pode atravessar esses limites usando os canais. Esses cruzamentos podem ser de entrada e saída. Um canal pode escutar em um ponto de extremidade de mensagens de entrada, enviar para um ponto de extremidade para as mensagens de saída, ou ambos. Isso fornece um ponto de extensibilidade no tempo de execução de protocolos uma ampla gama, mesmo que o tempo de execução não pode ser na outra extremidade do canal.  
  
 Objetos de tempo de execução podem ser usados para representar um conjunto de entidades e semântica amplo e Avançado. O canal fornece o ponto de extensibilidade para converter as mensagens para e de protocolos específicos. Se houver tempos de execução de ambas as extremidades do canal, um canal virtual é criado entre as duas extremidades, para conectar-se as cadeias de coletor do cliente e servidor em ambos os lados do limite.  
  
 A parte do cliente do canal está localizada no final de uma cadeia de coletor de contexto do cliente. A parte do canal de servidor está localizada no início da cadeia de coletor do contexto de servidor. As mensagens são entregues para o canal de cliente usando o <xref:System.Runtime.Remoting.Messaging.IMessageSink> de interface, percorrer o canal e, em seguida, são recebidas pelo canal de servidor. O canal do servidor de entrega a mensagem para o primeiro coletor de contexto do servidor.  
  
 Canais devem expor o <xref:System.Runtime.Remoting.Channels.IChannel> interface, que fornece propriedades informativas, como o <xref:System.Runtime.Remoting.Channels.IChannel.ChannelName%2A> e <xref:System.Runtime.Remoting.Channels.IChannel.ChannelPriority%2A> propriedades. Canais podem ser registrados usando o <xref:System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChannelName">
      <MemberSignature Language="C#" Value="public string ChannelName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ChannelName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.IChannel.ChannelName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do canal.</summary>
        <value>O nome do canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[HttpServerChannel_Server_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CPP/httpserverchannel_9_server.cpp#2)]
 [!code-csharp[HttpServerChannel_Server_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CS/httpserverchannel_9_server.cs#2)]
 [!code-vb[HttpServerChannel_Server_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpServerChannel_Server_Client/VB/httpserverchannel_9_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ChannelPriority">
      <MemberSignature Language="C#" Value="public int ChannelPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ChannelPriority" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.Channels.IChannel.ChannelPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a prioridade do canal.</summary>
        <value>Um inteiro que indica a prioridade do canal.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números mais altos indicam uma prioridade mais alta, portanto, um canal com prioridade de 50 tem uma prioridade maior que um canal com prioridade 25. O canal de domínio entre aplicativos tem uma prioridade de 100.  
  
 Canais de cliente com prioridade superior terão a oportunidade de primeiro para se conectar a um objeto remoto especificado por uma URL ou uma entrada de dados de canal específico de um <xref:System.Runtime.Remoting.ObjRef>.  
  
 Para canais de servidor, a prioridade indica a ordem na qual os dados de canal aparecerá em um <xref:System.Runtime.Remoting.ObjRef>, que por sua vez afeta a ordem na qual os clientes tentarão conectar-se ao objeto do servidor. Se o servidor está escutando em um canal de HTTP com prioridade 50 e um canal TCP com prioridade 25 e o cliente registrou um HTTP e TCP de canal, o cliente usará o canal de HTTP para se comunicar com o servidor.  
  
   
  
## Examples  
 [!code-cpp[HttpServerChannel_Server_Client#5](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CPP/httpclientchannel_6_client.cpp#5)]
 [!code-csharp[HttpServerChannel_Server_Client#5](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CS/httpclientchannel_6_client.cs#5)]
 [!code-vb[HttpServerChannel_Server_Client#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpServerChannel_Server_Client/VB/httpclientchannel_6_client.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public string Parse (string url, out string objectURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string Parse(string url, [out] string&amp; objectURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.Channels.IChannel.Parse(System.String,System.String@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="objectURI" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="url">A URL do objeto.</param>
        <param name="objectURI">Quando este método retorna, contém um <see cref="T:System.String" /> que contém o objeto URI. Este parâmetro é passado não inicializado.</param>
        <summary>Retorna o objeto URI como um parâmetro de saída e o URI do canal atual como o valor de retorno.</summary>
        <returns>O URI do canal atual, ou <see langword="null" /> se o URI não pertence a esse canal.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[HttpServerChannel_Server_Client#5](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CPP/httpclientchannel_6_client.cpp#5)]
 [!code-csharp[HttpServerChannel_Server_Client#5](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpServerChannel_Server_Client/CS/httpclientchannel_6_client.cs#5)]
 [!code-vb[HttpServerChannel_Server_Client#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpServerChannel_Server_Client/VB/httpclientchannel_6_client.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador imediato não tem permissão de infraestrutura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para a operação com código de infraestrutura. Valor de demanda: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />; Valor de permissão:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
