<Type Name="BitmapCache" FullName="System.Windows.Media.BitmapCache">
  <TypeSignature Language="C#" Value="public sealed class BitmapCache : System.Windows.Media.CacheMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed BitmapCache extends System.Windows.Media.CacheMode" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.BitmapCache" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.CacheMode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Cria e armazena em cache uma representação de um <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Windows.Media.BitmapCache> classe para melhorar o desempenho de renderização de um complexo <xref:System.Windows.UIElement>. Criar um <xref:System.Windows.Media.BitmapCache> e atribuí-la para o <xref:System.Windows.UIElement.CacheMode%2A> propriedade de um <xref:System.Windows.UIElement> para armazenar em cache o elemento e sua subárvore como um bitmap na memória de vídeo. Isso é útil quando você precisa animar, converter ou dimensionar uma <xref:System.Windows.UIElement> assim que possível. Essa abordagem permite um equilíbrio entre desempenho e qualidade visual enquanto o conteúdo é armazenado em cache.  
  
 Use o <xref:System.Windows.Media.BitmapCacheBrush> classe eficiente reutilizar um elemento em cache.  
  
 Definir o <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> propriedade dimensionar o cache de bitmap. Isso é útil se um elemento será ampliado e você deseja que o elemento para processar mais clara do que seria se o cache simplesmente foram gerado em resolução nativa do elemento.  
  
 Definir o <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> propriedade quando o cache de conteúdo que requer alinhamento de pixel para processar corretamente, como texto ClearType é exibida. Essa propriedade será ignorada pelo <xref:System.Windows.Media.BitmapCacheBrush> e <xref:System.Windows.Media.Media3D.Viewport2DVisual3D> classes.  
  
 Cache de um controle não afeta o comportamento de passar o mouse, teste de clique para passar o mouse funciona como se fosse o bitmap de um controle em tempo real.  
  
 Regeneração de cache só ocorre quando a estrutura do <xref:System.Windows.UIElement> ou suas alterações de subárvore, ou quando o <xref:System.Windows.Media.CacheMode> alteração das configurações. Definindo o <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> ou <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> causas de propriedades cache regeneração. Alterações na árvore visual pai de cache <xref:System.Windows.UIElement>, como transformações, escalas, opacidades e efeitos, não afeta o cache.  
  
 As funções de cache quando a aceleração de hardware não está disponível. Nesse caso, o bitmap é renderizado no software e as dimensões de máximo de bitmap são 2048 x 2048.  
  
> [!NOTE]
>  <xref:System.Windows.Media.RenderOptions>e <xref:System.Windows.Media.TextOptions> não são propagadas por meio de um elemento em cache. Talvez você precise definir essas opções novamente nos elementos filho abaixo do cache.  
  
   
  
## Examples  
 O XAML a seguir mostra como o cache um <xref:System.Windows.Controls.Canvas> elemento. Para o exemplo de código completo, consulte [como: melhorar o desempenho de processamento por um elemento de cache](~/docs/framework/wpf/graphics-multimedia/how-to-improve-rendering-performance-by-caching-an-element.md).  
  
 [!code-xaml[System.Windows.Media.BitmapCache#_BitmapCacheCreation](~/samples/snippets/csharp/VS_Snippets_Wpf/system.windows.media.bitmapcache/cs/window1.xaml#_bitmapcachecreation)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitmapCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Media.BitmapCache" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BitmapCache (double renderAtScale);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 renderAtScale) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.#ctor(System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="renderAtScale" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="renderAtScale">Um duplo que dimensiona o bitmap.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Media.BitmapCache" /> classe com a escala especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O XAML a seguir mostra como criar e atribuir uma <xref:System.Windows.Media.BitmapCache> para um <xref:System.Windows.Controls.Canvas> elemento. Para o exemplo de código completo, consulte [como: melhorar o desempenho de processamento por um elemento de cache](~/docs/framework/wpf/graphics-multimedia/how-to-improve-rendering-performance-by-caching-an-element.md).  
  
 [!code-xaml[System.Windows.Media.BitmapCache#_BitmapCacheCreation](~/samples/snippets/csharp/VS_Snippets_Wpf/system.windows.media.bitmapcache/cs/window1.xaml#_bitmapcachecreation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapCache Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.BitmapCache Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapCache</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável do <see cref="T:System.Windows.Media.BitmapCache" />, fazendo cópias em profundidade dos valores do objeto. Ao copiar as propriedades de dependência do objeto, esse método copia expressões (que não podem resolver) mas não animações ou seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. O objeto clonado <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade <see langword="false" /> mesmo se a fonte <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade<see langword="true." /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapCache CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.BitmapCache CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.CloneCurrentValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapCache</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um clone modificável (cópia em profundidade) o <see cref="T:System.Windows.Media.BitmapCache" /> usando seus valores atuais.</summary>
        <returns>Um clone modificável do objeto atual. O objeto clonado <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade <see langword="false" /> mesmo se a fonte <see cref="P:System.Windows.Freezable.IsFrozen" /> é de propriedade<see langword="true." /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.BitmapCache.CreateInstanceCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableClearType">
      <MemberSignature Language="C#" Value="public bool EnableClearType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClearType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.EnableClearType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o bitmap é renderizado com ClearType ativado.</summary>
        <value>
          <see langword="true" />Se ClearType estiver ativo; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> propriedade para permitir que o texto ClearType ser renderizado no cache.  
  
 Quando o <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> é de propriedade `true`, seu aplicativo deve processar todo o texto ClearType em um plano de fundo opaco.  
  
 Quando o <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> é de propriedade `false`, texto no cache é renderizado com suavização de escala de cinza.  
  
 Texto ClearType requer alinhamento de pixel correta de caracteres renderizados, portanto, você deve definir o <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> propriedade `true`. Se você não definir essa propriedade, o conteúdo pode não estar corretamente.  
  
 Use o <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> propriedade quando você sabe que o cache é processada em limites de pixel, portanto, é seguro para armazenar em cache ClearType texto. Essa situação normalmente ocorre em cenários de rolagem de texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableClearTypeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EnableClearTypeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EnableClearTypeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.EnableClearTypeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Media.BitmapCache.EnableClearType" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderAtScale">
      <MemberSignature Language="C#" Value="public double RenderAtScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 RenderAtScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.RenderAtScale" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica a escala é aplicada para o bitmap.</summary>
        <value>A escala é aplicada para o bitmap. O padrão é 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> propriedade para renderizar o <xref:System.Windows.Media.BitmapCache> em um múltiplo do tamanho do bitmap normal. O tamanho normal é determinado pelo tamanho do elemento local.  
  
 Valores maiores que 1 aumentar a resolução do bitmap em relação a resolução nativa do elemento e valores menor que 1 diminuir a resolução. Por exemplo, se o <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> está definida como 2.0 e você aplicar uma transformação de escala que amplia o conteúdo por um fator de 2, o conteúdo terá o mesmo conteúdo com a mesma qualidade visual <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> definido como 1.0 e uma escala de transformação de 1.  
  
 Quando <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> é definido como 0, nenhum bitmap é renderizado. Valores negativos são fixados como 0.  
  
 Se você alterar esse valor, o cache é gerada novamente com a resolução apropriada de novo.  
  
 As imagens a seguir mostram como o mesmo conteúdo é exibido para valores diferentes de <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> propriedade.  
  
 **RenderAtScale = 1**  
  
 ![RenderAtScale &#61; 1](~/add/media/ndp-scale-1.png "RenderAtScale = 1")  
  
 **RenderAtScale = 0,5**  
  
 ![RenderAtScale &#61; 0,5](~/add/media/ndp-scale05.png "RenderAtScale = 0,5")  
  
 **RenderAtScale = 0,2**  
  
 ![RenderAtScale &#61; 0,2](~/add/media/ndp-scale02.png "RenderAtScale = 0,2")  
  
 A imagem a seguir mostra uma transformação de zoom que é aplicada a um ancestral do elemento em cache. Quando o zoom é definido como 1 e <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> é definido como 1, a qualidade da imagem é quase o mesmo que quando <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> é definido como 2. Mas quando o zoom é maior que 1, definindo <xref:System.Windows.Media.BitmapCache.RenderAtScale%2A> 2 será ter melhor qualidade da imagem.  
  
 **RenderAtScale = 1.0**  
  
 ![RenderAtScale &#61; 1.0](~/add/media/ndp-scale-10.png "RenderAtScale = 1.0")  
  
 **RenderAtScale = 2.0**  
  
 ![RenderAtScale &#61; 2.0](~/add/media/ndp-scale-20.png "RenderAtScale = 2.0")  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderAtScaleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderAtScaleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderAtScaleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.RenderAtScaleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Media.BitmapCache.RenderAtScale" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.BitmapCache.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o bitmap é renderizado com o ajuste de pixel.</summary>
        <value>
          <see langword="true" />Se o ajuste de pixel estiver ativo; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> propriedade quando o cache exibe o conteúdo que requer alinhamento de pixel para processar corretamente. Esse é o caso para texto ClearType. Se você definir o <xref:System.Windows.Media.BitmapCache.EnableClearType%2A> propriedade `true`, considere a configuração de <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> para `true` para garantir a renderização correta.  
  
 Quando o <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> está definida como `false`, você pode mover e redimensionar o elemento em cache por uma fração de um pixel e filtragem bilinear é aplicada.  
  
 Quando o <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> está definida como `true`, o cache de bitmap é alinhado com limites de pixel do destino. Se você mover ou redimensionar o elemento em cache por uma fração de um pixel, o bitmap se encaixa à grade de pixels. Nesse caso, o canto superior esquerdo do bitmap é arredondado para cima e ajustado para a grade de pixels, mas o canto inferior direito está em um limite de pixel fracionários.  
  
 O <xref:System.Windows.Media.BitmapCache.SnapsToDevicePixels%2A> propriedade é ignorada por <xref:System.Windows.Media.BitmapCacheBrush> e quando usado com um <xref:System.Windows.Media.Media3D.Viewport2DVisual3D>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.BitmapCache.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Media.BitmapCache.SnapsToDevicePixels" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
