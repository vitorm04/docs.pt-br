<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expõe um arquivo no armazenamento isolado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta classe para ler, gravar e criar arquivos no armazenamento isolado.  
  
 Como essa classe estende <xref:System.IO.FileStream>, você pode usar uma instância de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> na maioria das situações em que um <xref:System.IO.FileStream> caso contrário, podem ser usadas, como construir um <xref:System.IO.StreamReader> ou <xref:System.IO.StreamWriter>.  
  
 Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
> [!IMPORTANT]
>  O armazenamento isolado não está disponível para aplicativos [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)]. Em vez disso, use as classes de dados de aplicativos nos namespaces `Windows.Storage` incluídos na API [!INCLUDE[wrt](~/includes/wrt-md.md)] para armazenar dados e arquivos locais. Para saber mais, confira [Dados de aplicativo](http://go.microsoft.com/fwlink/?LinkId=229175) no Centro de Desenvolvimento do Windows.  
  
   
  
## Examples  
 O aplicativo de console a seguir demonstra como você pode usar <xref:System.IO.IsolatedStorage.IsolatedStorageFile> e <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> para gravar dados em um arquivo de armazenamento isolado. O usuário é solicitado a entrar. Se o usuário for um novo usuário, uma URL de notícias e uma URL de esportes são registradas como preferências pessoais no armazenamento isolado. Se o usuário for um usuário de retorno, as preferências do usuário atual são exibidas. Os exemplos de código usados em todo este namespace são apresentados no contexto desse aplicativo de exemplo. Você pode usar o [Storeadm.exe (ferramenta de armazenamento isolado)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) utilitário para listar e remover os arquivos de armazenamento isolado que são criados com este aplicativo de console.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <summary>Inicializa uma nova instância de um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto fornecendo acesso ao arquivo designado pelo <paramref name="path" /> do <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O armazenamento isolado que é usado é limitado por identidade do assembly em execução atual e que o domínio de aplicativo no qual ele está em execução. Esse repositório permanecerá aberto somente para o tempo de vida de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar um escopo diferente de armazenamento isolado, ou para permitir que o armazenamento permanecer aberta (portanto, vários <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos podem ser abertos dele), use o formulário de construtor que aceita uma <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 O `mode` parâmetro indica se deve ser criado um novo arquivo, um existente usada e assim por diante.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório no <paramref name="path" /> não existe.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não foi encontrado e o <paramref name="mode" /> é definido como<see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> classe dar acesso ao arquivo designado pelo <paramref name="path" />, especificado na <paramref name="mode" />, com o tipo de <paramref name="access" /> solicitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O armazenamento isolado que é usado é limitado por identidade do assembly em execução atual e que o domínio de aplicativo no qual ele está em execução. Esse repositório permanecerá aberto somente para o tempo de vida de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar um escopo diferente de armazenamento isolado, ou para permitir que o armazenamento permanecer aberta (portanto, vários <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos podem ser abertos dele), use o formulário de construtor que aceita uma <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 O `mode` parâmetro indica se deve ser criado um novo arquivo ou um existente usada. O `access` parâmetro inclui somente leitura, leitura/gravação e somente gravação.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="isf">O <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> no qual o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> será aberto.</param>
        <summary>Inicializa uma nova instância da classe de <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando acesso ao arquivo designado por <paramref name="path" />, no <paramref name="mode" /> especificado e no contexto do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> especificado por <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `mode` parâmetro indica se deve ser criado um novo arquivo, um existente usada e assim por diante.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse construtor. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          O <paramref name="isf" /> não tem uma cota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileShare" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> classe dar acesso ao arquivo designado pelo <paramref name="path" />, especificado na <paramref name="mode" />, com o arquivo especificado <paramref name="access" />, usando o arquivo de compartilhamento de modo especificado por <paramref name="share" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O armazenamento isolado que é usado é limitado por identidade do assembly em execução atual e que o domínio de aplicativo no qual ele está em execução. Esse repositório permanecerá aberto somente para o tempo de vida de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar um escopo diferente de armazenamento isolado, ou para permitir que o armazenamento permanecer aberta (portanto, vários <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos podem ser abertos dele), use o formulário de construtor que aceita uma <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse construtor. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <param name="isf">O <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> no qual o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> será aberto.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dando acesso ao arquivo designado por <paramref name="path" /> no <paramref name="mode" /> especificado, com o arquivo <paramref name="access" /> especificado e no contexto do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> especificado por <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `mode` parâmetro indica se deve ser criado um novo arquivo ou um existente usada. O `access` parâmetro inclui somente leitura, leitura/gravação e somente gravação.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse construtor. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O repositório isolado está fechado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          O <paramref name="isf" /> não tem uma cota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileShare" />.</param>
        <param name="bufferSize">O <see cref="T:System.IO.FileStream" /> tamanho do buffer.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> classe dar acesso ao arquivo designado pelo <paramref name="path" />, especificado na <paramref name="mode" />, com o arquivo especificado <paramref name="access" />, usando o arquivo especificado de modo de compartilhamento <paramref name="share" />, com o <paramref name="buffersize" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O armazenamento isolado que é usado é limitado por identidade do assembly em execução atual e que o domínio de aplicativo no qual ele está em execução. Esse repositório permanecerá aberto somente para o tempo de vida de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para especificar um escopo diferente de armazenamento isolado, ou para permitir que o armazenamento permanecer aberta (portanto, vários <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos podem ser abertos dele), use o formulário de construtor que aceita uma <xref:System.IO.IsolatedStorage.IsolatedStorageFile> objeto.  
  
 O `mode` parâmetro indica se deve ser criado um novo arquivo ou um existente usada. O `access` parâmetro inclui somente leitura, leitura/gravação e somente gravação.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileShare" />.</param>
        <param name="isf">O <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> no qual o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> será aberto.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> classe dar acesso ao arquivo designado pelo <paramref name="path" />, especificado na <paramref name="mode" />, com o arquivo especificado <paramref name="access" />, usando o arquivo de compartilhamento de modo especificado por <paramref name="share" />e no contexto de o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> especificado por <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `mode` parâmetro indica se deve ser criado um novo arquivo ou um existente usada. O `access` parâmetro inclui somente leitura, leitura/gravação e somente gravação.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse construtor. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          O <paramref name="isf" /> não tem uma cota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo do arquivo no armazenamento isolado.</param>
        <param name="mode">Um dos valores de <see cref="T:System.IO.FileMode" />.</param>
        <param name="access">Uma combinação bit a bit dos valores <see cref="T:System.IO.FileAccess" />.</param>
        <param name="share">Uma combinação bit a bit do <see cref="T:System.IO.FileShare" /> valores</param>
        <param name="bufferSize">O <see cref="T:System.IO.FileStream" /> tamanho do buffer.</param>
        <param name="isf">O <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> no qual o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> será aberto.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> classe dar acesso ao arquivo designado pelo <paramref name="path" />, especificado na <paramref name="mode" />, com o arquivo especificado <paramref name="access" />, usando o arquivo especificado de modo de compartilhamento <paramref name="share" />, com o <paramref name="buffersize" /> especificado e no contexto da <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> especificado por <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `mode` parâmetro indica se deve ser criado um novo arquivo ou um existente usada. O `access` parâmetro inclui somente leitura, leitura/gravação e somente gravação.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse construtor. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> está mal formado.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nenhum arquivo foi encontrado e o <paramref name="mode" /> está definido como <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          O <paramref name="isf" /> não tem uma cota.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">para acesso de armazenamento isolado</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer no qual os dados serão lidos.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a ler.</param>
        <param name="numBytes">O número máximo de bytes a serem lidos.</param>
        <param name="userCallback">O método a ser chamado quando a operação de leitura assíncrona é concluída. Esse parâmetro é opcional.</param>
        <param name="stateObject">O status da leitura assíncrona.</param>
        <summary>Começa uma leitura assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> ler de objeto que representa o assíncrona, que é possivelmente ainda pendente. Isso <see cref="T:System.IAsyncResult" /> deve ser passado para esse fluxo <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> método para determinar o número de bytes foram lidas. Isso pode ser feito com o mesmo código que chamou um <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ou em um retorno de chamada transmitido para <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A posição atual no fluxo é atualizada quando você emitir a gravação ou leitura assíncrona não quando a operação de e/s é concluída.  
  
 Você deve chamar <xref:System.IO.Stream.EndRead%2A> com essa <xref:System.IAsyncResult> para descobrir o número de bytes foram lidas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu uma tentativa de leitura assíncrona após o final do arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para gravar dados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a escrever.</param>
        <param name="numBytes">O número máximo de bytes a serem gravados.</param>
        <param name="userCallback">O método a ser chamado quando a operação de gravação assíncrona é concluída. Esse parâmetro é opcional.</param>
        <param name="stateObject">O status da gravação assíncrona.</param>
        <summary>Começa uma gravação assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a gravação assíncrona, que é possivelmente ainda pendente. Isso <see cref="T:System.IAsyncResult" /> deve ser passado para esse fluxo <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> método para garantir que a gravação seja concluída, em seguida, libera recursos adequadamente. Isso pode ser feito com o mesmo código que chamou um <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> ou em um retorno de chamada transmitido para <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto é gravável, gravando no final do fluxo expande o fluxo.  
  
 A posição atual no fluxo é atualizada quando você emitir a gravação ou leitura assíncrona não quando a operação de e/s é concluída.  
  
 Você deve chamar <xref:System.IO.Stream.EndWrite%2A> com o <xref:System.IAsyncResult> objeto retornado por esse método para descobrir o número de bytes foram gravado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Uma gravação assíncrona foi tentada após o fim do arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor booliano que indica se o arquivo pode ser lido.</summary>
        <value>
          <see langword="true" />Se um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto pode ser lido; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta propriedade para determinar se o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto pode ser lido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> a propriedade, como uma verificação para ver se um fluxo pode ser lido antes de chamar o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> ou <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> métodos. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor booliano que indica se busca operações têm suporte.</summary>
        <value>
          <see langword="true" />Se um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto oferece suporte a operações de busca; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta propriedade para determinar se o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto oferece suporte a operações de busca.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor booliano que indica se você pode gravar no arquivo.</summary>
        <value>
          <see langword="true" />Se um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto pode ser gravadas; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta propriedade para determinar se o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto podem ser gravados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> a propriedade, como uma verificação para ver se um fluxo pode ser lido antes de chamar o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> ou <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> métodos. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.IDisposable.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.IDisposable.Dispose%2A>invoca o protegido <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> método com o `disposing` como verdadeiro. <xref:System.Object.Finalize%2A>invoca <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> com `disposing` definido como false.  
  
 Quando o `disposing` parâmetro for true, este método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> referências. Este método invoca o método <xref:System.IDisposable.Dispose%2A> de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IDisposable.Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, tome cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see cref="M:System.IDisposable.Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação assíncrona pendente.</param>
        <summary>Encerra uma solicitação de leitura assíncrona pendente.</summary>
        <returns>O número de bytes lidos do fluxo, entre zero e o número de bytes solicitados. Fluxos só retornará zero no final do fluxo. Caso contrário, ele serão bloqueado até que pelo menos um byte esteja disponível.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> de objeto <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>e chamar <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> é a única maneira de saber quantos bytes foram lidos do <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A>será bloqueado até que a operação de e/s foi concluída.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <paramref name="asyncResult" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Solicitação assíncrona pendente e/s ao fim.</param>
        <summary>Termina uma gravação assíncrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>será bloqueado até que a operação de e/s foi concluída.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="asyncResult" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa os buffers desse fluxo e faz com que todos os dados armazenados em buffer sejam gravados no arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como um buffer pode ser usado para ler ou gravar, mas não ambos ao mesmo tempo, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> tem duas funções. Primeiro, os dados previamente gravados em buffer são copiados para o arquivo e o buffer será limpo. Segundo, se <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> é `true` e foi anteriormente copiados do arquivo de dados para o buffer de leitura, a posição atual dentro do arquivo é reduzida pelo número de bytes não lidos no buffer. O buffer, em seguida, será limpo.  
  
 Use o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> sobrecarga de método quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> para limpar todos os buffers de arquivo intermediário; caso contrário, <see langword="false" />.</param>
        <summary>Limpa os buffers desse fluxo e faz com que os dados armazenados em buffer sejam gravados no arquivo e também limpa todos os buffers de arquivo intermediário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de arquivo para o arquivo atual <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> encapsula o objeto. Acessar essa propriedade não é permitido em um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto e lança um <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />.</summary>
        <value>O identificador de arquivo para o arquivo que atual <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> encapsula o objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> propriedade.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">O <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> propriedade sempre gera essa exceção.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de acessar o código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor booliano que indica se o objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> foi aberto de forma assíncrona ou síncrona.</summary>
        <value>
          <see langword="true" /> se o objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> dá suporte ao acesso assíncrono; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assíncrono <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos não podem ser criados, diferentemente <xref:System.IO.FileStream>. No entanto, o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, e <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> métodos têm suporte em instâncias síncronas, com algumas penalidades de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como você pode usar o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> propriedade para verificar se um <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> é síncrono. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o comprimento do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</summary>
        <value>O comprimento do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A>representa o número de bytes no momento no arquivo. Ela não é afetada pela cota de armazenamento isolado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> propriedade.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">A posição inicial do intervalo de bloqueio. O valor desse parâmetro deve ser igual ou maior que 0 (zero).</param>
        <param name="length">O número de bytes para bloquear.</param>
        <summary>Impede que outros processos de leitura ou gravação no fluxo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueio de um intervalo de um fluxo de arquivos oferece os threads do acesso exclusivo travamento do processo para o intervalo do fluxo de arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.IO.IOException">O processo não pode acessar o arquivo porque outro processo bloqueou uma parte dele.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição atual do atual <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</summary>
        <value>A posição atual deste <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A definição dessa propriedade funciona quando o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> é de propriedade `true`.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> propriedade para gravar dados em um arquivo.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A posição não pode ser definida como um número negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para ler.</param>
        <param name="offset">O deslocamento no buffer no qual começar a gravar.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <summary>Copia bytes do buffer atual <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto em uma matriz.</summary>
        <returns>O número total de bytes de leitura para o <paramref name="buffer" />. Isso pode ser menor que o número de bytes solicitado se muitos bytes não estão disponíveis no momento ou zero se o fim do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `buffer` parâmetro pode ser uma instância do <xref:System.Buffer> classe ou uma matriz de um dos seguintes tipos: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32>, <xref:System.UInt64>, <xref:System.Single>, ou <xref:System.Double>. O `offset` parâmetro retorna o deslocamento do byte em buffer no qual começar a escrever (índice no buffer) e o `count` parâmetro fornece o número máximo de bytes que será lido do fluxo. O valor retornado é o número real de bytes lidos ou zero se o fim do fluxo for atingido. Se a operação de leitura for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.  
  
 O <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> método trata o `buffer` parâmetro como um bloco de bytes, independentemente de seu tipo real. Da mesma forma, o `offset` e `count` são sempre especificados em bytes. Para `buffer` parâmetros diferentes matrizes de bytes, isso significa que um índice de elemento deve ser multiplicado pelo tamanho em bytes para formar um valor correto para o elemento `offset` ou `count`.  
  
 O <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> método retornará zero somente se o fim do fluxo for atingido. Em todos os outros casos, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> lê sempre pelo menos um byte do fluxo antes de retornar. Se nenhum dado está disponível a partir de <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto após uma chamada para <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, o método será bloqueado até que pelo menos um byte de dados pode ser retornado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um único byte do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto no armazenamento isolado.</summary>
        <returns>O valor de inteiro não assinado de 8 bits ler o arquivo de armazenamento isolado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> método pode ser usado para ler dados de um <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa o identificador de arquivo do sistema operacional para o arquivo que o objeto <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> atual encapsula.</summary>
        <value>Um <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> objeto que representa o identificador de arquivo do sistema operacional para o arquivo que atual <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> encapsula o objeto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> propriedade não é suportada e sempre gera um <xref:System.IO.IsolatedStorage.IsolatedStorageException> exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">O <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> propriedade sempre gera essa exceção.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de acessar o código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> ação de segurança:<see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">A nova posição do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</param>
        <param name="origin">Um dos valores de <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Define a posição atual deste <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto para o valor especificado.</summary>
        <returns>A nova posição no <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objetos suportam posicionamento além do comprimento do fluxo, outras pessoas lançará uma exceção nesse caso.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="origin" /> deve ser o <see cref="T:System.IO.SeekOrigin" /> valores.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo comprimento do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</param>
        <summary>Define o comprimento deste <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto especificado <paramref name="value" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se especificado `value` é menor que o comprimento atual do <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> do objeto, o fluxo é truncado. Se especificado `value` é maior do que o tamanho atual do fluxo, o fluxo é expandido. Se o fluxo é expandido, o conteúdo do fluxo entre o antigo e o novo comprimento é indefinido. Para usar esse método, uma <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto deve dar suporte tanto gravação e busca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" />é um número negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">A posição inicial do intervalo para desbloquear. O valor desse parâmetro deve ser igual ou maior que 0 (zero).</param>
        <param name="length">O número de bytes para desbloquear.</param>
        <summary>Permite que outros processos acessar todo ou parte de um arquivo que foi bloqueado anteriormente.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer de gravação.</param>
        <param name="offset">O deslocamento de bytes no buffer do qual iniciar.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <summary>Grava um bloco de bytes para o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> usando dados lidos de uma matriz de bytes do objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `offset` parâmetro fornece o deslocamento de byte no `buffer` no qual começar a ler e o `count` parâmetro retorna o número de bytes que será gravado isso <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Se a operação de gravação for bem-sucedida, a atual posição do <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto avança pelo número de bytes gravados. Se ocorrer uma exceção, a posição atual do <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto permanece inalterado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">A tentativa de gravação excede a cota para o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O valor de byte para gravar o arquivo de armazenamento isolado.</param>
        <summary>Grava um único byte para o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> método pode ser usado para ler dados de um <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> objeto. Para o contexto completo deste exemplo, consulte o <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> visão geral.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">A tentativa de gravação excede a cota para o <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> objeto.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
