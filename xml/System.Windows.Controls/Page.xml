<Type Name="Page" FullName="System.Windows.Controls.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Windows.FrameworkElement implements class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.Page" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.FrameworkElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Content")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula uma página de conteúdo que pode ser navegado e hospedado pelo Windows Internet Explorer, <see cref="T:System.Windows.Navigation.NavigationWindow" />, e <see cref="T:System.Windows.Controls.Frame" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page>encapsula uma página de conteúdo que pode ser acessada e tem os seguintes membros de chave:  
  
-   **Gerenciamento de vida útil**: <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
-   **Navegação**: <xref:System.Windows.Controls.Page.NavigationService%2A>.  
  
-   **Aparência**: <xref:System.Windows.Controls.Page.Background%2A>, <xref:System.Windows.Controls.Page.Content%2A>, <xref:System.Windows.Controls.Page.FontFamily%2A>, <xref:System.Windows.Controls.Page.FontSize%2A>, <xref:System.Windows.Controls.Page.Foreground%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>, <xref:System.Windows.Controls.Page.Template%2A>, <xref:System.Windows.Controls.Page.Title%2A>.  
  
-   **Aparência da janela de host**: <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowTitle%2A>.  
  
 Uma página pode ser definida usando a marcação, marcação e code-behind ou código. Uma página é a melhor maneira de conteúdo do pacote para navegação, pelos seguintes motivos:  
  
-   É fácil definir, reutilizar e gerenciar.  
  
-   Ele pode acessar e usar o <xref:System.Windows.Navigation.NavigationService> que navegou até ele.  
  
-   Ela pode alterar o título, largura, altura e navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de sua janela do host (<xref:System.Windows.Controls.Page.WindowTitle%2A>, <xref:System.Windows.Controls.Page.WindowWidth%2A>, <xref:System.Windows.Controls.Page.WindowHeight%2A>, <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>).  
  
-   Ele tem suporte ao designer [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)].  
  
 Uma página pode ser hospedada em <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, ou em um navegador. Para ser armazenado, uma página pode ser:  
  
-   O filho direto de um <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, ou <xref:System.Windows.Controls.Frame> elemento [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)].  
  
-   Instanciados e definido como o valor da `Content` propriedade <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, e <xref:System.Windows.Controls.Frame>.  
  
-   Definir como o [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] origem do `Source` propriedade do <xref:System.Windows.Navigation.NavigationWindow> ou <xref:System.Windows.Controls.Frame>.  
  
-   Definir como o <xref:System.Windows.Application.StartupUri%2A> em um aplicativo autônomo.  
  
-   Definir como o <xref:System.Windows.Application.StartupUri%2A> em um [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)].  
  
 Um aplicativo normalmente tem duas ou mais páginas, que podem ser navegadas entre usar os seguintes mecanismos:  
  
-   Declarativamente usando <xref:System.Windows.Documents.Hyperlink>.  
  
-   Programaticamente, usando <xref:System.Windows.Navigation.NavigationService>.  
  
-   Visualmente, usando a navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] do host, incluindo [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], <xref:System.Windows.Navigation.NavigationWindow>, e <xref:System.Windows.Controls.Frame>.  
  
 Usando funções de página de navegação estruturada (<xref:System.Windows.Navigation.PageFunction%601>), consulte [visão geral de navegação estruturada](~/docs/framework/wpf/app-development/structured-navigation-overview.md) e [visão geral de topologias de navegação](~/docs/framework/wpf/app-development/navigation-topologies-overview.md).  
  
 Propriedades de dependência para este controle podem ser definidas pelo estilo padrão do controle.  Se uma propriedade é definida por um estilo padrão, a propriedade pode ser alterada de seu valor padrão quando o controle é exibido no aplicativo. O estilo padrão é determinado pelo qual tema de área de trabalho é usado quando o aplicativo está em execução.  Para obter mais informações, consulte [padrão WPF temas](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
   
  
## Examples  
 O exemplo a seguir mostra como uma página padrão é definida usando apenas marcação:  
  
 [!code-xaml[PageSnippets#MarkupPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupPage.xaml#markuppagemarkup)]  
  
 A exemplo a seguir mostra como uma página padrão é definida usando somente de código:  
  
 [!code-csharp[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/CodePage.cs#codepagecodebehind)]
 [!code-vb[PageSnippets#CodePageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/codepage.vb#codepagecodebehind)]  
  
 O exemplo a seguir mostra como uma página padrão é definido usando uma combinação de marcação e code-behind.  
  
 [!code-xaml[PageSnippets#MarkupAndCodeBehindPageMARKUP](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml#markupandcodebehindpagemarkup)]  
  
 [!code-csharp[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageSnippets/CSharp/MarkupAndCodeBehindPage.xaml.cs#markupandcodebehindpagecodebehind)]
 [!code-vb[PageSnippets#MarkupAndCodeBehindPageCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageSnippets/visualbasic/markupandcodebehindpage.xaml.vb#markupandcodebehindpagecodebehind)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Controls.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um <xref:System.Windows.Controls.Page> não está sendo mantida ativa (consulte <xref:System.Windows.Controls.Page.KeepAlive%2A>), é necessário para implementar um construtor padrão para permitir [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] para criar uma nova instância dela quando navegar até em ou encaminhar o histórico de navegação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">O tamanho a ser usado para organizar os elementos filho.</param>
        <summary>Organiza o conteúdo (elementos filho) o <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Um <see cref="T:System.Windows.Size" /> que representa o tamanho organizado da página.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Background">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Background { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Background" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Background" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o plano de fundo para um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O <see cref="T:System.Windows.Media.Brush" /> que <see cref="T:System.Windows.Controls.Page" /> usa para pintar o plano de fundo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageBackground"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.BackgroundProperty>|  
|Propriedades de metadados é definido como`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BackgroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BackgroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.BackgroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.Background" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o conteúdo de um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>Um objeto que contém o conteúdo de um <see cref="T:System.Windows.Controls.Page" />. O padrão é <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Controls.Page> pode ter apenas um único elemento filho. Todos os outros elementos em um <xref:System.Windows.Controls.Page> devem ser descendentes desse elemento. Normalmente, o conteúdo de um <xref:System.Windows.Controls.Page> hospeda um elemento de layout — como <xref:System.Windows.Controls.Grid>, <xref:System.Windows.Controls.StackPanel>, e <xref:System.Windows.Controls.DockPanel>— que hospeda o conteúdo a <xref:System.Windows.Controls.Page>.  
  
<a name="dependencyPropertyInfo_PageContent"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.ContentProperty>|  
|Propriedades de metadados é definido como`true`|Nenhum|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ContentProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamily">
      <MemberSignature Language="C#" Value="public System.Windows.Media.FontFamily FontFamily { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.FontFamily FontFamily" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Font, Modifiability=System.Windows.Modifiability.Unmodifiable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.FontFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome da família de fonte especificada.</summary>
        <value>Um <see cref="T:System.Windows.Media.FontFamily" /> que é a família da fonte do conteúdo de um <see cref="T:System.Windows.Controls.Page" />. O padrão é <see cref="P:System.Windows.SystemFonts.MessageFontFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageFontFamily"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.FontFamilyProperty>|  
|Propriedades de metadados é definido como`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontFamilyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontFamilyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontFamilyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontFamilyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.FontFamily" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador da propriedade de dependência <xref:System.Windows.Controls.Page.FontFamily%2A>.  
  
   
  
## Examples  
 [Visão geral das propriedades da dependência](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSize">
      <MemberSignature Language="C#" Value="public double FontSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 FontSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.FontSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.FontSizeConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho da fonte.</summary>
        <value>O tamanho da fonte do conteúdo de um <see cref="T:System.Windows.Controls.Page" />. O padrão é <see cref="P:System.Windows.SystemFonts.MessageFontSize" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho da fonte deve ser um positivo e número no intervalo da <xref:System.Windows.SystemFonts.MessageFontSize%2A>.  
  
<a name="dependencyPropertyInfo_PageFontSize"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.FontSizeProperty>|  
|Propriedades de metadados é definido como`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FontSizeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FontSizeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FontSizeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.FontSizeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.FontSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador da propriedade de dependência <xref:System.Windows.Controls.Page.FontSize%2A>.  
  
   
  
## Examples  
 [Visão geral das propriedades da dependência](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Foreground">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush Foreground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush Foreground" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Foreground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o primeiro plano para um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O <see cref="T:System.Windows.Media.Brush" /> que <see cref="T:System.Windows.Controls.Page" /> usa para pintar o primeiro plano. O padrão é <see cref="P:System.Windows.Media.Brushes.Black" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_PageForeground"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.ForegroundProperty>|  
|Propriedades de metadados é definido como`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForegroundProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForegroundProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForegroundProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.ForegroundProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.Foreground" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador da propriedade de dependência <xref:System.Windows.Controls.Page.Foreground%2A>.  
  
   
  
## Examples  
 [Visão geral das propriedades da dependência](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a instância <see cref="T:System.Windows.Controls.Page" /> é mantida no histórico de navegação.</summary>
        <value>
          <see langword="true" /> se a instância <see cref="T:System.Windows.Controls.Page" /> é mantida no histórico de navegação; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma página é primeiro navegou para uma nova instância do <xref:System.Windows.Controls.Page> classe é criada. Quando uma página é acessada de (atrás ou adiante), uma entrada para a página é adicionada ao histórico de navegação. Por padrão, a entrada não faz referência o objeto de página. Em vez disso, a entrada contém um pacote [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a página. Quando a entrada para a página é navegada usando o histórico de navegação, o pacote [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] é usado para criar uma nova instância da página. Esse comportamento é o padrão, para evitar o uso excessivo de memória: Manter instâncias de página pode consumir rapidamente a memória, especialmente aqueles com um valor não trivial do conteúdo. Esse problema é aumentado pelo fato de que não há nenhum limite para o número de entradas que podem ser armazenados na parte traseira e pilhas de avanço do histórico de navegação. Por outro lado, armazenando o pacote [!INCLUDE[TLA#tla_uri#plural](~/includes/tlasharptla-urisharpplural-md.md)] para páginas praticamente não tem impacto no consumo de memória.  
  
 O efeito principal da criação de novas instâncias de uma página é o estado da página não será lembrado de uma instância de uma página para outra. Nesses casos, [!INCLUDE[TLA#tla_wpf](~/includes/tlasharptla-wpf-md.md)] oferece várias técnicas para lembrar o estado.  
  
 Para manter uma página ativa, você deve definir o <xref:System.Windows.Controls.Page.KeepAlive%2A> propriedade `true` (o padrão é `false`).  
  
> [!NOTE]
>  Páginas que são instanciadas e navegadas usando somente o código (por exemplo, chamar <xref:System.Windows.Navigation.NavigationService.Navigate%2A>), são mantidas ativas automaticamente.  
  
 Você deve evitar configuração <xref:System.Windows.Controls.Page.KeepAlive%2A> para `true` , a menos que você precisa:  
  
-   Quando uma página tiver muito conteúdo, ele pode levar muito tempo para criar uma instância. Se a página não é mantida ativa, e a página é navegada frequentemente, o custo de constantemente instanciando a página pode ter um impacto negativo sobre a experiência do usuário. No entanto, de uma perspectiva de desempenho, você deve contar com as configurações padrão e criar o perfil de desempenho do seu aplicativo; Se o teste identifica páginas com tempos de carregamento que caem abaixo do intervalo necessário para seu aplicativo, configurar as páginas a serem mantidos atividade pode ser uma maneira de resolver o problema.  
  
> [!NOTE]
>  Entradas para páginas que são mantidas ativas não são mantidas no histórico de navegação de um [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] se um usuário navega de e para o [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]. Somente as entradas de diário para páginas que não são mantidas ativas são mantidas no histórico de navegação.  
  
<a name="dependencyPropertyInfo_PageKeepAlive"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.KeepAliveProperty>|  
|Propriedades de metadados é definido como`true`|Nenhum|  
  
> [!NOTE]
>  O tipo de metadados sobre essa propriedade de dependência é <xref:System.Windows.PropertyMetadata>, não <xref:System.Windows.FrameworkPropertyMetadata>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] para manter uma instância do <xref:System.Windows.Controls.Page> classe entre vários navegações.  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageKeepAliveSnippets/XAML/HomePage.xaml#setpagekeepalivexaml2)]  
  
 [!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang1)]  
[!code-xaml[PageKeepAliveSnippets#SetPageKeepAliveXAMLForLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml#setpagekeepalivexamlforlang2)]  
  
 [!code-csharp[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageKeepAliveSnippets/CSharp/HomePage.xaml.cs#setpagekeepalivecodebehind)]
 [!code-vb[PageKeepAliveSnippets#SetPageKeepAliveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageKeepAliveSnippets/visualbasic/homepage.xaml.vb#setpagekeepalivecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAliveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty KeepAliveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty KeepAliveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.KeepAliveProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.KeepAlive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador da propriedade de dependência <xref:System.Windows.Controls.Page.KeepAlive%2A>.  
  
   
  
## Examples  
 [Visão geral das propriedades da dependência](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.LogicalChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna um enumerador para o filho lógico elementos de um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O <see cref="T:System.Collections.IEnumerator" /> para os elementos filho de um <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size constraint);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.MeasureOverride(System.Windows.Size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="constraint" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="constraint">A área disponível que a janela pode fornecer a seus filhos.</param>
        <summary>Mede os elementos filho do <see cref="T:System.Windows.Controls.Page" />.</summary>
        <returns>Um <see cref="T:System.Windows.Size" /> que é o tamanho real da janela. O método pode retornar um valor maior, nesse caso o pai pode ser necessário adicionar barras de rolagem.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigationService">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.NavigationService NavigationService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Navigation.NavigationService NavigationService" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.NavigationService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o serviço de navegação que o host da página está usando para gerenciar a navegação.</summary>
        <value>O objeto <see cref="T:System.Windows.Navigation.NavigationService" /> que o host da página está usando para gerenciar a navegação ou <see langword="null" />, se o host não der suporte à navegação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas podem ser hospedadas por vários tipos de hosts, incluindo <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>e um navegador.  
  
 Páginas muitas vezes é preciso integrar a navegação do seu host para oferecer suporte a navegação da página. No entanto, como uma página talvez não saiba o que seu host serão em tempo de execução, não é possível integrar diretamente com membros de navegação do seu host para fazer isso.  
  
 Em vez disso, ele pode tentar usar um serviço de navegação, que é um serviço que dá suporte à navegação de estilo de navegador e é encapsulado pela <xref:System.Windows.Navigation.NavigationService> classe. Não é possível criar seu próprio <xref:System.Windows.Navigation.NavigationService> instância, embora. Em vez disso, tipos de host, como <xref:System.Windows.Navigation.NavigationWindow>, <xref:System.Windows.Controls.Frame>, ou um navegador criar seus próprios <xref:System.Windows.Navigation.NavigationService> instância que você pode acessar a partir do <xref:System.Windows.Controls.Page.NavigationService%2A> propriedade.  
  
 O serviço de navegação que é retornado o <xref:System.Windows.Controls.Page.NavigationService%2A> propriedade é a instância do <xref:System.Windows.Navigation.NavigationService> classe que é gerenciado pelo navegador primeiro na árvore visual. Se não for encontrado, `null` for retornado, indicando que um host de página não oferece suporte a navegação.  
  
> [!NOTE]
>  O <xref:System.Windows.Window> classe não oferece suporte a navegação e não fornece um serviço de navegação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como uma página pode verificar se um serviço de navegação está disponível e, em caso afirmativo, usá-lo para navegar de volta para a página anterior.  
  
 [!code-csharp[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageNavigationServiceSnippets/CSharp/HomePage.xaml.cs#getpagenavigationservicecodebehind)]
 [!code-vb[PageNavigationServiceSnippets#GetPageNavigationServiceCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageNavigationServiceSnippets/visualbasic/homepage.xaml.vb#getpagenavigationservicecodebehind)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTemplateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTemplateChanged (System.Windows.Controls.ControlTemplate oldTemplate, System.Windows.Controls.ControlTemplate newTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTemplateChanged(class System.Windows.Controls.ControlTemplate oldTemplate, class System.Windows.Controls.ControlTemplate newTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldTemplate" Type="System.Windows.Controls.ControlTemplate" />
        <Parameter Name="newTemplate" Type="System.Windows.Controls.ControlTemplate" />
      </Parameters>
      <Docs>
        <param name="oldTemplate">O modelo antigo.</param>
        <param name="newTemplate">O novo modelo.</param>
        <summary>Chamado quando o modelo para um <see cref="T:System.Windows.Controls.Page" /> alterações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Windows.Controls.Control.OnTemplateChanged%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">O pai anterior. Definido como <see langword="null" /> se o <see cref="T:System.Windows.DependencyObject" /> não tem um pai anterior.</param>
        <summary>Chamado quando o pai do <see cref="T:System.Windows.Controls.Page" /> é alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <xref:System.Windows.UIElement.OnVisualParentChanged%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O novo pai não é nem um <see cref="T:System.Windows.Window" /> nem um <see cref="T:System.Windows.Controls.Frame" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeShowsNavigationUI ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeShowsNavigationUI() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeShowsNavigationUI" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que classes derivadas determinar o comportamento de serialização do <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> propriedade.</summary>
        <returns>
          <see langword="true" />Se o conteúdo deve ser serializado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeTitle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que classes derivadas determinar o comportamento de serialização do <see cref="P:System.Windows.Controls.Page.Title" /> propriedade.</summary>
        <returns>
          <see langword="true" />Se o conteúdo deve ser serializado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowHeight">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowHeight" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que classes derivadas determinar o comportamento de serialização do <see cref="P:System.Windows.Controls.Page.WindowHeight" /> propriedade.</summary>
        <returns>
          <see langword="true" />Se o conteúdo deve ser serializado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowTitle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowTitle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowTitle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowTitle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que classes derivadas determinar o comportamento de serialização do <see cref="P:System.Windows.Controls.Page.WindowTitle" /> propriedade.</summary>
        <returns>
          <see langword="true" />Se o conteúdo deve ser serializado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeWindowWidth">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeWindowWidth ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeWindowWidth() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.ShouldSerializeWindowWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que classes derivadas determinar o comportamento de serialização do <see cref="P:System.Windows.Controls.Page.WindowWidth" /> propriedade.</summary>
        <returns>
          <see langword="true" />Se o conteúdo deve ser serializado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowsNavigationUI">
      <MemberSignature Language="C#" Value="public bool ShowsNavigationUI { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowsNavigationUI" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.ShowsNavigationUI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de um <see cref="T:System.Windows.Navigation.NavigationWindow" /> em [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)] está visível.</summary>
        <value>
          <see langword="true" /> se a navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de um host <see cref="T:System.Windows.Navigation.NavigationWindow" /> estiver visível; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationWindow>Exibe a navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] por padrão para habilitar o estilo de navegador para frente e para trás navegação. Se uma página é definida como o <xref:System.Windows.Application.StartupUri%2A>, <xref:System.Windows.Application> abre automaticamente um <xref:System.Windows.Navigation.NavigationWindow> para hospedar a página. Se a página não desejar usar o padrão <xref:System.Windows.Navigation.NavigationWindow> navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], pode definir <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> para `false`.  
  
> [!NOTE]
>  Porque [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] não se integra com a navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] para [!INCLUDE[TLA#tla_ie6](~/includes/tlasharptla-ie6-md.md)], ele fornece sua própria navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], que podem ser mostrado ou ocultado definindo <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A>. [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)]integrar o [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)], portanto configuração <xref:System.Windows.Controls.Page.ShowsNavigationUI%2A> nas páginas do [!INCLUDE[TLA#tla_ie7](~/includes/tlasharptla-ie7-md.md)] não tem nenhum efeito.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] para ocultar o painel de navegação [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] de um <xref:System.Windows.Navigation.NavigationWindow>.  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML1](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAML2](~/samples/snippets/xaml/VS_Snippets_Wpf/PageShowsNavigationUISnippets/XAML/HomePage.xaml#setpageshowsnavigationuixaml2)]  
  
 [!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang1](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang1)]  
[!code-xaml[PageShowsNavigationUISnippets#SetPageShowsNavigationUIXAMLLang2](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml#setpageshowsnavigationuixamllang2)]  
  
 [!code-csharp[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/PageShowsNavigationUISnippets/CSharp/HomePage.xaml.cs#setpageshowsnavigationuicodebehind)]
 [!code-vb[PageShowsNavigationUISnippets#SetPageShowsNavigationUICODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PageShowsNavigationUISnippets/visualbasic/homepage.xaml.vb#setpageshowsnavigationuicodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Windows.Controls.Page.ShowsNavigationUI" /> é inspecionada em uma instância <see cref="T:System.Windows.Controls.Page" /> que não é hospedada por um <see cref="T:System.Windows.Window" />, <see cref="T:System.Windows.Navigation.NavigationWindow" /> ou por um navegador.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto filho a ser adicionado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Markup.IAddChild.AddChild(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Controls.Page> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string str);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.Page.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O texto a ser adicionado ao objeto.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Markup.IAddChild.AddText(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Controls.Page> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Template">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ControlTemplate Template { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ControlTemplate Template" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Template" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ControlTemplate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modelo de controle para um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O <see cref="T:System.Windows.Controls.ControlTemplate" /> para um <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlAttributeUsage_ContentTemplate"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object Template="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlValues_ContentTemplate"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *resourceExtension*  
 Uma extensão de marcação que identifica como referenciar o recurso de modelo, ou `StaticResource` ou `DynamicResource`. Consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 A chave que identifica o seletor de modelo solicitado. A chave refere-se a um recurso existente em um <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Sintaxe de elemento de propriedade é tecnicamente possível, mas não é recomendado. Para obter mais informações, consulte [modelos e estilos in-line](~/docs/framework/wpf/advanced/inline-styles-and-templates.md).  
  
<a name="dependencyPropertyInfo_PageTemplate"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.TemplateProperty>|  
|Propriedades de metadados é definido como`true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TemplateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TemplateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TemplateProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.Template" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o título do <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O título do <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor da <xref:System.Windows.Controls.Page.Title%2A> propriedade não é exibida por <xref:System.Windows.Controls.Page>, nem é exibida na barra de título da janela que está hospedando um <xref:System.Windows.Controls.Page>. Em vez disso, você definir <xref:System.Windows.Controls.Page.WindowTitle%2A> para alterar o título de uma janela do host.  
  
 <xref:System.Windows.Controls.Page.Title%2A>também pode ser usado para gerar o nome da entrada de histórico de navegação para uma parte do conteúdo navegado. As seguintes partes dos dados são usadas para construir automaticamente um nome de entrada de histórico de navegação, em ordem de precedência:  
  
-   O anexo <xref:System.Windows.Navigation.JournalEntry.Name%2A> atributo.  
  
-   A propriedade de <xref:System.Windows.Controls.Page.Title%2A> .  
  
-   O <xref:System.Windows.Controls.Page.WindowTitle%2A> propriedade e o [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a página atual  
  
-   O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a página atual.  
  
 Se você tiver associado uma <xref:System.Windows.Navigation.CustomContentState> objeto com uma parte do conteúdo no histórico de navegação, você pode especificar o nome que aparece na entrada de histórico de navegação, substituindo <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_PageTitle"></a>   
## <a name="dependency-property-information"></a>Informações da propriedade de dependência  
  
|||  
|-|-|  
|Campo de identificador|<xref:System.Windows.Controls.Page.TitleProperty>|  
|Propriedades de metadados é definido como`true`|Nenhum|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.Page.TitleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica a propriedade de dependência <see cref="P:System.Windows.Controls.Page.Title" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador da propriedade de dependência <xref:System.Windows.Controls.Page.Title%2A>.  
  
   
  
## Examples  
 [Visão geral das propriedades da dependência](~/docs/framework/wpf/advanced/dependency-properties-overview.md)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public double WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura do host <see cref="T:System.Windows.Window" /> ou <see cref="T:System.Windows.Navigation.NavigationWindow" /> de um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>A altura de uma janela que hospeda diretamente um <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowHeight%2A>só é aplicado quando um <xref:System.Windows.Controls.Page> está hospedado diretamente por uma janela, que inclui:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Se um <xref:System.Windows.Controls.Page> é hospedado por um <xref:System.Windows.Controls.Frame>, configuração <xref:System.Windows.Controls.Page.WindowHeight%2A> não tem nenhum efeito, mas você ainda pode obter o valor de <xref:System.Windows.Controls.Page.WindowHeight%2A>.  
  
 Um <xref:System.Windows.Controls.Page> em uma [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] só pode ser <xref:System.Windows.Controls.Page.WindowHeight%2A> para alterar a altura de [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; a altura não pode ser alterada definindo <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.MinHeight%2A>, ou <xref:System.Windows.FrameworkElement.MaxHeight%2A>.  
  
 A altura mínima do [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] janela é 150 pixels. Para páginas online, isso significa que o valor de <xref:System.Windows.Controls.Page.WindowHeight%2A> não podem ser aplicadas se isso faria com que a altura total do [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] janela a ser menos de 150 pixels.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir a altura de uma janela de uma página.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowHeightXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowHeightPage.xaml#setpagewindowheightxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowTitle">
      <MemberSignature Language="C#" Value="public string WindowTitle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o título do <see cref="T:System.Windows.Window" /> ou <see cref="T:System.Windows.Navigation.NavigationWindow" /> host de um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>O título de uma janela que hospeda diretamente o <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o título de uma janela que hospeda uma página, incluindo <xref:System.Windows.Navigation.NavigationWindow> e [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], é o nome do arquivo que está sendo hospedado no momento (com uma extensão. XAML se a página é solta [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)], ou uma extensão. xbap se a página for parte de um [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]).  
  
 Uma página pode alterar o padrão definindo seu <xref:System.Windows.Controls.Page.WindowTitle%2A> propriedade.  
  
 Depois que uma página define o título de uma janela dessa maneira, título da janela não muda até outra página define <xref:System.Windows.Controls.Page.WindowTitle%2A> com um valor diferente.  
  
> [!NOTE]
>  O <xref:System.Windows.Controls.Page> deve ser a parte superior do conteúdo em uma janela para <xref:System.Windows.Controls.Page.WindowTitle%2A> para ter efeito; se um <xref:System.Windows.Controls.Page> está hospedado em um <xref:System.Windows.Controls.Frame>, por exemplo, definindo <xref:System.Windows.Controls.Page.WindowTitle%2A> não altera o título da janela do host.  
  
 <xref:System.Windows.Controls.Page.WindowTitle%2A>também pode ser usado para gerar o nome da entrada de histórico de navegação para uma parte do conteúdo navegado. As seguintes partes dos dados são usadas para construir automaticamente um nome de entrada de histórico de navegação, em ordem de precedência:  
  
-   O anexo <xref:System.Windows.Navigation.JournalEntry.Name%2A> atributo.  
  
-   A propriedade de <xref:System.Windows.Controls.Page.Title%2A> .  
  
-   O <xref:System.Windows.Controls.Page.WindowTitle%2A> propriedade e o [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a página atual  
  
-   O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a página atual.  
  
 Se você tiver associado uma <xref:System.Windows.Navigation.CustomContentState> objeto com uma parte do conteúdo no histórico de navegação, você pode especificar o valor do nome de um elemento de histórico de navegação, substituindo <xref:System.Windows.Navigation.CustomContentState.JournalEntryName%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir o título de uma janela de uma página.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowTitleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowTitlePage.xaml#setpagewindowtitlexaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public double WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.Page.WindowWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a largura do host <see cref="T:System.Windows.Window" /> ou <see cref="T:System.Windows.Navigation.NavigationWindow" /> de um <see cref="T:System.Windows.Controls.Page" />.</summary>
        <value>A largura de uma janela que hospeda diretamente um <see cref="T:System.Windows.Controls.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.Page.WindowWidth%2A>só é aplicado quando um <xref:System.Windows.Controls.Page> está hospedado diretamente por uma janela, que inclui:  
  
-   <xref:System.Windows.Window>  
  
-   <xref:System.Windows.Navigation.NavigationWindow>  
  
-   [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]  
  
 Se um <xref:System.Windows.Controls.Page> é hospedado por um <xref:System.Windows.Controls.Frame>, configuração <xref:System.Windows.Controls.Page.WindowWidth%2A> não tem nenhum efeito, mas você ainda pode obter o valor de <xref:System.Windows.Controls.Page.WindowWidth%2A>.  
  
 Um <xref:System.Windows.Controls.Page> em uma [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] só pode ser <xref:System.Windows.Controls.Page.WindowWidth%2A> para alterar a largura do [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)]; a largura não pode ser alterada definindo <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, ou <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  
  
 A largura mínima do [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] janela é 250 pixels. Para páginas online, isso significa que o valor de <xref:System.Windows.Controls.Page.WindowWidth%2A> não podem ser aplicadas se isso faria com que a largura total do [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)] janela a ser menos de 250 pixels.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir a largura de uma janela de uma página.  
  
 [!code-xaml[HOWTONavigationSnippets#SetPageWindowWidthXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTONavigationSnippets/CSharp/SetWindowWidthPage.xaml#setpagewindowwidthxaml)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
