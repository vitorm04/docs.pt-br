<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma posição dentro de um <see cref="T:System.Windows.Documents.FlowDocument" /> ou <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer> classe apresenta a seguinte terminologia:  
  
-   Posicione - inerentemente, um <xref:System.Windows.Documents.TextPointer> sempre aponta para um *posição* no conteúdo.  Essas posições em se encaixam entre caracteres do conteúdo ou fluxo de conteúdo de elemento marcas que definem a estrutura do conteúdo.  
  
-   Posição atual - porque um <xref:System.Windows.Documents.TextPointer> sempre indica uma posição e porque muitas das operações que podem ser executadas por meio de um <xref:System.Windows.Documents.TextPointer> são em relação à posição atualmente apontada pelo <xref:System.Windows.Documents.TextPointer>, faz sentido para referir-se apenas à posição indicada por um <xref:System.Windows.Documents.TextPointer> como o *posição atual*.  
  
-   Posição de inserção - um *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, uma posição de inserção é em qualquer lugar no conteúdo em que um cursor pode ser posicionado.  Um exemplo de uma opção válida <xref:System.Windows.Documents.TextPointer> posição que não é uma posição de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento de parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
-   Símbolo - para fins de <xref:System.Windows.Documents.TextPointer> operações que envolvem símbolos, qualquer um dos seguintes é considerado um *símbolo*:  
  
    -   Uma abertura ou marca de fechamento para um <xref:System.Windows.Documents.TextElement> elemento.  
  
    -   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
    -   Cada 16-bit [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
-   Contêiner de texto - A *recipiente de texto* é o elemento que faz a borda final para o conteúdo de fluxo em questão; posição indicada por um <xref:System.Windows.Documents.TextPointer> sempre está dentro de um recipiente de texto.  No momento, um contêiner de texto deve ser um <xref:System.Windows.Documents.FlowDocument> ou <xref:System.Windows.Controls.TextBlock>.  Em linhas gerais, operações entre <xref:System.Windows.Documents.TextPointer> não há suporte para instâncias em contêineres de texto diferente.  
  
-   Documento - o conteúdo em um contêiner de texto é conhecido como um *documento*, como no <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método e o <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> e <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> propriedades.  
  
 O <xref:System.Windows.Documents.TextPointer> classe é destinada para facilitar a passagem e a manipulação de conteúdo que é representado por [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] elementos de conteúdo de fluxo; em geral, esses elementos derivam <xref:System.Windows.Documents.TextElement>.  Algumas das operações que <xref:System.Windows.Documents.TextPointer> facilita incluem o seguinte:  
  
-   Execute uma comparação ordinal da posição atual com uma segunda posição especificada.  Consulte o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método.  
  
-   Determine o tipo de conteúdo adjacente à posição atual em uma direção especificada.  Consulte o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método e <xref:System.Windows.Documents.TextPointerContext> enumeração.  
  
-   Obter o <xref:System.Windows.Documents.TextElement> que os escopos ou adjacente à posição atual.  Consulte <xref:System.Windows.Documents.Paragraph> e <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> método.  
  
-   Obter o contêiner de texto que tem como escopo o documento atual.  Consulte a propriedade <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Obter um número especificado de caracteres antes ou após a posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método.  
  
-   Insira uma cadeia de caracteres na posição atual.  Consulte o <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> método.  
  
-   Localize os limites de linha no conteúdo.  Consulte o <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade.  
  
-   Converter entre <xref:System.Windows.Documents.TextPointer> deslocamentos de posições e símbolo em conteúdo.  Consulte o <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos.  
  
-   Executar o teste de clique visual convertendo entre um <xref:System.Windows.Documents.TextPointer> posição e um <xref:System.Windows.Point> representar coordenadas relativas.  
  
-   Localizar uma posição de inserção próximo ou verifique se a posição atual é uma posição de inserção.  Consulte o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> métodos e <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> propriedade.  
  
 A posição e <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> indicado por um <xref:System.Windows.Documents.TextPointer> objeto são imutáveis.  Quando o conteúdo é editado ou modificado, posição indicada por um <xref:System.Windows.Documents.TextPointer> não é alterado em relação ao texto ao redor; em vez disso, o deslocamento da posição do início do conteúdo é ajustado correspondente para refletir a nova posição relativa no conteúdo.  Por exemplo, um <xref:System.Windows.Documents.TextPointer> que indica uma posição no início de um determinado parágrafo continua apontar para o início desse parágrafo, mesmo quando o conteúdo é inserido ou excluído antes ou depois do parágrafo.  
  
 O <xref:System.Windows.Documents.TextPointer> classe não tem nenhum construtor público.  Uma instância de <xref:System.Windows.Documents.TextPointer> é criado usando propriedades ou métodos de outros objetos (incluindo outros <xref:System.Windows.Documents.TextPointer> objetos). A lista a seguir fornece alguns exemplos de métodos e propriedades que criam e retorna um <xref:System.Windows.Documents.TextPointer>.  Essa lista não é completa:  
  
-   De um <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> e <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   De um <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, e <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   De um <xref:System.Windows.Controls.TextBlock> (contêiner de texto): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, e <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   De um <xref:System.Windows.Documents.FlowDocument> (contêiner de texto): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, e<xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   De uma já existente <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Windows.Documents.TextPointer> para localizar uma posição dentro de primeira <xref:System.Windows.Documents.Run> elemento em um contêiner de texto especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 O exemplo a seguir implementa um algoritmo de localizar simplista usando <xref:System.Windows.Documents.TextPointer> instalações.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição para comparar à posição atual.</param>
        <summary>Executa uma comparação ordinal entre as posições especificadas pelo <see cref="T:System.Windows.Documents.TextPointer" /> atual e um segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>– 1 se o <see cref="T:System.Windows.Documents.TextPointer" /> atual preceder <paramref name="position" />, 0 se os locais forem iguais, +1 se o <see cref="T:System.Windows.Documents.TextPointer" /> atual seguir <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de -1 indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> precede a posição especificada pelo `position`.  Um valor de 0 indica que as posições indicadas são iguais.  Um valor de + 1 positivo indica que a posição especificada pelo atual <xref:System.Windows.Documents.TextPointer> segue a posição especificada pelo `position`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método.  No exemplo, o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> método é usado em conjunto com o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para testar se um especificado <xref:System.Windows.Documents.TextElement> está vazio.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> especifica uma posição fora do contêiner de texto associado à posição atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">O número de caracteres a serem excluídos, começando na posição atual. Especifique um valor positivo para excluir um caractere que segue a posição atual. Especifique um valor negativo para excluir os caracteres que precedem a posição atual.</param>
        <summary>Exclui o número especificado de caracteres da posição indicada pelo atual <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>O número de caracteres realmente excluído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique um valor positivo para excluir um caractere que segue a posição atual (como em <xref:System.Windows.Documents.LogicalDirection?displayProperty=nameWithType>); Especifique um valor negativo para excluir os caracteres que precedem a posição atual (como em <xref:System.Windows.Documents.LogicalDirection?displayProperty=nameWithType>).  
  
 O número de caracteres realmente excluído pode ser menor que o número especificado por `count`.  Isso ocorre em casos onde `count` especifica mais caracteres que existem para ser excluído.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O método é chamado em uma posição em que o texto não é permitido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Windows.Documents.TextPointer" /> no final do conteúdo no contêiner de texto associado à posição atual.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no final do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Windows.Documents.TextPointer" /> no início do conteúdo no contêiner de texto associado à posição atual.</summary>
        <value>Um <see cref="T:System.Windows.Documents.TextPointer" /> no início do conteúdo no contêiner de texto associado à posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use a posição retornada por essa propriedade como uma posição de linha de base para trabalhar com deslocamentos relativos às outras posições.  O <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> e <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> métodos fornecem uma maneira de converter entre posições e posição deslocamentos.  
  
 O <xref:System.Windows.Documents.TextPointer.Parent%2A> para retornado <xref:System.Windows.Documents.TextPointer> sempre é um contêiner de texto (<xref:System.Windows.Controls.TextBlock> ou <xref:System.Windows.Documents.FlowDocument>), em vez de <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual procurar um elemento adjacente.</param>
        <summary>Retorna o elemento, se houver, que limita o atual <see cref="T:System.Windows.Documents.TextPointer" /> na direção lógica especificada.</summary>
        <returns>O elemento adjacente especificado na <paramref name="direction" />, ou <see langword="null" /> se não existe nenhum elemento adjacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O elemento retornado é geralmente um <xref:System.Windows.Documents.TextElement>.  Um <xref:System.Windows.UIElement> pode ser retornado quando o <xref:System.Windows.Documents.TextPointer> indica uma posição dentro de um <xref:System.Windows.Documents.BlockUIContainer> elemento ou um <xref:System.Windows.Documents.InlineUIContainer> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual localizar conteúdo de um caixa delimitadora.</param>
        <summary>Retorna uma caixa delimitadora (<see cref="T:System.Windows.Rect" />) para o conteúdo que bordas atual <see cref="T:System.Windows.Documents.TextPointer" /> na direção lógica especificada.</summary>
        <returns>Uma caixa delimitadora para o conteúdo que bordas atual <see cref="T:System.Windows.Documents.TextPointer" /> na direção especificada, ou <see cref="P:System.Windows.Rect.Empty" /> se atual, informações de layout válido não estão disponíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement>as bordas não são consideradas conteúdo para os fins deste método.  Se o <xref:System.Windows.Documents.TextPointer> é posicionado antes de uma <xref:System.Windows.Documents.TextElement> borda, o valor de retorno é uma caixa delimitadora para o próximo não<xref:System.Windows.Documents.TextElement> conteúdo na direção especificada.  Se não houver nenhum conteúdo na direção especificada, uma largura zero <xref:System.Windows.Rect> é retornado com uma altura correspondente a altura de qualquer precedente conteúda.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Para obter mais informações, consulte [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual procurar a posição de inserção mais próxima.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição de inserção mais próxima na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para a posição de inserção mais próxima na direção especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma posição de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, uma posição de inserção é em qualquer lugar no conteúdo em que um cursor pode ser posicionado.  Um exemplo de uma opção válida <xref:System.Windows.Documents.TextPointer> posição que não é uma posição de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento de parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 Se o <xref:System.Windows.Documents.TextPointer> já aponta para uma posição de inserção válido, mas a marca de fechamento para uma sequência de formatação não vazia logo após a posição na direção determinada, o <xref:System.Windows.Documents.TextPointer> retornado por esse método é ajustado para apontar para a posição de inserção logo após o fechamento da sequência de formatação. Por exemplo, considere a sequência de marcação `<Bold>a</Bold>b`. Observe que há duas posições de inserção entre as letras `a` e `b` — uma que precede o `Bold` marca e um diretamente após o fechamento `Bold` marca. Se <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> é chamado em um <xref:System.Windows.Documents.TextPointer> para a posição diretamente após a letra `a` e antes do fechamento `Bold` marca e com um `direction` de <xref:System.Windows.Documents.LogicalDirection.Forward>, retornado <xref:System.Windows.Documents.TextPointer> é ajustado para apontar para a posição apenas antes da letra `b`, após o fechamento `Bold` marca. Um ajuste semelhante é feito para abrir as marcas de formatação ao trabalhar na direção oposta lógica. Este método destina-se a fornecer um meio de ambiguidades entre as posições de inserção em casos semelhantes.  
  
 Esse método também pode ser usado para ser seletivo sobre pontos de inserção quando uma sequência de marcas estruturais envolvida. Por exemplo, quando estiver em uma posição entre marcas de parágrafo de abertura e fechamento, a direção de parâmetro pode ser usada para selecionar o mais próximo ponto de inserção no início do parágrafo seguinte (especificando <xref:System.Windows.Documents.LogicalDirection?displayProperty=nameWithType>) ou no final do parágrafo anterior (especificando <xref:System.Windows.Documents.LogicalDirection?displayProperty=nameWithType>).  
  
 Se o ponteiro já está na posição de inserção e não há nenhum marcas de formatação adjacentes especificado na `direction`, retornado <xref:System.Windows.Documents.TextPointer> aponta para a mesma posição de chamada <xref:System.Windows.Documents.TextPointer>.  
  
 É possível que nenhuma posição de inserção válido existe em relação à posição apontada por um <xref:System.Windows.Documents.TextPointer>.  Isso pode acontecer se o conteúdo referenciado é estruturalmente incompleto, como em uma tabela vazia ou lista.  Nesses casos, esse método retorna apenas um <xref:System.Windows.Documents.TextPointer> para a mesma posição que o <xref:System.Windows.Documents.TextPointer> de que esse método foi chamado.  Esse método sempre retorna um válido <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 Este exemplo mostra como usar o <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> método para verificar se determinado <xref:System.Windows.Documents.TextElement> está vazia de conteúdo pode ser impresso.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">O número de marcadores de início de linha para ignorar ao determinar a linha para o qual retornar a posição inicial. Valores negativos especificam linhas precedentes, 0 especifica que a linha atual e especificam valores positivos linhas a seguir.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para o início de uma linha que é especificada em relação ao atual <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> apontando para o início da linha especificada (com o <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> definida como <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), ou <see langword="null" /> se a linha especificada está fora do intervalo ou não pode ser localizada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> é selecionado como a linha de início relativa.  
  
 A operação executada por esse método depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Para obter mais informações, consulte [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">O número de marcadores de início de linha para ignorar ao determinar a linha para o qual retornar a posição inicial. Valores negativos especificam linhas precedentes, 0 especifica que a linha atual e especificam valores positivos linhas a seguir.</param>
        <param name="actualCount">Quando este método retorna, contém o número real de marcadores de início de linha que foram ignorados ao determinar a linha para o qual retornar a posição inicial.  Esse valor pode ser menor que <c>contagem</c> se o início ou término de conteúdo for encontrado antes que o número especificado de linhas é ignorado. Este parâmetro é passado não inicializado.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para o início de uma linha que é especificada em relação ao atual <see cref="T:System.Windows.Documents.TextPointer" />e informa quantas linhas foram ignoradas.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> apontando para o início da linha especificada (com o <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> definida como <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), ou para o início da linha mais próximo à linha especificada se a linha especificada está fora do intervalo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade for selecionada como a linha de início relativa.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual procurar o próximo símbolo.</param>
        <summary>Retorna um ponteiro para o próximo símbolo na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para o próximo símbolo na direção solicitada, ou <see langword="null" /> se atual <see cref="T:System.Windows.Documents.TextPointer" /> bordas de início ou término de conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma abertura ou marca de fechamento para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, ou <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (conforme identificado pelo <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método), o <xref:System.Windows.Documents.TextPointer> retornado por esse método é adiantado por exatamente um símbolo da posição atual.  
  
 Se o próximo símbolo é categorizado como <xref:System.Windows.Documents.TextPointerContext.Text>, o <xref:System.Windows.Documents.TextPointer> retornado por este método é ultrapassaram o texto para o próximo símbolo não texto (ou seja, a próxima posição onde a <xref:System.Windows.Documents.TextPointerContext> não é <xref:System.Windows.Documents.TextPointerContext.Text>).  A contagem exata de símbolo cruzada pode ser calculada com antecedência chamando o <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> método junto com o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método percorrer e extrair os símbolos em um especificado <xref:System.Windows.Documents.TextElement>.  
  
 Enquanto o exemplo pode ser usado para extrair um [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] estrutura do conteúdo de um determinado <xref:System.Windows.Documents.TextElement>, ele é apenas para fins ilustrativos e não deve ser usado no código de produção.  Consulte o <xref:System.Xml> namespace para um rico conjunto de tipos projetados para trabalhar com e processamento de XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual procurar a próxima posição de inserção.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> para a próxima posição de inserção na direção lógica especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> que identifica a próxima posição de inserção na direção solicitada, ou <see langword="null" /> se a próxima posição de inserção pode ser encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um *posição de inserção* é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, uma posição de inserção é em qualquer lugar no conteúdo em que um cursor pode ser posicionado.  Um exemplo de uma opção válida <xref:System.Windows.Documents.TextPointer> posição que não é uma posição de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento de parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> método atravessar os limites do elemento de conteúdo para contar o número de <xref:System.Windows.Documents.Paragraph> elementos apresentam entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição da qual encontrar a distância (em símbolos).</param>
        <summary>Retorna a contagem de símbolos entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e um segundo <see cref="T:System.Windows.Documents.TextPointer" /> especificado.</summary>
        <returns>O número relativo de símbolos entre o <see cref="T:System.Windows.Documents.TextPointer" /> atual e <paramref name="position" />.  Um valor negativo indica que o <see cref="T:System.Windows.Documents.TextPointer" /> atual segue a posição especificada por <paramref name="position" />, 0 indica que as posições são iguais e um valor positivo indica que o <see cref="T:System.Windows.Documents.TextPointer" /> atual precede a posição especificada por <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma abertura ou marca de fechamento para um <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> método para encontrar os deslocamentos de dois <xref:System.Windows.Documents.TextPointer> instâncias e, em seguida, usa essas informações para salvar e restaurar a seleção em um <xref:System.Windows.Controls.RichTextBox>.  O exemplo supõe que o conteúdo do <xref:System.Windows.Controls.RichTextBox> não foram alterados entre uma seleção de salvar e restaurar uma seleção.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> especifica uma posição fora do contêiner de texto associado à posição atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual determinar a categoria para o conteúdo adjacente.</param>
        <summary>Retorna um indicador de categoria para o conteúdo adjacente atual <see cref="T:System.Windows.Documents.TextPointer" /> na direção lógica especificada.</summary>
        <returns>Uma da <see cref="T:System.Windows.Documents.TextPointerContext" /> valores que indicam a categoria para o conteúdo adjacente na direção lógica especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra um uso para este método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> método para implementar um algoritmo para calcular o saldo de abertura e fechamento de marcas de elemento entre dois especificado <xref:System.Windows.Documents.TextPointer> posições.  Cada marca de elemento de abertura é contada como + 1 e cada marca de elemento de fechamento é contabilizada como -1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento, em símbolos, para o qual calcular e retornar a posição.  Se o deslocamento for negativo, a posição será calculada na direção lógica oposta àquela indicada pela propriedade <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado nos símbolos, desde o início do <see cref="T:System.Windows.Documents.TextPointer" /> atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado, ou <see langword="null" /> se nenhuma posição correspondente pode ser encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma abertura ou marca de fechamento para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> método para implementar um par de métodos, um para calcular o deslocamento em uma posição especificada em relação a um parágrafo de hospedagem e o outro para retornar um <xref:System.Windows.Documents.TextPointer> para um deslocamento especificado de um parágrafo especificado.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento, em símbolos, para o qual calcular e retornar a posição.  Se o deslocamento for negativo, o <see cref="T:System.Windows.Documents.TextPointer" /> retornado precede o atual <see cref="T:System.Windows.Documents.TextPointer" />, caso contrário, ele sucede.</param>
        <param name="direction">Um dos valores <see cref="T:System.Windows.Documents.LogicalDirection" /> que especifica a direção da lógica do <see cref="T:System.Windows.Documents.TextPointer" /> retornado.</param>
        <summary>Retorna um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado nos símbolos, desde o início do <see cref="T:System.Windows.Documents.TextPointer" /> atual e na direção especificada.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> à posição indicada pelo deslocamento especificado, ou <see langword="null" /> se o deslocamento ultrapassa o final do conteúdo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma abertura ou marca de fechamento para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica para localizar e retornar qualquer texto adjacente.</param>
        <summary>Retorna uma cadeia de caracteres que contém qualquer texto adjacente a atual <see cref="T:System.Windows.Documents.TextPointer" /> na direção lógica especificada.</summary>
        <returns>Uma cadeia de caracteres que contém qualquer texto adjacente na direção especificada lógico, ou <see cref="F:System.String.Empty" /> se nenhum texto adjacente pode ser encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna apenas ininterruptas sequências de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto é retornado somente até o próximo símbolo não texto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método. O exemplo usa o <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> método para implementar um extrator de texto simples.  O método retorna uma concatenação de cadeia de caracteres de todo o texto entre dois especificado <xref:System.Windows.Documents.TextPointer> instâncias.  
  
 Embora o exemplo pode ser usado para extrair qualquer texto entre dois <xref:System.Windows.Documents.TextPointer> instâncias, ele é apenas para fins ilustrativos e não deve ser usado no código de produção.  Use a propriedade <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType> em seu lugar.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica para localizar e copiar qualquer texto adjacente.</param>
        <param name="textBuffer">Um buffer em que qualquer texto é copiado.</param>
        <param name="startIndex">Um índice em <c>textBuffer</c> no qual começar a gravar copiado texto.</param>
        <param name="count">O número máximo de caracteres a serem copiados.</param>
        <summary>Copia o número máximo especificado de caracteres de qualquer texto adjacente na direção especificada em uma matriz de caracteres fornecida pelo chamador.</summary>
        <returns>O número de caracteres, na verdade, copiados para <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna apenas ininterruptas sequências de texto.  Nada será retornado se nenhum tipo de símbolo diferente de <xref:System.Windows.Documents.TextPointerContext.Text> adjacente ao atual <xref:System.Windows.Documents.TextPointer> na direção especificada.  Da mesma forma, o texto é retornado somente até o próximo símbolo não texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" />é menor que 0 ou maior que o <see cref="P:System.Array.Length" /> propriedade <paramref name="textBuffer" />.  
  
 -ou-  
  
 <paramref name="count" />é menor que 0 ou maior que o espaço restante no <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> menos <paramref name="startIndex" />).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Uma da <see cref="T:System.Windows.Documents.LogicalDirection" /> valores que especifica a direção lógica na qual contar o número de caracteres.</param>
        <summary>Retorna o número de caracteres Unicode entre atual <see cref="T:System.Windows.Documents.TextPointer" /> e o próximo símbolo não texto, na direção lógica especificada.</summary>
        <returns>O número de caracteres Unicode entre atual <see cref="T:System.Windows.Documents.TextPointer" /> e o próximo símbolo não texto.  Esse número pode ser 0 se não houver nenhum texto adjacente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer um dos seguintes é considerado um símbolo:  
  
-   Uma abertura ou marca de fechamento para o <xref:System.Windows.Documents.TextElement> elemento.  
  
-   Um <xref:System.Windows.UIElement> elemento contido em um <xref:System.Windows.Documents.InlineUIContainer> ou <xref:System.Windows.Documents.BlockUIContainer>.  Observe que essa um <xref:System.Windows.UIElement> sempre são contados como exatamente um símbolo; qualquer conteúdo adicional ou elementos contidos pela <xref:System.Windows.UIElement> não são contadas como símbolos.  
  
-   16 bits [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] caracteres dentro de um texto <xref:System.Windows.Documents.Run> elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o contêiner de texto associado à posição atual tem um layout (atualizado) válido.</summary>
        <value>
          <see langword="true" />Se o layout atual e válido. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando necessário, as operações que dependem de um layout válido (como o <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> método <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> método, e <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> propriedade) tentar gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use essa propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Para obter mais informações, consulte [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insere uma quebra de linha na posição atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> posicionado imediatamente após o <see cref="T:System.Windows.Documents.LineBreak" /> elemento inserido por este método.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Insere uma quebra de parágrafo na posição atual.</summary>
        <returns>Um <see cref="T:System.Windows.Documents.TextPointer" /> para o início (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) do novo parágrafo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método é chamado quando a posição atual está dentro de uma existente <xref:System.Windows.Documents.Paragraph> elemento, o parágrafo existente e qualquer conteúdo que ele contém são divididas em dois parágrafos na posição atual.  Se esse método é chamado quando a posição atual não está dentro de um parágrafo existente, um novo parágrafo vazio é inserido.  Se esse método for chamado em uma posição inadequado para dividir ou inserindo um parágrafo (por exemplo, se a posição atual está dentro de um <xref:System.Windows.Documents.Hyperlink> elemento), uma exceção será lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esse método é chamado em uma posição que não pode ser dividida para acomodar um novo parágrafo, como no escopo de um <see cref="T:System.Windows.Documents.Hyperlink" /> ou <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">O texto a ser inserido.</param>
        <summary>Insere o texto especificado no texto <see cref="T:System.Windows.Documents.Run" /> na posição atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> não é limitado por um <xref:System.Windows.Documents.Run> elemento, um <xref:System.Windows.Documents.Run> é inserida junto com o `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A posição atual não está em um <see cref="T:System.Windows.Documents.Run" /> elemento.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textData" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição atual é uma posição de inserção.</summary>
        <value>
          <see langword="true" />Se a posição atual é uma posição de inserção. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma posição de inserção é uma posição em que o novo conteúdo pode ser adicionado sem interromper todas as regras semânticas para o conteúdo associado.  Na prática, uma posição de inserção é em qualquer lugar no conteúdo em que um cursor pode ser posicionado.  Um exemplo de uma opção válida <xref:System.Windows.Documents.TextPointer> posição que não é uma posição de inserção é a posição entre dois adjacentes <xref:System.Windows.Documents.Paragraph> marcas (ou seja, entre a marca de fechamento de parágrafo anterior e a marca de abertura do próximo parágrafo).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição atual está no início de uma linha.</summary>
        <value>
          <see langword="true" />Se a posição atual está no início de uma linha. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Documents.TextPointer> aponta para uma posição ambígua, por exemplo, entre duas linhas, a linha na direção especificada pelo <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> propriedade for selecionada como a linha de início relativa.  
  
 A operação executada por esta propriedade depende de um layout válido.  Quando necessário, esse método tenta gerar automaticamente um layout válido antes de continuar com a operação.  Regenerar um layout pode ser uma operação relativamente cara.  Use o <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> propriedade para verificar se há um layout válido antes de executar operações que podem regenerar o layout.  Para obter mais informações, consulte [Layout](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">Um <see cref="T:System.Windows.Documents.TextPointer" /> que especifica uma posição para comparar à posição atual.</param>
        <summary>Indica se a posição especificada está no mesmo contêiner de texto como a posição atual.</summary>
        <returns>
          <see langword="true" />Se <paramref name="textPosition" /> indica uma posição que está no mesmo contêiner de texto como a posição atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria das operações que envolvem vários <xref:System.Windows.Documents.TextPointer> instâncias são válidas somente se as instâncias em questão indicam posições que estão no mesmo escopo de contêiner de texto.  Por exemplo o <xref:System.Windows.Documents.TextPointer.CompareTo%2A> e <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> métodos não podem ser usados com um <xref:System.Windows.Documents.TextPointer> para uma posição fora o contêiner de texto associado à posição atual.  Use esse método para verificar se determinado <xref:System.Windows.Documents.TextPointer> é compatível com a posição atual para essas operações.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso para este método.  O exemplo usa o <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> método para verificar se determinado <xref:System.Windows.Documents.TextPointer> é posicionado entre dois outros especificado <xref:System.Windows.Documents.TextPointer> instâncias em uma situação em que não há nenhuma garantia de que todos os três posições pertencem ao mesmo contêiner de texto.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="textPosition" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a direção lógica associada à posição atual que é usada para resolver a ambiguidade conteúdo associado à posição atual.</summary>
        <value>O <see cref="T:System.Windows.Documents.LogicalDirection" /> valor associado com a posição atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como um exemplo de como essa propriedade é usada, o <xref:System.Windows.Documents.LogicalDirection> do <xref:System.Windows.Documents.TextPointer> retornado por um teste de hit método fornece uma dica que entre dois caracteres de texto. A direção da lógica Especifica que os dois caracteres, na verdade, foi atingido, à esquerda ou à direita.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o parágrafo que tem como escopo a posição atual, se houver.</summary>
        <value>O <see cref="T:System.Windows.Documents.Paragraph" /> que a posição atual, os escopos ou <see langword="null" /> se tal parágrafo não existe.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o pai lógico que tem como escopo a posição atual.</summary>
        <value>O pai lógico que tem como escopo a posição atual.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Este tipo ou membro dá suporte à infraestrutura [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] e não se destina a ser usado diretamente do código.</summary>
        <returns>A cadeia de caracteres que representa o objeto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
