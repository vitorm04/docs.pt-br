<Type Name="SessionAuthenticationModule" FullName="System.IdentityModel.Services.SessionAuthenticationModule">
  <TypeSignature Language="C#" Value="public class SessionAuthenticationModule : System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SessionAuthenticationModule extends System.IdentityModel.Services.HttpModuleBase" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Services.SessionAuthenticationModule" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel.Services</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IdentityModel.Services.HttpModuleBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Implementa um módulo do ASP.NET que processa os cookies de sessão em cenários de Web Services Federation.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando presente no pipeline do ASP.NET, o <xref:System.IdentityModel.Services.SessionAuthenticationModule> (SAM) processa cookies de sessão em cenários de WS-Federation. Ele usa o manipulador de cookie especificado pelo <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade ler o cookie de sessão bruto da solicitação de HTTP e gravá-la para a resposta HTTP. Ele usa o <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler> que está configurado para um aplicativo desserializar o cookie de sessão bruto em <xref:System.IdentityModel.Tokens.SessionSecurityToken> objetos. O token de segurança de sessão contém as declarações (<xref:System.Security.Claims.Claim>) e principal (<xref:System.Security.Claims.ClaimsPrincipal>) associados à entidade para a qual a solicitação está sendo realizada.  
  
 Adiciona o SAM seu <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> manipulador de eventos para o <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> eventos no pipeline do ASP.NET. Este manipulador interceptar solicitações de entrada e, se houver um cookie de sessão, desserializa-o em um token de sessão e define o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedades para a entidade de segurança de declarações contidas no token de sessão. Ele chama vários outros métodos expostos pelo SAM durante esse processo.  
  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método pode ser chamado para desconectar o usuário uma sessão (por exemplo, em um arquivo de code-behind SignOut.aspx.cs).  
  
 O SAM expõe vários eventos que fornecem acesso ao seu pipeline de processamento. O <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> eventos permitem modificar tokens de sessão que são lidas de cookies ou criados durante o processamento. Normalmente, isso é feito para adicionar, remover ou transformar as declarações no token de ou para ajustar seu tempo de expiração. O <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut>, e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> eventos fornecem ganchos para o processamento de solicitações de saída. Para muitos cenários, simplesmente adicionando manipuladores para esses eventos, geralmente ao arquivo. asax, será suficiente.  
  
 Para cenários mais complexos, você pode derivar de <xref:System.IdentityModel.Services.SessionAuthenticationModule> para implementar um SAM personalizado. Para esse fim, muitos dos métodos que são chamados durante <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> são expostos de forma que você pode fornecer um comportamento personalizado em estágios específicos do ciclo de vida de processamento de sessão.  
  
 Você pode adicionar o SAM para o pipeline do ASP.NET em um arquivo de configuração, adicionando-os para os módulos HTTP em um a `<system.webServer>` elemento para o IIS versão 7 e posterior ou sob o `<system.web>` elemento para versões anteriores do IIS 7. O manipulador de cookie usado pelo SAM pode ser configurado com o [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
   
  
## Examples  
 [!code-csharp[WifSAM#1](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#1)]  
  
 O XML a seguir mostra como configurar o SAM no pipeline do ASP.NET. Muitos outros elementos que estão presentes em uma configuração típica são omitidos aqui para fins de brevidade.  
  
```xml  
<configuration>  
  <system.webServer>  
    <modules>  
      <!--WIF 4.5 modules -->  
      <add name="SessionAuthenticationModule" type="System.IdentityModel.Services.SessionAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
      <add name="WsFederationAuthenticationModule" type="System.IdentityModel.Services.WSFederationAuthenticationModule, System.IdentityModel.Services, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
  </system.webServer>  
</configuration>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SessionAuthenticationModule ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IdentityModel.Services.SessionAuthenticationModule" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> está definida como `false` e <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade é inicializada para uma instância padrão do <xref:System.IdentityModel.Services.CookieHandlerElement.ChunkedCookieHandler%2A> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual void AuthenticateSessionSecurityToken (System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AuthenticateSessionSecurityToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken, bool writeCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken(System.IdentityModel.Tokens.SessionSecurityToken,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
        <Parameter Name="writeCookie" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sessionToken">O token de segurança de sessão a ser usado para autenticar a solicitação HTTP de entrada.</param>
        <param name="writeCookie">
          <see langword="true" />para gravar o cookie de sessão. Caso contrário, <see langword="false" />.</param>
        <summary>Autentica a solicitação de entrada por meio da validação do token de sessão. Após a validação for bem-sucedida, ela atualiza o contexto HTTP atual e o thread principal com especificado <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método. Ele chama o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken%2A> método para validar o token de entrada e atualize o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedades. Se o `writeCookie` parâmetro é `true`, o <xref:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie%2A> método é invocado para gravar o token de sessão em um cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsSessionTokenCookie">
      <MemberSignature Language="C#" Value="public bool ContainsSessionTokenCookie (System.Web.HttpCookieCollection httpCookieCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ContainsSessionTokenCookie(class System.Web.HttpCookieCollection httpCookieCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ContainsSessionTokenCookie(System.Web.HttpCookieCollection)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="httpCookieCollection" Type="System.Web.HttpCookieCollection" />
      </Parameters>
      <Docs>
        <param name="httpCookieCollection">A coleção de cookies no qual pesquisar.</param>
        <summary>Determina se um cookie de sessão está na coleção do cookie especificado.</summary>
        <returns>
          <see langword="true" />Se um cookie de sessão for encontrado; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="httpCookieCollection" />é nulo</exception>
      </Docs>
    </Member>
    <Member MemberName="ContextSessionSecurityToken">
      <MemberSignature Language="C#" Value="public virtual System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Tokens.SessionSecurityToken ContextSessionSecurityToken" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.ContextSessionSecurityToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ativo <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> atual <see cref="T:System.Web.HttpContext" />.</summary>
        <value>O token de segurança de sessão ativa.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieHandler">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Services.CookieHandler CookieHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IdentityModel.Services.CookieHandler CookieHandler" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Services.CookieHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o manipulador de cookie usado para ler, gravar e excluir cookies de sessão.</summary>
        <value>O manipulador de cookie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade é inicializada através de <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration%2A> método. Esse método inicializa a propriedade com base no manipulador de cookie especificado no <xref:System.IdentityModel.Services.Configuration.FederationConfiguration> definida no objeto de <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> propriedade. Você pode definir o manipulador de cookie em um arquivo de configuração por meio de [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSessionSecurityToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken (System.Security.Claims.ClaimsPrincipal principal, string context, DateTime validFrom, DateTime validTo, bool isPersistent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken CreateSessionSecurityToken(class System.Security.Claims.ClaimsPrincipal principal, string context, valuetype System.DateTime validFrom, valuetype System.DateTime validTo, bool isPersistent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.CreateSessionSecurityToken(System.Security.Claims.ClaimsPrincipal,System.String,System.DateTime,System.DateTime,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Claims.ClaimsPrincipal" />
        <Parameter Name="context" Type="System.String" />
        <Parameter Name="validFrom" Type="System.DateTime" />
        <Parameter Name="validTo" Type="System.DateTime" />
        <Parameter Name="isPersistent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="principal">A entidade a ser capturado no token.</param>
        <param name="context">Uma cadeia de caracteres de contexto definido pelo aplicativo.</param>
        <param name="validFrom">O primeiro instante em que esse token é válido.</param>
        <param name="validTo">O último instante em que esse token é válido.</param>
        <param name="isPersistent">
          <see langword="true" />Se o valor deve ser persistido pelo agente do usuário; Caso contrário, <see langword="false" />.</param>
        <summary>Cria um <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> dos parâmetros especificados usando o manipulador de token de sessão configurado.</summary>
        <returns>O token de sessão.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Não há um manipulador de token de sessão válido configurado. (Não há nenhum <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado na propriedade <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteSessionTokenCookie">
      <MemberSignature Language="C#" Value="public void DeleteSessionTokenCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteSessionTokenCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui o cookie de sessão e a remove do cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Exclui o cookie de sessão usando o manipulador do cookie especificado pelo <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade. Este método é chamado durante o logout, o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeModule">
      <MemberSignature Language="C#" Value="protected override void InitializeModule (System.Web.HttpApplication context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializeModule(class System.Web.HttpApplication context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule(System.Web.HttpApplication)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpApplication" />
      </Parameters>
      <Docs>
        <param name="context">O objeto de aplicativo HTTP que contém este módulo.</param>
        <summary>Inicializa o módulo e o prepara para manipular eventos a partir do módulo [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)] objeto application.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Adiciona o <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> e <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> manipuladores para o <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> e <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> eventos do objeto de aplicativo especificado pelo `context` parâmetro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializePropertiesFromConfiguration">
      <MemberSignature Language="C#" Value="protected override void InitializePropertiesFromConfiguration ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void InitializePropertiesFromConfiguration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.InitializePropertiesFromConfiguration" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa as propriedades de módulo com base nas definições no arquivo de configuração.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicializa o <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade manipulador especificado na configuração do <xref:System.IdentityModel.Services.Configuration.FederationConfiguration?displayProperty=nameWithType> definida no objeto de <xref:System.IdentityModel.Services.FederatedAuthentication.FederationConfiguration%2A?displayProperty=nameWithType> propriedade. Você pode especificar o manipulador de cookie em um arquivo de configuração por meio de [ &lt;cookieHandler&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/cookiehandler.md) elemento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceMode">
      <MemberSignature Language="C#" Value="public bool IsReferenceMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReferenceMode" />
      <MemberSignature Language="DocId" Value="P:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se as informações da sessão (valores de declaração, etc.) devem ser armazenadas no cookie de sessão ou se o conteúdo de sessão deve ser armazenado no lado do servidor, usando o cookie para armazenar apenas uma referência.</summary>
        <value>
          <see langword="true" /> se os cookies emitidos estiverem no modo de referência; caso contrário, <see langword="false" />. O padrão é <see langword="false" />, que especifica que os cookies emitidos não estão no modo de referência.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No modo de referência, o <xref:System.IdentityModel.Tokens.SessionSecurityToken> é armazenado em cache do lado do servidor (um objeto que é derivada de <xref:System.IdentityModel.Tokens.SessionSecurityTokenCache>). O cookie emitido contém apenas um identificador de contexto que é usado para recuperar o token do cache.  
  
> [!IMPORTANT]
>  Para operar no modo de referência, fornecendo um manipulador para a Microsoft recomenda o <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated?displayProperty=nameWithType> eventos no arquivo global.asax.cs e configuração de <xref:System.IdentityModel.Tokens.SessionSecurityToken.IsReferenceMode%2A?displayProperty=nameWithType> propriedade no token passado a <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> propriedade. Isso garantirá que o token de sessão opera em modo de referência para cada solicitação e é favorecido em relação a simplesmente configurar o <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A?displayProperty=nameWithType> propriedade sobre o módulo de autenticação de sessão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthenticateRequest (object sender, EventArgs eventArgs);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthenticateRequest(object sender, class System.EventArgs eventArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="eventArgs" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte para o evento. Isso será um objeto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="eventArgs">Os dados do evento.</param>
        <summary>Manipula o evento <see cref="E:System.Web.HttpApplication.AuthenticateRequest" /> do pipeline [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método faz o seguinte:  
  
1.  Invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie%2A> método para ler um <xref:System.IdentityModel.Tokens.SessionSecurityToken> do cookie de sessão, se houver.  
  
2.  Se uma sessão de token de segurança não pode ser leitura (provavelmente porque não foi estabelecida uma sessão), retornar.  
  
3.  Invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived%2A> método para gerar o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento. Isso fornece uma oportunidade para o token de leitura do cookie a ser modificado ou para a solicitação a ser cancelada. O manipulador também pode especificar que o token deve ser reemitido, definindo o <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> propriedade.  
  
4.  Se o token é necessário emitir novamente, ele remove o cache e invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated%2A> método para gerar o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento. Isso fornece a oportunidade para o token a ser modificado novamente. O comportamento de emita novamente também pode ser modificado definindo a <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> propriedade no manipulador de eventos.  
  
5.  Invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método para autenticar o usuário. Se for bem-sucedido, isso tem o efeito da configuração de <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propriedade para a entidade que está contida no <xref:System.IdentityModel.Tokens.SessionSecurityToken.ClaimsPrincipal%2A?displayProperty=nameWithType> propriedade do token de entrada.  
  
6.  Se a sessão expirou, invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método.  
  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método é adicionado aos manipuladores para o <xref:System.Web.HttpApplication.AuthenticateRequest?displayProperty=nameWithType> evento o <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há um manipulador de token de sessão válido configurado. (Não há nenhum <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado na propriedade <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="OnPostAuthenticateRequest">
      <MemberSignature Language="C#" Value="protected virtual void OnPostAuthenticateRequest (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPostAuthenticateRequest(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">A fonte para o evento. Isso será um objeto <see cref="T:System.Web.HttpApplication" />.</param>
        <param name="e">Os dados do evento.</param>
        <summary>Manipula o evento <see cref="E:System.Web.HttpApplication.PostAuthenticateRequest" /> do pipeline [!INCLUDE[vstecasp](~/includes/vstecasp-md.md)].</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão está vazia.  
  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnPostAuthenticateRequest%2A> manipulador é adicionado aos manipuladores para o <xref:System.Web.HttpApplication.PostAuthenticateRequest?displayProperty=nameWithType> evento o <xref:System.IdentityModel.Services.SessionAuthenticationModule.InitializeModule%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenCreated (System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenCreated(class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenCreated(System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionSecurityTokenReceived (System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionSecurityTokenReceived(class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSessionSecurityTokenReceived(System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignedOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSignedOut (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignedOut(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método após o logout foi executado e o cookie de sessão foi excluído.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSigningOut">
      <MemberSignature Language="C#" Value="protected virtual void OnSigningOut (System.IdentityModel.Services.SigningOutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSigningOut(class System.IdentityModel.Services.SigningOutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut(System.IdentityModel.Services.SigningOutEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.SigningOutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método para executar o logout. Ele é chamado antes que o cookie de sessão é excluído.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSignOutError">
      <MemberSignature Language="C#" Value="protected virtual void OnSignOutError (System.IdentityModel.Services.ErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSignOutError(class System.IdentityModel.Services.ErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError(System.IdentityModel.Services.ErrorEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.IdentityModel.Services.ErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método se ocorrer um erro durante a saída.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie (byte[] sessionCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SessionSecurityToken ReadSessionTokenFromCookie(unsigned int8[] sessionCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SessionSecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionCookie" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="sessionCookie">O cookie, no formato bruto, que contém o token de sessão.</param>
        <summary>Lê um <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> do cookie de sessão especificada.</summary>
        <returns>O token de sessão que foi lido do cookie.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Não há um manipulador de token de sessão válido configurado. (Não há nenhum <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado na propriedade <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenCreated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt; SessionSecurityTokenCreated" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um token de segurança de sessão foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse evento para modificar o token de segurança de sessão antes de serem gravado em um cookie.  
  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> é gerado de dentro de <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método depois de um token de sessão (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) foi criado. Isso acontece, por exemplo, se um manipulador de eventos para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento modifica o token.  
  
 Você pode usar esse evento para modificar as propriedades do token da sessão antes de ela é passada à frente do pipeline e é usada para autenticar a entidade que faz a solicitação (usuário).  
  
 Em um manipulador de eventos, você pode acessar o token por meio de <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A?displayProperty=nameWithType> propriedade. Depois de modificar o token, você pode garantir que ele é regravado no cookie definindo a <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.WriteSessionCookie%2A?displayProperty=nameWithType> propriedade `true`. Ao contrário, o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> não é um evento cancelável.  
  
   
  
## Examples  
 O código a seguir mostra um manipulador para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenCreated> evento implementado no arquivo global.asax.cs de um aplicativo web ASP.NET. Você também deve adicionar o manipulador para o evento. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#6](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionSecurityTokenReceived">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt; SessionSecurityTokenReceived" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um token de segurança de sessão foi lido de um cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> é gerado de dentro de <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnAuthenticateRequest%2A> método depois de um token de sessão (<xref:System.IdentityModel.Tokens.SessionSecurityToken>) tenham sido lidos com êxito o cookie de sessão.  
  
 Você pode usar esse evento para modificar as propriedades do token da sessão antes de ela é passada à frente do pipeline e é usada para autenticar a entidade que faz a solicitação (usuário). Um dos cenários mais comuns envolve modificar o tempo de expiração de sessão (acessível por meio de <xref:System.IdentityModel.Tokens.SessionSecurityToken.ValidTo%2A?displayProperty=nameWithType> propriedade) para substituir o tempo de expiração de sessão definido na configuração por meio do `lifetime` atributo do [ &lt;sessionTokenRequirement&gt; ](~/docs/framework/configure-apps/file-schema/windows-identity-foundation/sessiontokenrequirement.md) elemento. Ao modificar esta propriedade em cada solicitação, você pode implementar uma sessão deslizante; ou seja, uma sessão em que o tempo de vida é estendido cada vez os acessos de usuário do site.  
  
 Em um manipulador de eventos, você pode acessar o token por meio de <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.SessionToken%2A?displayProperty=nameWithType> propriedade. Depois de modificar o token, você pode garantir que ele é regravado no cookie definindo a <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs.ReissueCookie%2A?displayProperty=nameWithType> para `true`. Por fim, o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> é um evento cancelável e você pode definir o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriedade o <xref:System.IdentityModel.Services.SessionSecurityTokenReceivedEventArgs> para anular o processamento da solicitação.  
  
   
  
## Examples  
 O código a seguir mostra um manipulador para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SessionSecurityTokenReceived> evento implementado no arquivo global.asax.cs de um aplicativo web ASP.NET. Você também deve adicionar o manipulador para o evento. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#5](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalFromSessionToken">
      <MemberSignature Language="C#" Value="protected virtual void SetPrincipalFromSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetPrincipalFromSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SetPrincipalFromSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">O token de sessão da qual definir a entidade de segurança.</param>
        <summary>Define a entidade de segurança sobre o <see cref="T:System.Web.HttpContext" /> e <see cref="T:System.Threading.Thread" /> para a entidade que está contida no token de sessão especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken%2A> método e define o <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propriedade e o <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedade em <xref:System.Web.HttpContext.Current%2A?displayProperty=nameWithType> usando as identidades que são retornadas.  
  
 Este método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignedOut">
      <MemberSignature Language="C#" Value="public event EventHandler SignedOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SignedOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o usuário será desconectado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gerados a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método logo após o <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> método é invocado.  
  
 Esse evento não é garantido para ser chamado para cada sessão. Por exemplo, os cookies podem ser excluídos no lado do cliente, caso em que este evento nunca será gerado porque não há nenhum evento do lado do servidor para excluir a sessão.  
  
   
  
## Examples  
 O código a seguir mostra um manipulador para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignedOut> evento implementado no arquivo global.asax.cs de um aplicativo web ASP.NET. Você também deve adicionar o manipulador para o evento. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#3](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SigningOut">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.SigningOutEventArgs&gt; SigningOut" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.SigningOutEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes de excluir a sessão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gerados a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método antes de <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A> método é invocado.  
  
 Esse evento não é garantido para ser chamado para cada sessão. Por exemplo, os cookies podem ser excluídos no lado do cliente, caso em que este evento nunca será gerado porque não há nenhum evento do lado do servidor para excluir a sessão.  
  
   
  
## Examples  
 O código a seguir mostra um manipulador para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SigningOut> evento implementado no arquivo global.asax.cs de um aplicativo web ASP.NET. Você também deve adicionar o manipulador para o evento. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#4](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOut">
      <MemberSignature Language="C#" Value="public virtual void SignOut ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SignOut() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.SignOut" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desconecta o usuário atual e gera os eventos associados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSigningOut%2A>, <xref:System.IdentityModel.Services.SessionAuthenticationModule.DeleteSessionTokenCookie%2A>, e <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignedOut%2A> métodos para executar o logout. Se ocorrer uma exceção, o <xref:System.IdentityModel.Services.SessionAuthenticationModule.OnSignOutError%2A> método é chamado para aumentar o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> evento. Você pode definir o <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriedade o <xref:System.IdentityModel.Services.ErrorEventArgs> objeto passado para o manipulador de eventos para esse evento Cancelar o logout e evitar a exceção sejam propagadas para o cliente.  
  
 Você pode substituir este método para adicionar um comportamento específico do aplicativo.  
  
   
  
## Examples  
 O código a seguir mostra o código para chamar o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método de uma página de SignOut (SignOut.aspx.cs) em um aplicativo web ASP.NET. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#7](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignOutError">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.IdentityModel.Services.ErrorEventArgs&gt; SignOutError" />
      <MemberSignature Language="DocId" Value="E:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.IdentityModel.Services.ErrorEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando há um erro durante a saída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gerados a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOut%2A> método quando ocorre um erro durante a saída.  
  
 Em um manipulador de eventos, você pode obter a exceção que resultaram de eventos gerados a partir de <xref:System.IdentityModel.Services.ErrorEventArgs.Exception%2A?displayProperty=nameWithType> propriedade. Você pode cancelar o processamento de exceção, que tem o resultado de não propagando a exceção para o cliente, definindo a <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> propriedade o <xref:System.IdentityModel.Services.ErrorEventArgs> para `true`.  
  
 Esse evento não é garantido para ser chamado para cada sessão. Por exemplo, os cookies podem ser excluídos no lado do cliente, caso em que este evento nunca será gerado porque não há nenhum evento do lado do servidor para excluir a sessão.  
  
   
  
## Examples  
 O código a seguir mostra um manipulador para o <xref:System.IdentityModel.Services.SessionAuthenticationModule.SignOutError> evento implementado no arquivo global.asax.cs de um aplicativo web ASP.NET. Você também deve adicionar o manipulador para o evento. Um exemplo mais completo é mostrado no <xref:System.IdentityModel.Services.SessionAuthenticationModule> tópico de visão geral.  
  
 [!code-csharp[WifSAM#2](~/samples/snippets/csharp/VS_Snippets_Misc/wifsam/cs/webapplication1/global.asax.cs#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadSessionTokenFromCookie">
      <MemberSignature Language="C#" Value="public bool TryReadSessionTokenFromCookie (out System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryReadSessionTokenFromCookie([out] class System.IdentityModel.Tokens.SessionSecurityToken&amp; sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.TryReadSessionTokenFromCookie(System.IdentityModel.Tokens.SessionSecurityToken@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="sessionToken">Quando este método retorna, contém o token de segurança de sessão que foi lido o cookie de sessão.</param>
        <summary>Tenta ler um <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> de um cookie de sessão e retorna um valor que indica se o cookie de sessão foi lido com êxito.</summary>
        <returns>
          <see langword="true" />Se o cookie de sessão foi lido com êxito a solicitação; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lê o cookie usando o manipulador de cookie configurado no <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade e, em seguida, invoca o <xref:System.IdentityModel.Services.SessionAuthenticationModule.ReadSessionTokenFromCookie%2A> método leia o token do cookie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateSessionToken">
      <MemberSignature Language="C#" Value="protected System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken (System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.Security.Claims.ClaimsIdentity&gt; ValidateSessionToken(class System.IdentityModel.Tokens.SessionSecurityToken sessionSecurityToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.ValidateSessionToken(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;System.Security.Claims.ClaimsIdentity&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionSecurityToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionSecurityToken">O token a ser validado.</param>
        <summary>Valida especificado <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> e retorna suas identidades.</summary>
        <returns>A coleção das identidades contidas no token.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado a partir de <xref:System.IdentityModel.Services.SessionAuthenticationModule.AuthenticateSessionSecurityToken%2A> método. Ele chama o <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler.ValidateToken%2A?displayProperty=nameWithType> método do manipulador de token de sessão configurada para validar o token e extrair suas identidades.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IdentityModel.Services.FederatedSessionExpiredException">O token expirou.</exception>
        <exception cref="T:System.IdentityModel.Services.FederationException">A hora de início token ainda não é válida.</exception>
        <exception cref="T:System.InvalidOperationException">Não há um manipulador de token de sessão válido configurado. (Não há nenhum <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado na propriedade <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSessionTokenToCookie">
      <MemberSignature Language="C#" Value="public void WriteSessionTokenToCookie (System.IdentityModel.Tokens.SessionSecurityToken sessionToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSessionTokenToCookie(class System.IdentityModel.Tokens.SessionSecurityToken sessionToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Services.SessionAuthenticationModule.WriteSessionTokenToCookie(System.IdentityModel.Tokens.SessionSecurityToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel.Services</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sessionToken" Type="System.IdentityModel.Tokens.SessionSecurityToken" />
      </Parameters>
      <Docs>
        <param name="sessionToken">O token de segurança de sessão para gravação.</param>
        <summary>Grava a especificada <see cref="T:System.IdentityModel.Tokens.SessionSecurityToken" /> para um cookie de sessão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Grava o cookie usando o manipulador de cookie configurado no <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sessionToken" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não há um manipulador de token de sessão válido configurado. (Não há nenhum <see cref="T:System.IdentityModel.Tokens.SessionSecurityTokenHandler" /> configurado na propriedade <see cref="P:System.IdentityModel.Configuration.IdentityConfiguration.SecurityTokenHandlers" />.)</exception>
      </Docs>
    </Member>
  </Members>
</Type>
