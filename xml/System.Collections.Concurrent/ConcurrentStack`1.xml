<Type Name="ConcurrentStack&lt;T&gt;" FullName="System.Collections.Concurrent.ConcurrentStack&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class ConcurrentStack&lt;T&gt; : System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit ConcurrentStack`1&lt;T&gt; extends System.Object implements class System.Collections.Concurrent.IProducerConsumerCollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Concurrent.ConcurrentStack`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Concurrent</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.14.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">O tipo dos elementos contidos na pilha.</typeparam>
    <summary>Representa uma coleção thread-safe LIFO (último a entrar, primeiro a sair).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Collections.Concurrent.ConcurrentStack%601>implementa o <xref:System.Collections.Generic.IReadOnlyCollection%601> interface começando com o [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; nas versões anteriores do .NET Framework, o <xref:System.Collections.Concurrent.ConcurrentStack%601> classe não implementou esta interface.  
  
 <xref:System.Collections.Concurrent.ConcurrentStack%601>fornece algumas operações principais:  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A>Insere um elemento na parte superior do <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A>Remove um elemento da parte superior do <xref:System.Collections.Concurrent.ConcurrentStack%601>, ou retorna `false` se o item não pode ser removido.  
  
-   <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPeek%2A>Retorna um elemento que está na parte superior do <xref:System.Collections.Concurrent.ConcurrentStack%601> , mas não removê-lo a <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
-   O <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> e <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> métodos fornecem eficiente enviar por push e pop de vários elementos em uma única operação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar um <xref:System.Collections.Concurrent.ConcurrentStack%601> para enviar por push e pop itens individuais:  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentStack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentstack/cs/concstack.cs#2)]
 [!code-vb[System.Collections.Concurrent.ConcurrentStack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentstack/vb/concstack.vb#2)]  
  
 O exemplo a seguir mostra como usar um <xref:System.Collections.Concurrent.ConcurrentStack%601> para enviar por push e pop intervalos de itens:  
  
 [!code-csharp[System.Collections.Concurrent.ConcurrentStack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.concurrent.concurrentstack/cs/concstack.cs#1)]
 [!code-vb[System.Collections.Concurrent.ConcurrentStack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.concurrent.concurrentstack/vb/concstack.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Todos os membros protegidos e públicos da <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> são thread-safe e podem ser usados simultaneamente em vários threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConcurrentStack (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção cujos elementos são copiados para o novo <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> classe que contém os elementos copiados da coleção especificada</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">O argumento <paramref name="collection" /> é nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os objetos da <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="index">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia os elementos <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> em um <see cref="T:System.Array" /> unidimensional existente, começando no índice da matriz especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> é igual ou maior que o tamanho do <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentStack`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <value>O número de elementos contidos no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar se a coleção contém todos os itens, uso do <xref:System.Collections.Concurrent.ConcurrentStack%601.IsEmpty%2A> propriedade é recomendada em vez de recuperar o número de itens do <xref:System.Collections.Concurrent.ConcurrentStack%601.Count%2A> propriedade e compare-o como 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;T&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera por meio do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <returns>Um enumerador para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A enumeração representa um instantâneo do momento-in-time do conteúdo da pilha. Ele não reflete todas as atualizações para a coleção após <xref:System.Collections.Concurrent.ConcurrentStack%601.GetEnumerator%2A> foi chamado. O enumerador é seguro usar simultaneamente com leituras de e grava a pilha. O enumerador retorna itens em ordem LIFO (último a entrar, primeiro a sair).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> está vazia.</summary>
        <value>true se a <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> estiver vazia, caso contrário, false.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar se a coleção contém todos os itens, é recomendável usar essa propriedade em vez de recuperar o número de itens a partir de <xref:System.Collections.Concurrent.ConcurrentStack%601.Count%2A> propriedade e compare-o como 0. No entanto, como essa coleção se destina a ser acessadas simultaneamente, ele pode ser o caso que outro thread irá modificar a coleção após <xref:System.Collections.Concurrent.ConcurrentStack%601.IsEmpty%2A> retorna, portanto, invalidando o resultados.  
  
 Para obter um exemplo de código, consulte <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Push">
      <MemberSignature Language="C#" Value="public void Push (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Push(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser enviado por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
        <summary>Insere um objeto na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PushRange">
      <MemberSignature Language="C#" Value="public void PushRange (T[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushRange(!T[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="items">Os objetos para enviar por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <summary>Insere vários objetos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomicamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao adicionar vários itens na pilha, usar PushRange é um mecanismo mais eficiente que usar <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A> um item por vez. Além disso, PushRange garante que todos os elementos serão adicionados atomicamente, que significa que nenhum outro thread poderá inserir elementos entre os elementos que estão sendo enviados por push. Itens com índices inferiores no `items` matriz será enviada antes de itens com índices superiores.  
  
 Para obter um exemplo de código, consulte <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="PushRange">
      <MemberSignature Language="C#" Value="public void PushRange (T[] items, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushRange(!T[] items, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="items">Os objetos para enviar por push para o <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <param name="startIndex">O deslocamento de base zero no <c>itens</c> no qual começar a inserir elementos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <param name="count">O número de elementos a serem inseridos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <summary>Insere vários objetos na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomicamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao adicionar vários itens na pilha, usar PushRange é um mecanismo mais eficiente que usar <xref:System.Collections.Concurrent.ConcurrentStack%601.Push%2A> um item por vez. Além disso, PushRange garante que todos os elementos serão adicionados atomicamente, que significa que nenhum outro thread poderá inserir elementos entre os elementos que estão sendo enviados por push. Itens com índices inferiores no `items` matriz será enviada antes de itens com índices superiores.  
  
 Para obter um exemplo de código, consulte <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> é negativo. Ou <paramref name="startIndex" /> é maior que ou igual ao comprimento da <paramref name="items" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> + <paramref name="count" />é maior que o comprimento de <paramref name="items" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryAdd">
      <MemberSignature Language="C#" Value="bool IProducerConsumerCollection&lt;T&gt;.TryAdd (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryAdd(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection&lt;T&gt;#TryAdd(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser adicionado ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />. O valor pode ser uma referência nula (Nada no Visual Basic) para tipos de referência.</param>
        <summary>Tenta adicionar um objeto ao <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
        <returns>true se um objeto tiver sido removido com êxito; caso contrário, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Collections.Concurrent.ConcurrentStack%601>, esta operação irá inserir sempre na parte superior do objeto de <xref:System.Collections.Concurrent.ConcurrentStack%601> e retornar true.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryTake">
      <MemberSignature Language="C#" Value="bool IProducerConsumerCollection&lt;T&gt;.TryTake (out T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.Concurrent.IProducerConsumerCollection&lt;T&gt;.TryTake([out] !T&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection&lt;T&gt;#TryTake(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="item">Quando este método retorna, se a operação foi bem-sucedida, <c>item</c> contém o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
        <summary>Tenta remover e retornar um objeto do <see cref="T:System.Collections.Concurrent.IProducerConsumerCollection`1" />.</summary>
        <returns>true se um elemento tiver sido removido e tiver retornado com êxito; caso contrário, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para <xref:System.Collections.Concurrent.ConcurrentStack%601>, esta operação irá tentar inserir o objeto no topo do <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Um <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="index">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é uma referência nula (Nada no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional. -ou- O <paramref name="array" /> não deve ter indexação baseada em zero. -ou- <paramref name="index" /> é igual ou maior que o tamanho da <paramref name="array" /> -ou- O número de elementos no <see cref="T:System.Collections.ICollection" /> de origem é maior que o espaço disponível do <paramref name="index" /> até o fim da <paramref name="array" /> de destino. -ou- O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser convertido automaticamente no tipo do <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor indicando se o acesso ao <see cref="T:System.Collections.ICollection" /> está sincronizado com o SyncRoot.</summary>
        <value>True se o acesso a <see cref="T:System.Collections.ICollection" /> é sincronizado com o SyncRoot; caso contrário, false. Para <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />, essa propriedade sempre retorna false.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />. Não há suporte para essa propriedade.</summary>
        <value>Retorna nulo (Nothing no Visual Basic).</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a propriedade SyncRoot</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera em uma coleção.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A enumeração representa um instantâneo do momento-in-time do conteúdo da pilha. Ele não reflete todas as atualizações para a coleção após <xref:System.Collections.Concurrent.ConcurrentStack%601.GetEnumerator%2A> foi chamado. O enumerador é seguro usar simultaneamente com leituras de e grava a pilha.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os itens armazenados no <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> para uma nova matriz.</summary>
        <returns>Uma nova matriz que contém um instantâneo dos elementos copiados de <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPeek">
      <MemberSignature Language="C#" Value="public bool TryPeek (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPeek([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">Quando este método retorna, <c>resultados</c> contém um objeto da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> ou um valor não especificado se a operação falhou.</param>
        <summary>Tenta retornar um objeto da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> sem removê-lo.</summary>
        <returns>true se um objeto tiver sido retornado com êxito; caso contrário, false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPop">
      <MemberSignature Language="C#" Value="public bool TryPop (out T result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryPop([out] !T&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="T&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="result">Quando este método retorna, se a operação foi bem-sucedida, <c>resultados</c> contém o objeto removido. Caso nenhum objeto esteja disponível para ser removido, o valor é não especificado.</param>
        <summary>Tenta remover e retornar o objeto na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <returns>true se um elemento tiver sido removido e retornado na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> com êxito; caso contrário, false.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter um exemplo de código, consulte <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPopRange">
      <MemberSignature Language="C#" Value="public int TryPopRange (T[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 TryPopRange(!T[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="items">O <see cref="T:System.Array" /> para quais objetos é exibido na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> será adicionado.</param>
        <summary>Tenta pop e retornar vários objetos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomicamente.</summary>
        <returns>O número de objetos é exibido com êxito da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> e inserido no <paramref name="items" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao exibir vários itens, se houver pouca contenção na pilha, usando `TryPopRange` pode ser mais eficiente que usar <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A> uma vez por item a ser removido. Preenchimento de nós a `items` matriz com o primeiro item a ser exibido em startIndex, o segundo item a ser exibido em startIndex + 1 e assim por diante.  
  
 Para obter um exemplo de código, consulte <xref:System.Collections.Concurrent.ConcurrentStack%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" />é um argumento nulo (Nothing no Visual Basic).</exception>
      </Docs>
    </Member>
    <Member MemberName="TryPopRange">
      <MemberSignature Language="C#" Value="public int TryPopRange (T[] items, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 TryPopRange(!T[] items, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Concurrent</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.14.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="items">O <see cref="T:System.Array" /> para quais objetos é exibido na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> será adicionado.</param>
        <param name="startIndex">O deslocamento de base zero no <c>itens</c> no qual começar a inserir elementos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</param>
        <param name="count">O número de elementos deve ser exibido na parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> e inseridas na <c>itens</c>.</param>
        <summary>Tenta pop e retornar vários objetos da parte superior do <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" /> atomicamente.</summary>
        <returns>O número de objetos com êxito ser exibido na parte superior da pilha e inseridos no <paramref name="items" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao exibir vários itens, se houver pouca contenção na pilha, usar TryPopRange pode ser mais eficiente que usar <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPop%2A> uma vez por item a ser removido. Preenchimento de nós a `items` matriz com o primeiro item a ser exibido em startIndex, o segundo item a ser exibido em startIndex + 1 e assim por diante.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="items" /> é uma referência nula (Nada no Visual Basic).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> é negativo. Ou <paramref name="startIndex" /> é maior que ou igual ao comprimento da <paramref name="items" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> + <paramref name="count" />é maior que o comprimento de <paramref name="items" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
