<Type Name="CriticalHandle" FullName="System.Runtime.InteropServices.CriticalHandle">
  <TypeSignature Language="C#" Value="public abstract class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.CriticalHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma classe wrapper para os recursos do identificador.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.CriticalHandle> classe é semelhante do <xref:System.Runtime.InteropServices.SafeHandle> classe, exceto que <xref:System.Runtime.InteropServices.SafeHandle> implementa a contagem de referência. Você pode usar <xref:System.Runtime.InteropServices.CriticalHandle> em vez de <xref:System.Runtime.InteropServices.SafeHandle> para as considerações de desempenho de endereços quando você pode fornecer a sincronização necessária mais eficiente por conta própria.  
  
 Porque o <xref:System.Runtime.InteropServices.CriticalHandle> classe não realiza a contagem de referência, ele não fornece proteção contra ataques de segurança de reciclagem de identificador. Porque a referência de algoritmo de contagem implicitamente serializa as operações, uma determinada quantidade de acesso thread-safe também serão perdida. Se você chamar o <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método enquanto uma operação que está usando o identificador está pendente em outro thread, ou se você chamar <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> de dois threads ao mesmo tempo, os resultados são não determinísticas. O <xref:System.Runtime.InteropServices.CriticalHandle> classe ainda fornece a finalização crítica garantida fornecida pelo <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe.  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Este membro não pode ser herdado por código parcialmente confiável.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Essa classe não pode ser usada por código parcialmente confiável ou transparente.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalHandle (IntPtr invalidHandleValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.#ctor(System.IntPtr)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">O valor de um identificador inválido (geralmente 0 ou -1).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> com o valor do identificador inválido especificado.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.TypeLoadException">A classe derivada reside em um assembly sem permissão de acesso ao código não gerenciado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Este membro não pode ser herdado por código parcialmente confiável.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Essa classe não pode ser usada por código parcialmente confiável ou transparente.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca o identificador de liberação de recursos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que os recursos sejam liberados. Ao contrário de <xref:System.Runtime.InteropServices.SafeHandle> classe, isso acontecerá sempre imediatamente porque não há nenhuma contagem de referência para indicar que outro thread está usando esse identificador. Portanto, você deve empregar um mecanismo de sincronização para garantir que ele é seguro chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método. Embora a maioria das classes que usam o <xref:System.Runtime.InteropServices.CriticalHandle> classe não é necessário fornecer um finalizador, isso às vezes é necessário (por exemplo, para liberar os buffers de arquivo ou escrever alguns dados de volta para a memória). Nesse caso, a classe pode fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.CriticalHandle> executa finalizador crítico.  
  
 Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.CriticalHandle> objeto. O <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deixa o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em um estado inutilizável.  
  
 **Observação** sempre chamada <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.CriticalHandle> do objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.Runtime.InteropServices.CriticalHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método permite que os recursos sejam liberados. Ao contrário de <xref:System.Runtime.InteropServices.SafeHandle> classe, isso acontecerá sempre imediatamente porque não há nenhuma contagem de referência para indicar que outro thread está usando esse identificador. Portanto, você deve empregar um mecanismo de sincronização para garantir que ele é seguro chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método. Embora a maioria das classes que usam o <xref:System.Runtime.InteropServices.CriticalHandle> classe não é necessário fornecer um finalizador, isso às vezes é necessário (por exemplo, para liberar os buffers de arquivo ou escrever alguns dados de volta para a memória). Nesse caso, a classe pode fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.CriticalHandle> executa finalizador crítico.  
  
 Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.CriticalHandle> objeto. O <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método deixa o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em um estado inutilizável.  
  
 **Observação** sempre chamada a <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.CriticalHandle> do objeto <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para uma operação de descarte normal, <see langword="false" /> para finalizar o identificador.</param>
        <summary>Libera os recursos não gerenciados usados pela classe <see cref="T:System.Runtime.InteropServices.CriticalHandle" /> que especifica se deve executar uma operação de descarte normal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar nunca explicitamente o <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método com o `disposing` parâmetro definido como `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos associados com o identificador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.CriticalHandle.Finalize%2A> método é o destruidor para o <xref:System.Runtime.InteropServices.CriticalHandle> classe. Código do aplicativo não deve chamar este método diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.CriticalHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o identificador a ser encapsulado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não exponha o identificador publicamente (ou seja, fora da classe derivada).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o identificador está fechado.</summary>
        <value>
          <see langword="true" /> se o identificador estiver fechado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método retorna um valor que indica se o <xref:System.Runtime.InteropServices.CriticalHandle> identificador do objeto não está mais associado um recurso nativo. Isso é diferente da definição do <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade, que calcula se um determinado identificador sempre é considerado inválido. O <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> método retorna um `true` valor nos seguintes casos:  
  
-   O <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método foi chamado.  
  
-   O <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método ou <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> método foi chamado e não houver nenhuma referência para o <xref:System.Runtime.InteropServices.CriticalHandle> objeto em outros threads.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.CriticalHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o valor do identificador é inválido.</summary>
        <value>
          <see langword="true" />Se o identificador é válido. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes derivadas devem implementar a <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade para que o common language runtime pode determinar se a finalização crítica é necessária. Classes derivadas devem fornecer uma implementação que se adapta ao tipo geral de identificador de dar suporte a eles (0 ou -1 é inválida). Essas classes, em seguida, podem ser mais derivadas para tipos de identificador de segurança específico.  
  
 Ao contrário de <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> propriedade, que informa se o <xref:System.Runtime.InteropServices.CriticalHandle> objeto terminou de usar o identificador subjacente, o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade calcula se o valor do identificador fornecido é sempre considerado inválido. Portanto, o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> propriedade sempre retorna o mesmo valor para qualquer valor de um identificador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, executa o código necessário para liberar o identificador.</summary>
        <returns>
          <see langword="true" />Se o identificador é liberado com êxito; Caso contrário, no caso de uma falha catastrófica, <see langword="false" />. Nesse caso, ele gera um [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistente de depuração gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método é garantido para ser chamado apenas uma vez, desde que você empregue mecanismos de sincronização adequada para garantir que apenas uma chamada para o <xref:System.Runtime.InteropServices.CriticalHandle.Close%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.Dispose%2A> método é feito. O <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método não será chamado se o <xref:System.Runtime.InteropServices.CriticalHandle.IsInvalid%2A> ou <xref:System.Runtime.InteropServices.CriticalHandle.IsClosed%2A> é de propriedade `true`. Implementar esse método no seu <xref:System.Runtime.InteropServices.CriticalHandle> derivadas de classes para executar qualquer código que é necessário para liberar o identificador. Porque uma das funções de <xref:System.Runtime.InteropServices.CriticalHandle> é garantir a prevenção de perda de recursos, o código em sua implementação de <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> nunca deve falhar. O coletor de lixo chama <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> depois finalizadores normais foram executados para objetos que foram limpos ao mesmo tempo, e garante que os recursos para invocar e que ele não será interrompido enquanto ele está em andamento. Esse método será preparado como uma região de execução restrita (CER) no tempo de construção da instância (junto com todos os métodos em seu gráfico de chamada estaticamente determinável). Embora isso impede que as interrupções de anulação de thread, você ainda deve ter cuidado para não incluir todos os caminhos falhas no seu substituído <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método. Em particular, se aplicam a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> a qualquer método que você chamar a partir de atributo <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A>. Na maioria dos casos, esse código deve ser:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Além disso, para limpeza simple (por exemplo, chamar a API do Win32 `CloseHandle` em um identificador de arquivo) você pode verificar o valor de retorno de chamada de invocação de plataforma única. Para limpeza complexa, você pode ter muita lógica de programa e muitas chamadas de método, algumas das quais podem falhar. Certifique-se de que sua lógica de programa tem código de retorno para cada um desses casos.  
  
 Se o <xref:System.Runtime.InteropServices.CriticalHandle.ReleaseHandle%2A> método `false` por qualquer motivo, ele gera um [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistente de depuração gerenciada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">O identificador pré-existente a ser usado.</param>
        <summary>Define o identificador para o identificador pré-existente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método somente se você precisar oferecer suporte a um identificador já existente (por exemplo, se o identificador é retornado em uma estrutura) porque a infraestrutura de interoperabilidade do .NET Framework COM não oferece suporte para marshaling trata-se em uma estrutura.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca um identificador como inválido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> método somente quando souber que o identificador é inválido e deseja marcá-la como tal. Isso não altera o valor de <xref:System.Runtime.InteropServices.CriticalHandle.handle> campo; ela marca apenas o identificador como inválido. O identificador, em seguida, pode conter um valor potencialmente obsoleto. O efeito dessa chamada é que é feita nenhuma tentativa para liberar os recursos.  
  
 Assim como acontece com o <xref:System.Runtime.InteropServices.CriticalHandle.SetHandle%2A> método, use <xref:System.Runtime.InteropServices.CriticalHandle.SetHandleAsInvalid%2A> somente se você precisar oferecer suporte a um identificador já existente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
