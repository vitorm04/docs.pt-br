<Type Name="Marshal" FullName="System.Runtime.InteropServices.Marshal">
  <TypeSignature Language="C#" Value="public static class Marshal" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Marshal extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.Marshal" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de métodos para alocar a memória não gerenciada, copiando os blocos de memória não gerenciada e convertendo tipos gerenciados em não gerenciados, bem como outros diversos métodos usados ao interagir com código não gerenciado.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `static` métodos definidos no <xref:System.Runtime.InteropServices.Marshal> classe são essenciais para trabalhar com código não gerenciado. A maioria dos métodos definidos nessa classe são normalmente usados por desenvolvedores que desejam fornecer uma ponte entre o gerenciado e modelos de programação. Por exemplo, o <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A> método copia caracteres ANSI de uma cadeia de caracteres especificada (no heap gerenciado) para um buffer no heap gerenciado. Ele também aloca o heap de destino do tamanho correto.  
  
 O common language runtime fornece recursos de empacotamento específicos. Para obter detalhes sobre o comportamento de marshaling, consulte [Marshaling de interoperabilidade](~/docs/framework/interop/interop-marshaling.md).  
  
 O `Read` e `Write` métodos de <xref:System.Runtime.InteropServices.Marshal> classe oferecem suporte a acesso alinhado e não alinhado.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar vários métodos definidos pelo <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#1](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#1)]
 [!code-csharp[Marshal#1](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#1)]
 [!code-vb[Marshal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddRef">
      <MemberSignature Language="C#" Value="public static int AddRef (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 AddRef(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">A contagem de referência da interface a ser incrementada.</param>
        <summary>Incrementa a contagem de referência na interface especificada.</summary>
        <returns>O novo valor da contagem de referência no parâmetro <paramref name="pUnk" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime gerencia a contagem de referência de um objeto COM para você, tornando desnecessário usar este método diretamente. Em casos raros, como testes de um marshaler personalizado, talvez seja necessário para manipular o tempo de vida de um objeto manualmente. Depois de chamar <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, você deve diminuir a contagem de referência usando um método como <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType>. Não confie no valor de retorno de <xref:System.Runtime.InteropServices.Marshal.AddRef%2A>, como às vezes pode estar instável.  
  
 Você pode chamar <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> para obter um <xref:System.IntPtr> valor que representa um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro de interface. Você também pode usar esses métodos e <xref:System.Runtime.InteropServices.Marshal.AddRef%2A> método em objetos gerenciados para obter as interfaces COM representado pelo invólucro do objeto gerenciado. Se você não estiver familiarizado com os detalhes deste tipo de conteúdo adicional, consulte [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr AllocCoTaskMem (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocCoTaskMem(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">O tamanho do bloco de memória a ser alocado.</param>
        <summary>Aloca um bloco de memória do tamanho especificado do alocador de memória de tarefas COM.</summary>
        <returns>Um inteiro que representa o endereço do bloco de memória alocada. Essa memória deve ser liberada com <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>é uma alocação de memória de dois métodos de API no <xref:System.Runtime.InteropServices.Marshal> classe. (<xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> é outro.) O conteúdo de memória inicial retornado é indefinido e a memória alocada pode ser maior que o número solicitado de bytes. Esse método expõe o COM [CoTaskMemAlloc](http://go.microsoft.com/fwlink/?LinkId=148626) função, que é conhecida como o alocador de memória COM tarefas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para atender à solicitação.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">O número necessário de bytes na memória.</param>
        <summary>Aloca memória de memória não gerenciada do processo usando o número de bytes especificado.</summary>
        <returns>Um ponteiro para a memória alocada recentemente. Essa memória deve ser liberada usando o <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>é um dos dois métodos de alocação de memória no <xref:System.Runtime.InteropServices.Marshal> classe. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> é outro.) Esse método expõe o Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkId=148628) função Kernel32.  
  
 Quando <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> chamadas `LocalAlloc`, ele passa um `LMEM_FIXED` sinalizador, que faz com que a memória alocada ser bloqueada no local. Além disso, a memória alocada não é preenchidas com zeros.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamar o <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para atender à solicitação.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr AllocHGlobal (IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int AllocHGlobal(native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="cb">O número necessário de bytes na memória.</param>
        <summary>Aloca memória de memória não gerenciada do processo usando o ponteiro para o número de bytes especificado.</summary>
        <returns>Um ponteiro para a memória alocada recentemente. Essa memória deve ser liberada usando o <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" /> método.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>é um dos dois métodos de alocação de memória no <xref:System.Runtime.InteropServices.Marshal> classe. (<xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A?displayProperty=nameWithType> é outro.) Esse método expõe o Win32 [LocalAlloc](http://go.microsoft.com/fwlink/?LinkID=148628) função Kernel32.  
  
 Quando <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> chamadas `LocalAlloc`, ele passa um `LMEM_FIXED` sinalizador, que faz com que a memória alocada ser bloqueada no local. Além disso, a memória alocada não é preenchidas com zeros.  
  
 Por exemplo de código, consulte <xref:System.Runtime.InteropServices.Marshal> e <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para atender à solicitação.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AreComObjectsAvailableForCleanup">
      <MemberSignature Language="C#" Value="public static bool AreComObjectsAvailableForCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreComObjectsAvailableForCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se o runtime callable wrappers (RCWs) de qualquer contexto estão disponíveis para limpeza.</summary>
        <returns>
          <see langword="true" />Se houver qualquer RCWs disponíveis para limpeza; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se houver muitas referências entre código gerenciado e nativo com elementos gráficos de dependência profunda pode levar muito tempo para todos os objetos Limpar. Cada vez que um GC é executado ele irá liberar algumas RCWs, que por sua vez liberará os objetos subjacentes. Esses objetos COM, em seguida, serão liberar sua referência gerenciada e disponibilizar mais objetos para limpeza na próxima vez que executa um GC, que inicia o processo novamente.  
  
 O <xref:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup%2A> método fornece uma maneira para que o aplicativo determinar quantos ciclos de GC. Coletar e GC. WaitForPendingFinalizers devem ser realizadas para Limpar tudo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BindToMoniker">
      <MemberSignature Language="C#" Value="public static object BindToMoniker (string monikerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object BindToMoniker(string monikerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BindToMoniker(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="monikerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="monikerName">O moniker correspondente para o ponteiro de interface desejado.</param>
        <summary>Obtém um ponteiro de interface identificado pelo moniker especificado.</summary>
        <returns>Um objeto que contém uma referência para o ponteiro de interface identificado pelo parâmetro <paramref name="monikerName" />. Um moniker é um nome e, nesse caso, o moniker é definido por uma interface.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.BindToMoniker%2A>expõe o COM `BindToMoniker` método que produz um objeto que pode ser convertido em qualquer interface COM que você precisa. Esse método fornece a mesma funcionalidade que o `GetObject` método no Visual Basic 6.0 e [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">Um HRESULT não reconhecido foi retornado pelo método <see langword="BindToMoniker" /> não gerenciado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BufferToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr BufferToBSTR (Array ptr, int slen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int BufferToBSTR(class System.Array ptr, int32 slen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.BufferToBSTR(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Array" />
        <Parameter Name="slen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="slen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeWrapperHandleStrength">
      <MemberSignature Language="C#" Value="public static void ChangeWrapperHandleStrength (object otp, bool fIsWeak);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ChangeWrapperHandleStrength(object otp, bool fIsWeak) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength(System.Object,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otp" Type="System.Object" />
        <Parameter Name="fIsWeak" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="otp">O objeto cujo CCW contém um identificador de referência contado. O identificador é forte se a contagem de referência de CCW é maior que zero. Caso contrário, é fraca.</param>
        <param name="fIsWeak">
          <see langword="true" />Para alterar a intensidade da alça no <c>otp</c> parâmetro fraca, independentemente de sua contagem de referência; <see langword="false" /> para redefinir a intensidade da alça em <c>otp</c> ser contados como referência.</param>
        <summary>Altera a intensidade de um objeto [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) identificador (CCW).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength%2A>é usado para funcionalidade ao pool de objetos e nunca deve ser chamado pelo código do usuário diretamente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CleanupUnusedObjectsInCurrentContext">
      <MemberSignature Language="C#" Value="public static void CleanupUnusedObjectsInCurrentContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CleanupUnusedObjectsInCurrentContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica o tempo de execução para limpar todos os RCWs ([Runtime Callable Wrappers](~/docs/framework/interop/runtime-callable-wrapper.md)) alocados no contexto atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sistema de interoperabilidade bomba de mensagens enquanto tenta limpar RCWs. Isso garante que a limpeza para single-threaded apartment (STA) RCWs ocorre em todos os aplicativos, incluindo aqueles que não bomba com bastante frequência. No entanto, alguns aplicativos que bomba adequadamente são muito sensíveis a onde bombeamento ocorre. Quando o sistema interoperabilidade bomba de mensagens nesses aplicativos, em locais inesperados, o aplicativo pode encontrar problemas de reentrância que são difíceis de diagnosticar. Portanto, os aplicativos precisam ser capaz de controlar seus próprios bombeamento para um determinado STA e a limpeza de controle de RCWs.  
  
 No entanto, os desenvolvedores geralmente só um subconjunto dos segmentos no seu aplicativo de controle e, portanto, não podem garantir que todos os threads são bombeamento adequadamente.  
  
 Para resolver esse problema:  
  
1.  Use o <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A?displayProperty=nameWithType> método para desativar a limpeza automática de RCWs e a bombeamento de mensagens que ocorre em uma base por thread. Isso permite aos desenvolvedores recusar a limpeza automática e a bombeamento de mensagens correspondente.  
  
2.  Use o <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A> método para notificar o tempo de execução para limpar todos os RCWs são alocados no contexto atual. Esse método complementar permite aos desenvolvedores controlar com precisão quando o tempo de execução executa a limpeza no contexto atual.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (byte[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(unsigned int8[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de inteiro sem sinal unidimensional de 8 bits para um ponteiro de memória não gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.Copy%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.IntPtr%2CSystem.Int32%29> sobrecarregar e copia a matriz não gerenciada para gerenciado de memória usando o <xref:System.Runtime.InteropServices.Marshal.Copy%28System.IntPtr%2CSystem.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (char[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(char[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de caracteres gerenciada unidimensional para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (double[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de número de ponto flutuante de precisão dupla unidimensional gerenciada para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (short[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int16[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de inteiro com sinal unidimensional de 16 bits para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (int[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz unidimensional de inteiro com sinal de 32 bits para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (long[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(int64[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de inteiro com sinal unidimensional de 64 bits para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, byte[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, unsigned int8[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada para uma matriz gerenciada de inteiro sem sinal de 8 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-byte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-byte/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, char[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, char[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada em uma matriz gerenciada de caracteres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-char#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-char/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, double[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Double[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada para uma matriz de número de ponto flutuante de precisão dupla gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-double#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-double/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, short[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int16[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int16[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada em uma matriz gerenciada de inteiro com sinal de 16 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int16#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int16/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, int[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int32[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciado em uma matriz gerenciada de inteiro com sinal de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, long[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, int64[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Int64[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada em uma matriz gerenciada de inteiro com sinal de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a`source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
   
  
## Examples  
 O exemplo a seguir copia uma matriz para a memória não gerenciada e, em seguida, copia a matriz não gerenciada para memória gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.Copy-int64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.Copy-int64/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, IntPtr[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, native int[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada em uma matriz gerenciada <see cref="T:System.IntPtr" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados que corresponde do `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar o <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr source, float[] destination, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int source, float32[] destination, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr" />
        <Parameter Name="destination" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">O ponteiro de memória do qual copiar.</param>
        <param name="destination">A matriz na qual copiar.</param>
        <param name="startIndex">O índice baseado em zero na matriz de destino em que a cópia deve iniciar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de um ponteiro de memória não gerenciada para uma matriz de número de ponto flutuante de precisão simples gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não gerenciados, matrizes de estilo C não contêm informações de limites, o que impede que o `startIndex` e `length` parâmetros sejam validados. Portanto, os dados não gerenciados correspondente a `source` parâmetro preenche a matriz gerenciada, independentemente de sua utilidade. Você deve inicializar a matriz gerenciada com o tamanho apropriado antes de chamar esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (IntPtr[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(native int[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.IntPtr[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz gerenciada unidimensional <see cref="T:System.IntPtr" /> para um ponteiro de memória não gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de unidimensional gerenciado <xref:System.IntPtr> matriz para uma matriz de estilo C não gerenciada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="destination" />, <paramref name="startIndex" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (float[] source, int startIndex, IntPtr destination, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(float32[] source, int32 startIndex, native int destination, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Single[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.IntPtr" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">A matriz unidimensional a ser copiada.</param>
        <param name="startIndex">O índice baseado em zero na matriz de origem em que a cópia deve iniciar.</param>
        <param name="destination">O ponteiro de memória para copiar.</param>
        <param name="length">O número de elementos da matriz para copiar.</param>
        <summary>Copia os dados de uma matriz de número de ponto flutuante de precisão simples unidimensional gerenciada para um ponteiro de memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para copiar um subconjunto de uma matriz unidimensional de gerenciado para uma matriz de estilo C não gerenciada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" />e <paramref name="length" /> não são válidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="startIndex" />, <paramref name="destination" /> ou <paramref name="length" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject (IntPtr pOuter, object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject(native int pOuter, object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="pOuter">Externa <see langword="IUnknown" /> ponteiro.</param>
        <param name="o">Um objeto para agregação.</param>
        <summary>Agrega um objeto gerenciado com o objeto COM especificado.</summary>
        <returns>Interna <see langword="IUnknown" /> ponteiro do objeto gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> método agrega o ponteiro gerenciado interno de um objeto gerenciado com o ponteiro de externo especificado e retorna uma interna [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro do objeto gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> é um objeto [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateAggregatedObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr CreateAggregatedObject&lt;T&gt; (IntPtr pOuter, T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int CreateAggregatedObject&lt;T&gt;(native int pOuter, !!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pOuter" Type="System.IntPtr" />
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo do objeto gerenciado para agregação.</typeparam>
        <param name="pOuter">Externa [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro.</param>
        <param name="o">O objeto gerenciado para agregação.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Agrega um objeto gerenciado do tipo especificado com o objeto COM especificado.</summary>
        <returns>Interna [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro do objeto gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.CreateAggregatedObject%2A> método agrega o ponteiro gerenciado interno de um objeto gerenciado de um tipo especificado com o ponteiro de externo especificado e retorna uma interna [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro do objeto gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="o" /> é um objeto [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType">
      <MemberSignature Language="C#" Value="public static object CreateWrapperOfType (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateWrapperOfType(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">O objeto a ser encapsulado.</param>
        <param name="t">O tipo de wrapper para criar.</param>
        <summary>Encapsula o objeto COM indicado em um objeto do tipo especificado.</summary>
        <returns>O objeto encapsulado recentemente que é uma instância do tipo desejado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%2A>Converte um tipo de classe COM, normalmente genérica `__ComObject` tipo em outro tipo de classe COM. O objeto COM entrada, representado pelo parâmetro `o`, é um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).  
  
 Tanto o `t` e `o` classes cujas assinaturas são atribuídas com os parâmetros devem ser <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType>. O [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta aplica esse atributo para você quando importa uma biblioteca de tipos. Se você criar manualmente o RCW no código-fonte, você deve aplicar esse atributo para a assinatura gerenciada que representa o coclass original para mostrar suas origens COM.  
  
 Tlbimp.exe importa uma COM [coclass](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582) como uma classe gerenciada e uma interface. A interface de coclass tem o mesmo nome de coclass original e a classe gerenciada com o nome de coclass original acrescentado com "Class". Por exemplo, uma coclass chamado `MyCoclass` torna-se uma interface coclass chamada `MyCoclass` e uma classe gerenciada chamada `MyCoclassClass`. Como `t` deve ser uma classe, não uma interface, certifique-se de especificar a classe gerenciada (`MyCoclassClass`) e não a interface coclass.  
  
> [!NOTE]
>  Você perderá a identidade da entrada COM o objeto, pois uma nova instância RCW encapsula o [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro exposto pelo RCW original.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />deve ser derivado de <see langword="__ComObject" />.  
  
 -ou-  
  
 <paramref name="t" /> é um tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="t" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" /> não pode ser convertido no tipo de destino porque ele não dá suporte a todas as interfaces necessárias.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateWrapperOfType&lt;T,TWrapper&gt;">
      <MemberSignature Language="C#" Value="public static TWrapper CreateWrapperOfType&lt;T,TWrapper&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TWrapper CreateWrapperOfType&lt;T, TWrapper&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TWrapper</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TWrapper" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de objeto para encapsular.</typeparam>
        <typeparam name="TWrapper">O tipo de objeto a ser retornado.</typeparam>
        <param name="o">O objeto a ser encapsulado.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Encapsula o objeto COM indicado em um objeto do tipo especificado.</summary>
        <returns>O objeto recentemente encapsulado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.CreateWrapperOfType%60%602%28%60%600%29>Converte um objeto COM do tipo `T` para o `TWrapper` o tipo de classe COM. O objeto COM entrada, representado pelo parâmetro `o`, é um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW).  
  
 Ambos o `T` parâmetro de tipo genérico e o `o` parâmetro deve ser classes cujas assinaturas são atribuídas com o <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> atributo. O [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta aplica esse atributo para você quando importa uma biblioteca de tipos. Se você criar manualmente o RCW no código-fonte, você deve aplicar esse atributo para a assinatura gerenciada que representa o coclass original para mostrar suas origens COM.  
  
 Tlbimp.exe importa uma COM [coclass](http://msdn.microsoft.com/en-us/333d0904-ffa2-4d25-878d-7422bcd40582) como uma classe gerenciada e uma interface. A interface de coclass tem o mesmo nome de coclass original e a classe gerenciada com o nome de coclass original acrescentado com "Class". Por exemplo, uma coclass chamado `MyCoclass` torna-se uma interface coclass chamada `MyCoclass` e uma classe gerenciada chamada `MyCoclassClass`. Porque`T` deve ser uma classe, não uma interface, certifique-se de especificar a classe gerenciada (`MyCoclassClass`) e não o `coclass` interface.  
  
> [!NOTE]
>  Você perderá a identidade do objeto COM entrada, porque uma nova instância RCW encapsula o [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro exposto pelo RCW original.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" />deve ser derivado de <see langword="__ComObject" />.  
  
 -ou-  
  
 <typeparamref name="T" /> é um tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />não é possível converter o <paramref name="TWrapper" /> porque ele não oferece suporte a interfaces de todos os itens necessárias.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure">
      <MemberSignature Language="C#" Value="public static void DestroyStructure (IntPtr ptr, Type structuretype);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure(native int ptr, class System.Type structuretype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structuretype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <param name="structuretype">Tipo de uma classe formatada. Isso fornece as informações de layout necessárias para excluir o buffer no <c>ptr</c> parâmetro.</param>
        <summary>Libera todas as subestruturas para as quais o bloco de memória não gerenciada especificado aponta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para liberar os campos de tipo de referência, como cadeias de caracteres, de uma estrutura não gerenciada. Ao contrário de seus campos, uma estrutura pode ser um tipo de valor ou um tipo de referência. Estruturas de tipo de valor que contêm campos de tipo de valor (blittable todos) não possuem referências cuja memória deve ser liberada. O <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> método usa esse método para evitar perdas de memória ao reutilizar a memória ocupada por uma estrutura.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>chama o COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) função, que, por sua vez, libera uma cadeia de caracteres alocada.  
  
 Além <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>, o <xref:System.Runtime.InteropServices.Marshal> classe fornece dois outros métodos de desalocação de memória: <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structureType" /> tem um layout automático. Use explícito ou sequencial no seu lugar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="DestroyStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DestroyStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DestroyStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo da estrutura formatado. Isso fornece as informações de layout necessárias para excluir o buffer no <c>ptr</c> parâmetro.</typeparam>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Libera todos os subestruturas de um tipo especificado que o bloco de memória não gerenciado especificado aponta para.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para liberar os campos de tipo de referência, como cadeias de caracteres, de uma estrutura não gerenciada. Ao contrário de seus campos, uma estrutura pode ser um tipo de valor ou um tipo de referência. Estruturas de tipo de valor que contêm campos de tipo de valor (blittable todos) não possuem referências cuja memória deve ser liberada. O <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A?displayProperty=nameWithType> método usa esse método para evitar perdas de memória ao reutilizar a memória ocupada por uma estrutura.  
  
 <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A>chama o COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkId=148633) função, que, por sua vez, libera uma cadeia de caracteres alocada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <typeparamref name="T" /> tem um layout automático. Use explícito ou sequencial no seu lugar.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="FinalReleaseComObject">
      <MemberSignature Language="C#" Value="public static int FinalReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FinalReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O RCW a ser liberado.</param>
        <summary>Libera todas as referências a um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) definindo sua contagem de referência como 0.</summary>
        <returns>O novo valor da contagem de referência do RCW associado a <paramref name="o" /> parâmetro, que é 0 (zero) se a versão for bem-sucedida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> método libera a referência gerenciada para um objeto COM. Chamar esse método é equivalente a chamar o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> método em um loop até que ele retorna 0 (zero).  
  
 Quando a contagem de referência no objeto COM torna-se 0, o objeto COM geralmente é liberado, embora isso depende implementação do objeto COM e está fora do controle de tempo de execução. No entanto, o RCW pode ainda existe, aguardando para ser coletado como lixo.  
  
 O objeto COM não pode ser usado depois que ele foi separado de seu RCW subjacente. Se você tentar chamar um método em RCW depois que a contagem de referência é 0, um <xref:System.Runtime.InteropServices.InvalidComObjectException> será lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O <paramref name="o" /> não é um objeto COM válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeBSTR">
      <MemberSignature Language="C#" Value="public static void FreeBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do BSTR para ser liberado.</param>
        <summary>Libera um <see langword="BSTR" /> usando o COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) função.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType>, você pode usar esse método para desalocar memória. <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A>chama o COM [SysFreeString](http://go.microsoft.com/fwlink/?LinkID=148633) função, o que libera a memória alocada por qualquer um dos seguintes métodos não gerenciados: `SysAllocString`, `SysAllocStringByteLen`, `SysAllocStringLen`, `SysReAllocString`, `SysReAllocStringLen`. Você pode chamar métodos não gerenciados, como esses recursos com a plataforma invocar. Para obter detalhes, consulte [consumindo funções de DLL não gerenciadas](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeCoTaskMem">
      <MemberSignature Language="C#" Value="public static void FreeCoTaskMem (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeCoTaskMem(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço da memória a ser liberada.</param>
        <summary>Libera um bloco de memória alocado pelo alocador de memória de tarefa COM não gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A> para liberar a memória alocada por qualquer <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>, ou nenhum equivalente de método não gerenciado. Se o `ptr` parâmetro é `null`, o método não fará nada.  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>expõe o COM [CoTaskMemFree](http://go.microsoft.com/fwlink/?LinkId=148638) função, o que libera todos os bytes, para que você não pode usar a memória que o `ptr` parâmetro aponta para.  
  
 Além <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>, o <xref:System.Runtime.InteropServices.Marshal> classe fornece dois outros métodos de desalocação de memória: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="FreeHGlobal">
      <MemberSignature Language="C#" Value="public static void FreeHGlobal (IntPtr hglobal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeHGlobal(native int hglobal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hglobal" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hglobal">O identificador retornado pela chamada original correspondente para <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</param>
        <summary>Libera memória anteriormente alocada da memória não gerenciada do processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> para liberar qualquer memória do heap global alocada por <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A>, <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>, ou nenhum equivalente de método API não gerenciado. Se o `hglobal` parâmetro é <xref:System.IntPtr.Zero?displayProperty=nameWithType> o método não fará nada.  
  
 <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>expõe o [LocalFree](http://go.microsoft.com/fwlink/?LinkId=148640) função Kernel32. dll, que libera todos os bytes, para que você não pode usar a memória apontado pela `hglobal`.  
  
 Além <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>, o <xref:System.Runtime.InteropServices.Marshal> classe fornece dois outros desalocação de memória métodos de API: <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> e <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamar o <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#4](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#4)]
 [!code-csharp[Marshal#4](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#4)]
 [!code-vb[Marshal#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#4)]  
  
 O exemplo a seguir demonstra como converter o conteúdo de um gerenciado <xref:System.String> classe a memória não gerenciada e, em seguida, descarte a memória não gerenciada quando terminar.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GenerateGuidForType">
      <MemberSignature Language="C#" Value="public static Guid GenerateGuidForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GenerateGuidForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateGuidForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para gerar um GUID.</param>
        <summary>Retorna o identificador global exclusivo (GUID) para o tipo especificado ou gera um GUID usando o algoritmo usado pelo Exportador da biblioteca (Tlbexp.exe).</summary>
        <returns>Um identificador para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo tem um GUID nos metadados, ele é retornado. Caso contrário, um GUID é gerado automaticamente. Você pode usar esse método para determinar programaticamente o GUID de COM para qualquer tipo gerenciado, incluindo invisível COM tipos. Interfaces de classe são a única exceção porque não correspondem a um tipo gerenciado. <xref:System.Runtime.InteropServices.Marshal.GenerateGuidForType%2A>fornece a mesma funcionalidade que o <xref:System.Type.GUID%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GenerateProgIdForType">
      <MemberSignature Language="C#" Value="public static string GenerateProgIdForType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GenerateProgIdForType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GenerateProgIdForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para obter um ProgID.</param>
        <summary>Retorna um identificador programático (ProgID) para o tipo especificado.</summary>
        <returns>O ProgID do tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo tem um ProgID nos metadados, o ProgID retornado. Caso contrário, um ProgID é gerado com base no nome totalmente qualificado do tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="type" /> parâmetro não é uma classe que pode criar por COM. A classe deve ser público, ter um construtor padrão público e ser visíveis no COM.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="type" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetActiveObject">
      <MemberSignature Language="C#" Value="public static object GetActiveObject (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetActiveObject(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetActiveObject(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">O ProgID (identificador programático) do objeto solicitado.</param>
        <summary>Obtém uma instância em execução do objeto especificado do ROT (tabela de objetos em execução).</summary>
        <returns>O objeto que foi solicitado; Caso contrário, <see langword="null" />. Você pode converter esse objeto para qualquer interface COM que ele suporta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A>expõe o COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) função OLEAUT32. DLL; No entanto, o último esperava um identificador de classe (CLSID) em vez do identificador programático (`ProgID`) esperados por este método. Para obter uma instância em execução de um objeto COM sem um registrado `ProgID`, usar invocação de plataforma para definir o COM [GetActiveObject](https://msdn.microsoft.com/library/ms221467\(v=vs.85\).aspx) função. Para obter uma descrição da plataforma invoke, consulte [consumindo funções de DLL não gerenciadas](~/docs/framework/interop/consuming-unmanaged-dll-functions.md).  
  
## <a name="progid-and-clsid"></a>ProgID e CLSID  
 As chaves na subárvore HKEY_CLASSES_ROOT do registro contêm uma variedade de tipos de subchave. A maioria das subchaves são ProgIDs, que mapeiam uma cadeia de caracteres amigável para um CLSID. Aplicativos geralmente usam essas cadeias de caracteres legível em vez dos CLSIDs numéricos. Geralmente, um componente tem uma versão de ProgID que é mapeado para a versão mais recente do componente que é instalado no sistema.  
  
 Aplicativos e componentes principalmente usam ProgIDs para recuperar seus CLSIDs correspondentes.  
  
   
  
## Examples  
 O exemplo a seguir foi executado em um computador que foi configurado com uma instância em execução do Microsoft Word. Não havia nenhuma instância do Microsoft Excel em execução.  
  
 O exemplo chama <xref:System.Runtime.InteropServices.Marshal.GetActiveObject%2A> duas vezes. A primeira chamada tenta recuperar uma referência a uma instância do Microsoft Word (uma instância do `Word.Application` objeto). A segunda chamada tenta recuperar uma referência a uma instância do Microsoft Excel (uma instância de um `Excel.Application` objeto).  
  
 O código recupera uma referência a uma instância do Microsoft Word com êxito. No entanto, como o Microsoft Excel não está em execução, a tentativa de recuperar o segundo objeto gera um <xref:System.Runtime.InteropServices.COMException>.  
  
 [!code-csharp[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/cs/marshal.getactiveobject.cs#1)]
 [!code-vb[System.Runtime.InteropServices.Marshal.GetActiveObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.interopservices.marshal.getactiveobject/vb/marshal.getactiveobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.COMException">O objeto não foi encontrado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">O objeto que fornece a interface.</param>
        <param name="T">O tipo de interface que é solicitado.</param>
        <summary>Retorna um ponteiro para um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface que representa a interface especificada no objeto especificado. O acesso à interface de consulta personalizada é habilitada por padrão.</summary>
        <returns>O ponteiro da interface que representa a interface especificada para o objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna um ponteiro de interface que representa a interface solicitada no objeto especificado. É particularmente útil se você tiver um método não gerenciado que espera deve passar um ponteiro de interface. Chamando um objeto com esse método faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Sempre use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> para diminuir a contagem de referência quando tiver concluído com o ponteiro. Você deve aderir às regras definidas pelo COM ao usar ponteiros de interface COM bruto.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29>é útil ao chamar um método que expõe um parâmetro de objeto COM como uma <xref:System.IntPtr> tipo, ou com empacotamento personalizado. Embora menos comum, você pode usar esse método em um objeto gerenciado para obter um ponteiro para invólucro do objeto. Por exemplo, você pode usar <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> em um objeto gerenciado que é exportado para COM para obter um ponteiro de interface para <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>. Você não pode obter um ponteiro para uma interface de classe como uma interface de classe não tem o tipo correspondente para passar para o segundo parâmetro (`t`). Em vez disso, use <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> para invocar os membros na interface do padrão de invólucro, que geralmente é uma interface de classe de distribuição automática.  
  
 O <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> sobrecarga do método permite a personalização da interface de consulta por padrão. Para especificar se deseja aplicar a personalização da interface de consulta, use o <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> sobrecarga do método.  
  
 Para obter informações adicionais, consulte o [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), e [introduzindo a Interface de classe](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024) tópicos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <typeparamref name="T" /> não é uma interface.  
  
 -ou-  
  
 O tipo não é visível para COM.  
  
 -ou-  
  
 O parâmetro <typeparamref name="T" /> é um tipo genérico.</exception>
        <exception cref="T:System.InvalidCastException">O parâmetro <paramref name="o" /> não dá suporte à interface solicitada.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="o" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <typeparamref name="T" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject (object o, Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject(object o, class System.Type T, valuetype System.Runtime.InteropServices.CustomQueryInterfaceMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="T" Type="System.Type" />
        <Parameter Name="mode" Type="System.Runtime.InteropServices.CustomQueryInterfaceMode" />
      </Parameters>
      <Docs>
        <param name="o">O objeto que fornece a interface.</param>
        <param name="T">O tipo de interface que é solicitado.</param>
        <param name="mode">Um dos valores de enumeração que indica se deve aplicar um <see langword="IUnknown::QueryInterface" /> personalização que é fornecida por um <see cref="T:System.Runtime.InteropServices.ICustomQueryInterface" />.</param>
        <summary>Retorna um ponteiro para um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface que representa a interface especificada no objeto especificado. Acesso à interface de consulta personalizada é controlado pelo modo de personalização especificado.</summary>
        <returns>O ponteiro de interface que representa a interface para o objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29>permite que você especifique se deseja aplicar a personalização da interface de consulta. Use o <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%29> sobrecarga para aplicar a personalização da interface de consulta por padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <typeparamref name="T" /> não é uma interface.  
  
 -ou-  
  
 O tipo não é visível para COM.  
  
 -ou-  
  
 O parâmetro <typeparamref name="T" /> é um tipo genérico.</exception>
        <exception cref="T:System.InvalidCastException">O objeto <paramref name="o" /> não oferece suporte à interface solicitada.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="o" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <typeparamref name="T" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObject&lt;T,TInterface&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObject&lt;T,TInterface&gt; (T o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObject&lt;T, TInterface&gt;(!!T o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TInterface" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de <c>o</c>.</typeparam>
        <typeparam name="TInterface">O tipo de interface para retornar.</typeparam>
        <param name="o">O objeto que fornece a interface.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Retorna um ponteiro para um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface que representa a interface especificada em um objeto do tipo especificado. O acesso à interface de consulta personalizada é habilitada por padrão.</summary>
        <returns>O ponteiro de interface que representa o <paramref name="TInterface" /> interface.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna um ponteiro de interface que representa o `TInterface` interface no objeto especificado. É particularmente útil se você tiver um método não gerenciado que espera deve passar um ponteiro de interface. Chamando um objeto com esse método faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Use sempre o <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> método para diminuir a contagem de referência quando você tiver terminado com o ponteiro. Você deve aderir às regras definidas pelo COM ao usar ponteiros de interface COM bruto.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29>é útil ao chamar um método que expõe um parâmetro de objeto COM como uma <xref:System.IntPtr> tipo, ou com empacotamento personalizado. Você também pode usar esse método em um objeto gerenciado para obter um ponteiro para invólucro do objeto, embora isso é menos comum. Por exemplo, você pode usar <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> em um objeto gerenciado que é exportado para COM para obter um ponteiro de interface para <xref:System.Runtime.InteropServices.UCOMIConnectionPointContainer?displayProperty=nameWithType>.  
  
 O <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%60%602%28%60%600%29> sobrecarga do método permite a personalização da interface de consulta por padrão. Para especificar se deseja aplicar a personalização da interface de consulta, use o <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%28System.Object%2CSystem.Type%2CSystem.Runtime.InteropServices.CustomQueryInterfaceMode%29> sobrecarga do método.  
  
 Para obter informações adicionais, consulte o [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md), [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), e [introduzindo a Interface de classe](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024) tópicos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="TInterface" /> não é uma interface.  
  
 -ou-  
  
 O tipo não é visível para COM.  
  
 -ou-  
  
 O <typeparamref name="T" /> parâmetro é um tipo genérico aberto.</exception>
        <exception cref="T:System.InvalidCastException">O <paramref name="o" /> parâmetro não oferece suporte a <paramref name="TInterface" /> interface.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="o" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComInterfaceForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetComInterfaceForObjectInContext (object o, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetComInterfaceForObjectInContext(object o, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">O objeto que fornece a interface.</param>
        <param name="t">O tipo de interface que é solicitado.</param>
        <summary>Retorna um ponteiro de interface que representa a interface especificada para um objeto, se o chamador estiver no mesmo contexto de objeto.</summary>
        <returns>O ponteiro de interface especificado por <paramref name="t" /> que representa a interface para o objeto especificado, ou <see langword="null" /> se o chamador não está no mesmo contexto de objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é o mesmo que <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A> exceto que ela retorna `null` se o chamador não está no mesmo contexto de objeto. É particularmente útil se você tiver um método não gerenciado que espera deve passar um ponteiro de interface.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />não é uma interface.  
  
 -ou-  
  
 O tipo não é visível para COM.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />não oferece suporte à interface solicitada.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="t" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComObjectData">
      <MemberSignature Language="C#" Value="public static object GetComObjectData (object obj, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetComObjectData(object obj, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComObjectData(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto COM que contém os dados que você deseja.</param>
        <param name="key">A chave na tabela de hash interno do <c>obj</c> para recuperar os dados do.</param>
        <summary>Recupera os dados que são referenciados pela chave especificada do objeto COM especificado.</summary>
        <returns>Os dados representados pelo <paramref name="key" /> parâmetro na tabela de hash interno a <paramref name="obj" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos COM encapsulados em um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) tem um hash associada da tabela, que <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A> recupera. <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A?displayProperty=nameWithType>adiciona dados à tabela de hash. Você nunca deve ter que chamar o método do seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" />não é um objeto COM.  
  
 -ou-  
  
 <paramref name="obj" /> é um objeto [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetComSlotForMethodInfo">
      <MemberSignature Language="C#" Value="public static int GetComSlotForMethodInfo (System.Reflection.MemberInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetComSlotForMethodInfo(class System.Reflection.MemberInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo(System.Reflection.MemberInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MemberInfo" />
      </Parameters>
      <Docs>
        <param name="m">Um objeto que representa um método de interface.</param>
        <summary>Recupera o slot de tabela (tabela v ou VTBL) de função virtual para um <see cref="T:System.Reflection.MemberInfo" /> tipo quando o tipo é exposto a COM.</summary>
        <returns>O slot VTBL <paramref name="m" /> identificador quando ele é exposto a COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de slot com base em zero retornado pelas contas método para três [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) e possivelmente quatro [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) métodos, tornando o valor do primeiro slot disponível 3 ou 7. <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType>.  
  
 Você pode usar esse método para recuperar os números de slot para membros de interfaces que não estão visíveis no COM e membros de interfaces privadas. Os números de slot retornados correspondem aos números v-table deve ser reservada se o tipo foi exposto a COM. Invisível COM membros realmente ocupam um slot em uma tabela-v exposto, mesmo que o cliente COM não é possível usar o slot. Não é possível usar <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A> em uma interface de classe, passando <xref:System.Reflection.MemberInfo> de uma classe. Para obter mais informações, consulte [introduzindo a Interface de classe](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="m" /> parâmetro não é um <see cref="T:System.Reflection.MemberInfo" /> objeto.  
  
 -ou-  
  
 O <paramref name="m" /> parâmetro não é um método de interface.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer">
      <MemberSignature Language="C#" Value="public static Delegate GetDelegateForFunctionPointer (IntPtr ptr, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate GetDelegateForFunctionPointer(native int ptr, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">O ponteiro de função não gerenciada a ser convertido.</param>
        <param name="t">O tipo de delegado a ser retornado.</param>
        <summary>Converte um ponteiro de função não gerenciada em um delegado.</summary>
        <returns>Uma instância de delegado que pode ser convertida para o tipo de delegado apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nas versões 1.0 e 1.1 do .NET Framework, é possível passar um delegado que representa um método gerenciado para código não gerenciado como um ponteiro de função, permitindo que o código não gerenciado chamar o método gerenciado através do ponteiro de função. Também é possível que o código não gerenciado passar esse ponteiro de função para o código gerenciado e o ponteiro foi resolvido corretamente para o método gerenciado subjacente.  
  
 No .NET Framework 2.0 e versões posteriores, você pode usar o <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> e <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> métodos de realizar marshaling de representantes em ambas as direções. Com <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A>, `ptr` é importado como um <xref:System.IntPtr?displayProperty=nameWithType>. Um <xref:System.IntPtr?displayProperty=nameWithType> pode ser obtido para um delegado gerenciado chamando <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%2A> e passado como um parâmetro; em seguida, pode ser chamado de dentro do método não gerenciado. Observe que o marshaler do parâmetro também puder realizar marshaling de ponteiros de função para delegados no .NET Framework 2.0 e versões posteriores.  
  
 O <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%2A> método tem as seguintes restrições:  
  
-   Não há suporte para genéricos em cenários de interoperabilidade.  
  
-   Você não pode passar um ponteiro de função inválido para este método.  
  
-   Você pode usar esse método somente para ponteiros de função não gerenciada puro.  
  
-   Você não pode usar esse método com ponteiros de função obtidos por meio de C++ ou do <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> método.  
  
-   Você não pode usar esse método para criar um delegado de um ponteiro de função para outro delegado gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="t" /> não é um delegado ou é genérico.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="t" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDelegateForFunctionPointer&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TDelegate GetDelegateForFunctionPointer&lt;TDelegate&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TDelegate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo do delegado a ser retornado.</typeparam>
        <param name="ptr">O ponteiro de função não gerenciada a ser convertido.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Converte um ponteiro de função não gerenciada em um delegado de um tipo especificado.</summary>
        <returns>Uma instância do tipo de delegado especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> e <xref:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate%60%601%28%60%600%29> métodos de realizar marshaling de representantes em ambas as direções.  
  
 O <xref:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer%60%601%28System.IntPtr%29> método tem as seguintes restrições:  
  
-   Você não pode passar um ponteiro de função inválido para este método.  
  
-   Você pode usar esse método somente para ponteiros de função não gerenciada puro.  
  
-   Você não pode usar esse método com ponteiros de função obtidos por meio de C++ ou do <xref:System.RuntimeMethodHandle.GetFunctionPointer%2A> método.  
  
-   Você não pode usar esse método para criar um delegado de um ponteiro de função para outro delegado gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro genérico <paramref name="TDelegate" /> não é um delegado ou é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="ptr" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetEndComSlot">
      <MemberSignature Language="C#" Value="public static int GetEndComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetEndComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Um tipo que representa uma interface ou classe.</param>
        <summary>Recupera o última slot na tabela de função virtual (v-table ou VTBL) de um tipo quando exposto a COM.</summary>
        <returns>O último slot VTBL da interface quando exposto a COM. Se o <paramref name="t" /> parâmetro é uma classe, o slot VTBL retornado é o último slot na interface do que é gerada a partir da classe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna o número de tabela v baseado em zero, para uma interface ou classe. Quando usado em uma classe, o número de slot retornado refere-se a interface de classe para a classe. Se a interface de classe é auto dual, esse método sempre retornará -1 para indicar que a interface somente de expedição não expõe uma tabela v para clientes gerenciados. Você pode usar <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A> e <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> em conjunto com <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> para passar slots dentro de um intervalo especificado. Para obter mais informações, consulte [introduzindo a Interface de classe](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionCode">
      <MemberSignature Language="C#" Value="public static int GetExceptionCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetExceptionCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um código que identifica o tipo da exceção ocorrido.</summary>
        <returns>O tipo da exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionCode%2A>é exposta para suporte de compilador estruturado de manipulação de exceção (SEH) apenas. Se esse método é chamado antes de uma exceção será lançada, ela retornará 0x0.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">O HRESULT a ser convertido.</param>
        <summary>Converte o código de erro HRESULT especificado em um objeto <see cref="T:System.Exception" /> correspondente.</summary>
        <returns>Um objeto que representa o HRESULT convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> método para obter um <xref:System.Exception> com base em um HRESULT sem a necessidade de chamar o <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> método e capturar a exceção.  
  
 Atual [IErrorInfo](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface é usada para construir a exceção.  
  
 Para o mapeamento de cada HRESULT para sua classe de exceção comparáveis no .NET Framework, consulte [como: mapear HRESULTs e exceções](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionForHR">
      <MemberSignature Language="C#" Value="public static Exception GetExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Exception GetExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">O HRESULT a ser convertido.</param>
        <param name="errorInfo">Um ponteiro para o <see langword="IErrorInfo" /> interface que fornece mais informações sobre o erro. Você pode especificar <c>IntPtr(0)</c> usar atual <see langword="IErrorInfo" /> interface, ou <c>IntPtr(-1)</c> para ignorar atual <see langword="IErrorInfo" /> interface e construir a exceção apenas do código de erro.</param>
        <summary>Converte o código de erro HRESULT especificado correspondente <see cref="T:System.Exception" /> objeto, com informações de erro adicionais passados em uma [IErrorInfo](http://msdn.microsoft.com/en-us/4dda6909-2d9a-4727-ae0c-b5f90dcfa447) interface para o objeto de exceção.</summary>
        <returns>Um objeto que representa o HRESULT convertido e as informações obtidas <paramref name="errorInfo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Runtime.InteropServices.Marshal.GetExceptionForHR%2A> método para obter um <xref:System.Exception> com base em um HRESULT sem a necessidade de chamar o <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> método e captura a exceção (evitando assim o sobrecarga de desempenho correspondente). O `errorInfo` parâmetro fornece informações adicionais sobre o erro, como sua descrição textual e o identificador global exclusivo (GUID) para a interface que definiu o erro.  
  
 Use essa sobrecarga de método se você tiver informações de erro personalizada que forneça na conversão.  
  
 Para o mapeamento de cada HRESULT para sua classe de exceção comparáveis no .NET Framework, consulte [como: mapear HRESULTs e exceções](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetExceptionPointers">
      <MemberSignature Language="C#" Value="public static IntPtr GetExceptionPointers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetExceptionPointers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetExceptionPointers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma descrição independente de computador de uma exceção e as informações sobre o estado que existia para o thread quando ocorreu a exceção.</summary>
        <returns>Um ponteiro para um [EXCEPTION_POINTERS](http://go.microsoft.com/fwlink/?LinkId=148648) estrutura.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetExceptionPointers%2A>é exposta para suporte de compilador estruturado de manipulação de exceção (SEH) apenas.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">O delegado a ser passado para código não gerenciado.</param>
        <summary>Converte um delegado em um ponteiro de função que pode ser chamado do código não gerenciado.</summary>
        <returns>Um valor que pode ser passado para código não gerenciado, que, por sua vez, pode ser usado para chamar o delegado subjacente gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O representante `d` é convertido em um ponteiro de função que pode ser passado para código não gerenciado usando o [stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convenção de chamada.  
  
 Manualmente, você deve manter o delegado seja coletado pelo coletor de lixo do código gerenciado. O coletor de lixo rastreia as referências a código não gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="d" /> é um tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="d" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetFunctionPointerForDelegate&lt;TDelegate&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr GetFunctionPointerForDelegate&lt;TDelegate&gt; (TDelegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetFunctionPointerForDelegate&lt;TDelegate&gt;(!!TDelegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDelegate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="d" Type="TDelegate" />
      </Parameters>
      <Docs>
        <typeparam name="TDelegate">O tipo de delegado para converter.</typeparam>
        <param name="d">O delegado a ser passado para código não gerenciado.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Converte um delegado de um tipo especificado em um ponteiro de função que pode ser chamado do código não gerenciado.</summary>
        <returns>Um valor que pode ser passado para código não gerenciado, que, por sua vez, pode ser usado para chamar o delegado subjacente gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O representante `d` é convertido em um ponteiro de função que pode ser passado para código não gerenciado pelo uso de [stdcall](http://msdn.microsoft.com/library/e212594b-1827-4d07-9527-7d412b300df8) convenção de chamada.  
  
 Manualmente, você deve manter o delegado seja coletado pelo coletor de lixo do código gerenciado. O coletor de lixo rastreia as referências a código não gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="d" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHINSTANCE">
      <MemberSignature Language="C#" Value="public static IntPtr GetHINSTANCE (System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetHINSTANCE(class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHINSTANCE(System.Reflection.Module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="m">O módulo cujo HINSTANCE é desejado.</param>
        <summary>Retorna o identificador de instância (HINSTANCE) do módulo especificado.</summary>
        <returns>O HINSTANCE de <paramref name="m" />; ou -1 se o módulo não tiver um HINSTANCE.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando os módulos dinâmicos ou na memória, não tem um HINSTANCE.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="m" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForException">
      <MemberSignature Language="C#" Value="public static int GetHRForException (Exception e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForException(class System.Exception e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="e">A exceção que será convertida em um HRESULT.</param>
        <summary>Converte a exceção especificada para um HRESULT.</summary>
        <returns>O HRESULT mapeado para a exceção fornecida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A>também define uma [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface para a exceção que pode ser obtida chamando a função COM GetErrorInfoNEEDGUID. Você pode usar essa função para retornar um valor HRESULT em uma implementação de classe gerenciada de uma interface COM onde você aplicar o <xref:System.Runtime.InteropServices.PreserveSigAttribute> atributo. Ter as método atribuído captura todas as exceções e usar o <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> método para retornar o valor HRESULT apropriado. Permitindo que uma exceção se propaguem fora do método produz um comportamento incorreto. (Na verdade, o common language runtime não pode passar uma exceção para um cliente COM que chama esse método um por meio de uma tabela v.)  
  
 Observe que o <xref:System.Runtime.InteropServices.Marshal.GetHRForException%2A> método define o [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface do thread atual. Isso pode causar resultados inesperados para métodos, como o <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> métodos como padrão o [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) do thread atual se ele for definido.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHRForLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetHRForLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHRForLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o HRESULT que corresponde ao último erro devido Win32 código executado usando <see cref="T:System.Runtime.InteropServices.Marshal" />.</summary>
        <returns>O HRESULT que corresponde ao último código de erro Win32.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A função de destino deve ter tido o `setLastError` metadados sinalizador definido. Por exemplo, o `SetLastError` campo o <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> devem ser `true`. O processo para definir esse sinalizador depende do idioma de origem usado: c# e C++ são `false` por padrão, mas o `Declare` instrução no Visual Basic é `true`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar um HRESULT correspondente a um código de erro Win32 usando o <xref:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetHRForLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cuja interface <see langword="IDispatch" /> é solicitada.</param>
        <summary>Retorna um [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface de um objeto gerenciado.</summary>
        <returns>O ponteiro <see langword="IDispatch" /> para o parâmetro <paramref name="o" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No código gerenciado, raramente trabalhar diretamente com o `IDispatch` interface. No entanto, <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> é útil ao chamar um método que expõe um parâmetro de objeto COM como uma <xref:System.IntPtr> tipo, ou com empacotamento personalizado. Chamando um objeto com esse método faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Sempre use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> para diminuir a contagem de referência quando tiver concluído com o ponteiro.  
  
 Você também pode usar esse método em um objeto gerenciado para obter um ponteiro de interface de invólucro para o objeto. Para obter mais informações, consulte [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />não oferece suporte à interface solicitada.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIDispatchForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIDispatchForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIDispatchForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIDispatchForObjectInContext(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cuja interface <see langword="IDispatch" /> é solicitada.</param>
        <summary>Retorna um [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface ponteiro de um objeto gerenciado, se o chamador estiver no mesmo contexto de objeto.</summary>
        <returns>O <see langword="IDispatch" /> ponteiro de interface para o objeto especificado, ou <see langword="null" /> se o chamador não está no mesmo contexto do objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é o mesmo que <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A> exceto que ela retorna `null` se o chamador não está no mesmo contexto de objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">
          <paramref name="o" />não oferece suporte à interface solicitada.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetITypeInfoForType">
      <MemberSignature Language="C#" Value="public static IntPtr GetITypeInfoForType (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetITypeInfoForType(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetITypeInfoForType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">O tipo cujo <see langword="ITypeInfo" /> interface está sendo solicitada.</param>
        <summary>Retorna um <see cref="T:System.Runtime.InteropServices.ComTypes.ITypeInfo" /> interface de um tipo gerenciado.</summary>
        <returns>Um ponteiro para o <see langword="ITypeInfo" /> a interface para o <paramref name="t" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna um ponteiro para um `ITypeInfo` implementação baseada no tipo original. Chamar um objeto com <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Sempre use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> para diminuir a contagem de referência quando tiver concluído com o ponteiro. Você pode aplicar o <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> para substituir o comportamento de marshaling de interoperabilidade padrão com este marshaler personalizado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar um ponteiro para o `ITypeInfo` interface para um tipo usando o <xref:System.Runtime.InteropServices.Marshal.GetITypeInfoForType%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetITypeInfoForType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetITypeInfoForType/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />não é um tipo visível para COM.  
  
 -ou-  
  
 <paramref name="t" /> é um tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Uma biblioteca de tipos é registrada para o assembly que contém o tipo, mas a definição de tipo não pode ser encontrada.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObject">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cuja interface <see langword="IUnknown" /> é solicitada.</param>
        <summary>Retorna um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface de um objeto gerenciado.</summary>
        <returns>O ponteiro <see langword="IUnknown" /> para o parâmetro <paramref name="o" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No código gerenciado, raramente trabalhar diretamente com o `IUnknown` interface. No entanto, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> é útil ao chamar um método que expõe um parâmetro de objeto COM como uma <xref:System.IntPtr> tipo, ou com empacotamento personalizado. Chamando um objeto com esse método faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Sempre use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> para diminuir a contagem de referência quando tiver concluído com o ponteiro. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A?displayProperty=nameWithType> método.  
  
 Você também pode usar esse método em um objeto gerenciado para obter um ponteiro de interface para o [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md) para o objeto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface para um objeto gerenciado usando o <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetIUnknownForObjectInContext">
      <MemberSignature Language="C#" Value="public static IntPtr GetIUnknownForObjectInContext (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetIUnknownForObjectInContext(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto cuja interface <see langword="IUnknown" /> é solicitada.</param>
        <summary>Retorna um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface de um objeto gerenciado, se o chamador estiver no mesmo contexto de objeto.</summary>
        <returns>O <see langword="IUnknown" /> ponteiro para o objeto especificado, ou <see langword="null" /> se o chamador não está no mesmo contexto do objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é o mesmo que <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> exceto que ela retorna `null` se o chamador não está no mesmo contexto de objeto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar um `IUnknown` interface para um objeto gerenciado usando o <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObjectInContext-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWin32Error">
      <MemberSignature Language="C#" Value="public static int GetLastWin32Error ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetLastWin32Error() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código de erro retornado pela última função não gerenciada chamada com a invocação da plataforma que tem o sinalizador <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> definido.</summary>
        <returns>O último código de erro definido por uma chamada para o Win32 [SetLastError](http://go.microsoft.com/fwlink/?LinkId=148656) função.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A>expõe o Win32 [GetLastError](http://go.microsoft.com/fwlink/?LinkId=148657) função Kernel32. Este método existe porque não é seguro fazer uma plataforma direta invocar a chamada para `GetLastError` para obter essas informações. Se você quiser acessar esse código de erro, você deve chamar <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> em vez de escrever sua própria plataforma invocar definição para `GetLastError` e chamando-o. O common language runtime pode fazer chamadas internas para APIs que substituir a `GetLastError` mantidos pelo sistema operacional.  
  
 Você pode usar esse método para obter os códigos de erro somente se você aplicar o <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=nameWithType> para a assinatura de método e defina o <xref:System.Runtime.InteropServices.DllImportAttribute.SetLastError> campo`true`. O processo varia dependendo do idioma de origem usado: c# e C++ são `false` por padrão, mas o `Declare` instrução no Visual Basic é `true`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamar o <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error%2A> método. O exemplo demonstra primeiro chamar o método sem erro presente e, em seguida, demonstra isso chamando o método com um erro presente.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetLastWin32Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetLastWin32Error/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetManagedThunkForUnmanagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetManagedThunkForUnmanagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetManagedThunkForUnmanagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Um ponteiro para o método para realizar marshaling.</param>
        <param name="pbSignature">Um ponteiro para a assinatura do método.</param>
        <param name="cbSignature">O número de bytes em <c>pbSignature</c>.</param>
        <summary>Obtém um ponteiro para uma função gerada pelo tempo de execução que realiza marshaling de uma chamada do código gerenciado para não gerenciado.</summary>
        <returns>Um ponteiro para a função que irá realizar marshaling de uma chamada a partir de <paramref name="pfnMethodToWrap" /> parâmetro para código não gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr%2A>é exposta para suporte de compilador somente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodInfoForComSlot">
      <MemberSignature Language="C#" Value="public static System.Reflection.MemberInfo GetMethodInfoForComSlot (Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MemberInfo GetMethodInfoForComSlot(class System.Type t, int32 slot, valuetype System.Runtime.InteropServices.ComMemberType&amp; memberType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="slot" Type="System.Int32" />
        <Parameter Name="memberType" Type="System.Runtime.InteropServices.ComMemberType&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="t">O tipo para o qual o <see cref="T:System.Reflection.MemberInfo" /> devem ser recuperados.</param>
        <param name="slot">O slot VTBL.</param>
        <param name="memberType">Em bem-sucedida um retorno, dos valores de enumeração que especifica o tipo do membro.</param>
        <summary>Recupera um <see cref="T:System.Reflection.MemberInfo" /> objeto para o slot de tabela (tabela v ou VTBL) de função virtual especificado.</summary>
        <returns>O objeto que representa o membro no slot VTBL especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno pode ser um <xref:System.Reflection.FieldInfo>, <xref:System.Reflection.MethodInfo>, ou <xref:System.Reflection.PropertyInfo> objeto. O valor de retorno depende do tipo de membro gerenciado que existe no slot COM determinado (portanto, o generalizado tipo de retorno <xref:System.Reflection.MemberInfo> da qual todas as três derivam).  
  
 O número de slot com base em zero que é retornado por esse método é responsável por três [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) e possivelmente quatro [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) métodos, tornando o valor do primeiro slot disponível 3 ou 7. <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo%2A?displayProperty=nameWithType>. Você pode usar <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A?displayProperty=nameWithType> em conjunto com <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A> para passar slots dentro de um intervalo especificado.  
  
 O `memberType` parâmetro é importante apenas no retorno. Contém o tipo do membro de COM (um método regular ou um acessador de propriedade) corresponde à retornado <xref:System.Reflection.MemberInfo> objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />não é visível do COM.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject (object obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject(object obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto para o qual obter um COM VARIANT.</param>
        <param name="pDstNativeVariant">Um ponteiro para receber a VARIANTE que corresponde do <c>obj</c> parâmetro.</param>
        <summary>Converte um objeto em um COM VARIANT.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pDstNativeVariant` parâmetro deve apontar para a memória suficiente para armazenar a VARIANTE resultante. Além disso, a implementação desse método chama o [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) função na memória bruta que o `pDstNativeVariant` parâmetro aponta para.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="obj" /> é um tipo genérico.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetNativeVariantForObject&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void GetNativeVariantForObject&lt;T&gt; (T obj, IntPtr pDstNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetNativeVariantForObject&lt;T&gt;(!!T obj, native int pDstNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
        <Parameter Name="pDstNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de objeto a ser convertido.</typeparam>
        <param name="obj">O objeto para o qual obter um COM VARIANT.</param>
        <param name="pDstNativeVariant">Um ponteiro para receber a VARIANTE que corresponde do <c>obj</c> parâmetro.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Converte um objeto de um tipo especificado em uma VARIANTE de COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `pDstNativeVariant` parâmetro deve apontar para a memória suficiente para armazenar a VARIANTE resultante. Além disso, a implementação desse método chama [VariantInit](https://msdn.microsoft.com/library/ms221402\(v=vs.85\).aspx) função na memória bruta que o `pDstNativeVariant` parâmetro aponta para.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetObjectForIUnknown (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForIUnknown(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">Um ponteiro para a interface <see langword="IUnknown" />.</param>
        <summary>Retorna uma instância de um tipo que representa um objeto COM um ponteiro para seu [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</summary>
        <returns>Um objeto que representa o objeto COM não gerenciado especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método envolve `IUnknown` em um objeto gerenciado. Isso tem o efeito de incrementar a contagem de referência do componente COM. A contagem de referência será diminuída quando o tempo de execução executa a coleta de lixo no objeto gerenciado que representa o objeto COM.  
  
 O `pUnk` parâmetro representa um `IUnknown` ponteiro de interface; no entanto, porque todas as interfaces COM derivam direta ou indiretamente de `IUnknown`, você pode passar qualquer interface COM para esse método. O objeto retornado por <xref:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown%2A> é um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md), que gerencia o common language runtime como ele faz qualquer outro objeto gerenciado. O tipo desse wrapper geralmente é genérica `System.__ComObject` tipo, que é um tipo oculto usado quando o tipo de wrapper é ambíguo. Você ainda pode fazer chamadas de associação tardia para tal um tipo genérico, desde que implementa o objeto COM o [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5) interface. Da mesma forma, você pode converter o objeto retornado para uma interface COM apropriada.  
  
 Para um objeto a ser encapsulado com um tipo de classe gerenciada específica (e não é um tipo genérico wrapper), você deve atender aos seguintes requisitos:  
  
-   Implementar o [IProvideClassInfo](http://go.microsoft.com/fwlink/?LinkID=148012) interface para o objeto COM.  
  
-   Registre o assembly contendo com o [Regasm.exe (ferramenta de registro de Assembly)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 Como alternativa, você pode evitar esses requisitos e ainda obter um objeto que é encapsulado com um tipo de classe gerenciada específica usando o <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant">
      <MemberSignature Language="C#" Value="public static object GetObjectForNativeVariant (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectForNativeVariant(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pSrcNativeVariant">Um ponteiro para um COM VARIANT.</param>
        <summary>Converte um COM VARIANT em um objeto.</summary>
        <returns>Um objeto que corresponde ao parâmetro <paramref name="pSrcNativeVariant" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>Retorna um objeto gerenciado que corresponde a um ponteiro bruto para um tipo de VARIANTE não gerenciado. O interopmarshaler realiza a transformação idêntica ao expor um tipo VARIANT para código gerenciado.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%2A?displayProperty=nameWithType>.  
  
 Quando o tipo de VARIANTE é VT_ERROR, <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%2A> retorna um objeto do tipo `Int32` em vez de `UInt32`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" /> não é um tipo VARIANT válido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" /> tem um tipo sem suporte.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectForNativeVariant&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T GetObjectForNativeVariant&lt;T&gt; (IntPtr pSrcNativeVariant);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T GetObjectForNativeVariant&lt;T&gt;(native int pSrcNativeVariant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="pSrcNativeVariant" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo para o qual converter a VARIANTE COM.</typeparam>
        <param name="pSrcNativeVariant">Um ponteiro para um COM VARIANT.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Converte uma VARIANTE COM um objeto de um tipo especificado.</summary>
        <returns>Um objeto do tipo especificado que corresponde do <paramref name="pSrcNativeVariant" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>Retorna um objeto gerenciado do tipo `T` que corresponde a um ponteiro bruto para um tipo de VARIANTE não gerenciado. O interopmarshaler realiza a transformação idêntica ao expor um tipo VARIANT para código gerenciado.  
  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant%60%601%28System.IntPtr%29>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject%60%601%28%60%600%2CSystem.IntPtr%29>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.InteropServices.InvalidOleVariantTypeException">
          <paramref name="pSrcNativeVariant" /> não é um tipo VARIANT válido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="pSrcNativeVariant" /> tem um tipo sem suporte.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants">
      <MemberSignature Language="C#" Value="public static object[] GetObjectsForNativeVariants (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object[] GetObjectsForNativeVariants(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="aSrcNativeVariant">Um ponteiro para o primeiro elemento de uma matriz de variantes de COM.</param>
        <param name="cVars">A contagem de variantes de COM no <c>aSrcNativeVariant</c>.</param>
        <summary>Converte uma matriz de COM [variantes](http://go.microsoft.com/fwlink/?LinkId=148670) para uma matriz de objetos.</summary>
        <returns>Uma matriz de objetos que corresponde ao <paramref name="aSrcNativeVariant" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%2A>Retorna uma matriz de objetos gerenciados que corresponde a um ponteiro bruto para uma matriz de estilo C de tipos VARIANT não gerenciados. O interopmarshaler realiza a transformação idêntica ao expor um tipo VARIANT para código gerenciado. O método retorna vazio da matriz quando o `cVars` parâmetro é 0.  
  
 A matriz de objetos (o valor de retorno) obtém limpos como de costume. A matriz de entrada não gerenciado ou variantes individuais na matriz de entrada não são liberados. Portanto, é sua responsabilidade para liberá-los conforme apropriado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" />é um número negativo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectsForNativeVariants&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetObjectsForNativeVariants&lt;T&gt; (IntPtr aSrcNativeVariant, int cVars);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] GetObjectsForNativeVariants&lt;T&gt;(native int aSrcNativeVariant, int32 cVars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="aSrcNativeVariant" Type="System.IntPtr" />
        <Parameter Name="cVars" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo da matriz para retornar.</typeparam>
        <param name="aSrcNativeVariant">Um ponteiro para o primeiro elemento de uma matriz de variantes de COM.</param>
        <param name="cVars">A contagem de variantes de COM no <c>aSrcNativeVariant</c>.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Converte uma matriz de variantes de COM para uma matriz de um tipo especificado.</summary>
        <returns>Uma matriz de <typeparamref name="T" /> objetos que corresponde ao <paramref name="aSrcNativeVariant" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants%60%601%28System.IntPtr%2CSystem.Int32%29>Retorna uma matriz de `T` que corresponde a um ponteiro bruto para uma matriz de estilo C de tipos VARIANT não gerenciados. O interopmarshaler realiza a transformação idêntica ao expor um tipo VARIANT para código gerenciado. O método retorna vazio da matriz quando o `cVars` parâmetro é 0.  
  
 A matriz retornada é coletado como lixo como de costume. A matriz de entrada não gerenciado ou variantes individuais na matriz de entrada não são liberados. Portanto, é sua responsabilidade liberá-los conforme apropriado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cVars" />é um número negativo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetStartComSlot">
      <MemberSignature Language="C#" Value="public static int GetStartComSlot (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetStartComSlot(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">Um tipo que representa uma interface.</param>
        <summary>Obtém o primeiro slot na tabela de função virtual (v-table ou VTBL) que contém os métodos definidos pelo usuário.</summary>
        <returns>O primeiro VTBL slot que contém os métodos definidos pelo usuário. O primeiro slot é 3, se a interface é baseada em [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003)e 7 se a interface é baseada em [IDispatch](http://msdn.microsoft.com/en-us/ebbff4bc-36b2-4861-9efa-ffa45e013eb5).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna o número de base zero v-table para uma interface ou classe. Quando usado em uma classe, o número de slot é retornado se refere à interface de classe para a classe. Se a interface de classe é expedição automática, esse método sempre retornará -1 para indicar que a interface somente de expedição não expõe uma tabela v para clientes gerenciados. Você pode usar <xref:System.Runtime.InteropServices.Marshal.GetStartComSlot%2A> e <xref:System.Runtime.InteropServices.Marshal.GetEndComSlot%2A?displayProperty=nameWithType> em conjunto com <xref:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot%2A?displayProperty=nameWithType> para passar slots dentro de um intervalo especificado. Para obter mais informações, consulte [introduzindo a Interface de classe](http://msdn.microsoft.com/en-us/733c0dd2-12e5-46e6-8de1-39d5b25df024).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />não é visível do COM.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetThreadFromFiberCookie">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread GetThreadFromFiberCookie (int cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Thread GetThreadFromFiberCookie(int32 cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cookie">Um inteiro que representa um cookie de fibra.</param>
        <summary>Converte um cookie de fibra em correspondente <see cref="T:System.Threading.Thread" /> instância.</summary>
        <returns>Um thread que corresponde do <paramref name="cookie" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os cookies de fibra são tokens opacos que são usados pelo host quando o common language runtime para suas decisões de planejamento de fibra de alerta. Eles consistem em uma pilha e registre o contexto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="cookie" /> parâmetro é 0.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypedObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetTypedObjectForIUnknown (IntPtr pUnk, Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetTypedObjectForIUnknown(native int pUnk, class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="pUnk">Um ponteiro para a interface <see langword="IUnknown" /> do objeto não gerenciado.</param>
        <param name="t">O tipo de classe gerenciada solicitada.</param>
        <summary>Retorna um objeto gerenciado de um tipo especificado que representa um objeto COM.</summary>
        <returns>Uma instância da classe correspondente para o <see cref="T:System.Type" /> objeto que representa o objeto COM não gerenciado solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `t` parâmetro deve ser um tipo importado COM ou um subtipo de um tipo importado COM. Além disso, `t` deve ser um tipo cujos metadados foi importado de [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta. Esse tipo deve ser uma classe e não uma interface coclass associado, que assume o nome da classe COM. Por exemplo, se importa Tlbimp.exe `Myclass` como uma classe chamada `MyclassClass` e como uma interface coclass chamado `Myclass`, você deve usar `MyclassClass` (não `Myclass`) com esse método. Para obter informações adicionais sobre importados classes e interfaces de coclass, consulte [conversão de tipo importado](http://msdn.microsoft.com/en-us/cb1ee67d-8ef0-4e40-b2a5-13714b9f33c3).  
  
 Se um objeto já foi obtido para o `pUnk` parâmetro `t` é ignorado e o objeto existente será retornado. `pUnk`representa um[IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro de interface; no entanto, já que todas as interfaces COM derivam diretamente ou indiretamente de `IUnknown`, você pode passar qualquer interface COM para esse método. O objeto retornado por <xref:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown%2A> é um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW), que gerencia o common language runtime como ele faz qualquer outro objeto gerenciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="t" />não é atribuído com <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />.  
  
 -ou-  
  
 <paramref name="t" /> é um tipo [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeForITypeInfo">
      <MemberSignature Language="C#" Value="public static Type GetTypeForITypeInfo (IntPtr piTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeForITypeInfo(native int piTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="piTypeInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="piTypeInfo">O <see langword="ITypeInfo" /> interface para realizar marshaling.</param>
        <summary>Converte um não gerenciado [ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680) o objeto para um gerenciado <see cref="T:System.Type" /> objeto.</summary>
        <returns>Um tipo gerenciado que representa o gerenciado <see langword="ITypeInfo" /> objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A>Retorna um <xref:System.Type?displayProperty=nameWithType> instância com base no tipo original. Você pode aplicar o <xref:System.Runtime.InteropServices.MarshalAsAttribute?displayProperty=nameWithType> para substituir o comportamento de marshaling de interoperabilidade padrão com este marshaler personalizado. O [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta usa o marshaler personalizado para traduzir `ITypeInfo` parâmetros <xref:System.Type?displayProperty=nameWithType> parâmetros. No entanto, se você obtiver um `ITypeInfo` interface por alguns outros meios que Tlbimp.exe, você pode usar <xref:System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo%2A> para executar manualmente a mesma conversão.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">O CLSID do tipo a ser retornado.</param>
        <summary>Retorna o tipo associado ao CLSID (identificador de classe) especificado.</summary>
        <returns>
          <see langword="System.__ComObject" /> independentemente do CLSID ser válido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Runtime.InteropServices.ComTypes.ITypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">Um objeto que representa um <see langword="ITypeInfo" /> ponteiro.</param>
        <summary>Recupera o nome do tipo representado por um [ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680) objeto.</summary>
        <returns>O nome do tipo que o <paramref name="typeInfo" /> parâmetro aponta para.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você também pode recuperar o nome do tipo representado por um `ITypeInfo` chamando o <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> método e passando -1 para o primeiro parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="typeInfo" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfoName">
      <MemberSignature Language="C#" Value="public static string GetTypeInfoName (System.Runtime.InteropServices.UCOMITypeInfo pTI);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeInfoName(class System.Runtime.InteropServices.UCOMITypeInfo pTI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTI" Type="System.Runtime.InteropServices.UCOMITypeInfo" />
      </Parameters>
      <Docs>
        <param name="pTI">Um objeto que representa um <see langword="ITypeInfo" /> ponteiro.</param>
        <summary>Recupera o nome do tipo representado por um [ITypeInfo](http://msdn.microsoft.com/en-us/f3356463-3373-4279-bae1-953378aa2680) objeto.</summary>
        <returns>O nome do tipo que o <paramref name="pTI" /> parâmetro aponta para.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você também pode recuperar o nome do tipo representado por um `ITypeInfo` objeto chamando o <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> método e passando -1 para o primeiro parâmetro.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">A biblioteca de tipos é cujo ID da biblioteca a ser recuperado.</param>
        <summary>Recupera o identificador de biblioteca (LIBID) de uma biblioteca de tipos.</summary>
        <returns>A ID da biblioteca da biblioteca do tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>extrai a ID da biblioteca diretamente de uma biblioteca de tipo existente. Esta ação é diferente do <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> método, que calcula o que deve ser o ID da biblioteca com base no assembly atual.  
  
 Para obter mais informações sobre os identificadores de biblioteca, consulte [exportado conversão de Assembly](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuid">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">A biblioteca de tipos é cujo ID da biblioteca a ser recuperado.</param>
        <summary>Recupera o identificador de biblioteca (LIBID) de uma biblioteca de tipos.</summary>
        <returns>A ID da biblioteca de biblioteca de tipos do que o <paramref name="pTLB" /> parâmetro aponta para.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>extrai a ID da biblioteca diretamente de uma biblioteca de tipo existente. Esta ação é diferente do <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A?displayProperty=nameWithType> método, que calcula o que deve ser o ID da biblioteca com base no assembly atual.  
  
 Para obter mais informações sobre os identificadores de biblioteca, consulte [exportado conversão de Assembly](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibGuidForAssembly">
      <MemberSignature Language="C#" Value="public static Guid GetTypeLibGuidForAssembly (System.Reflection.Assembly asm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetTypeLibGuidForAssembly(class System.Reflection.Assembly asm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly(System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asm" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="asm">O assembly do qual a biblioteca de tipos foi exportada.</param>
        <summary>Recupera o identificador de biblioteca (LIBID) que é atribuído a uma biblioteca de tipo quando ele foi exportado do assembly especificado.</summary>
        <returns>A ID da biblioteca que é atribuído a uma biblioteca de tipo quando ele for exportado do assembly especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando os assemblies são exportados para bibliotecas de tipos, a biblioteca de tipos é atribuída um ID da biblioteca. Você pode definir explicitamente o ID da biblioteca, aplicando o <xref:System.Runtime.InteropServices.GuidAttribute?displayProperty=nameWithType> no assembly nível, ou ele pode ser gerado automaticamente. O [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta calcula um valor de ID da biblioteca com base na identidade do assembly. <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A>Retorna a ID da biblioteca que está associado com o <xref:System.Runtime.InteropServices.GuidAttribute>, se o atributo é aplicado. Caso contrário, <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly%2A> retorna o valor calculado. Como alternativa, você pode usar o <xref:System.Runtime.InteropServices.Marshal.GetTypeLibGuid%2A> método para extrair a ID da biblioteca real de uma biblioteca de tipo existente.  
  
 Consulte o [conversão de Assembly exportados](http://msdn.microsoft.com/en-us/3fffd8db-240f-4fde-a558-a5bcc01e1a86) tópico para obter mais informações sobre os identificadores de biblioteca.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asm" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">A biblioteca de tipos cujo LCID é a ser recuperado.</param>
        <summary>Recupera o LCID de uma biblioteca de tipos.</summary>
        <returns>O LCID da biblioteca de tipos do que o <paramref name="typelib" /> parâmetro aponta para.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibLcid">
      <MemberSignature Language="C#" Value="public static int GetTypeLibLcid (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetTypeLibLcid(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">A biblioteca de tipos cujo LCID é a ser recuperado.</param>
        <summary>Recupera o LCID de uma biblioteca de tipos.</summary>
        <returns>O LCID da biblioteca de tipos do que o <paramref name="pTLB" /> parâmetro aponta para.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.ComTypes.ITypeLib typelib);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.ComTypes.ITypeLib typelib) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typelib" Type="System.Runtime.InteropServices.ComTypes.ITypeLib" />
      </Parameters>
      <Docs>
        <param name="typelib">A biblioteca de tipos cujo nome é a ser recuperado.</param>
        <summary>Recupera o nome de uma biblioteca de tipos.</summary>
        <returns>O nome da biblioteca de tipos do que o <paramref name="typelib" /> parâmetro aponta para.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome retornado por esse método é o identificador usado com a instrução de biblioteca, como ADODB para a biblioteca de tipos do Microsoft ADO. O nome não é um nome de arquivo.  
  
 Você também pode recuperar o nome da biblioteca de tipo chamando o <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> método e passando -1 para o primeiro parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="typelib" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibName">
      <MemberSignature Language="C#" Value="public static string GetTypeLibName (System.Runtime.InteropServices.UCOMITypeLib pTLB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTypeLibName(class System.Runtime.InteropServices.UCOMITypeLib pTLB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pTLB" Type="System.Runtime.InteropServices.UCOMITypeLib" />
      </Parameters>
      <Docs>
        <param name="pTLB">A biblioteca de tipos cujo nome é a ser recuperado.</param>
        <summary>Recupera o nome de uma biblioteca de tipos.</summary>
        <returns>O nome da biblioteca de tipos do que o <paramref name="pTLB" /> parâmetro aponta para.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome retornado por esse método é o identificador usado com a instrução de biblioteca, como ADODB para a biblioteca de tipos do Microsoft ADO. O nome não é um nome de arquivo.  
  
 Você também pode recuperar o nome da biblioteca de tipo chamando o <xref:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation%2A?displayProperty=nameWithType> método e passando -1 para o primeiro parâmetro.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetTypeLibVersionForAssembly">
      <MemberSignature Language="C#" Value="public static void GetTypeLibVersionForAssembly (System.Reflection.Assembly inputAssembly, out int majorVersion, out int minorVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetTypeLibVersionForAssembly(class System.Reflection.Assembly inputAssembly, [out] int32&amp; majorVersion, [out] int32&amp; minorVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetTypeLibVersionForAssembly(System.Reflection.Assembly,System.Int32@,System.Int32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputAssembly" Type="System.Reflection.Assembly" />
        <Parameter Name="majorVersion" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="minorVersion" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="inputAssembly">Um assembly gerenciado.</param>
        <param name="majorVersion">O número da versão principal.</param>
        <param name="minorVersion">O número da versão secundária.</param>
        <summary>Recupera o número de versão de uma biblioteca de tipos que será exportado do assembly especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de exportar um assembly usando <xref:System.Runtime.InteropServices.TypeLibExporterFlags> com o `CallerResolvedReferences` valor, você pode usar esse método para recuperar a versão da biblioteca de tipo do assembly.  
  
 Se você não se aplicam a <xref:System.Runtime.InteropServices.TypeLibVersionAttribute> atributo a um assembly exportado para controlar explicitamente o número da versão da biblioteca de tipo gerado, a biblioteca de tipos terá o mesmo número de versão do assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputAssembly" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueObjectForIUnknown">
      <MemberSignature Language="C#" Value="public static object GetUniqueObjectForIUnknown (IntPtr unknown);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUniqueObjectForIUnknown(native int unknown) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unknown" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="unknown">Um ponteiro gerenciado para um <see langword="IUnknown" /> interface.</param>
        <summary>Cria uma única [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) objeto (RCW) para um determinado [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) interface.</summary>
        <returns>Um RCW exclusivo especificado <see langword="IUnknown" /> interface.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown%2A> método garante que você receba um RCW exclusivo, porque não corresponde a um `IUnknown` ponteiro para um objeto existente. Use este método quando você precisa criar um RCW exclusivo que não seja afetado por outro código que chama o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetUnmanagedThunkForManagedMethodPtr">
      <MemberSignature Language="C#" Value="public static IntPtr GetUnmanagedThunkForManagedMethodPtr (IntPtr pfnMethodToWrap, IntPtr pbSignature, int cbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int GetUnmanagedThunkForManagedMethodPtr(native int pfnMethodToWrap, native int pbSignature, int32 cbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr(System.IntPtr,System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pfnMethodToWrap" Type="System.IntPtr" />
        <Parameter Name="pbSignature" Type="System.IntPtr" />
        <Parameter Name="cbSignature" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pfnMethodToWrap">Um ponteiro para o método para realizar marshaling.</param>
        <param name="pbSignature">Um ponteiro para a assinatura do método.</param>
        <param name="cbSignature">O número de bytes em <c>pbSignature</c>.</param>
        <summary>Obtém um ponteiro para uma função gerada pelo tempo de execução que realiza marshaling de uma chamada de não gerenciado para código gerenciado.</summary>
        <returns>Um ponteiro para uma função que será realizar marshaling de uma chamada de <paramref name="pfnMethodToWrap" /> para código gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr%2A>é exposta para suporte de compilador somente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsComObject">
      <MemberSignature Language="C#" Value="public static bool IsComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto a ser verificado.</param>
        <summary>Indica se um objeto especificado representa um objeto COM.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="o" /> for um tipo COM; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsComObject%2A>Retorna `true` se o tipo de classe da instância é atribuído com <xref:System.Runtime.InteropServices.ComImportAttribute?displayProperty=nameWithType> ou se ela deriva diretamente ou indiretamente de uma classe atribuída com <xref:System.Runtime.InteropServices.ComImportAttribute>. O [Tlbimp.exe (importador da biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) ferramenta aplica esse atributo para você quando importa uma biblioteca de tipos.  
  
 Outros dois métodos também determinam se um objeto especificado representa um objeto COM, mas os requisitos para retornar `true` diferem entre os requisitos desse método. <xref:System.Type.IsImport%2A?displayProperty=nameWithType>Retorna `true` se a classe (ou interface) é atribuída com <xref:System.Runtime.InteropServices.ComImportAttribute> diretamente; ela não retorna `true` para tipos derivados. <xref:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType%2A?displayProperty=nameWithType>Retorna `true` se o tipo é atribuído com <xref:System.Runtime.InteropServices.ComImportAttribute> ou deriva de um tipo com o mesmo GUID.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="o" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsTypeVisibleFromCom">
      <MemberSignature Language="C#" Value="public static bool IsTypeVisibleFromCom (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsTypeVisibleFromCom(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">O tipo para verificar se há visibilidade COM.</param>
        <summary>Indica se um tipo é visível para clientes COM.</summary>
        <returns>
          <see langword="true" />Se o tipo é visível para COM; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom%2A>permite que você verifique para visibilidade COM em uma única etapa. Tipos que não são visíveis não podem ser usados no COM. Um tipo é visível se ele for `public` e não ocultos com o <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NumParamBytes">
      <MemberSignature Language="C#" Value="public static int NumParamBytes (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 NumParamBytes(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.NumParamBytes(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">O método a ser verificada.</param>
        <summary>Calcula o número de bytes de memória não gerenciada que são necessários para manter os parâmetros para o método especificado.</summary>
        <returns>O número de bytes necessários para representar os parâmetros do método na memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.NumParamBytes%2A> método retorna o tamanho da pilha (em bytes) necessário para representar os parâmetros de uma assinatura do método na memória não gerenciada.  
  
 Observe que o valor de retorno desse método é dependente de plataforma. Por exemplo, uma assinatura com um único parâmetro de inteiro retorna um valor de 4 em plataformas de 32 bits e um valor de 8 em plataformas de 64 bits.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="m" /> parâmetro não é um <see cref="T:System.Reflection.MethodInfo" /> objeto.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf (Type t, string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf(class System.Type t, string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="t">Um tipo de valor ou tipo de referência formatada que especifica a classe gerenciada. Você deve aplicar o <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> à classe.</param>
        <param name="fieldName">O campo dentro do <c>t</c> parâmetro.</param>
        <summary>Retorna o deslocamento de campo do formulário não gerenciado da classe gerenciada.</summary>
        <returns>O deslocamento, em bytes, para o parâmetro <paramref name="fieldName" /> dentro da classe especificada que é declarado pela invocação de plataforma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A>fornece o deslocamento em termos no layout de estrutura não gerenciada, o que não corresponde ao deslocamento do layout da estrutura gerenciada. A estrutura de empacotamento pode transformar o layout e alterar o deslocamento. O `t` parâmetro pode ser um tipo de valor ou um tipo de referência formatado (com um layout explícito ou sequencial). Você pode obter o tamanho de todo o layout usando o <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A?displayProperty=nameWithType> método. Para obter mais informações, consulte [padrão de empacotamento para tipos de valor](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Começando com o .NET Framework versão 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> pode expor campos particulares.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A classe não pode ser exportada, visto que uma estrutura ou o campo é confidencial. A partir do .NET Framework versão 2.0, o campo pode ser privado.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="t" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OffsetOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr OffsetOf&lt;T&gt; (string fieldName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int OffsetOf&lt;T&gt;(string fieldName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">Um tipo de valor gerenciado ou um tipo de referência formatado. Você deve aplicar o <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> à classe de atributo.</typeparam>
        <param name="fieldName">O nome do campo no <c>T</c> tipo.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Retorna o deslocamento de campo do formulário não gerenciado de uma classe gerenciada especificada.</summary>
        <returns>O deslocamento, em bytes, para o parâmetro <paramref name="fieldName" /> dentro da classe especificada que é declarado pela invocação de plataforma.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.OffsetOf%60%601%28System.String%29>fornece o deslocamento em termos no layout de estrutura não gerenciada, o que não corresponde ao deslocamento do layout da estrutura gerenciada. A estrutura de empacotamento pode transformar o layout e alterar o deslocamento. O `T` parâmetro de tipo genérico pode ser um tipo de valor ou um tipo de referência formatado (com um layout explícito ou sequencial). Você pode obter o tamanho de todo o layout usando o <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> método. Para obter mais informações, consulte [padrão de empacotamento para tipos de valor](http://msdn.microsoft.com/en-us/4d9a876c-e05a-40ba-bd85-bd22877f984a).  
  
> [!NOTE]
>  Começando com o .NET Framework versão 2.0, <xref:System.Runtime.InteropServices.Marshal.OffsetOf%2A> pode expor campos particulares.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prelink">
      <MemberSignature Language="C#" Value="public static void Prelink (System.Reflection.MethodInfo m);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Prelink(class System.Reflection.MethodInfo m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Prelink(System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="m">O método a ser verificada.</param>
        <summary>Executa tarefas de configuração de uso único método sem chamar o método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tarefas de configuração fornecem inicialização antecipada e são executadas automaticamente quando o método de destino é invocado. Pela primeira vez tarefas incluem o seguinte:  
  
-   Verificando a plataforma invocar metadados está formatado corretamente.  
  
-   Verificar se todos os tipos gerenciados são os parâmetros válidos de plataforma invocar funções.  
  
-   Localizar e carregar a DLL não gerenciada para o processo.  
  
-   Localizando o ponto de entrada do processo.  
  
 Chamando <xref:System.Runtime.InteropServices.Marshal.Prelink%2A> em um método fora da plataforma invoke não tem nenhum efeito. Para executar o programa de instalação na plataforma de todas as tarefas de invocar métodos em um tipo, use <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="m" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="m" /> parâmetro não é um <see cref="T:System.Reflection.MethodInfo" /> objeto.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrelinkAll">
      <MemberSignature Language="C#" Value="public static void PrelinkAll (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrelinkAll(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PrelinkAll(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">A classe cujos métodos devem ser verificados.</param>
        <summary>Executa uma verificação de pré-vínculo para todos os métodos em uma classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> método invoca <xref:System.Runtime.InteropServices.Marshal.Prelink%2A?displayProperty=nameWithType> em cada método de um determinado tipo. <xref:System.Runtime.InteropServices.Marshal.Prelink%2A>executa tarefas de configuração de uso único método sem chamar cada método. Você pode usar <xref:System.Runtime.InteropServices.Marshal.PrelinkAll%2A> apenas para a plataforma de chamadas de invocação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="c" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do primeiro caractere da cadeia de caracteres não gerenciada.</param>
        <summary>Copia todos os caracteres até o primeiro caractere nulo de uma cadeia de caracteres ANSI não gerenciada para um <see cref="T:System.String" /> gerenciado e amplia cada caractere ANSI para Unicode.</summary>
        <returns>Uma cadeia de caracteres gerenciada que mantém uma cópia da cadeia de caracteres ANSI não gerenciada. Se <paramref name="ptr" /> for <see langword="null" />, o método retornará uma cadeia de caracteres nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> método para criar uma cadeia de caracteres gerenciada de um não `char` matriz.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAnsi">
      <MemberSignature Language="C#" Value="public static string PtrToStringAnsi (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAnsi(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do primeiro caractere da cadeia de caracteres não gerenciada.</param>
        <param name="len">O número de bytes da cadeia de caracteres de entrada a ser copiado.</param>
        <summary>Aloca um <see cref="T:System.String" /> gerenciado, copia um número especificado de caracteres de uma cadeia de caracteres ANSI não gerenciada para ele e amplia cada caractere ANSI para Unicode.</summary>
        <returns>Uma cadeia de caracteres gerenciada que mantém uma cópia da cadeia de caracteres ANSI nativa se o valor do parâmetro <paramref name="ptr" /> não for <see langword="null" />; caso contrário, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A> método para criar uma cadeia de caracteres gerenciada de um não`char` matriz.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> é menor que zero.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">Para plataformas Unicode, o endereço do primeiro caractere Unicode.  
  
 -ou-  
  
 Para plataformas Unicode, o endereço do primeiro caractere ANSI.</param>
        <summary>Aloca um <see cref="T:System.String" /> gerenciado e copia todos os caracteres até o primeiro caractere nulo de uma cadeia de caracteres armazenada na memória não gerenciada para ele.</summary>
        <returns>Uma cadeia de caracteres gerenciada que mantém uma cópia da cadeia de caracteres não gerenciada, se o valor do <paramref name="ptr" /> parâmetro não é <see langword="null" />; caso contrário, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a plataforma atual é Unicode, cada caractere ANSI será ampliada para um caractere Unicode e este método chama <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>. Caso contrário, este método chama <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType> métodos.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringAuto">
      <MemberSignature Language="C#" Value="public static string PtrToStringAuto (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringAuto(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">Para plataformas Unicode, o endereço do primeiro caractere Unicode.  
  
 -ou-  
  
 Para plataformas Unicode, o endereço do primeiro caractere ANSI.</param>
        <param name="len">O número de caracteres a serem copiados.</param>
        <summary>Aloca um gerenciado <see cref="T:System.String" /> e copia o número especificado de caracteres de uma cadeia de caracteres armazenada na memória não gerenciada para ele.</summary>
        <returns>Uma cadeia de caracteres gerenciada que contém uma cópia da cadeia de caracteres nativo, se o valor da <paramref name="ptr" /> parâmetro não é <see langword="null" />; caso contrário, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em plataformas de Unicode, este método chama <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>; em plataformas de ANSI, ele chama <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A>. Não há transformações são feitas antes que esses métodos são chamados.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="len" /> é menor que zero.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringBSTR">
      <MemberSignature Language="C#" Value="public static string PtrToStringBSTR (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringBSTR(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do primeiro caractere da cadeia de caracteres não gerenciada.</param>
        <summary>Aloca um gerenciado <see cref="T:System.String" /> e copia um [cadeia de caracteres binária (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) armazenados em memória não gerenciada para ele.</summary>
        <returns>Uma cadeia de caracteres gerenciada que contém uma cópia da cadeia de caracteres não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame este método somente em cadeias de caracteres que foram alocadas com não gerenciado [SysAllocString](https://msdn.microsoft.com/library/ms221458\(v=vs.85\).aspx) e [SysAllocStringLen](https://msdn.microsoft.com/library/ms221639\(v=vs.85\).aspx) funções.  
  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="ptr" /> é igual a <see cref="F:System.IntPtr.Zero" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do primeiro caractere da cadeia de caracteres não gerenciada.</param>
        <summary>Aloca uma <see cref="T:System.String" /> gerenciada e copia para ela todos os caracteres até o primeiro caractere nulo de uma cadeia de caracteres Unicode não gerenciada.</summary>
        <returns>Uma cadeia de caracteres gerenciada que mantém uma cópia da cadeia de caracteres não gerenciada, se o valor do <paramref name="ptr" /> parâmetro não é <see langword="null" />; caso contrário, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>é útil para empacotamento personalizado ou para uso quando a mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> métodos.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUni">
      <MemberSignature Language="C#" Value="public static string PtrToStringUni (IntPtr ptr, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUni(native int ptr, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço do primeiro caractere da cadeia de caracteres não gerenciada.</param>
        <param name="len">O número de caracteres Unicode a ser copiado.</param>
        <summary>Aloca uma <see cref="T:System.String" /> gerenciada e copia nela um número especificado de caracteres de uma cadeia de caracteres Unicode não gerenciada.</summary>
        <returns>Uma cadeia de caracteres gerenciada que mantém uma cópia da cadeia de caracteres não gerenciada, se o valor do <paramref name="ptr" /> parâmetro não é <see langword="null" />; caso contrário, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método cria uma cópia do conteúdo da cadeia de caracteres não gerenciados, você deve liberar a cadeia de caracteres original, conforme apropriado. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A?displayProperty=nameWithType> e <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A?displayProperty=nameWithType> métodos.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStringUTF8">
      <MemberSignature Language="C#" Value="public static string PtrToStringUTF8 (IntPtr ptr, int byteLen);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string PtrToStringUTF8(native int ptr, int32 byteLen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStringUTF8(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="byteLen" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">To be added.</param>
        <param name="byteLen">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static void PtrToStructure (IntPtr ptr, object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure(native int ptr, object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <param name="structure">O objeto para o qual os dados serão copiados. Isso deve ser uma instância de uma classe formatada.</param>
        <summary>Realizar o marshaling de dados de um bloco de memória não gerenciado para um objeto gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>geralmente é necessário no COM invocação de plataforma e interoperabilidade quando os parâmetros de estrutura são representados como um <xref:System.IntPtr?displayProperty=nameWithType> valor. Você não pode usar esse método de sobrecarga com tipos de valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O layout da estrutura não é sequencial nem explícito.  
  
 -ou-  
  
 Estrutura é um tipo de valor demarcado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure">
      <MemberSignature Language="C#" Value="public static object PtrToStructure (IntPtr ptr, Type structureType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object PtrToStructure(native int ptr, class System.Type structureType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structureType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <param name="structureType">O tipo de objeto a ser criado. Esse objeto deve representar uma classe ou estrutura formatada.</param>
        <summary>Realiza marshal de dados de um bloco não gerenciado de memória para um objeto gerenciado recém-alocado do tipo especificado.</summary>
        <returns>Um objeto gerenciado que contém os dados apontados pelo parâmetro <paramref name="ptr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A>geralmente é necessário no COM invocação de plataforma e interoperabilidade quando os parâmetros de estrutura são representados como um <xref:System.IntPtr?displayProperty=nameWithType> valor. Você pode passar um tipo de valor para este método de sobrecarga. Nesse caso, o objeto retornado será uma instância demarcada.  
  
   
  
## Examples  
 O exemplo a seguir cria uma estrutura gerenciada, transfere-a memória não gerenciada e, em seguida, transfere-a para uso de memória gerenciada de <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 O exemplo a seguir demonstra como realizar marshaling de um bloco não gerenciado de memória para uma estrutura gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> método.  
  
> [!IMPORTANT]
>  Esse código supõe a compilação de 32 bits. Antes de usar um compilador de 64 bits, substitua <xref:System.IntPtr.ToInt32%2A?displayProperty=nameWithType> com <xref:System.IntPtr.ToInt64%2A?displayProperty=nameWithType>.  
  
 [!code-cpp[PtrToStructure#1](~/samples/snippets/cpp/VS_Snippets_CLR/PtrToStructure/CPP/pts.cpp#1)]
 [!code-csharp[PtrToStructure#1](~/samples/snippets/csharp/VS_Snippets_CLR/PtrToStructure/CS/pts.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O layout do parâmetro <paramref name="structureType" /> não é sequencial ou explícito.  
  
 -ou-  
  
 O parâmetro <paramref name="structureType" /> é um tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="structureType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">A classe especificada por <paramref name="structureType" /> não tem um construtor padrão acessível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PtrToStructure&lt;T&gt; (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T PtrToStructure&lt;T&gt;(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo do objeto para o qual os dados serão copiados. Isso deve ser uma classe formatada ou uma estrutura.</typeparam>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Realiza marshaling de dados de um bloco não gerenciado de memória para um objeto gerenciado recém-alocado do tipo especificado por um parâmetro de tipo genérico.</summary>
        <returns>Um objeto gerenciado que contém os dados que o parâmetro <paramref name="ptr" /> aponta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%29>geralmente é necessário no COM invocação de plataforma e interoperabilidade quando os parâmetros de estrutura são representados como <xref:System.IntPtr?displayProperty=nameWithType> valores. Você pode passar um tipo de valor para essa sobrecarga de método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O layout do <typeparamref name="T" /> não é sequencial nem explícito.</exception>
        <exception cref="T:System.MissingMethodException">A classe especificada por <typeparamref name="T" /> não tem um construtor padrão acessível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PtrToStructure&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PtrToStructure&lt;T&gt; (IntPtr ptr, T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PtrToStructure&lt;T&gt;(native int ptr, !!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo de <c>estrutura</c>. Isso deve ser uma classe formatada.</typeparam>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória.</param>
        <param name="structure">O objeto para o qual os dados serão copiados.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Realiza marshaling de dados de um bloco não gerenciado de memória para um objeto gerenciado do tipo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%60%601%28System.IntPtr%2C%60%600%29>geralmente é necessário no COM invocação de plataforma e interoperabilidade quando os parâmetros de estrutura são representados como <xref:System.IntPtr> valores. Você não pode usar essa sobrecarga de método com tipos de valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O layout da estrutura não é sequencial nem explícito.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="QueryInterface">
      <MemberSignature Language="C#" Value="public static int QueryInterface (IntPtr pUnk, ref Guid iid, out IntPtr ppv);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 QueryInterface(native int pUnk, valuetype System.Guid&amp; iid, [out] native int&amp; ppv) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
        <Parameter Name="iid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="ppv" Type="System.IntPtr&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pUnk">A interface a ser consultada.</param>
        <param name="iid">O identificador de interface (IID) da interface solicitada.</param>
        <param name="ppv">Quando este método retorna, contém uma referência para a interface retornada.</param>
        <summary>Solicita um ponteiro para uma interface especificada de um objeto COM.</summary>
        <returns>Um HRESULT que indica o êxito ou falha da chamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.QueryInterface%2A> método expõe o [IUnknown:: QueryInterface](http://go.microsoft.com/fwlink/?LinkID=144867) método de um objeto COM, que tenta obter um ponteiro de interface específica. Usando `QueryInterface` em uma COM o objeto é o mesmo que executar uma operação de conversão em código gerenciado. Chamando um objeto com esse método faz com que a contagem de referência incrementar o ponteiro de interface antes do ponteiro será retornado. Sempre use <xref:System.Runtime.InteropServices.Marshal.Release%2A?displayProperty=nameWithType> para diminuir a contagem de referência quando tiver concluído com o ponteiro. Para obter um <xref:System.IntPtr> valor que representa um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) ponteiro de interface, você pode chamar <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço na memória não gerenciada do qual ler.</param>
        <summary>Lê um único byte da memória não gerenciada.</summary>
        <returns>Leem os bytes de memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>tem um deslocamento implícito de 0. Esse método permite interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir cria um bloco de memória não gerenciada, grava um byte em memória não gerenciada, lê os bytes de memória não gerenciada e, em seguida, descarta a memória não gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> método para ler o valor de um caractere não gerenciado.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual a leitura será realizada.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um único byte em um determinado deslocamento (ou índice) de memória não gerenciada.</summary>
        <returns>O byte lido da memória não gerenciada em um determinado deslocamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> método para ler o valor de um caractere não gerenciado.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte-IntPtr-int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public static byte ReadByte (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 ReadByte([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de origem.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um único byte em um determinado deslocamento (ou índice) de memória não gerenciada.</summary>
        <returns>O byte lido da memória não gerenciada em um determinado deslocamento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço na memória não gerenciada do qual ler.</param>
        <summary>Lê um inteiro assinado de 16 bits de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 16 bits de memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>tem um deslocamento implícito de 0. Esse método permite interação direta com um estilo C não gerenciado `Int16` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> método para ler o valor de um não gerenciado `short` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual a leitura será realizada.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro assinado de 16 bits em um determinado deslocamento de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 16 bits de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> método para ler o valor de um não gerenciado `short` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt16">
      <MemberSignature Language="C#" Value="public static short ReadInt16 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 ReadInt16([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de origem.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro assinado de 16 bits em um determinado deslocamento de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 16 bits de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço na memória não gerenciada do qual ler.</param>
        <summary>Lê um inteiro com sinal de 32 bits da memória não gerenciada.</summary>
        <returns>O inteiro com sinal de 32 bits da memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>tem um deslocamento implícito de 0. Esse método permite interação direta com um estilo C não gerenciado `Int32` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> método para ler o valor de um não gerenciado `int` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual a leitura será realizada.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro com sinal de 32 bits em um deslocamento fornecido na memória não gerenciada.</summary>
        <returns>O inteiro com sinal de 32 bits da memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>Habilita interação direta com uma matriz não gerenciada 32 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> método para ler o valor de um não gerenciado `int` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt32">
      <MemberSignature Language="C#" Value="public static int ReadInt32 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReadInt32([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de origem.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro com sinal de 32 bits em um deslocamento fornecido na memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 32 bits de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A>Habilita interação direta com uma matriz não gerenciada 32 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço na memória não gerenciada do qual ler.</param>
        <summary>Lê um inteiro assinado de 64 bits de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 64 bits de memória não gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>tem um deslocamento implícito de 0. Esse método permite interação direta com um estilo C não gerenciado `Int64` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> método para ler o valor de um não gerenciado `__int64` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual a leitura será realizada.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro assinado de 64 bits em um determinado deslocamento de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 64 bits de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>Habilita interação direta com uma matriz não gerenciada 64 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> método para ler o valor de um não gerenciado `__int64` variável.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int/cpp/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadInt64">
      <MemberSignature Language="C#" Value="public static long ReadInt64 (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 ReadInt64([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de origem.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro assinado de 64 bits em um determinado deslocamento de memória não gerenciada.</summary>
        <returns>Leia o inteiro assinado de 64 bits de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A>Habilita interação direta com uma matriz não gerenciada 64 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço na memória não gerenciada do qual ler.</param>
        <summary>Lê um inteiro de tamanho nativo de processador da memória não gerenciada.</summary>
        <returns>O número inteiro de leitura de memória não gerenciada. Um inteiro de 32 bits é retornado em computadores de 32 bits e um inteiro de 64 bits é retornado em computadores de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>tem um deslocamento implícito de 0. Esse método permite interação direta com um estilo C não gerenciado `IntPtr` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (IntPtr ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr(native int ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual a leitura será realizada.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro de tamanho nativo de processador em um determinado deslocamento de memória não gerenciada.</summary>
        <returns>O número inteiro de leitura de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>Habilita interação direta com um estilo C não gerenciado `IntPtr` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ReadIntPtr (object ptr, int ofs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReadIntPtr([in]object ptr, int32 ofs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de origem.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes da leitura.</param>
        <summary>Lê um inteiro dimensionados nativo de processador de memória não gerenciada.</summary>
        <returns>O número inteiro de leitura de memória não gerenciada no deslocamento especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A>Habilita interação direta com um estilo C não gerenciado `IntPtr` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de ler os valores de elemento.  
  
 Leitura de locais de memória não é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReAllocCoTaskMem">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocCoTaskMem (IntPtr pv, int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocCoTaskMem(native int pv, int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pv">Um ponteiro para a memória alocada com <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</param>
        <param name="cb">O novo tamanho do bloco alocado.</param>
        <summary>Redimensiona um bloco de memória alocado anteriormente com <see cref="M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)" />.</summary>
        <returns>Um inteiro que representa o endereço do bloco de memória realocado. Essa memória deve ser liberada com <see cref="M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A>é um dos dois métodos de realocação de memória no <xref:System.Runtime.InteropServices.Marshal> classe. (<xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A> é outro.) O início do conteúdo da memória realocada é o mesmo que o conteúdo original; No entanto, o bloco de memória inteiro pode ser em um local diferente. Esse método expõe o COM [CoTaskMemRealloc](http://go.microsoft.com/fwlink/?LinkId=148778) função, que é conhecida como o alocador de memória COM tarefas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para atender à solicitação.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReAllocHGlobal">
      <MemberSignature Language="C#" Value="public static IntPtr ReAllocHGlobal (IntPtr pv, IntPtr cb);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ReAllocHGlobal(native int pv, native int cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pv" Type="System.IntPtr" />
        <Parameter Name="cb" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pv">Um ponteiro para a memória alocada com <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</param>
        <param name="cb">O novo tamanho do bloco alocado. Isso não é um ponteiro; é o número de bytes que você está solicitando, conversão para tipo <see cref="T:System.IntPtr" />. Se você transmitir um ponteiro, ele será tratado como um tamanho.</param>
        <summary>Redimensiona um bloco de memória alocado anteriormente com <see cref="M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)" />.</summary>
        <returns>Um ponteiro para a memória realocada. Essa memória deve ser liberada usando <see cref="M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.ReAllocHGlobal%2A>é um de realocação de memória de dois métodos de API no <xref:System.Runtime.InteropServices.Marshal> classe. (<xref:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem%2A?displayProperty=nameWithType> é outro.)  
  
 Esse método expõe o Win32 [GlobalReAlloc](http://go.microsoft.com/fwlink/?LinkId=148780) função Kernel32. O ponteiro retornado pode ser diferente do original. Se ele for diferente, o conteúdo do bloco de memória original foram copiado para o novo bloco e o bloco de memória original foi liberado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para atender à solicitação.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public static int Release (IntPtr pUnk);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Release(native int pUnk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pUnk" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="pUnk">A interface a ser liberada.</param>
        <summary>Diminui a contagem de referência na interface especificada.</summary>
        <returns>O novo valor da contagem de referência na interface especificada pelo parâmetro <paramref name="pUnk" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime gerencia a contagem de referência de um objeto COM para você, tornando desnecessário usar este método diretamente. Use esse valor apenas para fins de teste. Em casos raros, como testes de um marshaler personalizado, talvez seja necessário para manipular o tempo de vida de um objeto manualmente. Somente programas que chamam <xref:System.Runtime.InteropServices.Marshal.AddRef%2A?displayProperty=nameWithType> devem chamar <xref:System.Runtime.InteropServices.Marshal.Release%2A>. Chamando <xref:System.Runtime.InteropServices.Marshal.Release%2A> depois que a contagem de referência atingir zero faz com que um comportamento indefinido.  
  
 Você pode chamar <xref:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject%2A?displayProperty=nameWithType>, <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A?displayProperty=nameWithType>, ou <xref:System.Runtime.InteropServices.Marshal.GetIDispatchForObject%2A?displayProperty=nameWithType> para obter um <xref:System.IntPtr> valor que representa um [IUnknown](http://go.microsoft.com/fwlink/?LinkId=148003) para liberar o ponteiro de interface. Você também pode usar esses métodos e <xref:System.Runtime.InteropServices.Marshal.Release%2A> método em objetos gerenciados para liberar as interfaces COM representado pelo objeto gerenciado [COM Callable Wrapper](~/docs/framework/interop/com-callable-wrapper.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como recuperar um `IUnknown` interface para um objeto gerenciado usando o <xref:System.Runtime.InteropServices.Marshal.GetIUnknownForObject%2A> método. O exemplo, em seguida, libera o ponteiro de interface chamando o <xref:System.Runtime.InteropServices.Marshal.Release%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.GetIUnknownForObject-release/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseComObject">
      <MemberSignature Language="C#" Value="public static int ReleaseComObject (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ReleaseComObject(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto COM a ser liberado.</param>
        <summary>Diminui a contagem de referência do [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) associado com o objeto COM especificado.</summary>
        <returns>O novo valor da contagem de referência do RCW associado ao <paramref name="o" />. Normalmente, esse valor é zero, pois o RCW mantém apenas uma referência ao objeto COM encapsulado, independentemente do número de clientes gerenciados que estejam chamando-o.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado para controlar explicitamente o tempo de vida de um objeto COM usado no código gerenciado. Você deve usar esse método para liberar o objeto COM subjacente que contém referências a recursos de maneira oportuna ou objetos devem ser liberados em uma ordem específica.  
  
 Sempre que um ponteiro de interface COM insere o common language runtime (CLR), ele é encapsulado em um RCW.  
  
 RCW tem uma contagem de referência que é incrementada toda vez que um ponteiro de interface COM é mapeado para ele. O <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> diminui de método a contagem de referência de um RCW. Quando a contagem de referência chega a zero, o tempo de execução libera todas as suas referências no objeto COM não gerenciado e lança um <xref:System.NullReferenceException?displayProperty=nameWithType> se você tentar usar o objeto ainda mais. Se a mesma interface COM é passada mais de uma vez de não gerenciado para código gerenciado, a contagem de referência em um wrapper é incrementado toda vez e chamada <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> retorna o número de referências restantes.  
  
 Esse método permite que você force uma versão de contagem de referência RCW para que ele ocorre precisamente quando você quiser. No entanto, o uso inadequado de <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> pode fazer com que o aplicativo falhar, ou pode causar uma violação de acesso.  
  
 Considere um cenário no qual o código gerenciado em um domínio de aplicativo mantiver um RCW que representa um componente COM. Se você chamar o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> método no RCW, o código gerenciado não poderá acessar o RCW e gerará um <xref:System.Runtime.InteropServices.InvalidComObjectException> exceção.  
  
 Um erro mais grave pode ocorrer se uma chamada para o RCW está em execução quando o RCW é liberado. Nesse caso, há uma boa chance de que o thread que faz a chamada fará com que uma violação de acesso. No entanto, memória de processo pode ser corrompida e o processo pode continuar a executar até falhar por razões que são muito difíceis de depurar.  
  
 Esse risco aumenta quando o componente COM que está sendo usado é um singleton, pelo seguinte motivo: O CLR ativa componentes COM chamando o COM [CoCreateInstance](http://go.microsoft.com/fwlink/?LinkID=142894) função, que retorna o mesmo ponteiro de interface toda vez que ele é chamado para componentes COM de singleton. Assim, separados e independentes partes do código gerenciado em um domínio de aplicativo podem usar o RCW mesmo para um componente de singleton COM e se chama um o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> método no componente COM, o outro será quebrado.  
  
 Portanto, usar o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> somente se ele é absolutamente necessário. Se você deseja chamar esse método para garantir que um componente COM é liberado em um momento determinado, considere o uso de <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> método em vez disso. <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A>liberará o componente COM subjacente, independentemente de quantas vezes ela entrou novamente o CLR. A contagem de referência interna do RCW é incrementada em um cada vez que o componente COM reinserido CLR. Portanto, você poderia chamar o <xref:System.Runtime.InteropServices.Marshal.ReleaseComObject%2A> método em um loop até que o valor retornado é zero. Gera o mesmo resultado que o <xref:System.Runtime.InteropServices.Marshal.FinalReleaseComObject%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O <paramref name="o" /> não é um objeto COM válido.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="o" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseThreadCache">
      <MemberSignature Language="C#" Value="public static void ReleaseThreadCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReleaseThreadCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ReleaseThreadCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera o cache de thread.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToBSTR (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToBSTR(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">O objeto gerenciado a se copiar.</param>
        <summary>Aloca um não gerenciado [cadeia de caracteres binária (BSTR)](https://msdn.microsoft.com/library/ms221069\(v=vs.85\).aspx) e copia o conteúdo de um gerenciado <see cref="T:System.Security.SecureString" /> objeto nele.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual o parâmetro <paramref name="s" /> foi copiado ou 0 se um objeto nulo foi fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.SecureStringToBSTR%2A> método é útil para empacotamento personalizado ou ao misturar gerenciado e código não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar o `BSTR` quando terminar, chamando o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O computador atual não está executando o Windows 2000 Service Pack 3 ou posterior.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <block subset="none" type="usage">
          <para>Esse método é suportada apenas em computadores que executam o Windows 2000 Service Pack 3 ou posterior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">O objeto gerenciado a se copiar.</param>
        <summary>Copia o conteúdo de um objeto <see cref="T:System.Security.SecureString" /> gerenciado para um bloco de memória alocado do alocador de tarefas COM não gerenciado.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual o parâmetro <paramref name="s" /> foi copiado ou 0 se um objeto nulo foi fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> método é útil para empacotamento personalizado ou ao misturar gerenciado e código não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A>. Os caracteres da cadeia de caracteres são copiados como caracteres ANSI.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> método para empacotar e descriptografar o conteúdo de um <xref:System.Security.SecureString> objeto para um bloco de memória não gerenciada. Ele usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> método para zerar e descartar o bloco não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O computador atual não está executando o Windows 2000 Service Pack 3 ou posterior.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <block subset="none" type="usage">
          <para>Esse método é suportada apenas em computadores que executam o Windows 2000 Service Pack 3 ou posterior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToCoTaskMemUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToCoTaskMemUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">O objeto gerenciado a se copiar.</param>
        <summary>Copia o conteúdo de um objeto <see cref="T:System.Security.SecureString" /> gerenciado para um bloco de memória alocado do alocador de tarefas COM não gerenciado.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual o parâmetro <paramref name="s" /> foi copiado ou 0 se um objeto nulo foi fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> método é útil para empacotamento personalizado ou ao misturar gerenciado e código não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> método. Os caracteres da cadeia de caracteres são copiados como caracteres Unicode.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> método para empacotar e descriptografar o conteúdo de um <xref:System.Security.SecureString> objeto para um bloco de memória não gerenciada. Ele usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> método para zerar e descartar o bloco não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O computador atual não está executando o Windows 2000 Service Pack 3 ou posterior.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <block subset="none" type="usage">
          <para>Esse método é suportada apenas em computadores que executam o Windows 2000 Service Pack 3 ou posterior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocAnsi (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocAnsi(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">O objeto gerenciado a se copiar.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.Security.SecureString" /> gerenciado para a memória não gerenciada, convertendo em formato ANSI durante a cópia.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual o parâmetro <paramref name="s" /> foi copiado ou 0 se um objeto nulo foi fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> método é útil para empacotamento personalizado ou ao misturar gerenciado e código não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> método para empacotar e descriptografar o conteúdo de um <xref:System.Security.SecureString> objeto para um bloco de memória não gerenciada. Ele usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> método para zerar e descartar o bloco não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O computador atual não está executando o Windows 2000 Service Pack 3 ou posterior.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <block subset="none" type="usage">
          <para>Esse método é suportada apenas em computadores que executam o Windows 2000 Service Pack 3 ou posterior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SecureStringToGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static IntPtr SecureStringToGlobalAllocUnicode (System.Security.SecureString s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int SecureStringToGlobalAllocUnicode(class System.Security.SecureString s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.Security.SecureString" />
      </Parameters>
      <Docs>
        <param name="s">O objeto gerenciado a se copiar.</param>
        <summary>Copia o conteúdo de um objeto <see cref="T:System.Security.SecureString" /> gerenciado para uma memória não gerenciada.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual <paramref name="s" /> foi copiado ou 0, se <paramref name="s" /> for um objeto <see cref="T:System.Security.SecureString" /> cujo tamanho é 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> método é útil para empacotamento personalizado ou para uso ao misturar gerenciado e código não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> método com não gerenciado `LogonUser` função para executar a representação com o <xref:System.Security.SecureString> classe. O exemplo usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> método para zerar e liberar a referência de cadeia de caracteres não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O computador atual não está executando o Windows 2000 Service Pack 3 ou posterior.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <block subset="none" type="usage">
          <para>Esse método é suportada apenas em computadores que executam o Windows 2000 Service Pack 3 ou posterior.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetComObjectData">
      <MemberSignature Language="C#" Value="public static bool SetComObjectData (object obj, object key, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetComObjectData(object obj, object key, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SetComObjectData(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto COM, no qual armazenar os dados.</param>
        <param name="key">A chave na tabela de hash interno do objeto COM, no qual armazenar os dados.</param>
        <param name="data">Os dados a serem definidos.</param>
        <summary>Define os dados referenciados pela chave especificada no objeto especificado COM.</summary>
        <returns>
          <see langword="true" />Se os dados foi definidos com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos COM encapsulados em um [Runtime Callable Wrapper](~/docs/framework/interop/runtime-callable-wrapper.md) (RCW) tem uma tabela de hash associada, no qual <xref:System.Runtime.InteropServices.Marshal.SetComObjectData%2A> adiciona dados. <xref:System.Runtime.InteropServices.Marshal.GetComObjectData%2A?displayProperty=nameWithType>recupera dados da tabela de hash. Você nunca deve ter que chamar o método do seu código.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="obj" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" />não é um objeto COM.  
  
 -ou-  
  
 <paramref name="obj" /> é um objeto [!INCLUDE[wrt](~/includes/wrt-md.md)].</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (object structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(object structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="structure">O objeto cujo tamanho deve ser retornado.</param>
        <summary>Retorna o tamanho não gerenciado de um objeto em bytes.</summary>
        <returns>O tamanho do objeto especificado em código não gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aceita uma instância de uma estrutura, o que pode ser um tipo de referência ou um tipo de valor Demarcado. O layout deve ser explícita ou sequencial.  
  
 O tamanho retornado é o tamanho do objeto não gerenciado. Os tamanhos gerenciados e não de um objeto podem ser diferente. Para tipos de caractere, o tamanho é afetado pelo <xref:System.Runtime.InteropServices.CharSet> valor aplicado à classe.  
  
 Você pode usar o <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> método para determinar a quantidade de memória não gerenciada para alocar usando o <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> e <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir cria uma estrutura gerenciada, transfere-a memória não gerenciada e, em seguida, transfere-a para memória gerenciada. Este exemplo usa o <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> método para determinar a quantidade de memória não gerenciada para alocar.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="structure" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SizeOf">
      <MemberSignature Language="C#" Value="public static int SizeOf (Type t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf(class System.Type t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="t">O tipo cujo tamanho deve ser retornado.</param>
        <summary>Retorna o tamanho de um tipo não gerenciado em bytes.</summary>
        <returns>O tamanho do tipo especificado no código não gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método quando você não tem uma estrutura. O layout deve ser explícita ou sequencial.  
  
 O tamanho retornado é o tamanho do tipo não gerenciado. Os tamanhos gerenciados e não de um objeto podem ser diferente. Para tipos de caractere, o tamanho é afetado pelo <xref:System.Runtime.InteropServices.CharSet> valor aplicado à classe.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamar o <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#3](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#3)]
 [!code-csharp[Marshal#3](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#3)]
 [!code-vb[Marshal#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="t" /> é um tipo genérico.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="t" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo cujo tamanho deve ser retornado.</typeparam>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Retorna o tamanho de um tipo não gerenciado em bytes.</summary>
        <returns>O tamanho, em bytes, do tipo especificado pelo parâmetro de tipo genérico <typeparamref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método quando você não tem uma estrutura. O layout deve ser explícita ou sequencial.  
  
 O tamanho retornado é o tamanho do tipo não gerenciado. Os tamanhos gerenciados e não de um objeto podem ser diferente. Para tipos de caractere, o tamanho é afetado pelo <xref:System.Runtime.InteropServices.CharSet> valor aplicado à classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; (T structure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;(!!T structure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo do <c>estrutura</c> parâmetro.</typeparam>
        <param name="structure">O objeto cujo tamanho deve ser retornado.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Retorna o tamanho não gerenciado de um objeto de um tipo especificado em bytes.</summary>
        <returns>O tamanho, em bytes, do objeto especificado em código não gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aceita uma instância de uma estrutura, o que pode ser um tipo de referência ou um tipo de valor Demarcado. O layout deve ser explícita ou sequencial.  
  
 O tamanho retornado é o tamanho do objeto não gerenciado. Os tamanhos gerenciados e não de um objeto podem ser diferente. Para tipos de caractere, o tamanho é afetado pelo <xref:System.Runtime.InteropServices.CharSet> valor aplicado à classe.  
  
 Você pode usar o <xref:System.Runtime.InteropServices.Marshal.SizeOf%60%601%28%60%600%29> método para determinar a quantidade de memória não gerenciada para alocar usando o <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A> e <xref:System.Runtime.InteropServices.Marshal.AllocCoTaskMem%2A> métodos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="structure" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="StringToBSTR">
      <MemberSignature Language="C#" Value="public static IntPtr StringToBSTR (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToBSTR(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Aloca um [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) e copia o conteúdo de um gerenciado <see cref="T:System.String" /> nele.</summary>
        <returns>Um ponteiro não gerenciado para o <see langword="BSTR" /> ou 0, se <paramref name="s" /> for nulo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToBSTR%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar o `BSTR` terminada chamando <xref:System.Runtime.InteropServices.Marshal.FreeBSTR%2A?displayProperty=nameWithType>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringBSTR%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho de <paramref name="s" /> está fora do intervalo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para um bloco de memória alocado do alocador de tarefas COM não gerenciado.</summary>
        <returns>Um inteiro que representa um ponteiro para o bloco de memória alocado na cadeia de caracteres ou 0, se <paramref name="s" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>. Os caracteres da cadeia de caracteres são copiados como caracteres ANSI.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="s" /> excede o tamanho máximo permitido pelo sistema operacional.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para um bloco de memória alocado do alocador de tarefas COM não gerenciado.</summary>
        <returns>O bloco de memória alocada, ou 0 se <paramref name="s" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto%2A>é útil para empacotamento personalizado ou para uso quando a mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Os caracteres da cadeia de caracteres são copiados como caracteres ANSI ou Unicode, dependendo do sistema operacional onde o código está sendo executado. No Windows 98, os caracteres são copiados como caracteres ANSI. No Windows NT 4.0, Windows 2000, Windows XP e a família Windows Server 2003, os caracteres são copiados como caracteres Unicode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho de <paramref name="s" /> está fora do intervalo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para um bloco de memória alocado do alocador de tarefas COM não gerenciado.</summary>
        <returns>Um inteiro que representa um ponteiro para o bloco de memória alocado na cadeia de caracteres ou 0, se s for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni%2A>é útil para empacotamento personalizado ou para uso quando a mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeCoTaskMem%2A?displayProperty=nameWithType>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>. Os caracteres da cadeia de caracteres são copiados como caracteres Unicode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="s" /> excede o tamanho máximo permitido pelo sistema operacional.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static IntPtr StringToCoTaskMemUTF8 (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToCoTaskMemUTF8(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUTF8(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAnsi">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAnsi (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAnsi(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para a memória não gerenciada, convertendo em formato ANSI durante a cópia.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual <paramref name="s" /> foi copiado ou 0 se <paramref name="s" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>é útil para empacotamento personalizado ou mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A>fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType>.  
  
 Esse método copia caracteres nulos inseridos e inclui um caractere null de terminação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como converter o conteúdo de um gerenciado <xref:System.String> classe a memória não gerenciada e, em seguida, descarte a memória não gerenciada quando terminar.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/CPP/stringtohglobalansi.cpp#1)]
 [!code-csharp[Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAnsi/cs/stringtohglobalansi.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="s" /> excede o tamanho máximo permitido pelo sistema operacional.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalAuto">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalAuto (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalAuto(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para a memória não gerenciada, convertendo para formato ANSI, se necessário.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual a cadeia de caracteres foi copiada ou 0, se <paramref name="s" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto%2A>é útil para empacotamento personalizado ou para uso quando a mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringAuto%2A?displayProperty=nameWithType>.  
  
 Esse método copia caracteres nulos inseridos e inclui um caractere null de terminação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como converter o conteúdo de um gerenciado <xref:System.String> classe a memória não gerenciada e, em seguida, descarte a memória não gerenciada quando terminar.  
  
 [!code-cpp[Runtime.InteropServices.Marshal.StringToHGlobalAuto#1](~/samples/snippets/cpp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.StringToHGlobalAuto/CPP/sample.cpp#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StringToHGlobalUni">
      <MemberSignature Language="C#" Value="public static IntPtr StringToHGlobalUni (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int StringToHGlobalUni(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Uma cadeia de caracteres gerenciada a ser copiada.</param>
        <summary>Copia o conteúdo de um <see cref="T:System.String" /> gerenciado para uma memória não gerenciada.</summary>
        <returns>O endereço, na memória não gerenciada, para o qual <paramref name="s" /> foi copiado ou 0 se <paramref name="s" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalUni%2A>é útil para empacotamento personalizado ou para uso quando a mistura de código gerenciado e não gerenciado. Como esse método aloca a memória não gerenciada, necessária para uma cadeia de caracteres, sempre liberar a memória chamando <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A>. Esse método fornece a funcionalidade oposta do <xref:System.Runtime.InteropServices.Marshal.PtrToStringUni%2A?displayProperty=nameWithType>.  
  
 Esse método copia caracteres nulos inseridos e inclui um caractere null de terminação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não foi possível para o método alocar memória suficiente de heap nativo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="s" /> excede o tamanho máximo permitido pelo sistema operacional.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr">
      <MemberSignature Language="C#" Value="public static void StructureToPtr (object structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr(object structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="structure" Type="System.Object" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="structure">Um objeto gerenciado que mantém os dados que terão o marshaling realizado. Esse objeto deve ser uma estrutura ou uma instância de uma classe formatada.</param>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória, que deve ser alocado antes que este método seja chamado.</param>
        <param name="fDeleteOld">
          <see langword="true" />para chamar o <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)" /> método o <c>ptr</c> parâmetro antes desse método copia os dados. O bloco deve conter dados válidos. Observe que passar <see langword="false" /> quando o bloco de memória já tiver dados podem levar a um vazamento de memória.</param>
        <summary>Realizar o marshaling de dados de um objeto gerenciado para um bloco não gerenciado de memória.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `structure` é um tipo de valor pode ser demarcado ou desencaixotado. Se ele é convertido, é não demarcado antes de copiar.  
  
 Uma classe formatada é um tipo de referência cujo layout é especificado pelo <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo, como <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A>Copia o conteúdo de `structure` para o bloco pré-alocados de memória que o `ptr` parâmetro aponta para. Se `structure` contém tipos de referência que realizar marshaling de ponteiros de interface COM (interfaces, classes sem layout, e <xref:System.Object?displayProperty=nameWithType>), os objetos gerenciados são mantidos ativas com contagens de referência. Todos os outros tipos de referência (por exemplo, cadeias de caracteres e matrizes) são empacotados para cópias. Para liberar esses objetos gerenciados ou não gerenciados, você deve chamar o <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A?displayProperty=nameWithType> método antes de liberar o bloco de memória.  
  
 Se você usar o <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> método para copiar uma instância diferente para o bloco de memória em um momento posterior, especifique `true` para `fDeleteOld` remover a referência de conta para tipos de referência na instância anterior. Caso contrário, as cópias de typesand não gerenciado de referência gerenciada efetivamente seja perdidas.  
  
 O padrão geral para usar <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> é o seguinte:  
  
1.  Na primeira chamada para o <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> método depois que um bloco de memória foi alocado, `fDeleteOld` devem ser `false`, pois não há nenhum conteúdo para limpar.  
  
    > [!IMPORTANT]
    >  Especifique `true` para `fDeleteOld` somente se o bloco contém dados válidos.  
  
2.  Se você copiar uma instância diferente para o bloco de memória e o objeto contém os tipos de referência, `fDeleteOld` devem ser `true` para liberar os tipos de referência no conteúdo antigo.  
  
3.  Se o objeto contiver tipos de referência, você deve chamar o <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> método antes de liberar o bloco de memória.  
  
> [!NOTE]
>  Para fixar uma estrutura existente em vez de copiá-lo, use o <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> tipo para criar um identificador fixo para a estrutura. Para obter detalhes sobre como fixar, consulte [copiando e fixando](~/docs/framework/interop/copying-and-pinning.md).  
  
   
  
## Examples  
 O exemplo a seguir cria uma estrutura gerenciada, transfere-a memória não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> método e, em seguida, transfere-o novamente para memória gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.PtrToStructure%2A> método.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.PtrToStructure-SizeOf/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> é um tipo de referência que não é uma classe formatada.  
  
 -ou-  
  
 <paramref name="structure" /> é um tipo genérico.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StructureToPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void StructureToPtr&lt;T&gt; (T structure, IntPtr ptr, bool fDeleteOld);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void StructureToPtr&lt;T&gt;(!!T structure, native int ptr, bool fDeleteOld) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="structure" Type="T" />
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="fDeleteOld" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo do objeto gerenciado.</typeparam>
        <param name="structure">Um objeto gerenciado que mantém os dados que terão o marshaling realizado. O objeto deve ser uma estrutura ou uma instância de uma classe formatada.</param>
        <param name="ptr">Um ponteiro para um bloco não gerenciado de memória, que deve ser alocado antes que este método seja chamado.</param>
        <param name="fDeleteOld">
          <see langword="true" />para chamar o <see cref="M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)" /> método o <c>ptr</c> parâmetro antes desse método copia os dados. O bloco deve conter dados válidos. Observe que passar <see langword="false" /> quando o bloco de memória já tiver dados podem levar a um vazamento de memória.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Realiza marshaling de dados de um objeto gerenciado de um tipo especificado para um bloco de memória não gerenciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe formatada é um tipo de referência cujo layout é especificado pelo <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo, como <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType> ou <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=nameWithType>.  
  
 <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29>Copia o conteúdo de `structure` para o bloco pré-alocados de memória que o `ptr` parâmetro aponta para. Se `structure` contém tipos de referência que realizar marshaling de ponteiros de interface COM (interfaces, classes sem layout, e <xref:System.Object?displayProperty=nameWithType>), os objetos gerenciados são mantidos ativas com contagens de referência. Todos os outros tipos de referência (por exemplo, cadeias de caracteres e matrizes) são empacotados para cópias. Para liberar esses objetos gerenciados ou não gerenciados, você deve chamar o <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%60%601%28System.IntPtr%29> método antes de liberar o bloco de memória.  
  
 Se você usar o <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> método para copiar uma instância diferente para o bloco de memória em um momento posterior, especifique `true` para `fDeleteOld` remover a referência de conta para tipos de referência na instância anterior. Caso contrário, os tipos de referência gerenciada e cópias não gerenciadas são efetivamente vazou.  
  
 O padrão geral para usar <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%60%601%28%60%600%2CSystem.IntPtr%2CSystem.Boolean%29> é o seguinte:  
  
1.  Na primeira chamada para o <xref:System.Runtime.InteropServices.Marshal.StructureToPtr%2A> método depois que um bloco de memória foi alocado, `fDeleteOld` devem ser `false`, pois não há nenhum conteúdo para limpar.  
  
    > [!IMPORTANT]
    >  Especifique `true` para `fDeleteOld` somente se o bloco contém dados válidos.  
  
2.  Se você copiar uma instância diferente para o bloco de memória e o objeto contém os tipos de referência, `fDeleteOld` devem ser `true` para liberar os tipos de referência no conteúdo antigo.  
  
3.  Se o objeto contiver tipos de referência, você deve chamar o <xref:System.Runtime.InteropServices.Marshal.DestroyStructure%2A> método antes de liberar o bloco de memória.  
  
> [!NOTE]
>  Para fixar uma estrutura existente em vez de copiá-lo, use o <xref:System.Runtime.InteropServices.GCHandle?displayProperty=nameWithType> tipo para criar um identificador fixo para a estrutura. Para obter detalhes sobre como fixar, consulte [copiando e fixando](~/docs/framework/interop/copying-and-pinning.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="structure" /> é um tipo de referência que não é uma classe formatada.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDefaultCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemDefaultCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemDefaultCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o tamanho de caractere padrão do sistema; o padrão é 2 para sistemas Unicode e 1 para sistemas de ANSI. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> campo. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemMaxDBCSCharSize">
      <MemberSignature Language="C#" Value="public static readonly int SystemMaxDBCSCharSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int32 SystemMaxDBCSCharSize" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa o tamanho máximo de um tamanho DBCS (conjunto) de caractere de byte duplo, em bytes, para o sistema operacional atual. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize> campo. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.Marshal> classe.  
  
 [!code-cpp[Marshal#2](~/samples/snippets/cpp/VS_Snippets_CLR/Marshal/cpp/marshal.cpp#2)]
 [!code-csharp[Marshal#2](~/samples/snippets/csharp/VS_Snippets_CLR/Marshal/CS/Marshal.cs#2)]
 [!code-vb[Marshal#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Marshal/VB/Marshal.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="errorCode">O HRESULT correspondente à exceção desejada.</param>
        <summary>Aciona uma exceção com uma valor HRESULT de falha específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um objeto de exceção de falha HRESULT especificado. Se o HRESULT é 0 ou positivo (um código de êxito), o método retornará sem criar ou gerar uma exceção.  
  
 Observe que o <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%28System.Int32%29> método retornará uma exceção com base no [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface do thread atual se um for definido. Quando isso acontece, o `errorCode` parâmetro é ignorado.  
  
 Algumas falhas HRESULTs mapeiam para exceções definidas, enquanto outros não. Se o HRESULT é mapeado para uma exceção de definido, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> cria uma instância da exceção e lança-lo. Caso contrário, ele cria uma instância de <xref:System.Runtime.InteropServices.COMException>, inicializa o campo de código de erro com o HRESULT e gera essa exceção. Quando <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> é invocado, ele tenta recuperar informações adicionais sobre o erro usando o gerenciado [GetErrorInfo](https://msdn.microsoft.com/library/ms221032\(v=vs.85\).aspx) função.  
  
 Para o mapeamento de cada HRESULT para sua classe de exceção comparáveis no .NET Framework, consulte [como: mapear HRESULTs e exceções](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 Ocasionalmente, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> pode retornar uma exceção de uma chamada anterior de COM. Nesse caso, você pode usar a seguinte solução e passar `IntPtr(-1)` como o segundo parâmetro (`errorInfo`):  
  
```  
[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]  
public static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ThrowExceptionForHR">
      <MemberSignature Language="C#" Value="public static void ThrowExceptionForHR (int errorCode, IntPtr errorInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ThrowExceptionForHR(int32 errorCode, native int errorInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="errorCode" Type="System.Int32" />
        <Parameter Name="errorInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="errorCode">O HRESULT correspondente à exceção desejada.</param>
        <param name="errorInfo">Um ponteiro para o [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface que fornece mais informações sobre o erro. Você pode especificar <c>IntPtr(0)</c> usar atual [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface, ou <c>IntPtr(-1)</c> para ignorar atual [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface e construir a exceção apenas do código de erro.</param>
        <summary>Lançará uma exceção com falha específica HRESULT, com base em especificado [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria um objeto de exceção de falha HRESULT especificado. Se o HRESULT é 0 ou positivo (um código de êxito), o método retornará sem criar ou gerar uma exceção.  
  
 O <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> método versões o `errorInfo` contagem de referência de parâmetro, diminuindo o COM o [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface.  
  
 Observe que o <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> método retornará uma exceção com base no [IErrorInfo](https://msdn.microsoft.com/library/ms221233\(v=vs.85\).aspx) interface do thread atual se um for definido. Quando isso acontece, o `errorCode` parâmetro é ignorado.  
  
 Algumas falhas HRESULTs mapeiam para exceções definidas, enquanto outros não. Se o HRESULT é mapeado para uma exceção de definido, <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A> cria uma instância da exceção e lança-lo. Caso contrário, ele cria uma instância de <xref:System.Runtime.InteropServices.COMException?displayProperty=nameWithType>, inicializa o campo de código de erro com o HRESULT e gera essa exceção. O `errorInfo` parâmetro é usado para recuperar informações adicionais sobre o erro.  
  
 Para o mapeamento de cada HRESULT para sua classe de exceção comparáveis no .NET Framework, consulte [como: mapear HRESULTs e exceções](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">A matriz que contém o elemento desejado.</param>
        <param name="index">O índice de <c>arr</c> parâmetro do elemento desejado.</param>
        <summary>Obtém o endereço do elemento no índice especificado na matriz especificada.</summary>
        <returns>O endereço de <paramref name="index" /> dentro de <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz deve ser fixada usando um <xref:System.Runtime.InteropServices.GCHandle> antes de ser passado para este método. Para obter desempenho máximo, esse método não valida a matriz passada para ele; Isso pode resultar em comportamento inesperado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAddrOfPinnedArrayElement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr UnsafeAddrOfPinnedArrayElement&lt;T&gt; (T[] arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int UnsafeAddrOfPinnedArrayElement&lt;T&gt;(!!T[] arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arr" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo da matriz.</typeparam>
        <param name="arr">A matriz que contém o elemento desejado.</param>
        <param name="index">O índice do elemento desejado no <c>arr</c> matriz.</param>
        <summary>[Suporte somente no .NET Framework 4.5.1 e versões posteriores]  
  
 Obtém o endereço do elemento no índice especificado em uma matriz de um tipo especificado.</summary>
        <returns>O endereço do <paramref name="index" /> em <paramref name="arr" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz deve ser fixada usando um <xref:System.Runtime.InteropServices.GCHandle> antes de ser passado para este método. Para obter desempenho máximo, esse método não valida a matriz passada para ele; Isso pode resultar em comportamento inesperado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de byte único na memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
   
  
## Examples  
 O exemplo a seguir cria um bloco de memória não gerenciada, grava um byte em memória não gerenciada, lê os bytes de memória não gerenciada e, em seguida, descarta a memória não gerenciada.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/cs/example.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.ReadByte - WriteByte#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.ReadByte - WriteByte/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (IntPtr ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte(native int ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual gravar.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de byte único na memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadByte%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#3)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public static void WriteByte (object ptr, int ofs, byte val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteByte([out] object ptr, int32 ofs, unsigned int8 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de byte único na memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteByte%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um caractere de memória não gerenciada como um valor inteiro de 16 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro de 16 bits na memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em heap nativo para gravar.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 16 bits de memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (IntPtr ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16(native int ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual gravar.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 16 bits na memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt16%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#4)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, char val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, char val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 16 bits de memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt16">
      <MemberSignature Language="C#" Value="public static void WriteInt16 (object ptr, int ofs, short val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt16([out] object ptr, int32 ofs, int16 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 16 bits de memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt16%2A>Habilita interação direta com uma matriz não gerenciada 16 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro com sinal de 32 bits na memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Habilita interação direta com uma matriz não gerenciada 32 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (IntPtr ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32(native int ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual gravar.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 32 bits na memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Habilita interação direta com uma matriz não gerenciada 32 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt32%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#5)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt32">
      <MemberSignature Language="C#" Value="public static void WriteInt32 (object ptr, int ofs, int val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt32([out] object ptr, int32 ofs, int32 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 32 bits em memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt32%2A>Habilita interação direta com uma matriz não gerenciada 32 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 64 bits em memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Habilita interação direta com uma matriz não gerenciada 64 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (IntPtr ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64(native int ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada para gravação.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 64 bits em memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Habilita interação direta com uma matriz não gerenciada 64 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadInt64%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#6)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteInt64">
      <MemberSignature Language="C#" Value="public static void WriteInt64 (object ptr, int ofs, long val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteInt64([out] object ptr, int32 ofs, int64 val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SuppressUnmanagedCodeSecurity</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor inteiro assinado de 64 bits em memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteInt64%2A>Habilita interação direta com uma matriz não gerenciada 64 bits assinada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço a ser gravado na memória não gerenciada.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de inteiro dimensionados nativo de processador em memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Habilita interação direta com um estilo C não gerenciado `IntPtr` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">
          <paramref name="ptr" />não é um formato reconhecido.  
  
 -ou-  
  
 <paramref name="ptr" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="ptr" /> é inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (IntPtr ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr(native int ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.IntPtr" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço básico na memória não gerenciada no qual gravar.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de inteiro dimensionados nativo de processador para a memória não gerenciada em um deslocamento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método grava um inteiro de 32 bits em sistemas de 32 bits e um inteiro de 64 bits em sistemas de 64 bits.  
  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Habilita interação direta com um estilo C não gerenciado `IntPtr` matriz, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como ler e gravar em uma matriz não gerenciada usando o <xref:System.Runtime.InteropServices.Marshal.ReadIntPtr%2A> e <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A> métodos.  
  
 [!code-csharp[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/cs/sample.cs#2)]
 [!code-vb[System.Runtime.interopServices.Marshal.Read-Write val#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.interopServices.Marshal.Read-Write val/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WriteIntPtr">
      <MemberSignature Language="C#" Value="public static void WriteIntPtr (object ptr, int ofs, IntPtr val);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteIntPtr([out] object ptr, int32 ofs, native int val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ptr" Type="System.Object" />
        <Parameter Name="ofs" Type="System.Int32" />
        <Parameter Name="val" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="ptr">O endereço base em memória não gerenciada do objeto de destino.</param>
        <param name="ofs">Um deslocamento de bytes adicionais, que é adicionado para o <c>ptr</c> parâmetro antes de gravar.</param>
        <param name="val">O valor a ser gravado.</param>
        <summary>Grava um valor de inteiro dimensionados nativo de processador para a memória não gerenciada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.Marshal.WriteIntPtr%2A>Habilita interação direta com uma matriz de bytes de estilo C não gerenciada, eliminando a despesa de cópia de uma matriz não gerenciada toda (usando <xref:System.Runtime.InteropServices.Marshal.Copy%2A?displayProperty=nameWithType>) em uma matriz separada gerenciada antes de definir seus valores de elemento.  
  
 Há suporte para os locais de memória não alinhada gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AccessViolationException">O endereço básico (<paramref name="ptr" />) e o deslocamento de byte (<paramref name="ofs" />) produz um endereço nulo ou inválido.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="ptr" /> é um objeto de <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> . Esse método não aceita <see cref="T:System.Runtime.InteropServices.ArrayWithOffset" /> parâmetros.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeBSTR">
      <MemberSignature Language="C#" Value="public static void ZeroFreeBSTR (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeBSTR(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">O endereço do <see langword="BSTR" /> a ser liberado.</param>
        <summary>Libera um [BSTR](https://msdn.microsoft.com/library/ms221069.aspx) ponteiro que foi alocado usando o <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)" /> método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR%2A> método primeiro define o conteúdo do BSTR como zero e, em seguida, libera o BSTR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">O endereço da cadeia de caracteres não gerenciado para liberar.</param>
        <summary>Libera um ponteiro não gerenciado de cadeia de caracteres que foi alocado usando o <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)" /> método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> método primeiro zeros out e, em seguida, libera memória não gerenciada que foi alocada usando o <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi%2A> método para empacotar e descriptografar o conteúdo de um <xref:System.Security.SecureString> objeto para um bloco de memória não gerenciada. Ele usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi%2A> método para zerar e descartar o bloco não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/cs/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">O endereço da cadeia de caracteres não gerenciado para liberar.</param>
        <summary>Libera um ponteiro não gerenciado de cadeia de caracteres que foi alocado usando o <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)" /> método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode%2A> método primeiro zeros out e, em seguida, libera memória não gerenciada que foi alocada usando o <xref:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode%2A> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeCoTaskMemUTF8">
      <MemberSignature Language="C#" Value="public static void ZeroFreeCoTaskMemUTF8 (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeCoTaskMemUTF8(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUTF8(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocAnsi">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocAnsi (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocAnsi(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">O endereço da cadeia de caracteres não gerenciado para liberar.</param>
        <summary>Libera um ponteiro não gerenciado de cadeia de caracteres que foi alocado usando o <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)" /> método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> método primeiro zeros out e, em seguida, libera memória não gerenciada que foi alocada usando o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi%2A> método para empacotar e descriptografar o conteúdo de um <xref:System.Security.SecureString> objeto para um bloco de memória não gerenciada. Ele usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi%2A> método para zerar e descartar o bloco não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ZeroFreeGlobalAllocUnicode">
      <MemberSignature Language="C#" Value="public static void ZeroFreeGlobalAllocUnicode (IntPtr s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ZeroFreeGlobalAllocUnicode(native int s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="s">O endereço da cadeia de caracteres não gerenciado para liberar.</param>
        <summary>Libera um ponteiro não gerenciado de cadeia de caracteres que foi alocado usando o <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)" /> método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> método primeiro zeros out e, em seguida, libera memória não gerenciada que foi alocada usando o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode%2A> método com não gerenciado `LogonUser` função para executar a representação com o <xref:System.Security.SecureString> classe. O exemplo usa o <xref:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode%2A> método para zerar e liberar a referência de cadeia de caracteres não gerenciado.  
  
 [!code-csharp[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/CS/sample.cs#1)]
 [!code-vb[Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.InteropServices.Marshal.SecureStringToHGlobalUni/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
