<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma classe wrapper para identificadores do sistema operacional. Essa classe deve ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle> classe fornece finalização crítica dos recursos do identificador, impedindo identificadores seja recuperada prematuramente pela coleta de lixo e de ser reciclado pelo Windows para fazer referência a objetos não gerenciados não intencionais.  
  
 Este tópico inclui as seções a seguir:  
  
 [Por que SafeHandle?](#Why)   
 [O que faz SafeHandle](#Does)   
 [Classes derivadas de SafeHandle](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a>Por que SafeHandle?  
 Antes do .NET Framework versão 2.0, o sistema operacional identificadores só podem ser encapsulados no <xref:System.IntPtr> objeto wrapper gerenciado. Embora essa era uma maneira conveniente para a interoperação com código nativo, identificadores poderiam ser vazados por exceções assíncronas, como um thread anulando inesperadamente ou um estouro de pilha. Essas exceções assíncronas são um obstáculo para limpar os recursos do sistema operacional, e eles podem ocorrer praticamente qualquer lugar no seu aplicativo.  
  
 Embora as substituições feitas ao <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método permite que a limpeza de recursos não gerenciados, quando um objeto está sendo limpo, em algumas circunstâncias, objetos finalizáveis podem ser recuperados pelo lixo coleção durante a execução de um método em uma plataforma de chamada de invocação. Se um finalizador libera o identificador passado para essa plataforma chamar invoke, isso pode levar a tratar corrupção. O identificador também poderia ser recuperado, enquanto o método é bloqueado durante uma plataforma de invocação de chamada, como ao ler um arquivo.  
  
 Mais crítico, porque o Windows agressivamente recicla identificadores, um identificador pode ser reciclado e aponte para outro recurso que pode conter dados confidenciais. Isso é conhecido como um ataque de reciclagem e pode potencialmente corromper os dados e ser uma ameaça à segurança.  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a>O que faz SafeHandle  
 O <xref:System.Runtime.InteropServices.SafeHandle> classe simplifica vários desses problemas de tempo de vida do objeto e está integrada com a plataforma de invocação de forma que os recursos do sistema operacional não vazam. O <xref:System.Runtime.InteropServices.SafeHandle> classe resolve problemas de tempo de vida do objeto atribuindo e liberar identificadores sem interrupções. Ele contém um finalizador crítico que garante que o identificador é fechado e sempre é executado durante inesperado <xref:System.AppDomain> descarrega, mesmo em casos em que a chamada de invocação de plataforma deve para estar em um estado corrompido.  
  
 Porque <xref:System.Runtime.InteropServices.SafeHandle> herda de <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, todos os finalizadores não críticos são chamados antes de qualquer os finalizadores críticos. Os finalizadores são chamados em objetos que não são mais dinâmicos durante a fase de coleta de lixo mesmo. Por exemplo, um <xref:System.IO.FileStream> objeto pode executar um finalizador normal para liberar os dados armazenados em buffer existentes sem o risco de que o identificador seja perdido ou reciclados. Essa classificação muito fraca entre finalizadores críticos e não se destina para uso geral. Ele existe principalmente para ajudar na migração das bibliotecas existentes, permitindo que essas bibliotecas usar <xref:System.Runtime.InteropServices.SafeHandle> sem alterar sua semântica. Além disso, o finalizador crítico e tudo o que ele chama, como o <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> método, deve estar em uma região de execução restrita. Isso impõe restrições na qual código pode ser gravado no gráfico de chamadas do finalizador.  
  
 Invocação de plataforma operações automaticamente incrementar a contagem de referência de identificadores encapsulado por um <xref:System.Runtime.InteropServices.SafeHandle> e de decremento-los após a conclusão. Isso garante que o identificador não será reciclado ou fechado inesperadamente.  
  
 Você pode especificar a propriedade do identificador subjacente ao construir <xref:System.Runtime.InteropServices.SafeHandle> objetos fornecendo um valor para o `ownsHandle` argumento o <xref:System.Runtime.InteropServices.SafeHandle> construtor de classe. Controla se o <xref:System.Runtime.InteropServices.SafeHandle> objeto liberará a alça depois que o objeto foi descartado.  Isso é útil para identificadores com os requisitos de tempo de vida peculiares ou para o consumo de um identificador cujo tempo de vida é controlado por outra pessoa.  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a>Classes derivadas de SafeHandle  
 <xref:System.Runtime.InteropServices.SafeHandle>é uma classe abstrata de wrapper para identificadores do sistema operacional. Essa classe é difícil. Em vez disso, use as classes derivadas no <xref:Microsoft.Win32.SafeHandles> namespace que forneça identificadores de segurança para o seguinte:  
  
-   Arquivos (o <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe).  
  
-   Arquivos de memória mapeada (o <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> classe).  
  
-   Pipes (o <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> classe).  
  
-   Exibições de memória (o <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> classe).  
  
-   Construções de criptografia (o <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, e <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).  
  
-   Processos (o <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> classe).  
  
-   Chaves do registro (o <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> classe).  
  
-   Identificadores de espera (o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> classe).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um identificador de seguro personalizado para um identificador de arquivo do sistema operacional, derivando de <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. Ele lê os bytes de um arquivo e exibe os valores hexadecimais. Ele também contém uma falha de equipamento de teste que faz com que o thread de anulação, mas o valor do identificador é liberado.  Ao usar um <xref:System.IntPtr> para representar os identificadores, o identificador ocasionalmente vazou devido à anulação de thread assíncrono.  
  
 Você precisará de um arquivo de texto na mesma pasta que o aplicativo compilado. Supondo que você nomear o aplicativo "HexViewer", o uso de linha de comando é:  
  
 `HexViewer <filename> -Fault`  
  
 Opcionalmente, especifique `-Fault` intencionalmente tente deixar vazar a alça, anulando o thread em uma janela de determinados. Use a ferramenta Windows Perform.exe para monitorar a contagem de identificadores ao injetar falhas.  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Este membro não pode ser herdado por código parcialmente confiável.</permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
    <block subset="none" type="overrides">
      <para>Para criar uma classe derivada de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, você deve saber como criar e liberar um identificador de sistema operacional. Esse processo é diferente para tipos de identificador diferente porque alguns usam o [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funcionar, enquanto outras usam funções mais específicas, como [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) ou [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx). Por esse motivo, você deve criar uma classe derivada de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> para cada tipo de identificador de sistema operacional que você deseja incluir em um identificador seguro.  
  
 Ao herdar de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, você deve substituir os seguintes membros: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> e <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.  
  
 Você também deve fornecer um construtor padrão que chama o construtor base com um valor que represente um valor identificador inválido, e um <see cref="T:System.Boolean" /> valor que indica se o identificador nativo é de propriedade de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> e, consequentemente, deve ser liberada quando que <see cref="T:System.Runtime.InteropServices.SafeHandle" /> foi descartado.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue">O valor de um identificador inválido (geralmente 0 ou -1).  A implementação do <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> deve retornar <see langword="true" /> para esse valor.</param>
        <param name="ownsHandle">
          <see langword="true" />para permitir que o confiável <see cref="T:System.Runtime.InteropServices.SafeHandle" /> o identificador de versão durante a fase de finalização; caso contrário, <see langword="false" /> (não recomendado).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> com o valor do identificador inválido especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `ownsHandle` parâmetro é `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nunca seja chamado; portanto, não é recomendável usar esse valor de parâmetro como seu código pode causar perda de recursos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException">A classe derivada reside em um assembly sem permissão de acesso ao código não gerenciado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Este membro não pode ser herdado por código parcialmente confiável.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca o identificador de liberação de recursos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método permite que os recursos sejam liberados. Isso pode não acontecer imediatamente se outros threads estão usando o mesmo objeto de identificador seguro, mas ocorrerá assim que não é mais o caso. Embora a maioria das classes que usam o <xref:System.Runtime.InteropServices.SafeHandle> classe não é necessário fornecer um finalizador, isso às vezes é necessário (por exemplo, para liberar os buffers de arquivo ou escrever alguns dados de volta para a memória). Nesse caso, a classe pode fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.SafeHandle> executa finalizador crítico.  
  
 Chamar o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.SafeHandle> objeto.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.SafeHandle> objeto. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.SafeHandle> do objeto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success">
          <see langword="true" /> se o contador de referências tiver sido aumentado com êxito; caso contrário, <see langword="false" />.</param>
        <summary>Incrementa manualmente o contador de referências em instâncias do <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> método impede que o common language runtime recuperar memória usada por um identificador (o que ocorre quando o tempo de execução chama o <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> método). Você pode usar esse método para incrementar a contagem de referência em manualmente um <xref:System.Runtime.InteropServices.SafeHandle> instância. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>Retorna um valor booliano usando um `ref` parâmetro (`success`) que indica se a contagem de referência foi incrementada com êxito. Isso permite que sua lógica de programa de volta em caso de falha. Você deve definir `success` para `false` antes de chamar <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Se `success` é `true`, evitar vazamentos de recursos correspondendo a chamada para <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> com uma chamada correspondente para <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  
  
> [!CAUTION]
>  Este método destina-se para usuários avançados e sempre deve ser usado com cuidado. Para evitar o vazamento de recursos do identificador, sempre chame esse método dentro de uma região de execução restrita (CER), onde uma anulação de thread não é possível interromper o processamento.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o valor do campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</summary>
        <returns>Um <see langword="IntPtr" /> que representa o valor do campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />. Se o identificador tiver sido marcado como inválido com <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, esse método ainda retornará o valor do identificador original, que pode ser um valor obsoleto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar esse método para recuperar o valor real do identificador de uma instância do <xref:System.Runtime.InteropServices.SafeHandle> classe derivada. Esse método é necessário para versões anteriores compatibilidade porque muitas propriedades no .NET Framework retornarem `IntPtr` tratar tipos. `IntPtr`tipos de identificador são tipos específicos de plataforma usados para representar um ponteiro ou um identificador.  
  
> [!CAUTION]
>  Usando o <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> método pode representar riscos de segurança porque, se o identificador tiver sido marcado como inválido com <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> ainda retorna o valor do identificador original, potencialmente obsoletos. O identificador retornado também pode ser reciclado a qualquer momento. Na melhor das hipóteses, isso significa que o identificador pode parar de funcionar repentinamente. Na pior das hipóteses, se o identificador ou o recurso que representa o identificador é exposto para código não confiável, isso pode levar a um ataque de segurança de reciclagem no identificador retornado ou reutilizado. Por exemplo, um chamador não confiável pode consultar dados no identificador do apenas retornados e receber informações de um recurso totalmente não relacionada. Consulte o <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> e <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> métodos para obter mais informações sobre como usar o <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Manualmente diminui o contador de referência em um <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instância.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> método é a contraparte <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. Você sempre deve corresponder a uma chamada para o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> método com uma chamada bem-sucedida para <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  
  
> [!CAUTION]
>  Este método destina-se para usuários avançados e sempre deve ser usado com cuidado. Para evitar o vazamento de recursos do identificador, sempre chame esse método dentro de uma região de execução restrita (CER), onde uma anulação de thread não é possível interromper o processamento. Da mesma forma que não correspondentes <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> chamadas podem causar vazamentos de recursos, sem correspondência <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chamadas podem fazer com que os estados de identificador inválido ficar visível para outros threads. Não exponha <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> chamadas para código não confiável.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela classe <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamando o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método permite que os recursos sejam liberados. Isso pode não acontecer imediatamente se outros threads estão usando a mesma instância de SafeHandle, mas ocorrerá assim que não é mais o caso. Embora mais classes usando <xref:System.Runtime.InteropServices.SafeHandle> não é necessário fornecer um finalizador, às vezes, é necessário (por exemplo, para liberar os buffers de arquivo ou write-back de alguns dados na memória). Nesse caso, podem fornecer um finalizador que sempre é executado antes do <xref:System.Runtime.InteropServices.SafeHandle> executa finalizador crítico.  
  
 Chamar o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método quando tiver terminado de usar o <xref:System.Runtime.InteropServices.SafeHandle> objeto. O <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método deixa o <xref:System.Runtime.InteropServices.SafeHandle> objeto em um estado inutilizável.  
  
> [!NOTE]
>  Sempre chamar o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> ou <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método antes de liberar sua última referência para o <xref:System.Runtime.InteropServices.SafeHandle> objeto. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Runtime.InteropServices.SafeHandle> do objeto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para uma operação de descarte normal, <see langword="false" /> para finalizar o identificador.</param>
        <summary>Libera os recursos não gerenciados usados pela classe <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que especifica se deve executar uma operação de descarte normal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar nunca explicitamente o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método com o `disposing` parâmetro definido como `false`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos associados com o identificador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> método é o destruidor para o <xref:System.Runtime.InteropServices.SafeHandle> classe. Código do aplicativo não deve chamar este método diretamente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o identificador a ser encapsulado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não exponha o identificador publicamente (ou seja, fora da classe derivada).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o identificador está fechado.</summary>
        <value>
          <see langword="true" /> se o identificador estiver fechado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> método retorna um valor que indica se o <xref:System.Runtime.InteropServices.SafeHandle> identificador do objeto não está mais associado um recurso nativo. Isso é diferente da definição do <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriedade, que calcula se um determinado identificador sempre é considerado inválido. O <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> método retorna um `true` valor nos seguintes casos:  
  
-   O <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> método foi chamado.  
  
-   O <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método ou <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método foi chamado e não houver nenhuma referência para o <xref:System.Runtime.InteropServices.SafeHandle> objeto em outros threads.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o valor do identificador é inválido.</summary>
        <value>
          <see langword="true" />Se o valor do identificador é inválido; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes derivadas devem implementar a <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriedade para que o common language runtime pode determinar se a finalização crítica é necessária. Classes derivadas devem fornecer uma implementação que se adapta ao tipo geral de identificador de dar suporte a eles (0 ou -1 é inválida). Essas classes, em seguida, podem ser mais derivadas para tipos de identificador de segurança específico.  
  
 Ao contrário de <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> propriedade, que informa se o <xref:System.Runtime.InteropServices.SafeHandle> objeto terminou de usar o identificador subjacente, o <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriedade calcula se o valor do identificador fornecido é sempre considerado inválido. Portanto, o <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriedade sempre retorna o mesmo valor para qualquer valor de um identificador.  
  
   
  
## Examples  
 O exemplo a seguir verifica se um arquivo foi aberto com êxito. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, executa o código necessário para liberar o identificador.</summary>
        <returns>
          <see langword="true" />Se o identificador é liberado com êxito; Caso contrário, no caso de uma falha catastrófica, <see langword="false" />. Nesse caso, ele gera um [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistente de depuração gerenciada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> é garantido que método ser chamado somente uma vez e apenas se o identificador é válido conforme definido pelo <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propriedade. Implementar esse método no seu <xref:System.Runtime.InteropServices.SafeHandle> derivadas de classes para executar qualquer código que é necessário para liberar o identificador. Porque uma das funções de <xref:System.Runtime.InteropServices.SafeHandle> é garantir a prevenção de perda de recursos, o código em sua implementação de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nunca deve falhar. O coletor de lixo chama <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> após a execução de finalizadores normais para objetos que foram limpos ao mesmo tempo. O coletor de lixo garante os recursos para invocar esse método e que o método não será interrompido enquanto ele está em andamento. Esse método será preparado como uma região de execução restrita (CER) no tempo de construção da instância (junto com todos os métodos em seu gráfico de chamada estaticamente determinável). Embora isso impede que as interrupções de anulação de thread, você ainda deve ter cuidado para não incluir todos os caminhos falhas no seu substituído <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> método. Em particular, se aplicam a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> a qualquer método que você chamar a partir de atributo <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. Na maioria dos casos, esse código deve ser:  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 Além disso, para limpeza simple (por exemplo, chamar a API do Win32 `CloseHandle` em um identificador de arquivo) você pode verificar o valor de retorno de chamada de invocação de plataforma única. Para limpeza complexa, você pode ter muita lógica de programa e muitas chamadas de método, algumas das quais podem falhar. Certifique-se de que sua lógica de programa tem código de retorno para cada um desses casos.  
  
 Se <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> retorna `false` por qualquer motivo, ele gera um [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Assistente de depuração gerenciada.  Isso ajuda a detectar os casos em que a tentativa de liberar recursos falha.  
  
   
  
## Examples  
 O exemplo de código a seguir libera o identificador e faz parte de um exemplo maior fornecido para a <xref:System.Runtime.InteropServices.SafeHandle> classe.  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">O identificador pré-existente a ser usado.</param>
        <summary>Define o identificador para o identificador pré-existente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> identificadores em uma estrutura de saída do método somente se você precisar oferecer suporte a um identificador já existente (por exemplo, se o identificador é retornado em uma estrutura) porque a infraestrutura de interoperabilidade do .NET Framework COM não oferece suporte para marshaling.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Marca um identificador como não mais usado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar o <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> método somente quando souber que o identificador não faz referência a um recurso. Isso não altera o valor de <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; apenas marcará o identificador como fechado. O identificador, em seguida, pode conter um valor potencialmente obsoleto. O efeito dessa chamada é que é feita nenhuma tentativa para liberar os recursos.  
  
 Assim como acontece com o <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> método, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> somente se você precisar oferecer suporte a um identificador já existente.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
