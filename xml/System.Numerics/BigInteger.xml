<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>2.3.98.1</AssemblyVersion>
    <AssemblyVersion>3.98.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um inteiro com sinal arbitrariamente grande.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger> tipo é um tipo imutável que representa um inteiro arbitrariamente grande cujo valor teoricamente não tem nenhum limite superior ou inferior. Os membros do <xref:System.Numerics.BigInteger> tipo paralelo perto de outros tipos integrais (o <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, e <xref:System.UInt64> tipos). Esse tipo difere de outros tipos integrais no [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], que tem um intervalo indicado por seus `MinValue` e `MaxValue` propriedades.  
  
> [!NOTE]
>  Porque o <xref:System.Numerics.BigInteger> tipo é imutável (consulte [Mutabilidade e a estrutura BigInteger](#mutability)) e porque ela tem nenhum limite superior ou inferior, um <xref:System.OutOfMemoryException> pode ser gerada para qualquer operação que faz com que um <xref:System.Numerics.BigInteger> valor aumentar muito grande.  
  
## <a name="instantiating-a-biginteger-object"></a>Criando uma instância de um objeto BigInteger  
 Você pode instanciar uma <xref:System.Numerics.BigInteger> objeto de várias maneiras:  
  
-   Você pode usar o `new` palavra-chave e forneça qualquer valor integral ou de ponto flutuante como um parâmetro para o <xref:System.Numerics.BigInteger> construtor. (Valores de ponto flutuante são truncados antes que eles forem atribuídos a <xref:System.Numerics.BigInteger>.) O exemplo a seguir ilustra como usar o `new` palavra-chave para instanciar <xref:System.Numerics.BigInteger> valores.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Você pode declarar uma <xref:System.Numerics.BigInteger> variável e atribuir um valor exatamente como você faria qualquer tipo numérico, desde que esse valor é um tipo integral. O exemplo a seguir usa a atribuição para criar um <xref:System.Numerics.BigInteger> valor de um <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Você pode atribuir um valor decimal ou flutuante para um <xref:System.Numerics.BigInteger> de objeto se você converter o valor ou convertê-la primeiro. O exemplo a seguir converte (em c#) ou converte (no Visual Basic) explicitamente um <xref:System.Double> e um <xref:System.Decimal> valor para um <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Esses métodos permitem que você criar uma instância de um <xref:System.Numerics.BigInteger> somente a tipos de objeto cujo valor está no intervalo de um numérico existente. Você pode instanciar uma <xref:System.Numerics.BigInteger> objeto cujo valor pode exceder o intervalo dos tipos numéricos existentes em uma das três maneiras:  
  
-   Você pode usar o `new` palavra-chave e forneça uma matriz de bytes de qualquer tamanho de <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> construtor. Por exemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Você pode chamar o <xref:System.Numerics.BigInteger.Parse%2A> ou <xref:System.Numerics.BigInteger.TryParse%2A> métodos para converter a representação de cadeia de caracteres de um número para um <xref:System.Numerics.BigInteger>. Por exemplo:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Você pode chamar um `static` (`Shared` no Visual Basic) <xref:System.Numerics.BigInteger> método que executa alguma operação em uma expressão numérica e retorna um calculado <xref:System.Numerics.BigInteger> resultados. O exemplo a seguir faz isso por cubing <xref:System.UInt64.MaxValue?displayProperty=nameWithType> e atribuir o resultado a um <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 O valor não inicializado de um <xref:System.Numerics.BigInteger> é <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Realizando operações em valores BigInteger  
 Você pode usar um <xref:System.Numerics.BigInteger> como você usaria qualquer outro tipo integral de instância. <xref:System.Numerics.BigInteger>sobrecargas de operadores numéricos padrão para que você possa executar operações matemáticas básicas, como adição, subtração, divisão, multiplicação, subtração, negação e negação unário. Você também pode usar os operadores numéricos padrão para comparar dois <xref:System.Numerics.BigInteger> valores entre si. Como os outros tipos integrais <xref:System.Numerics.BigInteger> também suporta o bit a bit `And`, `Or`, `XOr`, esquerdo shift e operadores de deslocamento para a direita. Para idiomas que não dão suporte a operadores personalizados, o <xref:System.Numerics.BigInteger> estrutura também fornece métodos equivalentes para executar operações matemáticas. Isso inclui <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>e vários outros.  
  
 Número de membros do <xref:System.Numerics.BigInteger> estrutura corresponde diretamente aos membros de outros tipos integrais. Além disso, <xref:System.Numerics.BigInteger> adiciona membros como o seguinte:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, que retorna um valor que indica o sinal de um <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, que retorna o valor absoluto de um <xref:System.Numerics.BigInteger> valor.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, que retorna o quociente e o resto de uma operação de divisão.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, que retorna o máximo divisor comum de dois <xref:System.Numerics.BigInteger> valores.  
  
 Muitos desses membros adicionais correspondem aos membros a <xref:System.Math> classe, que fornece a funcionalidade para trabalhar com os tipos numéricos primitivo.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Mutabilidade e a estrutura de BigInteger  
 O exemplo a seguir cria um <xref:System.Numerics.BigInteger> de objeto e, em seguida, incrementa o valor em um.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Embora esse exemplo é exibido modificar o valor do objeto existente, isso não é o caso. <xref:System.Numerics.BigInteger>objetos são imutáveis, o que significa que, internamente, o common language runtime, na verdade, cria um novo <xref:System.Numerics.BigInteger> de objeto e atribui um valor maior do que seu valor anterior. Esse novo objeto é retornado ao chamador.  
  
> [!NOTE]
>  Os tipos numéricos do .NET Framework também são imutáveis. No entanto, como o <xref:System.Numerics.BigInteger> tipo não tem nenhum limite superior ou inferior, seus valores podem ficar muito grandes e exerce um impacto significativo no desempenho.  
  
 Embora esse processo é transparente para o chamador, ele pode incorrer em uma penalidade de desempenho. Em alguns casos, especialmente quando várias operações são executadas em um loop em grandes <xref:System.Numerics.BigInteger> valores, que penalidade de desempenho pode ser significativa. Por exemplo, no exemplo a seguir, uma operação é executada repetidamente até um milhão de vezes e um <xref:System.Numerics.BigInteger> valor é incrementado em um cada vez que a operação for bem-sucedida.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 Nesse caso, você pode melhorar o desempenho executando todas as atribuições de intermediárias para um <xref:System.Int32> variável. O valor final da variável, em seguida, pode ser atribuído para o <xref:System.Numerics.BigInteger> objeto quando o loop será encerrado. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Trabalhando com matrizes de bytes e cadeias de caracteres hexadecimais  
 Se você converter <xref:System.Numerics.BigInteger> valores para matrizes de bytes, ou se você converter matrizes de bytes para <xref:System.Numerics.BigInteger> valores, você deve considerar a ordem de bytes. O <xref:System.Numerics.BigInteger> estrutura espera os bytes individuais em uma matriz de bytes para aparecer na ordem little endian (ou seja, os bytes de ordem inferior do valor precedem os bytes de ordem superior). Você pode viagem um <xref:System.Numerics.BigInteger> valor chamando o <xref:System.Numerics.BigInteger.ToByteArray%2A> método e, em seguida, passando o byte resultante de matriz para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Para criar uma instância de um <xref:System.Numerics.BigInteger> valor de uma matriz de bytes que representa um valor de outro tipo integral, você pode passar o valor inteiro para o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e, em seguida, passe o byte resultante de matriz para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor. O exemplo a seguir cria um <xref:System.Numerics.BigInteger> valor de uma matriz de bytes que representa um <xref:System.Int16> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 O <xref:System.Numerics.BigInteger> estrutura pressupõe que os valores negativos são armazenados usando a representação de complemento de dois. Porque o <xref:System.Numerics.BigInteger> estrutura representa um valor numérico com nenhum comprimento fixo, o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor sempre interpreta o bit mais significativo do último byte na matriz como uma entrada. Para evitar o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor da confuso de dois complemento representação de um valor negativo com a representação de entrada e a magnitude de um valor positivo, positivo de valores que o bit mais significativo do último byte na matriz de bytes será normalmente definido devem incluir um byte adicional cujo valor é 0. Por exemplo, 0xC0 0xBD 0xF0 0xFF é a representação hexadecimal little endian de-1,000,000 ou 4,293,967,296. Como o bit mais significativo do último byte nessa matriz é ativado, o valor da matriz de bytes deve ser interpretado pelo <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor como-1,000,000. Para criar uma instância de um <xref:System.Numerics.BigInteger> cujo valor é positivo, uma matriz de bytes cujos elementos são 0xC0 0xBD 0xF0 0xFF 0x00 devem ser passados para o construtor. O exemplo a seguir ilustra essa situação.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Matrizes de bytes criados pelo <xref:System.Numerics.BigInteger.ToByteArray%2A> método de valores positivos incluir essa extra do valor de zero bytes. Portanto, o <xref:System.Numerics.BigInteger> estrutura pode valores de ida e volta com êxito, atribuindo-lhes para e, em seguida, restaurá-los de matrizes de bytes, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 No entanto, você precisará adicionar essa bytes adicional do valor de zero para matrizes de bytes que são criados dinamicamente pelo desenvolvedor ou que são retornados por métodos que convertem inteiros sem sinal em matrizes de bytes (como <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, e <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Ao analisar uma cadeia de caracteres hexadecimal de <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> e <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> métodos supõem que, se o bit mais significativo do primeiro byte na cadeia de caracteres é definido ou se o primeiro dígito hexadecimal da cadeia de caracteres representa quatro bits inferiores de um valor de byte, o valor é representado usando a representação de complemento de dois. Por exemplo, "FF01" e "F01" representam o valor decimal-255. Para diferenciar positivo de valores negativos, a valores positivos devem incluir um zero à esquerda. As sobrecargas relevantes do <xref:System.Numerics.BigInteger.ToString%2A> método, quando eles são passados de cadeia de caracteres de formato "X", adicione um zero à esquerda para a cadeia de caracteres hexadecimal retornado para valores positivos. Isso possibilita a viagem <xref:System.Numerics.BigInteger> valores usando o <xref:System.Numerics.BigInteger.ToString%2A> e <xref:System.Numerics.BigInteger.Parse%2A> métodos, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 No entanto, as cadeias de caracteres hexadecimais é criado chamando o `ToString` métodos de outros tipos integrais ou as sobrecargas do <xref:System.Convert.ToString%2A> método que incluem um `toBase` parâmetro não indicam o sinal do valor ou o tipo de dados de origem da qual deriva a cadeia de caracteres hexadecimal. Criando com êxito um <xref:System.Numerics.BigInteger> valor de uma cadeia de caracteres requer lógica adicional. O exemplo a seguir fornece uma possível implementação.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de valores de bytes em ordem little endian.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando os valores de uma matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os bytes individuais a `value` matriz deve estar na ordem de little endian, de byte de ordem inferior para byte de ordem mais alta. Por exemplo, o valor numérico 1.000.000.000.000 é representado como mostrado na tabela a seguir:  
  
|||  
|-|-|  
|Cadeia de caracteres hexadecimal|E8D4A51000|  
|Matriz de bytes (menor índice primeiro)|00 E8 DE D4 A5 10 00|  
  
 A maioria dos métodos que convertem valores numéricos em matrizes de bytes, como <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> e <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, retornam matrizes de bytes na ordem little endian.  
  
 O construtor espera valores positivos da matriz de bytes para usar representação de magnitude sinal e valores negativos para usar representação de complemento de dois. Em outras palavras, se a ordem mais alta de bits do byte de ordem mais alta no `value` for definida, o resultante <xref:System.Numerics.BigInteger> valor é negativo. Dependendo da fonte da matriz do byte, isso pode causar um valor positivo para ser considerado como um valor negativo. Matrizes de bytes normalmente são gerados das seguintes maneiras:  
  
-   Chamando o <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> método. Como esse método retorna uma matriz de bytes com o bit de ordem mais alta do que o byte de ordem mais alta no conjunto de matriz para zero para valores positivos, não há nenhuma possibilidade de má interpretação um valor positivo como negativo. Sem modificações matrizes de bytes criados pelo <xref:System.Numerics.BigInteger.ToByteArray%2A> método sempre com êxito ida e volta quando eles são passados para o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor.  
  
-   Chamando o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e passá-lo em um inteiro com sinal como um parâmetro. Como inteiros com sinal de manipular a representação de magnitude logon e a representação de complemento de dois, não há nenhuma possibilidade de má interpretação um valor positivo como negativo.  
  
-   Chamando o <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> método e passá-lo em um inteiro sem sinal como um parâmetro. Como inteiros sem sinal são representados por sua magnitude apenas, valores positivos podem ser mal interpretados como valores negativos. Para evitar essa interpretação incorreta, você pode adicionar um valor de zero bytes até o final da matriz. O exemplo na próxima seção fornece uma ilustração.  
  
-   Criando uma matriz de bytes ou estática ou dinamicamente, sem necessariamente chamar qualquer um dos métodos anteriores ou modificando uma matriz de bytes existente. Para impedir que valores positivos sejam interpretados incorretamente como valores negativos, você pode adicionar um valor de zero bytes até o final da matriz.  
  
 Se `value` está vazio <xref:System.Byte> matriz, o novo <xref:System.Numerics.BigInteger> objeto é inicializado com um valor de <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `value` é `null`, o construtor lançará um <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Numerics.BigInteger> objeto a partir de uma matriz de bytes de 5 elemento cujo valor é {5, 4, 3, 2, 1}. Em seguida, exibe o <xref:System.Numerics.BigInteger> valor, representado como números decimais e hexadecimais, no console. Uma comparação de matriz de entrada com a saída de texto deixa claro por que esta sobrecarga do <xref:System.Numerics.BigInteger> construtor da classe cria um <xref:System.Numerics.BigInteger> objeto cujo valor é 4328719365 (ou 0x102030405). O primeiro elemento da matriz de bytes, cujo valor é 5, define o valor do byte de ordem inferior a <xref:System.Numerics.BigInteger> objeto, que é 0x05. O segundo elemento da matriz de bytes, cujo valor é 4, define o valor do byte do segundo o <xref:System.Numerics.BigInteger> objeto, que é 0x04 e assim por diante.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 O exemplo a seguir cria um positivo e um negativo <xref:System.Numerics.BigInteger> valor, passa para o <xref:System.Numerics.BigInteger.ToByteArray%2A> método e, em seguida, restaura o original <xref:System.Numerics.BigInteger> valores da matriz de bytes resultante. Observe que os dois valores são representados pelo matrizes de bytes idênticos. A única diferença entre eles é em que o bit mais significativo do último elemento da matriz de bytes. Esse bit estiver definido (o valor do byte é 0xFF) se a matriz é criada a partir de um resultado negativo <xref:System.Numerics.BigInteger> valor. O bits não estiver definido (o valor do byte será zero), se a matriz é criada a partir de um positivo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 O exemplo a seguir ilustra como certificar-se de que um valor positivo não é incorretamente instanciado como um valor negativo, adicionando um byte cujo valor é zero para o final da matriz.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um número decimal.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor <see cref="T:System.Decimal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O resultado de chamar este construtor é idêntico ao atribuir explicitamente um <xref:System.Decimal> valor para um <xref:System.Numerics.BigInteger> variável.  
  
 Chamar este construtor pode causar perda de dados; qualquer parte fracionária `value` é truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Define uma matriz de <xref:System.Decimal> valores e, em seguida, passa cada valor com o <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> construtor. Observe que o <xref:System.Decimal> valor é truncado em vez de arredondado quando ele está atribuído a <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um valor de ponto flutuante de precisão dupla.</param>
        <summary>Inicializa uma nova instância de estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor de ponto flutuante de precisão dupla.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
 Devido à falta de precisão do <xref:System.Double> tipo de dados, chamar este construtor pode causar perda de dados.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição explicitamente um <xref:System.Double> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Ele também ilustra a perda de precisão que pode ocorrer quando você usa o <xref:System.Double> tipo de dados. Um <xref:System.Double> é atribuído um valor grande, que é atribuído a um <xref:System.Numerics.BigInteger> objeto. Como mostra a saída, essa atribuição envolve uma perda de precisão. Os dois valores, em seguida, são incrementados em um. A saída mostra que o <xref:System.Numerics.BigInteger> objeto reflete o valor alterado, enquanto o <xref:System.Double> objeto não.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é <see cref="F:System.Double.NaN" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Double.NegativeInfinity" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro com sinal de 32 bits.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor inteiro com sinal de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> objeto usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <xref:System.Int32> valor para um <xref:System.Numerics.BigInteger>.  
  
 O <xref:System.Numerics.BigInteger> estrutura não tem construtores com um parâmetro de tipo <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, ou <xref:System.UInt16>. No entanto, o <xref:System.Int32> tipo oferece suporte à conversão implícita de 8 e 16 bits inteiros assinados e para inteiros de 32 bits com sinal. Como resultado, este construtor é chamado se `value` é qualquer um destes quatro tipos integrais.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> construtor para instanciar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros de 32 bits. Ele também usa a conversão implícita para atribuir a cada valor de inteiro de 32 bits para um <xref:System.Numerics.BigInteger> variável. Ele então compara os dois valores para estabelecer que resultante <xref:System.Numerics.BigInteger> valores são os mesmos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro com sinal de 64 bits.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> usando um valor inteiro com sinal de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> objeto usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <xref:System.Int64> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> construtor para instanciar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros de 64 bits. Ele também usa a conversão implícita para atribuir a cada valor de inteiro de 64 bits com um <xref:System.Numerics.BigInteger> variável. Ele então compara os dois valores para estabelecer que resultante <xref:System.Numerics.BigInteger> valores são os mesmos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um valor de ponto flutuante de precisão simples.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Numerics.BigInteger" /> estrutura usando um valor de ponto flutuante de precisão simples.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado ao instanciar um <xref:System.Numerics.BigInteger> objeto.  
  
 Devido à falta de precisão do <xref:System.Single> tipo de dados, chamar este construtor pode resultar em perda de dados.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição explicitamente um <xref:System.Single> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto. Ele também ilustra a perda de precisão que pode ocorrer quando você usa o <xref:System.Single> tipo de dados. Um <xref:System.Single> é atribuído um valor negativo grande, que é atribuído a um <xref:System.Numerics.BigInteger> objeto. Como mostra a saída, essa atribuição envolve uma perda de precisão. Os dois valores, em seguida, são incrementados em um. A saída mostra que o <xref:System.Numerics.BigInteger> objeto reflete o valor alterado, enquanto o <xref:System.Single> objeto não.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é <see cref="F:System.Single.NaN" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Single.NegativeInfinity" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro de 32 bits sem sinal.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Numerics.BigInteger" /> estrutura usando um valor inteiro de 32 bits sem sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <xref:System.UInt32> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> construtor e uma instrução de atribuição para inicializar <xref:System.Numerics.BigInteger> valores de uma matriz de inteiros de 32 bits sem sinal. Em seguida, compara os dois valores para demonstrar que os dois métodos de inicializar um <xref:System.Numerics.BigInteger> valor produzir resultados idênticos.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Um inteiro de 64 bits sem sinal.</param>
        <summary>Inicializa uma nova instância da estrutura <see cref="T:System.Numerics.BigInteger" /> com um valor inteiro de 64 bits sem sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há nenhuma perda de precisão ao instanciar um <xref:System.Numerics.BigInteger> usando este construtor.  
  
 O <xref:System.Numerics.BigInteger> valor resultante da chamada a este construtor é idêntico ao valor resultante da atribuição de um <xref:System.UInt64> valor para um <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> construtor para instanciar um <xref:System.Numerics.BigInteger> objeto cujo valor é igual a <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um número.</param>
        <summary>Obtém o valor absoluto de um objeto <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O valor absoluto de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um número é o número sem sinal, como mostrado na tabela a seguir.  
  
|Parâmetro `value`|Valor retornado|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 O <xref:System.Numerics.BigInteger.Abs%2A> método é equivalente a <xref:System.Math.Abs%2A?displayProperty=nameWithType> método para os tipos numéricos primitivo.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Abs%2A> método para converter um <xref:System.Numerics.BigInteger> valor de representação de complemento de dois a representação de entrada e magnitude antes serializá-lo para um arquivo. Os dados no arquivo são desserializados e atribuídos a um novo <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser adicionado.</param>
        <param name="right">O segundo valor a ser adicionado.</param>
        <summary>Adiciona dois valores de <see cref="T:System.Numerics.BigInteger" /> e retorna o resultado.</summary>
        <returns>A soma de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas que não dão suporte a sobrecarga de operador ou operadores personalizados podem usar o <xref:System.Numerics.BigInteger.Add%2A> método para executar a adição usando <xref:System.Numerics.BigInteger> valores.  
  
 O <xref:System.Numerics.BigInteger.Add%2A> método é um substituto úteis para o operador de adição ao instanciar um <xref:System.Numerics.BigInteger> variável atribuindo a ele uma soma resultante da adição, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Compara dois valores <see cref="T:System.Numerics.BigInteger" /> e retorna um inteiro que indica se o primeiro valor é menor que, igual a ou maior que o segundo valor.</summary>
        <returns>Um inteiro assinado que indica os valores relativos de <paramref name="left" /> e <paramref name="right" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Condição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description><paramref name="left" />é menor que <paramref name="right" />.  
  
 </description></item><item><term>Zero  
  
 </term><description><paramref name="left" />é igual a <paramref name="right" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description><paramref name="left" />é maior do que <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora o <xref:System.Numerics.BigInteger> tipo não tem nenhum intervalo fixo, as comparações de <xref:System.Numerics.BigInteger> valores não são caracterizados por falta de precisão que caracteriza a comparação de números de ponto flutuante. O exemplo a seguir compara dois <xref:System.Numerics.BigInteger> valores que diferenciam um e que cada um tem 1,896 dígitos. O <xref:System.Numerics.BigInteger.Compare%2A> método corretamente relata que os dois valores não são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro assinado de 64 bits para comparar.</param>
        <summary>Compara a essa instância para um inteiro assinado de 64 bits e retorna um inteiro que indica se o valor desta instância é menor, igual a ou maior que o valor de inteiro assinado de 64 bits.</summary>
        <returns>Um valor de inteiro com sinal que indica a relação desta instância com <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A instância atual for menor que <paramref name="other" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A instância atual é maior do que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> método é chamado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o resultado de chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> método com valores inteiros.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado.</param>
        <summary>Compara esta instância a um segundo <see cref="T:System.Numerics.BigInteger" /> e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um valor de inteiro com sinal que indica a relação desta instância com <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A instância atual for menor que <paramref name="other" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A instância atual é maior do que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa o <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> método. Ele é usado pelos objetos de coleção genérica para ordenar os itens na coleção.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> método para solicitar uma lista de `StarInfo` objetos. Cada `StarInfo` objeto fornece informações sobre o nome de uma estrela e sua distância da Terra em milhas. `StarInfo`implementa o <xref:System.IComparable%601> interface, que permite `StarInfo` objetos a serem classificados por classes de coleção genérica. Seu <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> implementação empacota apenas uma chamada para <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Em seguida, o código a seguir cria quatro `StarInfo` objetos e os armazena em um genérico <xref:System.Collections.Generic.List%601> objeto. Após o <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> método é chamado, `StarInfo` objetos são exibidos em ordem de sua distância da Terra.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado.</param>
        <summary>Compara esta instância a um objeto especificado e retorna um inteiro que indica se o valor desta instância é menor, igual ou maior que o valor do objeto especificado.</summary>
        <returns>Um inteiro que indica a relação da instância atual para o <paramref name="obj" /> parâmetro, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A instância atual for menor que <paramref name="obj" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>A instância atual é igual a <paramref name="obj" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A instância atual é maior do que <paramref name="obj" />, ou o <paramref name="obj" /> parâmetro é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Numerics.BigInteger.CompareTo%2A> método implementa o <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> método. Ele é usado pelos objetos de coleção não genérica para ordenar os itens na coleção.  
  
 O `obj` parâmetro deve ser um dos seguintes:  
  
-   Um objeto cujo tipo de tempo de execução é <xref:System.Numerics.BigInteger>.  
  
-   Um <xref:System.Object> variável cujo valor é `null`. Se o valor de `obj` parâmetro é `null`, o método retorna 1, que indica que a instância atual é maior do que `obj`.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método para comparar um <xref:System.Numerics.BigInteger> valor com cada elemento em uma matriz de objetos  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> não é um <see cref="T:System.Numerics.BigInteger" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro sem sinal de 64 bits para comparar.</param>
        <summary>Compara a essa instância para um inteiro não assinado de 64 bits e retorna um inteiro que indica se o valor desta instância é menor, igual a ou maior que o valor de inteiro de 64 bits.</summary>
        <returns>Um inteiro que indica o valor relativo desta instância e <paramref name="other" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>A instância atual for menor que <paramref name="other" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>A instância atual é igual a <paramref name="other" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>A instância atual é maior do que <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> em outro e retorna o resultado.</summary>
        <returns>O quociente da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Divide%2A> método executa uma divisão de inteiro; todo o restante que resulta da divisão é descartado. Para executar a divisão, enquanto preserva o resto, chamar o <xref:System.Numerics.BigInteger.DivRem%2A> método. Para recuperar apenas o resto, chame o <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 O <xref:System.Numerics.BigInteger.Divide%2A> método pode ser usado pelas linguagens que não dão suporte a sobrecarga de operador. Seu comportamento é idêntico a divisão usando o operador de divisão.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <param name="remainder">Quando este método retorna, contém um valor <see cref="T:System.Numerics.BigInteger" /> que representa o restante da divisão. Este parâmetro é passado não inicializado.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> por outro, retorna o resultado e retorna o restante em um parâmetro de saída.</summary>
        <returns>O quociente da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método preserva o quociente e o resto resultante da divisão de inteiro. Se você não estiver interessado no restante, use o <xref:System.Numerics.BigInteger.Divide%2A> método ou o operador de divisão; se você está apenas interessado no restante, use o <xref:System.Numerics.BigInteger.Remainder%2A> método.  
  
 O sinal do retornado `remainder` valor é o mesmo que o sinal do `dividend` parâmetro.  
  
 O comportamento do <xref:System.Numerics.BigInteger.DivRem%2A> método é idêntico do <xref:System.Math.DivRem%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">O valor inteiro com sinal de 64 bits para comparar.</param>
        <summary>Retorna um valor que indica se a instância atual e um inteiro assinado de 64 bits têm o mesmo valor.</summary>
        <returns>
          <see langword="true" />Se o inteiro assinado de 64 bits e a instância atual tiverem o mesmo valor. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `other` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando o método é chamado.  
  
 Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Numerics.BigInteger> objeto de cada tipo integral exceto <xref:System.UInt64>. Depois, ele chama o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> método para comparar o <xref:System.Numerics.BigInteger> valor com o valor de inteiro original que foi passado para o <xref:System.Numerics.BigInteger> construtor. Como mostra a saída, os valores são iguais em cada caso.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado.</param>
        <summary>Retorna um valor que indica se a instância atual e um especificado <see cref="T:System.Numerics.BigInteger" /> objetos têm o mesmo valor.</summary>
        <returns>
          <see langword="true" />Se este <see cref="T:System.Numerics.BigInteger" /> objeto e <paramref name="other" /> têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementa esse método de <xref:System.IEquatable%601> interface e executa um pouco melhor do que <xref:System.Numerics.BigInteger.Equals%28System.Object%29> porque ele não tem que converter a `other` parâmetro para um <xref:System.Numerics.BigInteger> objeto.  
  
 Para determinar a relação entre os dois <xref:System.Numerics.BigInteger> objetos em vez de testar apenas para fins de igualdade, chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir compara a distância aproximada de vários estrelas de Terra com a distância do i Épsilon de terra para determinar se eles são iguais. O exemplo usa cada sobrecarga o <xref:System.Numerics.BigInteger.Equals%2A> método de teste de igualdade.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado.</param>
        <summary>Retorna um valor que indica se a instância atual e um objeto especificado têm o mesmo valor.</summary>
        <returns>
          <see langword="true" /> se o <paramref name="obj" /> argumento for um objeto <see cref="T:System.Numerics.BigInteger" /> e seu valor for igual ao valor da instância <see cref="T:System.Numerics.BigInteger" /> atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `obj` argumento não é um <xref:System.Numerics.BigInteger> de valor, o método retornará `false`. O método retorna `true` somente se `obj` é um <xref:System.Numerics.BigInteger> instância cujo valor é igual à instância atual.  
  
 Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> método.  
  
   
  
## Examples  
 O exemplo a seguir define paralelo <xref:System.Object> e <xref:System.Numerics.BigInteger> matrizes. Cada elemento de uma matriz tem o mesmo valor que o elemento correspondente da segunda matriz. Como a saída mostra o exemplo, a instância no <xref:System.Numerics.BigInteger> matriz é considerada igual à instância no <xref:System.Object> matriz somente se for o último um <xref:System.Numerics.BigInteger> e seus valores são iguais.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">O inteiro sem sinal de 64 bits para comparar.</param>
        <summary>Retorna um valor que indica se a instância atual e um inteiro não assinado de 64 bits têm o mesmo valor.</summary>
        <returns>
          <see langword="true" />Se a instância atual e o inteiro sem sinal de 64 bits têm o mesmo valor. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar a relação entre os dois objetos em vez de testar apenas para fins de igualdade, chame o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir compara a distância aproximada de vários estrelas de Terra com a distância do i Épsilon de terra para determinar se eles são iguais. O exemplo usa cada sobrecarga o <xref:System.Numerics.BigInteger.Equals%2A> método de teste de igualdade.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para o objeto <see cref="T:System.Numerics.BigInteger" /> atual.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Localiza o maior divisor comum de dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O maior divisor comum de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O máximo divisor comum é o maior número na qual as duas <xref:System.Numerics.BigInteger> valores podem ser divididos sem retornar um resto.  
  
 Se o `left` e `right` parâmetros são números diferentes de zero, o método sempre retorna pelo menos um valor de 1, porque todos os números podem ser divididos em 1. Se um parâmetro for zero, o método retorna o valor absoluto de parâmetro diferente de zero. Se os dois valores forem zero, o método retornará zero.  
  
> [!NOTE]
>  Calculando o máximo divisor comum de valores muito grandes de `left` e `right` pode ser uma operação demorada.  
  
 O valor retornado pelo <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método sempre é positivo, independentemente do sinal do `left` e `right` parâmetros.  
  
   
  
## Examples  
 O exemplo a seguir ilustra uma chamada para o <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> método e a exceção tratamento necessários para fornecer informações úteis sobre um <xref:System.ArgumentOutOfRangeException>. O resultado indica que o máximo divisor comum desses dois números é 1.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual é um número par.</summary>
        <value>
          <see langword="true" /> se o valor do objeto <see cref="T:System.Numerics.BigInteger" /> é um número par; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é um recurso de conveniência que indica se um <xref:System.Numerics.BigInteger> valor for divisível por dois. É equivalente a seguinte expressão:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Se o valor atual <xref:System.Numerics.BigInteger> objeto <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, a propriedade retornará `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor atual <see cref="T:System.Numerics.BigInteger" /> objeto é <see cref="P:System.Numerics.BigInteger.One" />.</summary>
        <value>
          <see langword="true" />Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto <see cref="P:System.Numerics.BigInteger.One" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade oferece um desempenho significativamente melhor que outros comparações com um, como `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor atual <see cref="T:System.Numerics.BigInteger" /> objeto seja uma potência de dois.</summary>
        <value>
          <see langword="true" />Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto seja uma potência de dois; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade determina se um <xref:System.Numerics.BigInteger> valor tem um único bit diferente de zero definido. Isso significa que ela retorna `true` se o valor atual <xref:System.Numerics.BigInteger> objeto é 1 (ou seja, 2<sup>0</sup>) ou qualquer maior potência de dois. Ele retorna `false` se o valor atual <xref:System.Numerics.BigInteger> objeto é 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o valor atual <see cref="T:System.Numerics.BigInteger" /> objeto é <see cref="P:System.Numerics.BigInteger.Zero" />.</summary>
        <value>
          <see langword="true" />Se o valor de <see cref="T:System.Numerics.BigInteger" /> objeto <see cref="P:System.Numerics.BigInteger.Zero" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade oferece um desempenho significativamente melhor que `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O número cujo logaritmo deve ser encontrado.</param>
        <summary>Retorna o logaritmo natural (de base <see langword="e" />) de um número especificado.</summary>
        <returns>O logaritmo natural (base <see langword="e" />) de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro for especificado como um número de base 10.  
  
 O precisa retorna o valor desse método depende do sinal de `value`, como mostra a tabela a seguir.  
  
|Logon de `value` parâmetro|Valor retornado|  
|-------------------------------|------------------|  
|Positivo|O logaritmo natural de `value`; ou seja, ln `value`, ou de log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativo|<xref:System.Double.NaN>.|  
  
 Para calcular o logaritmo de base 10 de um <xref:System.Numerics.BigInteger> valor, chame o <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular o logaritmo de um número em outra base, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> método.  
  
 Você pode encontrar a raiz quadrada de um número chamando o <xref:System.Numerics.BigInteger.Log%2A> método junto com o <xref:System.Math.Exp%2A?displayProperty=nameWithType> método. Observe que o resultado é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> se o resultado for maior do que <xref:System.Double.MaxValue?displayProperty=nameWithType>. O exemplo a seguir calcula a raiz quadrada de cada elemento em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Esse método corresponde do <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> método para os tipos numéricos primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log natural de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um número cujo logaritmo deve ser localizado.</param>
        <param name="baseValue">A base do logaritmo.</param>
        <summary>Retorna o logaritmo de um número especificado em uma base especificada.</summary>
        <returns>O logaritmo de base <paramref name="baseValue" /> de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` e `baseValue` parâmetros são especificados como base 10 números.  
  
 O precisa retorna o valor do método depende do sinal de `value` e de entrada e o valor de `baseValue`, como mostra a tabela a seguir.  
  
|Parâmetro `value`|Parâmetro `baseValue`|Valor retornado|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) - ou -(`baseValue` > 1)|logbaseValue (`value`)|  
|`value` < 0|(nenhum valor)|<xref:System.Double?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` < 0|<xref:System.Double?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double?displayProperty=nameWithType>|<xref:System.Double?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` = <xref:System.Double?displayProperty=nameWithType>|<xref:System.Double?displayProperty=nameWithType>|  
|(nenhum valor)|`baseValue` = 1|<xref:System.Double?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Para calcular o logaritmo de base 10 de um <xref:System.Numerics.BigInteger> valor, chame o <xref:System.Numerics.BigInteger.Log10%2A> método. Para calcular o logaritmo natural de um número, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> método.  
  
 Esse método corresponde do <xref:System.Math.Log%2A?displayProperty=nameWithType> método para os tipos numéricos primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um número cujo logaritmo deve ser localizado.</param>
        <summary>Retorna o logaritmo de base 10 de um número especificado.</summary>
        <returns>O logaritmo de base 10 de <paramref name="value" />, conforme mostrado na tabela na seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro for especificado como um número de base 10.  
  
 O precisa retorna o valor do método depende do sinal de `value`, como mostra a tabela a seguir.  
  
|Entrada do parâmetro de valor|Valor retornado|  
|-----------------------------|------------------|  
|Positivo|O log de base 10 de `value`; ou seja, log10`value`.|  
|Zero|<xref:System.Double?displayProperty=nameWithType>.|  
|Negativo|<xref:System.Double?displayProperty=nameWithType>.|  
  
 Para calcular o logaritmo natural de um <xref:System.Numerics.BigInteger> valor, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método. Para calcular o logaritmo de um número em outra base, chame o <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> método.  
  
 Esse método corresponde do <xref:System.Math.Log10%2A?displayProperty=nameWithType> método para os tipos numéricos primitivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O log de base 10 de <paramref name="value" /> está fora do intervalo do tipo de dados <see cref="T:System.Double" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna o maior dos dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O parâmetro <paramref name="left" /> ou <paramref name="right" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método corresponde do <xref:System.Math.Max%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Max%2A> método para selecionar o maior número em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna o menor dos dois <see cref="T:System.Numerics.BigInteger" /> valores.</summary>
        <returns>O <paramref name="left" /> ou <paramref name="right" /> parâmetro, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método corresponde do <xref:System.Math.Min%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Min%2A> método para selecionar o menor número em uma matriz de <xref:System.Numerics.BigInteger> valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número um negativo (-1).</summary>
        <value>Um inteiro cujo valor é negativo (-1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.MinusOne%2A> propriedade é usada para comparar um <xref:System.Numerics.BigInteger> valor -1 ou -1 para atribuir um <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O número a elevar para o <c>expoente</c> energia.</param>
        <param name="exponent">O expoente para gerar <c>valor</c> por.</param>
        <param name="modulus">O número pelo qual dividir <c>valor</c> gerado para o <c>expoente</c> energia.</param>
        <summary>Executa a divisão de módulo em um número elevado à potência de outro número.</summary>
        <returns>O resto após dividir o <paramref name="value" /><sup>exponente</sup> por <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ModPow%2A> método avalia a expressão a seguir:  
  
 (baseValue ^ expoente) Módulo mod  
  
 Para executar o expoente em <xref:System.Numerics.BigInteger> valores sem divisão do módulo, use o <xref:System.Numerics.BigInteger.Pow%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir fornece uma ilustração simple de chamar o <xref:System.Numerics.BigInteger.ModPow%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> é negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro número a multiplicar.</param>
        <param name="right">O segundo número a multiplicar.</param>
        <summary>Retorna o produto de dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O produto dos parâmetros <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Multiply%2A> método é implementado para os idiomas que não oferecem suporte a sobrecarga de operador. Seu comportamento é idêntico a multiplicação usando o operador de multiplicação. Além disso, o <xref:System.Numerics.BigInteger.Multiply%2A> método é um substituto úteis para o operador de multiplicação ao instanciar um <xref:System.Numerics.BigInteger> variável atribuindo a ele um produto que resulta da multiplicação, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Se necessário, esse método executa automaticamente a conversão implícita de outros tipos integrais <xref:System.Numerics.BigInteger> objetos. Isso é ilustrado no exemplo na próxima seção, onde o <xref:System.Numerics.BigInteger.Multiply%2A> método é passado duas <xref:System.Int64> valores.  
  
   
  
## Examples  
 O exemplo a seguir tenta executar multiplicação com dois inteiros longos. Porque o resultado excede o intervalo de um inteiro longo, um <xref:System.OverflowException> é acionada e o <xref:System.Numerics.BigInteger.Multiply%2A> método é chamado para manipular a multiplicação. Observe que c# requer que você use o `checked` palavra-chave (como neste exemplo) ou o `/checked+` a opção de compilador para verificar se uma exceção será lançada em um estouro numéricos.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser negado.</param>
        <summary>Nega uma especificado <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>O resultado da <paramref name="value" /> parâmetro multiplicado por um negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negação obtém o inverso aditivo de um número. O inverso aditivo de um número é um número que produz um valor de zero quando ela é adicionada ao número original.  
  
 O <xref:System.Numerics.BigInteger.Negate%2A> método é implementado para os idiomas que não dão suporte a operadores personalizados. Seu comportamento é idêntico ao usando o operador de negação unário de negação. Além disso, o <xref:System.Numerics.BigInteger.Negate%2A> método é um substituto úteis para o operador de negação ao instanciar um <xref:System.Numerics.BigInteger> variável, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir ilustra três maneiras para negar o valor de uma <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número um (1).</summary>
        <value>Um objeto cujo valor é um (1).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.One%2A> propriedade normalmente é usada para comparar um <xref:System.Numerics.BigInteger> valor como 1 ou atribuir 1 para uma <xref:System.Numerics.BigInteger> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser adicionado.</param>
        <param name="right">O segundo valor a ser adicionado.</param>
        <summary>Adiciona os valores dos dois objetos <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>A soma de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Addition%2A> método define a operação de adição para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Add%2A> em vez disso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa uma operação <see langword="And" /> bit a bit em dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da operação <see langword="And" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método define o bit a bit `And` operação para <xref:System.Numerics.BigInteger> valores. Bit a bit `And` operação define um se apenas de bit de resultado os bits correspondentes em `left` e `right` também são definidas, conforme mostrado na tabela a seguir.  
  
|Bit no`left`|Bit no`right`|Bit no resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> método executa bit a bit `And` operação em dois <xref:System.Numerics.BigInteger> valores como se estivesse em dois complemento representação com extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa uma operação <see langword="Or" /> bit a bit em dois valores <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resultado da operação <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método define o bit a bit `Or` operação para <xref:System.Numerics.BigInteger> valores. Bit a bit `Or` operação define um se apenas de bit de resultado de um ou ambos os bits correspondentes em `left` e `right` estiverem definidas, conforme mostrado na tabela a seguir.  
  
|Bit no`left`|Bit no`right`|Bit no resultado|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 O <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> método executa bit a bit `Or` operação em dois <xref:System.Numerics.BigInteger> valores como se estivesse em dois complemento representação com extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser diminuído.</param>
        <summary>Diminui um valor <see cref="T:System.Numerics.BigInteger" /> em 1.</summary>
        <returns>O valor do parâmetro <paramref name="value" /> diminuído em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Decrement%2A> método define a operação de decremento para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Subtract%2A> em vez disso. Por exemplo:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Porque <xref:System.Numerics.BigInteger> objetos são imutáveis, a <xref:System.Numerics.BigInteger.op_Decrement%2A> operador cria um novo <xref:System.Numerics.BigInteger> objeto cujo valor é um menor do que o <xref:System.Numerics.BigInteger> objeto representado pelo `value`. Isso significa que repetidas chamadas para <xref:System.Numerics.BigInteger.op_Decrement%2A> pode ser cara.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Divide um valor <see cref="T:System.Numerics.BigInteger" /> especificado por outro valor <see cref="T:System.Numerics.BigInteger" /> especificado usando a divisão de inteiros.</summary>
        <returns>O resultado integral da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Division%2A> método define a operação de divisão para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Idiomas que dão suporte a operadores personalizados e sobrecarga de operador podem chamar o <xref:System.Numerics.BigInteger.Divide%2A> método em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 O exemplo a seguir cria uma matriz de <xref:System.Numerics.BigInteger> valores. Ele usa, em seguida, cada elemento como o quociente em uma operação de divisão que usa o <xref:System.Numerics.BigInteger.Divide%2A> método, o operador de divisão (/) e o <xref:System.Numerics.BigInteger.DivRem%2A> método.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor inteiro longo e um <see cref="T:System.Numerics.BigInteger" /> valor são iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="left" /> e <paramref name="right" /> parâmetros têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor e um valor inteiro longo são iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="left" /> e <paramref name="right" /> parâmetros têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se os valores de dois <see cref="T:System.Numerics.BigInteger" /> objetos são iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="left" /> e <paramref name="right" /> parâmetros têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método define a operação do operador de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor e um valor inteiro longo não assinado são iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="left" /> e <paramref name="right" /> parâmetros têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor inteiro longo não assinado e uma <see cref="T:System.Numerics.BigInteger" /> valor são iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="left" /> e <paramref name="right" /> parâmetros têm o mesmo valor; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> método define a operação de comparação de igualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> em vez disso, o método de instância.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor.</param>
        <param name="right">O segundo valor.</param>
        <summary>Executa um exclusivo bit a bit <see langword="Or" /> (<see langword="XOr" />) operação em dois <see cref="T:System.Numerics.BigInteger" /> valores.</summary>
        <returns>O resultado da operação <see langword="Or" /> bit a bit.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O resultado de um bit a bit exclusivo `Or` operação `true` se os valores dos dois bits forem diferentes; caso contrário, é `false`. A tabela a seguir ilustra o exclusivo `Or` operação.  
  
|Bit x`left`|Bit x`right`|Valor retornado|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 O <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 O <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> método executa bit a bit exclusiva `Or` operação em dois <xref:System.Numerics.BigInteger> valores como se estivesse em dois complemento representação com extensão de entrada virtual.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Decimal" /> em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado antes da conversão.

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Decimal> para <xref:System.Numerics.BigInteger> pode envolver truncar qualquer parte fracionária do `value`, os compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Decimal> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que qualquer fracionários faz parte de uma <xref:System.Decimal> valor é truncado durante a conversão.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um valor <see cref="T:System.Double" /> para um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado antes da conversão.

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Double> para <xref:System.Numerics.BigInteger> pode envolver truncar qualquer parte fracionária do `value`, os compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Double> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que qualquer fracionários faz parte de uma <xref:System.Double> valor é truncado durante a conversão.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é <see cref="F:System.Double.NaN" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Double.PositiveInfinity" />.
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Byte" />.</param>
        <summary>Define uma conversão explícita de uma <see cref="T:System.Numerics.BigInteger" /> objeto como um valor de byte não atribuído.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CByte` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Byte> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Byte> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Byte> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Byte> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.Byte.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Decimal" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor <see cref="T:System.Decimal" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CDec` no Visual Basic) é usado.   

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Decimal> tipo de dados. 

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Decimal> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Decimal> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.Decimal.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Double" />.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CDbl` no Visual Basic) é usado.   

 Porque o <xref:System.Numerics.BigInteger> valor pode estar fora do intervalo da <xref:System.Double> tipo de dados, esta operação é uma conversão de restrição. Se a conversão falhar, ele não gerará um <xref:System.OverflowException>. Em vez disso, se o <xref:System.Numerics.BigInteger> valor é menor que <xref:System.Double.MinValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor é <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Se o <xref:System.Numerics.BigInteger> valor é maior que <xref:System.Double.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Double> valor é <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 A conversão de um <xref:System.Numerics.BigInteger> para um <xref:System.Double> pode envolver uma perda de precisão. Em alguns casos, a perda de precisão pode fazer com que a operação de conversão ou tenha êxito mesmo se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Double> tipo de dados. O exemplo a seguir fornece uma ilustração. Ele atribui o valor máximo de um <xref:System.Double> duas <xref:System.Numerics.BigInteger> variáveis, em incrementos de um <xref:System.Numerics.BigInteger> variável 9.999e291 e as duas variáveis de testes de igualdade. Conforme o esperado, a chamada para o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método mostra que elas são diferentes. No entanto, a conversão do maior <xref:System.Numerics.BigInteger> valor de volta para um <xref:System.Double> for bem-sucedida, embora o <xref:System.Numerics.BigInteger> agora excede o valor <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Double> valores.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a converter para um inteiro assinado de 16 bits.</param>
        <summary>Define uma conversão explícita de uma <see cref="T:System.Numerics.BigInteger" /> objeto como um valor inteiro com sinal de 16 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CShort` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int16> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Int16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int16> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int16> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.Int16.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro com sinal de 32 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> para um valor inteiro com sinal de 32 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CInt` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.   

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int32> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.Int16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int32> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int32> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.Int32.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro com sinal de 64 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> para um valor inteiro com sinal de 64 bits.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CLng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.  

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int64> tipo de dados. 

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Int64> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Int64> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.Int64.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a converter um valor de 8 bits assinado.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Numerics.BigInteger" /> objeto para um valor de 8 bits assinado.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="T:System.Int16" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CSByte` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.  

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.SByte> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.SByte> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.SByte> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.SByte> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.SByte.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.SByte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a converter um valor de ponto flutuante de precisão simples.</param>
        <summary>Define uma conversão explícita de um <see cref="T:System.Numerics.BigInteger" /> objeto para um valor de ponto flutuante de precisão simples.</summary>
        <returns>Um objeto que contém a representação mais próxima possível de <paramref name="value" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados ou uma perda de precisão. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CSng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Porque o <xref:System.Numerics.BigInteger> valor pode estar fora do intervalo da <xref:System.Single> tipo de dados, esta operação é uma conversão de restrição. Se a conversão falhar, ele não gerará um <xref:System.OverflowException>. Em vez disso, se o <xref:System.Numerics.BigInteger> valor é menor que <xref:System.Single.MinValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor é <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Se o <xref:System.Numerics.BigInteger> valor é maior que <xref:System.Single.MaxValue?displayProperty=nameWithType>, resultante <xref:System.Single> valor é <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 A conversão de um <xref:System.Numerics.BigInteger> para um <xref:System.Single> pode envolver uma perda de precisão. Em alguns casos, a perda de precisão pode fazer com que a operação de conversão ou tenha êxito mesmo se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.Single> tipo de dados. O exemplo a seguir fornece uma ilustração. Ele atribui o valor máximo de um <xref:System.Single> duas <xref:System.Numerics.BigInteger> variáveis, em incrementos de um <xref:System.Numerics.BigInteger> variável 9.999e291 e as duas variáveis de testes de igualdade. Conforme o esperado, a chamada para o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método mostra que elas são diferentes. No entanto, a conversão do maior <xref:System.Numerics.BigInteger> valor de volta para um <xref:System.Single> for bem-sucedida, embora o <xref:System.Numerics.BigInteger> agora excede o valor <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.Single> valores.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor para converter para um inteiro de 16 bits sem sinal.</param>
        <summary>Define uma conversão explícita de uma <see cref="T:System.Numerics.BigInteger" /> objeto como um valor inteiro de 16 bits sem sinal.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="T:System.Int32" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CUShort` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt16> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt16> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt16> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt16> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.UInt16.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor para converter para um inteiro de 32 bits sem sinal.</param>
        <summary>Define uma conversão explícita de uma <see cref="T:System.Numerics.BigInteger" /> objeto como um valor inteiro de 32 bits sem sinal.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="T:System.Int64" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CUInt` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt32> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt32> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt32> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt32> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.UInt32.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.UInt32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido em um inteiro sem sinal de 64 bits.</param>
        <summary>Define uma conversão explícita de um objeto <see cref="T:System.Numerics.BigInteger" /> em um valor inteiro sem sinal de 64 bits.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Compiladores de linguagem não realizar essa conversão automaticamente porque ele pode envolver a perda de dados. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` ou `CULng` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.    

 Como essa operação define uma conversão de restrição, ela pode lançar um <xref:System.OverflowException> em tempo de execução se o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt64> tipo de dados. Não há nenhuma perda de precisão na resultante <xref:System.UInt64> valor se a conversão for bem-sucedida.

## Examples
 O exemplo a seguir ilustra a conversão de <xref:System.Numerics.BigInteger> para <xref:System.UInt64> valores. Ele também lida com um <xref:System.OverflowException> que foi lançado porque o <xref:System.Numerics.BigInteger> valor está fora do intervalo da <xref:System.UInt64> tipo de dados.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é menor que <see cref="F:System.UInt64.MinValue" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é maior do que <see cref="F:System.UInt64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão explícita de um valor <see cref="T:System.Single" /> para um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado antes da conversão.
 
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> método definem os tipos para o qual ou do qual um <xref:System.Numerics.BigInteger> objeto pode ser convertido. Porque a conversão de <xref:System.Single> para <xref:System.Numerics.BigInteger> pode envolver truncar qualquer parte fracionária do `value`, os compiladores de linguagem não realizar essa conversão automaticamente. Em vez disso, eles executarem a conversão somente se um operador de conversão (em c#) ou uma função de conversão (como `CType` no Visual Basic) é usado. Caso contrário, eles exibem um erro do compilador.

 Para idiomas que não dão suporte a operadores personalizados, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 O exemplo a seguir converte os elementos individuais em uma matriz de <xref:System.Single> valores <xref:System.Numerics.BigInteger> objetos e, em seguida, exibe o resultado de cada conversão. Observe que qualquer fracionários faz parte de uma <xref:System.Single> valor é truncado durante a conversão.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O valor de <paramref name="value" /> é <see cref="F:System.Single.NaN" />.  
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Single.PositiveInfinity" />.
  
 -ou-  
  
 O valor de <paramref name="value" /> é <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro assinado de 64 bits é maior do que um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Idiomas que dão suporte a operadores personalizados podem chamar o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso, o método de instância. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> é maior que um valor inteiro com sinal de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é maior que outro <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é maior que um inteiro não assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é maior que um inteiro não assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThan%2A> método define a operação de maior que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro assinado de 64 bits é maior que ou igual a um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um valor de <see cref="T:System.Numerics.BigInteger" /> é maior ou igual a um valor inteiro com sinal de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é maior que ou igual a outro <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é maior que ou igual a um valor inteiro não assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro não assinado de 64 bits é maior que ou igual a um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja maior que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> método define a operação de maior que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um byte não atribuído a um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Qualquer parte fracionária do `value` parâmetro será truncado antes da conversão.

 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Byte> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro assinado de 16 bits para uma <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Int16> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro assinado de 32 bits para um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Int32> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro com sinal de 64 bits em um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.Int64> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro assinado de 8 bits para uma <see cref="T:System.Numerics.BigInteger" /> valor.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.SByte> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro não assinado de 16 bits em um <see cref="T:System.Numerics.BigInteger" /> valor.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.UInt16> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro não assinado de 32 bits em um <see cref="T:System.Numerics.BigInteger" /> valor.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.UInt32> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser convertido para um <see cref="T:System.Numerics.BigInteger" />.</param>
        <summary>Define uma conversão implícita de um inteiro não assinado de 64 bits em um <see cref="T:System.Numerics.BigInteger" /> valor.  
  
 Esta API não compatível com CLS. É a alternativa compatível com <see cref="T:System.Double" />.</summary>
        <returns>Um objeto que contém o valor do parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para idiomas que não dão suporte a operadores implícita, o método alternativo é <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 As sobrecargas do <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> método definem os tipos de qual ou para que um compilador pode converter automaticamente um <xref:System.Numerics.BigInteger> valor sem um operador de conversão explícita (em c#) ou uma chamada para uma função de conversão (no Visual Basic). Eles são widening conversões que não envolvem a perda de dados e não gerará uma <xref:System.OverflowException>. Essa sobrecarga permite que o compilador trate conversões de um <xref:System.UInt64> valor para um <xref:System.Numerics.BigInteger> valor, como mostra o exemplo a seguir.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser incrementado.</param>
        <summary>Incrementa um valor <see cref="T:System.Numerics.BigInteger" /> em 1.</summary>
        <returns>O valor do parâmetro <paramref name="value" /> incrementado em 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Increment%2A> método define a operação de incremento para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Alguns idiomas (como o Visual Basic) que não têm um operador de incremento ou não oferecem suporte a sobrecarga de operador podem chamar o <xref:System.Numerics.BigInteger.op_Increment%2A> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Porque <xref:System.Numerics.BigInteger> objetos são imutáveis, a <xref:System.Numerics.BigInteger.op_Increment%2A> operador cria um novo <xref:System.Numerics.BigInteger> objeto cujo valor é um mais do que o <xref:System.Numerics.BigInteger> objeto representado pelo `value`. Portanto, repetidas chamadas para <xref:System.Numerics.BigInteger.op_Increment%2A> pode ser cara.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro assinado de 64 bits e um <see cref="T:System.Numerics.BigInteger" /> valor não são iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> instância de método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo.  
  
-   Chamando o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> da instância de método e Revertendo seu valor.  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor e um inteiro assinado de 64 bits não são iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> método e a reversão de seu valor.  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se dois <see cref="T:System.Numerics.BigInteger" /> objetos têm valores diferentes.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> método, que indica a relação entre duas <xref:System.Numerics.BigInteger> objetos.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> método e a reversão de seu valor.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor e um inteiro não assinado de 64 bits não são iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo não assinado.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e a reversão de seu valor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro não assinado de 64 bits e um <see cref="T:System.Numerics.BigInteger" /> valor não são iguais.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> e <paramref name="right" /> não sejam iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Inequality%2A> método define a operação do operador de desigualdade para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Idiomas que dão suporte a operadores personalizados podem testar desigualdade usando uma das seguintes técnicas:  
  
-   Chamando o <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> método, que indica a relação entre um <xref:System.Numerics.BigInteger> e um valor inteiro longo não assinado.  
  
-   Chamar o <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> método e a reversão de seu valor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujos bits devem ser deslocados.</param>
        <param name="shift">O número de bits para deslocar <c>valor</c> à esquerda.</param>
        <summary>Desloca um valor <see cref="T:System.Numerics.BigInteger" /> um número especificado de bits para a esquerda.</summary>
        <returns>Um valor que foi sido deslocado para a esquerda pelo número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LeftShift%2A> método define a operação do operador left shift bit a bit para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Ao contrário a operação left shift bit a bit com primitivos de inteiro, o <xref:System.Numerics.BigInteger.op_LeftShift%2A> método preserva o sinal do original <xref:System.Numerics.BigInteger> valor.  
  
 Idiomas que dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à esquerda multiplicando `value` por `BigInteger.Pow(2, shift)`. O exemplo a seguir mostra os resultados são idênticos para os resultados do uso desse operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro com sinal de 64 bits é menor que um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor do que um inteiro assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor que outro <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> em vez disso. Alguns idiomas também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor do que um inteiro não assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro não assinado de 64 bits é menor que a <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor que <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThan%2A> método define a operação pelo menor que o operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro assinado de 64 bits é menor ou igual a um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Se `left` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor ou igual a um inteiro assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Se `right` é um <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, ou <xref:System.UInt32> valor, ele é convertido implicitamente em um <xref:System.Int64> valor quando a operação é executada.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor ou igual a outro <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Compare%2A> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um <see cref="T:System.Numerics.BigInteger" /> valor é menor ou igual a um inteiro não assinado de 64 bits.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser comparado.</param>
        <param name="right">O segundo valor a ser comparado.</param>
        <summary>Retorna um valor que indica se um inteiro não assinado de 64 bits é menor ou igual a um <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="left" /> seja menor ou igual a <paramref name="right" />; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> método define a operação de menor que ou igual ao operador para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> em vez disso. Eles também podem chamar o <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> método diretamente, como o exemplo a seguir mostra.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Retorna o resto que resulta da divisão com dois valores especificados <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O resto que resulta da divisão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Modulus%2A> método define a operação do operador de módulo para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> em vez disso.  
  
 O sinal do valor retornado pela operação de módulo depende do sinal de `dividend`: se `dividend` for positivo, a operação de módulo retorna um resultado positivo; se for negativo, a operação de módulo retornará um resultado negativo. O comportamento da operação de módulo com <xref:System.Numerics.BigInteger> valores é idêntica à operação de módulo com outros tipos integrais.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro valor a ser multiplicado.</param>
        <param name="right">O segundo valor a ser multiplicado.</param>
        <summary>Multiplica dois valores <see cref="T:System.Numerics.BigInteger" /> especificados.</summary>
        <returns>O produto de <paramref name="left" /> e <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Multiply%2A> método define a operação do operador de multiplicação para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro.</param>
        <summary>Retorna o complemento bit a bit de um valor <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>O complemento bit a bit de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método define a operação de bit a bit de um operador de complemento para <xref:System.Numerics.BigInteger> valores. Bit a bit de um operador de complemento inverte cada bit em um valor numérico. Ou seja, o bits no `value` que são 0 são definidos como 1 no resultado e os bits forem 1 são definidos como 0 no resultado. O <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método permite que o código como o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Idiomas que dão suporte a operadores personalizados podem ser capazes de chamar o <xref:System.Numerics.BigInteger.op_OnesComplement%2A> método diretamente para executar um bit a bit de um complemento de operação. Por exemplo:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor cujos bits devem ser deslocados.</param>
        <param name="shift">O número de bits para deslocar <c>valor</c> à direita.</param>
        <summary>Desloca um valor <see cref="T:System.Numerics.BigInteger" /> um número especificado de bits para a direita.</summary>
        <returns>Um valor que foi sido deslocado para a direita pelo número especificado de bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_RightShift%2A> método define a operação do operador right shift bit a bit para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Idiomas que não dão suporte a operadores personalizados podem executar uma operação bit a bit de deslocamento à direita, dividindo `value` por `BigInteger.Pow(2, shift)` e subtraindo 1 vezes `shift` para valores negativos. O exemplo a seguir mostra os resultados são idênticos para os resultados do uso desse operador.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Se `shift` é maior que ou igual ao número de bits em um positivo <xref:System.Numerics.BigInteger> valor, o resultado da operação right shift é <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Se `shift` é maior que o número de bits em um negativo <xref:System.Numerics.BigInteger> valor, o resultado da operação right shift é <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O valor do qual um valor será subtraído (o minuendo).</param>
        <param name="right">O valor a ser subtraído (o subtraendo).</param>
        <summary>Subtrai um <see cref="T:System.Numerics.BigInteger" /> valor de outro <see cref="T:System.Numerics.BigInteger" /> valor.</summary>
        <returns>O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_Subtraction%2A> método define a operação do operador de subtração para <xref:System.Numerics.BigInteger> valores. Ele permite que o código seja o seguinte:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> em vez disso.  
  
 O método equivalente para esse operador é <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser negado.</param>
        <summary>Nega um valor BigInteger especificado.</summary>
        <returns>O resultado da <paramref name="value" /> parâmetro multiplicado por um negativo (-1).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> método define a operação de operador unário de negação (ou o operador aditivo inverso) para <xref:System.Numerics.BigInteger> valores. A operação produz um valor que resulta em 0 (zero) quando ele é adicionado ao número original. Linguagens que não dão suporte a operadores personalizados podem chamar o método <xref:System.Numerics.BigInteger.Negate%2A> em vez disso.  
  
 O método equivalente para esse operador é<xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 O exemplo a seguir ilustra três maneiras diferentes para negar o valor de uma <xref:System.Numerics.BigInteger> objeto.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Um valor inteiro.</param>
        <summary>Retorna o valor da <see cref="T:System.Numerics.BigInteger" /> operando. (O sinal do operando é inalterado.)</summary>
        <returns>O valor de <paramref name="value" /> operando.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> método define a operação do operador unário positivo para <xref:System.Numerics.BigInteger> valores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém o número a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres de um número no <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser a representação de cadeia de caracteres de um número no formato a seguir.  
  
 [*ws*] [*sinal*]*dígitos*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional. Os caracteres de sinal válido são determinados pelas propriedades <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> da cultura atual.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9. Todos os zeros à esquerda são ignorados.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada pelo `value` parâmetro é interpretado usando o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> estilo. Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.  
  
 O parâmetro `value` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> que é inicializado para a cultura do sistema atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Para analisar uma cadeia de caracteres usando as informações de formatação de uma cultura específica, use o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> método.  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método viagem a representação de cadeia de caracteres de um <xref:System.Numerics.BigInteger> valor foi saída o <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.Parse%28System.String%29> método para instanciar dois <xref:System.Numerics.BigInteger> objetos. Ele multiplica cada objeto por outro número e, em seguida, chama o <xref:System.Numerics.BigInteger.Compare%2A> método para determinar a relação entre os dois valores.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está no formato correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que especifica o formato permitido de <c>valor</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um estilo especificado em seu <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `style` parâmetro define os elementos de estilo (como o espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no `value` parâmetro para o êxito da operação de análise. `styles`deve ser uma combinação de sinalizadores de bit do <xref:System.Globalization.NumberStyles> enumeração. O `style` parâmetro faz com que esse método de sobrecarga útil quando `value` contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por `value` é conhecido apenas em tempo de execução, ou quando você deseja impedir que o espaço em branco ou um sinal de símbolo em `value`.  
  
 Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.* fractional_digits*] [E [*sinal*]*exponential_digits*] [*ws*]  
  
 Caso `style` inclua <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>, o parâmetro `value` pode conter os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início de `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador e podem aparecer no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pelas propriedades <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> da cultura atual. O símbolo de moeda da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Uma sequência de dígitos de 0 a 9. Para *fractional_digits*, somente os dígitos 0 é válido.|  
|*,*|Um símbolo de separador do grupo específico da cultura. Separador de grupo da cultura atual pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Somente os dígitos 0 podem ser exibido como um dígito de fração para a operação de análise ter êxito; Se *fractional_digits* inclui qualquer dígito, um <xref:System.FormatException> é gerada.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valor `NumberStyles`|Elementos permitidos em `value` além de dígitos|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Decimal de ponto (.) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O "e" ou o caractere "E", que indica a notação exponencial, juntamente com *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador do grupo (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final de `value`, *sinal* no início de `value`e o ponto decimal (*.*) símbolo. O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, separador de grupo (*,*) e o ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método viagem a representação de cadeia de caracteres de um <xref:System.Numerics.BigInteger> valor foi saída o <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Ao contrário de outros <xref:System.Globalization.NumberStyles> valores, que permitem, mas não exigem a presença de elementos de estilo específico `value`, o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> valor de estilo significa que os caracteres individuais nos `value` sempre são interpretados como caracteres hexadecimais. Os caracteres hexadecimais válidos são 0-9, A-F e a-f. Os únicos outros sinalizadores que podem ser combinados com o parâmetro `style` são <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (A enumeração de <xref:System.Globalization.NumberStyles> inclui um estilo de número composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal de <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor de zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 O parâmetro `value` é analisado usando-se as informações de formatação em um objeto <xref:System.Globalization.NumberFormatInfo> que é inicializado para a cultura do sistema atual. Para especificar a cultura cujas informações de formatação são usadas para a operação de análise, chame o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> sobrecarga.  
  
   
  
## Examples  
 O exemplo a seguir ilustra chamadas para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método com vários valores possíveis para a `style` parâmetro. Ele ilustra como uma cadeia de caracteres como um valor hexadecimal de interpretar e como não permitir espaços e assinar os símbolos.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é compatível com o padrão de entrada especificado por <see cref="T:System.Globalization.NumberStyles" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>valor</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número em um formato específico da cultura especificado em seu equivalente de <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro deve ser a representação de cadeia de caracteres de um número no seguinte formato:  
  
 [*ws*] [*sinal*]*dígitos*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional. Caracteres de entrada válida são determinados pelo <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> propriedades do <xref:System.Globalization.NumberFormatInfo> objeto que é retornado pelo `provider` do objeto <xref:System.IFormatProvider.GetFormat%2A> método.|  
|*digits*|Uma sequência de dígitos que varia de 0 a 9. Todos os zeros à esquerda são ignorados.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada pelo `value` parâmetro é interpretado usando o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> estilo. Ele não pode conter nenhum separador de grupo ou decimal, e não pode ter uma parte decimal.  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método viagem a representação de cadeia de caracteres de um <xref:System.Numerics.BigInteger> valor foi saída o <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 O `provider` parâmetro é um <xref:System.IFormatProvider> implementação cujo <xref:System.IFormatProvider.GetFormat%2A> método retorna um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura. Quando o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e o transmite um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> , em seguida, o método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações sobre o formato da `value` parâmetro. Existem três maneiras de usar o parâmetro `provider` para fornecer informações de formatação personalizadas para a operação de análise:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Se `provider` é `null`, a formatação de `value` é interpretado com base no <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual.  
  
   
  
## Examples  
 Os exemplos a seguir mostram dois modos para definir o til (~) como um sinal negativo para formatação <xref:System.Numerics.BigInteger> valores. Observe que para exibir o <xref:System.Numerics.BigInteger> valores no mesmo formato que as cadeias de caracteres originais, seu código deve chamar o <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método e passá-lo a <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 O primeiro exemplo define uma classe que implementa <xref:System.IFormatProvider> e usa o <xref:System.IFormatProvider.GetFormat%2A> método para retornar o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Um <xref:System.Numerics.BigInteger> objeto pode ser instanciado com o código a seguir:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 O segundo exemplo é mais simples. Ele passa a <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação para o `provider` parâmetro.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não está no formato correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Uma cadeia de caracteres que contém um número a ser convertido.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que especifica o formato permitido de <c>valor</c>.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>valor</c>.</param>
        <summary>Converte a representação de cadeia de caracteres de um número com um estilo especificado e um formato específico à cultura para seu <see cref="T:System.Numerics.BigInteger" /> equivalente.</summary>
        <returns>Um valor equivalente ao número especificado no parâmetro <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `style` parâmetro define os elementos de estilo (como o espaço em branco, o símbolo de sinal positivo ou negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal) que são permitidos no `value` parâmetro para o êxito da operação de análise. `styles`deve ser uma combinação de sinalizadores de bit do <xref:System.Globalization.NumberStyles> enumeração. O `style` parâmetro faz com que esse método de sobrecarga útil quando `value` contém a representação de cadeia de caracteres de um valor hexadecimal, quando o sistema de número (decimal ou hexadecimal) representado por `value` é conhecido apenas em tempo de execução, ou quando você deseja impedir que o espaço em branco ou um sinal de símbolo em `value`.  
  
 Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*] [*$*] [*sinal*] [*dígitos*,]*dígitos*[*. fractional_digits*] [E [*sinal*]*exponential_digits*] [*ws*]  
  
 Se `style` inclui <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>, o `value` parâmetro pode incluir os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início de `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador e podem aparecer no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. Sua posição na cadeia de caracteres é definida pelo <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> propriedades de cultura indicado pelo `provider` parâmetro. O símbolo de moeda da cultura atual pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Uma sequência de dígitos de 0 a 9. Para *fractional_digits*, somente os dígitos 0 é válido.|  
|*,*|Um símbolo de separador do grupo específico da cultura. O símbolo de separador de grupo da cultura especificada por `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo de ponto decimal da cultura designado pelo `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador. Somente os dígitos 0 podem ser exibido como um dígito de fração para a operação de análise ter êxito; Se *fractional_digits* inclui qualquer dígito, um <xref:System.FormatException> é gerada.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
 Uma cadeia de caracteres apenas com dígitos (que corresponde ao estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valor NumberStyles|Elementos permitidos no valor além de dígitos|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|O *dígitos* apenas do elemento.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Decimal de ponto (.) e *dígitos fracionários* elementos.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O caractere "e" ou "E", que indica a notação exponencial. juntamente com *exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento no final da `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O elemento separador do grupo (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|O elemento de moeda ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final de `value`, *sinal* no início de `value`e o símbolo de ponto decimal (.). O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O `ws`, `sign`, elementos de ponto decimal (.) e o separador de grupo (,).|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.Parse%2A> método viagem a representação de cadeia de caracteres de um <xref:System.Numerics.BigInteger> valor foi saída o <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.Parse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Ao contrário de outros <xref:System.Globalization.NumberStyles> valores, que permitem, mas não exigem a presença de elementos de estilo específico `value`, o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> valor de estilo significa que os caracteres individuais nos `value` sempre são interpretados como caracteres hexadecimais. Os caracteres hexadecimais válidos são 0-9, A-F e a-f. Os únicos outros sinalizadores que podem ser combinados com o parâmetro `style` são <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (A enumeração de <xref:System.Globalization.NumberStyles> inclui um estilo de número composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal de <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> método interpreta `value` como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor de zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato de `value`. Normalmente, `provider` pode ser qualquer um dos seguintes:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que representa a cultura que fornece informações de formatação numéricas. Seu <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação numéricas.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider> e usa o <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> método para instanciar e retornar o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação.  
  
 Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
   
  
## Examples  
 O exemplo a seguir faz várias chamadas para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método usando várias combinações de valores para o `style` e `provider` parâmetros.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Um número de chamadas individuais para o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método passar uma instância das seguintes `BigIntegerFormatProvider` classe, que define um til (~) como o sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> não é compatível com o padrão de entrada especificado por <paramref name="style" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O número a elevar para o <c>expoente</c> energia.</param>
        <param name="exponent">O expoente para gerar <c>valor</c> por.</param>
        <summary>Gera um valor <see cref="T:System.Numerics.BigInteger" /> à potência de um valor especificado.</summary>
        <returns>O resultado da elevação <paramref name="value" /> para a potência <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Pow%2A> método retornará 1 se o valor do parâmetro expoente é 0, ou se os valores de ambos os `value` e `exponent` parâmetros são 0. Se `exponent` é 1, o <xref:System.Numerics.BigInteger.Pow%2A> método retornará `value`. Se `value` for negativo, o método retornará um resultado negativo.  
  
 Esse método corresponde do <xref:System.Math.Pow%2A?displayProperty=nameWithType> método para tipos numéricos primitivos.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de exponenciação um <xref:System.Numerics.BigInteger> valor e um expoente cujo valor varia de 0 a 10.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor do parâmetro <paramref name="exponent" /> é negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">O valor a ser dividido.</param>
        <param name="divisor">O valor pelo qual dividir.</param>
        <summary>Executa a divisão do inteiro em dois valores <see cref="T:System.Numerics.BigInteger" /> e retorna o restante.</summary>
        <returns>O resto após dividir <paramref name="dividend" /> por <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sinal do resto é o sinal do `dividend` parâmetro.  
  
 O <xref:System.Numerics.BigInteger.Remainder%2A> método é implementado para os idiomas que não dão suporte a operadores personalizados. Seu comportamento é idêntico a divisão usando o operador de módulo.  
  
 Se necessário, o método executa automaticamente a conversão implícita de outros tipos integrais <xref:System.Numerics.BigInteger> objetos antes de executar a operação de módulo.  
  
   
  
## Examples  
 O exemplo a seguir compara o restante do <xref:System.Numerics.BigInteger.DivRem%2A> método com o restante retornado pelo <xref:System.Numerics.BigInteger.Remainder%2A> método para estabelecer os dois métodos calculam restante idêntico.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> é 0 (zero).</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um número que indica o sinal (negativo, positivo ou zero) do objeto <see cref="T:System.Numerics.BigInteger" /> atual.</summary>
        <value>Um número que indica o sinal do objeto <see cref="T:System.Numerics.BigInteger" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Número  
  
 </term><description>Descrição  
  
 </description></listheader><item><term> -1  
  
 </term><description>O valor do objeto é negativo.  
  
 </description></item><item><term> 0  
  
 </term><description>O valor do objeto é 0 (zero).  
  
 </description></item><item><term> 1  
  
 </term><description>O valor do objeto é positivo.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.Sign%2A> propriedade é equivalente a <xref:System.Math.Sign%2A?displayProperty=nameWithType> método para os tipos numéricos primitivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">O valor do qual um valor será subtraído (o minuendo).</param>
        <param name="right">O valor a ser subtraído (o subtraendo).</param>
        <summary>Subtrai um valor <see cref="T:System.Numerics.BigInteger" /> de outro e retorna o resultado.</summary>
        <returns>O resultado da subtração de <paramref name="right" /> de <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Idiomas que dão suporte a operadores personalizados podem usar o <xref:System.Numerics.BigInteger.Subtract%2A> método para executar usando subtração <xref:System.Numerics.BigInteger> valores.  
  
 O <xref:System.Numerics.BigInteger.Subtract%2A> método é um substituto úteis para o operador de subtração ao instanciar um <xref:System.Numerics.BigInteger> variável, atribuindo a diferença que resulta da subtração, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte um valor de <see cref="T:System.Numerics.BigInteger" /> em uma matriz de bytes.</summary>
        <returns>O valor do objeto <see cref="T:System.Numerics.BigInteger" /> atual convertido em uma matriz de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os bytes individuais na matriz retornada por este método aparecem na ordem little endian. Ou seja, os bytes de ordem inferior do valor precedem os bytes de ordem superior. O primeiro byte da matriz reflete os primeiros oito bits do <xref:System.Numerics.BigInteger> valor, o segundo byte reflete o próximos oito bits e assim por diante. Por exemplo, o valor de 1024 ou 0x0400, são armazenados como a seguinte matriz de dois bytes:  
  
|Elemento|Valor de byte|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Valores negativos são gravados para a matriz usando a representação de complemento de dois nos possíveis de forma mais compacto. Por exemplo, -1 é representado como um único byte cujo valor é `0xFF` em vez de como uma matriz com vários elementos, como `0xFF`, `0xFF` ou `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Porque do complemento de dois representação sempre interpreta o bit de ordem mais alta do que o último byte na matriz (bytes na posição <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) como o bit de sinal, o método retorna uma matriz de bytes com um elemento adicional cujo valor é zero para resolver a ambiguidade valores positivos caso contrário, podem ser interpretados como tendo seus bits de entrada definido. Por exemplo, o valor 120 ou `0x78` é representado como uma matriz de byte único: `0x78`. No entanto, 128, ou `0x80`, é representado como uma matriz de dois bytes: `0x80`, `0x00`.  
  
 Você pode viagem um <xref:System.Numerics.BigInteger> valor armazenando-o em uma matriz de bytes e, em seguida, restaurá-la usando o <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> construtor.  
  
> [!CAUTION]
>  Se seu código modifica o valor de bytes individuais na matriz retornada por este método antes de ele restaura o valor, você deve garantir que você não altere acidentalmente o bit de sinal. Por exemplo, se suas modificações aumentam um valor positivo para que os bits de ordem mais alta no último elemento da matriz de bytes torna-se definido, que você pode adicionar um novo cujo valor é zero para o final da matriz de byte.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como alguns <xref:System.Numerics.BigInteger> os valores são representados em matrizes de bytes.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual na representação da cadeia de caracteres equivalente.</summary>
        <returns>Uma representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString> formatos do método um <xref:System.Numerics.BigInteger> valor no "R" ou viagem, formato da cultura atual. Se você quiser especificar um formato diferente ou a cultura, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 A representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor inclui um sinal negativo se o valor for negativo e uma sequência de dígitos, variando de 0 a 9 sem zeros à esquerda. O sinal negativo é definido pelo <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir exibe um <xref:System.Numerics.BigInteger> valor usando o padrão <xref:System.Numerics.BigInteger.ToString> método. Ele também exibe as representações de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor resultante do uso de alguns especificadores de formato padrão. Os exemplos são exibidos usando-se as convenções de formatação da cultura en-US.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico do atual <see cref="T:System.Numerics.BigInteger" /> objeto em sua representação de cadeia de caracteres equivalente usando as informações de formatação específica da cultura especificadas.</summary>
        <returns>A representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual no formato especificado pelo parâmetro <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> formatos do método um <xref:System.Numerics.BigInteger> valor em "R", ou viagem, formatar usando o <xref:System.Globalization.NumberFormatInfo> objeto de uma cultura específica. Se você quiser especificar um formato diferente ou a cultura atual, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método. Se `provider` é `null`, o <xref:System.Numerics.BigInteger> valor é formatado usando o <xref:System.Globalization.NumberFormatInfo> objeto da cultura atual. A única propriedade do <xref:System.Globalization.NumberFormatInfo> que controla a representação de cadeia de caracteres do objeto de <xref:System.Numerics.BigInteger> valor usando o especificador de formato geral é <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, que define o caractere que representa o sinal negativo.  
  
 O parâmetro `provider` pode ser um dos seguintes:  
  
-   Um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação.  
  
-   O objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
   
  
## Examples  
 O exemplo a seguir cria um personalizado <xref:System.Globalization.NumberFormatInfo> objeto que define o til (~) como um sinal negativo. O <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> método usa personalizado <xref:System.Globalization.NumberFormatInfo> objeto para exibir um negativo <xref:System.Numerics.BigInteger> valor.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</param>
        <summary>Converte o valor numérico do objeto <see cref="T:System.Numerics.BigInteger" /> atual para sua representação de cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação de cadeia de caracteres do valor <see cref="T:System.Numerics.BigInteger" /> atual no formato especificado pelo parâmetro <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.String%29> formatos do método um <xref:System.Numerics.BigInteger> valor em um formato especificado usando um <xref:System.Globalization.NumberFormatInfo> objeto que representa as convenções da cultura atual. Se você quiser usar o "R", ou uma viagem, formatar ou especificar uma cultura diferente, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 O `format` parâmetro pode ser qualquer [cadeia de caracteres numérica padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), ou qualquer combinação de [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou `null`, o valor de retorno do atual <xref:System.Numerics.BigInteger> objeto é formatado com o especificador de formato de ida e volta ("R"). Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre o suporte para a formatação do .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O formato da cadeia de caracteres retornada é determinado pelo objeto <xref:System.Globalization.NumberFormatInfo> para a cultura atual. Dependendo do parâmetro `format`, esse objeto controla símbolos como o sinal negativo, o separador do grupo e o símbolo da vírgula decimal na cadeia de caracteres de saída. Para fornecer informações de formatação para culturas diferentes a cultura atual, chame o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> sobrecarga.  
  
   
  
## Examples  
 O exemplo a seguir inicializa um <xref:System.Numerics.BigInteger> valor e o exibe por meio de cada cadeia de caracteres de formato padrão e algumas cadeias de caracteres de formato personalizado.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> não é uma cadeia de caracteres de formato válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres padrão ou de formato numérico personalizado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor numérico do atual <see cref="T:System.Numerics.BigInteger" /> objeto em sua representação de cadeia de caracteres equivalente usando o formato especificado e as informações de formato específicos de cultura.</summary>
        <returns>A representação de cadeia de caracteres do atual <see cref="T:System.Numerics.BigInteger" /> valor conforme especificado pelo <paramref name="format" /> e <paramref name="provider" /> parâmetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> formatos do método um <xref:System.Numerics.BigInteger> valor em um formato especificado usando o <xref:System.Globalization.NumberFormatInfo> objeto de uma cultura específica. Se você quiser usar o formato de ida e volta ou configurações de cultura padrão, use as outras sobrecargas do <xref:System.Numerics.BigInteger.ToString%2A> método, da seguinte maneira:  
  
|Para usar o formato|Para a cultura|Use a sobrecarga|  
|-------------------|-----------------|----------------------|  
|Formato de round-trip ("R")|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString>|  
|Formato de round-trip ("R")|Uma cultura específica|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Um formato específico|Cultura do padrão (atual)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 O `format` parâmetro pode ser qualquer [cadeia de caracteres numérica padrão](~/docs/standard/base-types/standard-numeric-format-strings.md), ou qualquer combinação de [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Se `format` é igual a <xref:System.String.Empty?displayProperty=nameWithType> ou `null`, o valor de retorno do atual <xref:System.Numerics.BigInteger> objeto é formatado com o especificador de formato de ida e volta ("R"). Caso `format` tenha qualquer outro valor, o método lança um <xref:System.FormatException>.  
  
 O .NET Framework fornece extenso suporte à formatação, que é descrito com mais detalhes nos seguintes tópicos de formatação:  
  
-   Para obter mais informações sobre especificadores de formato numérico, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter mais informações sobre o suporte para a formatação do .NET Framework, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato da cadeia de caracteres retornada por esse método. Quando o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método é invocado, ele chama o `provider` do parâmetro <xref:System.IFormatProvider.GetFormat%2A> método e o transmite um <xref:System.Type> objeto que representa o <xref:System.Globalization.NumberFormatInfo> tipo. O <xref:System.IFormatProvider.GetFormat%2A> , em seguida, o método retorna o <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação de `value` parâmetro, como o símbolo de sinal negativo, o símbolo de separador de grupo ou o símbolo de ponto decimal. Há três maneiras de usar o `provider` parâmetro para fornecer informações de formatação para o <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> método:  
  
-   É possível passar um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   É possível passar o objeto real <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   É possível passar um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Caso `provider` seja `null`, a formatação da cadeia de caracteres retornada baseia-se no objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir inicializa um <xref:System.Numerics.BigInteger> valor e o exibe no console usando uma cadeia de caracteres de formato padrão e uma <xref:System.Globalization.NumberFormatInfo> objeto que define o til (~) como um sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> não é uma cadeia de caracteres de formato válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">A representação de cadeia de caracteres de um número.</param>
        <param name="result">Quando este método retorna, contém o <see cref="T:System.Numerics.BigInteger" /> equivalente ao número que está contido no <c>valor</c>, ou zero (0) se a conversão falhar. A conversão falhará se o <c>valor</c> parâmetro é <see langword="null" /> ou não está no formato correto. Este parâmetro é passado não inicializado.</param>
        <summary>Tenta converter a representação de cadeia de caracteres de seu equivalente de <see cref="T:System.Numerics.BigInteger" /> e retorna um valor que indica se a conversão foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> caso <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método é como o <xref:System.Numerics.BigInteger.Parse%28System.String%29> método, exceto que ele não gerará uma exceção se a conversão falhar. Esse método elimina a necessidade de usar a manipulação de exceção para testar um <xref:System.FormatException> se `value` é inválido e não pode ser analisado com êxito.  
  
 O parâmetro `value` deve ser a representação da cadeia de caracteres de um número decimal na seguinte forma:  
  
 [*ws*] [*sinal*]*dígitos*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional.|  
|*logon*|Um sinal opcional. Os caracteres de sinal válido são determinados pelas propriedades <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> e <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> da cultura atual.|  
|*digits*|Uma sequência de dígitos decimais que varia de 0 a 9.|  
  
> [!NOTE]
>  A cadeia de caracteres especificada o `value` parâmetro não pode conter qualquer separadores de grupo ou o separador decimal e não pode ter uma parte decimal.  
  
 O parâmetro `value` é interpretado usando-se o estilo <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Além dos dígitos decimais, apenas os espaço à esquerda e à direita com um sinal à esquerda são permitidos. Para definir explicitamente os elementos de estilo com as informações de formatação específica da cultura que podem estar presentes em `value`, chame o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método.  
  
 O `value` parâmetro é analisado usando as informações de formatação em um <xref:System.Globalization.NumberFormatInfo> objeto para a cultura atual. Para obter mais informações, consulte <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Essa sobrecarga interpreta todos os dígitos de `value` parâmetro como dígitos decimais. Para analisar a representação de cadeia de caracteres de um número hexadecimal, chame o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> sobrecarga.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> método para instanciar dois <xref:System.Numerics.BigInteger> objetos. Se as conversões tiver êxito, ele multiplica cada objeto por outro número e, em seguida, chama o <xref:System.Numerics.BigInteger.Compare%2A> método para determinar a relação entre os dois objetos.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">A representação de cadeia de caracteres de um número. A cadeia de caracteres é interpretada usando o estilo especificado por <c>estilo</c>.</param>
        <param name="style">Uma combinação bit a bit dos valores de enumeração que indica os elementos de estilo que podem estar presentes em <c>valor</c>. Um valor típico a ser especificado é <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Um objeto que fornece informações de formatação específica da cultura sobre <c>valor</c>.</param>
        <param name="result">Quando este método retorna, contém o <see cref="T:System.Numerics.BigInteger" /> equivalente ao número que está contido no <c>valor</c>, ou <see cref="P:System.Numerics.BigInteger.Zero" /> se a conversão falhou. A conversão falhará se o <c>valor</c> parâmetro é <see langword="null" /> ou não está em um formato que seja compatível com <c>estilo</c>. Este parâmetro é passado não inicializado.</param>
        <summary>Tenta converter a representação de cadeia de caracteres de um número em um estilo e formato específico à cultura especificados no equivalente <see cref="T:System.Numerics.BigInteger" /> e retorna um valor que indica se a conversão foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> caso o parâmetro <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método é como o <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> método, exceto que ele não gerará uma exceção se a conversão falhar. Esse método elimina a necessidade de usar a manipulação de exceção para testar um <xref:System.FormatException> se `value` é inválido e não pode ser analisado com êxito.  
  
 O parâmetro `style` define os elementos de estilo (como o espaço em branco ou um sinal positivo ou negativo) que são permitidos no parâmetro `value` para que a operação de análise seja bem-sucedida. Ele deve ser uma combinação de sinalizadores de bits da enumeração <xref:System.Globalization.NumberStyles>. Dependendo do valor de `style`, o parâmetro `value` pode incluir os seguintes elementos:  
  
 [*ws*][*$*][*sign*][*digits*,]*digits*[.* fractional_digits*] [E [*sinal*]*exponential_digits*] [*ws*]  
  
 Se o `style` inclui o parâmetro <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, o `value` parâmetro pode incluir os seguintes elementos:  
  
 [*ws*]*hexdigits*[*ws*]  
  
 Os elementos entre colchetes ([ e ]) são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*ws*|Espaço em branco opcional. Espaço em branco pode aparecer no início de `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador, ou no final da `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*$*|Um símbolo de moeda específico de cultura. A posição na cadeia de caracteres é definida pela propriedade <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> do objeto <xref:System.Globalization.NumberFormatInfo> retornado pelo método <xref:System.IFormatProvider.GetFormat%2A> do parâmetro `provider`. O símbolo de moeda pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*logon*|Um sinal opcional. O sinal pode ser exibido no início de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e ele pode ser exibido no final de `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. Os parênteses podem ser usados em `value` para indicar um valor negativo caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*digits*|Uma sequência de dígitos de 0 a 9.|  
|*,*|Um separador de grupo específico de cultura. O separador de grupo da cultura especificada por `provider` pode aparecer em `value` se `style` inclui o <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> sinalizador.|  
|*.*|Um símbolo de vírgula decimal específico de cultura. O símbolo da vírgula decimal da cultura especificada por `provider` pode ser exibido em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*fractional_digits*|Uma ou mais ocorrências de dígito 0. Os dígitos fracionários só podem ser exibidos em `value` caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|E|O caractere "e" ou "E", que indica que o valor é representado em notação exponencial (científica). O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*exponential_digits*|Uma sequência de dígitos de 0 a 9. O parâmetro `value` pode representar um número em notação exponencial caso `style` inclua o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>.|  
|*hexdigits*|Uma sequência de dígitos hexadecimais de 0 a f ou de 0 a F.|  
  
 Uma cadeia de caracteres apenas com dígitos decimais (que corresponde ao sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> ) sempre é analisada com êxito. A maioria dos elementos de controle de membros <xref:System.Globalization.NumberStyles> restantes que podem estar presentes, mas que não precisam estar presentes, na cadeia de caracteres de entrada. A tabela a seguir indica como os membros <xref:System.Globalization.NumberStyles> individuais afetam os elementos que podem estar presentes em `value`.  
  
|Valores `NumberStyles` não compostos|Elementos permitidos no valor além de dígitos|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Somente dígitos decimais.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|O ponto decimal (*.*) e *fractional_digits* elementos. No entanto, *fractional_digits* deve consistir de apenas um ou mais dígitos 0 ou o método retorna `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|O "e" ou o caractere "E", que indica a notação exponencial, juntamente com *exponential_digits*. Se `value` representa um número em notação exponencial, ele não pode ter um componente diferente de zero, frações.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|O *ws* elemento no início de `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|O *ws* elemento no final da `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|O *sinal* elemento antes *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|O *sinal* elemento após *dígitos*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|O *sinal* elemento na forma de parênteses delimitando o valor numérico.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|O separador de grupo (*,*) elemento.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|A moeda (*$*) elemento.|  
|<xref:System.Globalization.NumberStyles.Currency>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal ou um número em notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Float>|O *ws* elemento no início ou no final de `value`, *sinal* no início de `value`e o ponto decimal (*.*) símbolo. O parâmetro `value` também pode usar notação exponencial.|  
|<xref:System.Globalization.NumberStyles.Number>|O *ws*, *sinal*, separador de grupo (*,*) e o ponto decimal (*.*) elementos.|  
|<xref:System.Globalization.NumberStyles.Any>|Todos os elementos. No entanto, `value` não pode representar um número hexadecimal.|  
  
> [!IMPORTANT]
>  Se você usar o <xref:System.Numerics.BigInteger.TryParse%2A> método viagem a representação de cadeia de caracteres de um <xref:System.Numerics.BigInteger> valor foi saída o <xref:System.Numerics.BigInteger.ToString%2A> método, você deve usar o <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> método com o especificador de formato "R" para gerar a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> valor. Caso contrário, a representação de cadeia de caracteres da <xref:System.Numerics.BigInteger> preserva apenas os 50 dígitos significativos do valor original e dados podem ser perdidos quando você usa o <xref:System.Numerics.BigInteger.TryParse%2A> método para restaurar o <xref:System.Numerics.BigInteger> valor.  
  
 Caso o sinalizador <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> seja usado, `value` deve ser um valor hexadecimal. Os únicos outros sinalizadores que podem estar presentes em `style` são <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> e <xref:System.Globalization.NumberStyles?displayProperty=nameWithType>. (A enumeração <xref:System.Globalization.NumberStyles> tem um estilo composto, <xref:System.Globalization.NumberStyles.HexNumber>, que inclui ambos os sinalizadores de espaço em branco.)  
  
> [!NOTE]
>  Caso `value` seja a representação da cadeia de caracteres de um número hexadecimal, ele não pode ser precedido por qualquer decoração (como `0x` ou `&h`) que o diferencia como um número hexadecimal. Isso faz a conversão falhar.  
  
 Se `value` é uma cadeia de caracteres hexadecimal de <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método interpreta `value` como um número negativo armazenado usando representação de complemento de dois, se seu primeiro de dois dígitos hexadecimais forem maior que ou igual a `0x80`. Em outras palavras, o método interpreta o bit de ordem mais alta do primeiro byte no `value` como o bit de sinal. Para certificar-se de que uma cadeia de caracteres hexadecimal é interpretada corretamente como um número positivo, o primeiro dígito em `value` deve ter um valor de zero. Por exemplo, o método interpreta `0x80` como um valor negativo, mas ele interpreta o `0x080` ou `0x0080` como um valor positivo. O exemplo a seguir ilustra a diferença entre cadeias de caracteres hexadecimais que representam valores negativos e positivos.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 O parâmetro `provider` é uma implementação de <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> retorna um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações específicas de cultura sobre o formato de `value`. O parâmetro `provider` pode ser qualquer um dos seguintes:  
  
-   Um objeto <xref:System.Globalization.CultureInfo> que representa a cultura que fornece informações de formatação. O método <xref:System.Globalization.CultureInfo.GetFormat%2A> retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica para essa cultura.  
  
-   Um objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação numérica. (Sua implementação de <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> retorna apenas ele próprio.)  
  
-   Um objeto personalizado que implementa <xref:System.IFormatProvider>. O método <xref:System.IFormatProvider.GetFormat%2A> cria uma instância e retorna o objeto <xref:System.Globalization.NumberFormatInfo> que fornece informações de formatação.  
  
 Caso `provider` seja `null`, o objeto <xref:System.Globalization.NumberFormatInfo> da cultura atual é usado.  
  
   
  
## Examples  
 O exemplo a seguir faz algumas chamadas para o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método usando várias combinações de valores para o `style` e `provider` parâmetros.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Um número de chamadas individuais para o <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> método passar uma instância das seguintes `BigIntegerFormatProvider` classe, que define um til (~) como o sinal negativo.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> não é um valor <see cref="T:System.Globalization.NumberStyles" />.  
  
 -ou-  
  
 <paramref name="style" /> inclui o sinalizador <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> ou <see cref="F:System.Globalization.NumberStyles.HexNumber" /> em conjunto com outro valor.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>2.3.98.1</AssemblyVersion>
        <AssemblyVersion>3.98.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que representa o número 0 (zero).</summary>
        <value>Um inteiro cujo valor é 0 (zero).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Numerics.BigInteger> objeto retornado por esta propriedade fornece uma fonte conveniente de um valor de zero para uso em comparações e atribuições.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
