<Type Name="Style" FullName="System.Windows.Style">
  <TypeSignature Language="C#" Value="public class Style : System.Windows.Threading.DispatcherObject, System.Windows.Markup.IAddChild, System.Windows.Markup.INameScope, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Style extends System.Windows.Threading.DispatcherObject implements class System.Windows.Markup.IAddChild, class System.Windows.Markup.INameScope, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Style" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.INameScope</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("Setters")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.DictionaryKeyProperty("TargetType")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Permite o compartilhamento de propriedades, recursos e manipuladores de eventos entre instâncias de um tipo.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um <xref:System.Windows.Style> em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Um estilo mais comumente é declarado como um recurso dentro do <xref:System.Windows.Application.Resources%2A> seção. Como os estilos são recursos, eles obedecem as mesmas regras de escopo que se aplicam a todos os recursos, caso em que você declarar um estilo afeta onde ele pode ser aplicado. Se, por exemplo, você pode declarar o estilo no elemento raiz de sua definição de aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo, o estilo pode ser usado em qualquer lugar no seu aplicativo. Se você estiver criando um aplicativo de navegação e declarar o estilo em um do aplicativo [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivos, o estilo podem ser usados apenas em que [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] arquivo. Para obter mais informações sobre regras de escopo para recursos, consulte [recursos XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 A declaração de estilo consiste em um <xref:System.Windows.Style> objeto que contém uma coleção de um ou mais <xref:System.Windows.Setter> objetos. Cada <xref:System.Windows.Setter> consiste em uma <xref:System.Windows.Setter.Property%2A> e um <xref:System.Windows.Setter.Value%2A>. A propriedade é que o nome da propriedade do elemento de estilo é aplicar a. Depois que o estilo é declarado como um recurso, ele pode ser referenciado como qualquer outro recurso.  
  
> [!NOTE]
>  Se houver mais de um setter na coleção setter com o mesmo <xref:System.Windows.Setter.Property%2A> valor da propriedade, o setter que é declarado é usado pela última vez. Da mesma forma, se você definir um valor para a mesma propriedade em um estilo e em um elemento diretamente, o valor definido no elemento diretamente terá precedência.  
  
 O [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] estilos e modelagem de modelo permite que a manutenção e o compartilhamento de uma aparência, bem como a separação de apresentação e lógica. O modelo de estilos e modelagem inclui um conjunto de recursos que permitem que você personalize sua [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Este pacote de recursos inclui a <xref:System.Windows.Style> classe, bem como o seguinte:  
  
-   <xref:System.Windows.Trigger>  
  
-   <xref:System.Windows.EventTrigger> e <xref:System.Windows.Media.Animation.Storyboard>  
  
-   <xref:System.Windows.Controls.ControlTemplate>  
  
-   <xref:System.Windows.DataTemplate>  
  
 Para obter mais informações, consulte [Estilo e modelagem](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra uma declaração de estilo que afeta o <xref:System.Windows.Controls.Control.Background%2A> propriedade de um <xref:System.Windows.Controls.Control>.  
  
 [!code-xaml[StyleOvw01#StyleSimple](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimple)]   
  
 Para aplicar o estilo acima, faça o seguinte:  
  
 [!code-xaml[StyleOvw01#StyleSimpleApplied](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#stylesimpleapplied)]
  
 Você também pode aplicar estilos a todos os elementos de um determinado tipo usando o <xref:System.Windows.Style.TargetType%2A> propriedade. Adicionar o tipo de destino para o estilo significa que você não precisa qualificar totalmente a propriedade que você está definindo com o `ClassName.PropertyName` sintaxe. O exemplo a seguir define um estilo que será aplicado a todos <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
> [!NOTE]
>  Muitos [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, para criar um estilo que se aplica a todos os controles de um tipo podem ter um grande impacto. Por exemplo, se você criar um estilo destinado a <xref:System.Windows.Controls.TextBlock> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBlock> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBlock> faz parte de outro controle, como um <xref:System.Windows.Controls.ListBox>.  
  
 Para obter informações sobre como estender ou herdar de um estilo definido, consulte o <xref:System.Windows.Style.BasedOn%2A> página.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Style" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta chamada de construtor necessita de validação em atrasada <xref:System.Windows.Style.TargetType%2A> e <xref:System.Windows.Style.BasedOn%2A> estilo de tipo. Se isso for usado fora do contexto do analisador, o comportamento será indefinido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicada.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Style" /> classe a ser usada em especificado <see cref="T:System.Type" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Style (Type targetType, System.Windows.Style basedOn);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type targetType, class System.Windows.Style basedOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.#ctor(System.Type,System.Windows.Style)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetType" Type="System.Type" />
        <Parameter Name="basedOn" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="targetType">O tipo ao qual o estilo será aplicada.</param>
        <param name="basedOn">O estilo a base de dados este estilo.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Style" /> classe a ser usada em especificado <see cref="T:System.Type" /> e com base em especificado <see cref="T:System.Windows.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BasedOn">
      <MemberSignature Language="C#" Value="public System.Windows.Style BasedOn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style BasedOn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.BasedOn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um estilo definido que é a base do estilo atual.</summary>
        <value>Um estilo definido que é a base do estilo atual. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada estilo oferece suporte apenas a um <xref:System.Windows.Style.BasedOn%2A> valor.  
  
<a name="xamlAttributeUsage_BasedOn"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object BasedOn="myStyle" .../>  
```  
  
<a name="xamlValues_BasedOn"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *myStyle*  
 Um estilo existente. Normalmente, você usa o [extensões de marcação e WPF XAML](~/docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md) para se referir a um estilo existente.  
  
   
  
## Examples  
 Há várias maneiras de estilos em [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] pode ser estendida ou herdado. Estilos podem ser baseados nos outros estilos através desta propriedade. Quando você usar essa propriedade, o novo estilo herdará os valores do estilo original que não são explicitamente referenciados no novo estilo. No exemplo a seguir, `Style2` herda o <xref:System.Windows.Controls.Control.Background%2A?displayProperty=nameWithType> valor `Yellow`e adiciona um <xref:System.Windows.Controls.Control.Foreground%2A?displayProperty=nameWithType> valor `Blue`.  
  
 [!code-xaml[StyleOvw01#ExtendingStyle](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyle)]   
  
 Da mesma forma, os estilos podem se basear em estilo de um objeto existente [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] elemento, como no exemplo a seguir, onde o novo estilo é baseado no estilo de um <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#2)]   
  
> [!NOTE]
>  Se você criar um estilo com um <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo do estilo de base.  
  
 Os estilos definidos para tipos específicos também podem ser baseados nos outros estilos, como no exemplo a seguir.  
  
 [!code-xaml[StyleOvw01#ExtendingStyleTargetType](~/samples/snippets/csharp/VS_Snippets_Wpf/StyleOvw01/CS/Page1.xaml#extendingstyletargettype)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para este <see cref="T:System.Windows.Style" />.</summary>
        <returns>O código hash para este <see cref="T:System.Windows.Style" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.IsSealed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o estilo é somente leitura e não pode ser alterado.</summary>
        <value>
          <see langword="true" />Se o estilo for fechado; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um estilo é lacrado, quando outro estilo com base nela ou quando ela é aplicada pela primeira vez.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.RegisterName(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">O nome para registrar.</param>
        <param name="scopedElement">O objeto para mapear para especificado <c>nome</c>.</param>
        <summary>Registra um novo par de nome de objeto no namescope atual.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Resources" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a coleção de recursos que podem ser usados dentro do escopo desse estilo.</summary>
        <value>Os recursos que podem ser usados dentro do escopo desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
- or -   
<object>  
  <object.Resources>  
    <ResourceDictionary Source="externalDictionarySource"/>  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreResourceElements*  
 Um ou mais elementos de recurso. Para referência posterior no [StaticResource Markup Extension](~/docs/framework/wpf/advanced/staticresource-markup-extension.md) ou [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) sintaxe em [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], um elemento de recurso deve ter um `x:Key` atributo.  
  
 \<Origem de ResourceDictionary = " *externalDictionarySource*" / >  
 Uma fonte externa do dicionário. Para obter detalhes, consulte [dicionários de recursos mesclados](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seal">
      <MemberSignature Language="C#" Value="public void Seal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.Seal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia esse estilo e todos os gatilhos e fábricas de forma não podem ser alterados.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Setters">
      <MemberSignature Language="C#" Value="public System.Windows.SetterBaseCollection Setters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.SetterBaseCollection Setters" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Setters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.SetterBaseCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.Setter" /> e <see cref="T:System.Windows.EventSetter" />. O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Style.Setters%2A> propriedade de um <xref:System.Windows.Style> objeto pode consistir somente de objetos pode ser atribuídos a <xref:System.Windows.SetterBase>. Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto.  
  
 Um uso de elemento de propriedade explícita para <xref:System.Windows.Style.Setters%2A> também é relativamente comum. Esta é uma decisão de estilo de marcação que às vezes pode ajudar a distinguir <xref:System.Windows.Style.Setters%2A> de <xref:System.Windows.Style.Resources%2A> e <xref:System.Windows.Style.Triggers%2A> itens em um estilo complexas. Por exemplo:  
  
```  
<Style>  
  <Style.Setters>  
    <!--one or more SetterBase derived object elements here-->  
  </Style.Setters>  
</Style>  
```  
  
<a name="xamlPropertyElementUsage_Setters"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  oneOrMoreSetters  
</object>  
```  
  
<a name="xamlValues_Setters"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreSetters*  
 Um ou mais <xref:System.Windows.Setter> ou <xref:System.Windows.EventSetter> objetos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar essa propriedade.  
  
 [!code-csharp[listboxitemstyle#1](~/samples/snippets/csharp/VS_Snippets_Wpf/ListBoxItemStyle/CSharp/Pane1.xaml.cs#1)]
 [!code-vb[listboxitemstyle#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ListBoxItemStyle/VisualBasic/Pane1.xaml.vb#1)]  
  
 Adicionando um <xref:System.Windows.SetterBase> filho para uma <xref:System.Windows.Style> objeto adiciona implicitamente para o <xref:System.Windows.SetterBaseCollection> para o <xref:System.Windows.Style> objeto. O seguinte <xref:System.Windows.EventSetter> é implicitamente adicionado para o <xref:System.Windows.SetterBaseCollection> do estilo:  
  
 [!code-xaml[eventovwsupport#XAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml#xaml2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto filho a ser adicionado.</param>
        <summary>Adiciona um objeto filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">O texto a ser adicionado ao objeto.</param>
        <summary>Adiciona o conteúdo do texto de um nó ao objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.IAddChild>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.INameScope.FindName">
      <MemberSignature Language="C#" Value="object INameScope.FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.Windows.Markup.INameScope.FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#INameScope#FindName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O identificador de nome para o objeto que está sendo solicitado.</param>
        <summary>Retorna um objeto que tem o nome de identificação fornecido.</summary>
        <returns>O objeto, se encontrado. Retorna <see langword="null" /> se nenhum objeto desse nome foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Style> é convertida em uma interface de <xref:System.Windows.Markup.INameScope>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">O nome da propriedade de ambiente solicitada.</param>
        <summary>Consulta se uma propriedade de ambiente especificada está disponível no escopo atual.</summary>
        <returns>
          <see langword="true" />Se a propriedade de ambiente solicitada está disponível. Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetType">
      <MemberSignature Language="C#" Value="public Type TargetType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type TargetType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.TargetType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo para o qual esse estilo foi projetado.</summary>
        <value>O tipo de destino desse estilo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir um estilo em qualquer elemento que é derivada de <xref:System.Windows.FrameworkElement> ou <xref:System.Windows.FrameworkContentElement>. Portanto, o tipo de destino pode ser qualquer um desses elementos. No entanto, se você criar um estilo com um <xref:System.Windows.Style.TargetType%2A> propriedade e base-lo em outro estilo que também define um <xref:System.Windows.Style.TargetType%2A> propriedade, o tipo de destino do estilo derivado deve ser igual ou ser derivado do tipo de destino do estilo de base.  
  
 Se você não especificar um <xref:System.Windows.Style.TargetType%2A>, em seguida, você deve especificar um `x:Key` para sua <xref:System.Windows.Style> e também qualificar as propriedades no seu estilo com um nome de classe.  
  
<a name="xamlAttributeUsage_TargetType"></a>   
## <a name="xaml-attribute-usage"></a>Uso do Atributo XAML  
  
```  
<object  TargetType="{x:Type typeName}"/>  
-or-  
<object  TargetType="typeName"/>  
```  
  
<a name="xamlValues_TargetType"></a>   
## <a name="xaml-values"></a>Valores XAML  
 `{x:Type ...}`  
 Um [x: tipo de extensão de marcação](~/docs/framework/xaml-services/x-type-markup-extension.md) uso de extensão de marcação.  
  
 *typeName*  
 O nome do tipo da classe.  
  
   
  
## Examples  
 O exemplo a seguir define um estilo que será aplicado a todas as instâncias de <xref:System.Windows.Controls.TextBlock> elemento.  
  
 [!code-xaml[PhotoStoreDemoStyled#1](~/samples/snippets/csharp/VS_Snippets_Wpf/PhotoStoreDemoStyled/CS/window1.xaml#1)]   
  
 Definindo o <xref:System.Windows.Style.TargetType%2A> propriedade para o <xref:System.Windows.Controls.TextBlock> tipo sem definir uma `x:Key` define implicitamente a `x:Key` para `{x:Type TextBlock}`. Isso também significa que, se você fornecer acima <xref:System.Windows.Style> um `x:Key` valor de qualquer coisa diferente de `{x:Type TextBlock}`, o <xref:System.Windows.Style> não poderá ser aplicado a todos os <xref:System.Windows.Controls.TextBlock> elementos automaticamente. Em vez disso, você precisa aplicar o estilo de <xref:System.Windows.Controls.TextBlock> elementos explicitamente.  
  
 Muitos [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles consistem em uma combinação de outros [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] controles, para criar um estilo que se aplica a todos os controles de um tipo podem ter um grande impacto. Por exemplo, se você criar um estilo destinado a <xref:System.Windows.Controls.TextBox> controles em um <xref:System.Windows.Controls.Canvas>, o estilo é aplicado a todos os <xref:System.Windows.Controls.TextBox> controles na tela, mesmo se o <xref:System.Windows.Controls.TextBox> faz parte de outro controle, como um <xref:System.Windows.Controls.ComboBox>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Style.Triggers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> que se aplicam a valores de propriedade com base nas condições especificadas.</summary>
        <value>Uma coleção de objetos <see cref="T:System.Windows.TriggerBase" /> . O padrão é uma coleção vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] estilos e modelagem de modelo permite que você especifique acionadores em seu <xref:System.Windows.Style>. Essencialmente, os gatilhos são objetos que permitem que você aplicar alterações quando determinadas condições (como quando um determinado valor de propriedade torna-se `true`, ou quando ocorre um evento) são atendidos.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Uso do elemento propriedade XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Valores XAML  
 *oneOrMoreTriggers*  
 Zero ou mais elementos de objeto que são classes derivadas de <xref:System.Windows.TriggerBase>.  
  
   
  
## Examples  
 O exemplo a seguir mostra um conjunto nomeado <xref:System.Windows.Style> disponíveis para <xref:System.Windows.Controls.Button> controles. O <xref:System.Windows.Style> define uma <xref:System.Windows.Trigger> elemento altera o <xref:System.Windows.Controls.Control.Foreground%2A> propriedade de um botão quando o <xref:System.Windows.Controls.Primitives.ButtonBase.IsPressed%2A> é de propriedade `true`.  
  
 [!code-xaml[BtnStyles#2](~/samples/snippets/csharp/VS_Snippets_Wpf/BtnStyles/CS/app.xaml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Style.UnregisterName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do mapeamento a ser removido.</param>
        <summary>Remove um mapeamento de objeto de nome o namescope.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
