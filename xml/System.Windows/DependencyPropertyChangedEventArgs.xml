<Type Name="DependencyPropertyChangedEventArgs" FullName="System.Windows.DependencyPropertyChangedEventArgs">
  <TypeSignature Language="C#" Value="public struct DependencyPropertyChangedEventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DependencyPropertyChangedEventArgs extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyChangedEventArgs" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece dados para vários eventos alterados pela propriedade. Normalmente, esses eventos relatam alterações de valor efetivo no valor de uma propriedade de dependência somente leitura. Outro uso é como parte de uma implementação <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os eventos que usam o <xref:System.Windows.DependencyPropertyChangedEventArgs> classe para dados de eventos e o <xref:System.Windows.DependencyPropertyChangedEventHandler> implementações de método para manipuladores, geralmente seguem o padrão de nomenclatura `Is*Changed`e geralmente são implementadas como [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] eventos sem <xref:System.Windows.RoutedEvent> backup (eles não são eventos roteados). Alguns métodos "manipular" caso contrário de tratamento de classe exposta eventos que reportam uma alteração de estado por meio de uma alteração de propriedade, como <xref:System.Windows.Controls.Primitives.ButtonBase.OnIsPressedChanged%2A?displayProperty=nameWithType>, use também o <xref:System.Windows.DependencyPropertyChangedEventArgs> classe para dados de evento.  
  
 O cenário para <xref:System.Windows.PropertyChangedCallback> é usar os argumentos para relatórios antigos e novos valores provenientes de avaliação do sistema de propriedade da propriedade. Um retorno de chamada que processa os valores novos e antigos pode escolher um tratamento especial dependendo esses valores, como escolher não responder às alterações de valor que são consideradas insignificantes.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.DependencyPropertyChangedEventArgs> classe no contexto de um <xref:System.Windows.PropertyChangedCallback> para uma determinada propriedade de uma classe personalizada que também define os eventos. O retorno de chamada usa os resultados antigos e novos valores do sistema de propriedade como comunicadas por <xref:System.Windows.DependencyPropertyChangedEventArgs>e reempacota em uma classe de argumentos de eventos diferentes <xref:System.Windows.RoutedPropertyChangedEventArgs%601>. Os argumentos novos são usados como os dados de um evento de "ValueChanged" definidos por e gerados pela classe personalizada.  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#dependencypropertychangedeventargs)]
 [!code-vb[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#dependencypropertychangedeventargs)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyPropertyChangedEventArgs (System.Windows.DependencyProperty property, object oldValue, object newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.DependencyProperty property, object oldValue, object newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.#ctor(System.Windows.DependencyProperty,System.Object,System.Object)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
        <Parameter Name="oldValue" Type="System.Object" />
        <Parameter Name="newValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="property">O identificador para a propriedade de dependência que foram alteradas.</param>
        <param name="oldValue">O valor da propriedade antes da alteração relatada pelo evento relevante ou alteração de estado.</param>
        <param name="newValue">O valor da propriedade após a alteração relatada pelo evento relevante ou alteração de estado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementadores de eventos personalizados que as alterações de propriedade de dependência de relatório devem usar esse construtor para preencher os dados de eventos com as especificações da alteração quando o evento é gerado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado ao atual <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</param>
        <summary>Determina se o objeto fornecido é equivalente à atual <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</summary>
        <returns>
          <see langword="true" />Se o objeto fornecido é equivalente à atual <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação depende de equivalência do valor de todas as propriedades, incluindo propriedades internas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Windows.DependencyPropertyChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.Windows.DependencyPropertyChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.Equals(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">O <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> para comparar com a atual<see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /></param>
        <summary>Determina se o fornecido <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> é equivalente à atual <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</summary>
        <returns>
          <see langword="true" />Se fornecido <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> é equivalente à atual <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa implementação depende de equivalência do valor de todas as propriedades, incluindo propriedades internas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um código hash para este <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />.</summary>
        <returns>Um código hash do inteiro com sinal de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NewValue">
      <MemberSignature Language="C#" Value="public object NewValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object NewValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyChangedEventArgs.NewValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor da propriedade depois da alteração.</summary>
        <value>O valor da propriedade depois da alteração.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido deve sempre ser conversíveis para o tipo da propriedade de dependência que está sendo relatado.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.DependencyPropertyChangedEventArgs> classe no contexto de um <xref:System.Windows.PropertyChangedCallback> para uma determinada propriedade de uma classe personalizada que também define os eventos. O retorno de chamada usa os resultados antigos e novos valores do sistema de propriedade como comunicadas por <xref:System.Windows.DependencyPropertyChangedEventArgs>e reempacota em uma classe de argumentos de eventos diferentes <xref:System.Windows.RoutedPropertyChangedEventArgs%601>. Os argumentos novos são usados como os dados de um evento de "ValueChanged" definidos por e gerados pela classe personalizada.  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#dependencypropertychangedeventargs)]
 [!code-vb[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#dependencypropertychangedeventargs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OldValue">
      <MemberSignature Language="C#" Value="public object OldValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OldValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyChangedEventArgs.OldValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor da propriedade antes da alteração.</summary>
        <value>O valor da propriedade antes da alteração.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tipo do valor fornecido deve sempre ser conversíveis para o tipo da propriedade de dependência que está sendo relatado.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Windows.DependencyPropertyChangedEventArgs> classe no contexto de um <xref:System.Windows.PropertyChangedCallback> para uma determinada propriedade de uma classe personalizada que também define os eventos. O retorno de chamada usa os resultados antigos e novos valores do sistema de propriedade como comunicadas por <xref:System.Windows.DependencyPropertyChangedEventArgs>e reempacota em uma classe de argumentos de eventos diferentes <xref:System.Windows.RoutedPropertyChangedEventArgs%601>. Os argumentos novos são usados como os dados de um evento de "ValueChanged" definidos por e gerados pela classe personalizada.  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#dependencypropertychangedeventargs)]
 [!code-vb[CustomControlNumericUpDownOneProject#DependencyPropertyChangedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#dependencypropertychangedeventargs)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.DependencyPropertyChangedEventArgs left, System.Windows.DependencyPropertyChangedEventArgs right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Windows.DependencyPropertyChangedEventArgs left, valuetype System.Windows.DependencyPropertyChangedEventArgs right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.op_Equality(System.Windows.DependencyPropertyChangedEventArgs,System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.DependencyPropertyChangedEventArgs" />
        <Parameter Name="right" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> a ser comparado.</param>
        <param name="right">O segundo <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> a ser comparado.</param>
        <summary>Determina se dois objetos <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> especificados têm o mesmo valor.</summary>
        <returns>
          <see langword="true" />Se os dois <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> instâncias forem equivalentes; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação usa a mesma lógica <xref:System.Windows.DependencyPropertyChangedEventArgs.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.DependencyPropertyChangedEventArgs left, System.Windows.DependencyPropertyChangedEventArgs right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Windows.DependencyPropertyChangedEventArgs left, valuetype System.Windows.DependencyPropertyChangedEventArgs right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyChangedEventArgs.op_Inequality(System.Windows.DependencyPropertyChangedEventArgs,System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.DependencyPropertyChangedEventArgs" />
        <Parameter Name="right" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> a ser comparado.</param>
        <param name="right">O segundo <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> a ser comparado.</param>
        <summary>Determina se duas especificadas <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> objetos são diferentes.</summary>
        <returns>
          <see langword="true" />Se os dois <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> instâncias forem diferentes; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação retorna a negação da mesma lógica <xref:System.Windows.DependencyPropertyChangedEventArgs.Equals%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Property">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty Property { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty Property" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyChangedEventArgs.Property" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador para a propriedade de dependência em que ocorreu a alteração de valor.</summary>
        <value>O campo de identificador de propriedade de dependência em que ocorreu a alteração de valor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é relevante se usado em um comum <xref:System.Windows.PropertyChangedCallback> que está registrada para várias propriedades, e é necessário para resolver a ambiguidade que mudam de propriedade chamado o retorno de chamada. <xref:System.Windows.DependencyPropertyChangedEventArgs.Property%2A>não é normalmente relevante para gerar eventos, pois normalmente há uma correspondência 1:1 entre propriedades e eventos de alteração de propriedade do relatório. O evento que foi gerado em si é a indicação de que a propriedade alterada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
